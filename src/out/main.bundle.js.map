{"version":3,"sources":["webpack:///main.bundle.js","webpack:///./js/main.js","webpack:///./~/paper/dist/paper-full.js","webpack:///./js/story.js","webpack:///./~/ramda/dist/ramda.js","webpack:///./js/dialogue.js","webpack:///./~/kefir/dist/kefir.js","webpack:///./~/kefir.atom/lib/kefir.atom.js","webpack:///./~/partial.lenses/lib/partial.lenses.js","webpack:///./js/Element.mutation.js","webpack:///./css/global.css?e5e1","webpack:///./css/global.css"],"names":["webpackJsonp","module","exports","__webpack_require__","_interopRequireDefault","obj","__esModule","default","set","prop","val","toggleCharacters","graphene","visible","carbon","talk_text","g_text","c_text","_paper2","view","draw","update","calculateButtonSize","rect","res_rect","_ramda2","clone","margin","x","y","width","height","showDialogue","choices","story","isArrayLike","gobjects","map","choice","n","group","Group","text","PointText","content","fillColor","fontFamily","fontWeight","fontSize","font_size","justification","onClick","window","next","button","main_button","setBounds","bounds","addChild","getBounds","resize","onValue","size","rem","padding","length","cur","i","who","say","len","t","timeout_id","setTimeout","show","current","video","console","log","remove","addEventListener","container","appendChild","play","_paper","_story","_story2","_kefir","_kefir2","_kefir3","_ramda","R","p","Kefir","Observable","prototype","pluck","this","lensProp","canvas","volume","onBefore","setPosition","center","location","href","fromEvents","toProperty","innerHeight","innerWidth","createVolumeCtrl","w","h","path","mw","mh","volCtrlGroup","rect_out_box","Rectangle","box","Shape","rect_blue_path","path_blue","vol","get","rect_white_path","path_white","point","Point","vcg","black_line","value","clearTimeout","vol_timout","arg","hasChoices","forEach","o","hasDialogue","volumeModifier","event","document","getElementById","e","wheelDelta","mod","modify","old","setup","setViewSize","Raster","scale","v","position","importSVG","onMouseDown","__WEBPACK_AMD_DEFINE_FACTORY__","__WEBPACK_AMD_DEFINE_RESULT__","paper","undefined","Base","inject","dest","src","enumerable","beans","preserve","field","name","describe","substring","bean","isFunc","res","prev","base","match","beansNames","toLowerCase","isPlainObject","writable","configurable","define","hasOwnProperty","hidden","test","part","each","iter","bind","getLength","forIn","call","props","exclude","key","l","create","Object","proto","__proto__","getOwnPropertyDescriptor","__lookupGetter__","__lookupSetter__","_define","defineProperty","desc","__defineGetter__","__defineSetter__","arguments","statics","extend","ctor","initialize","apply","constructor","pick","a","b","toString","_id","_class","_name","type","push","Formatter","instance","number","join","getClassName","exportJSON","options","toJSON","serialize","_set","dontCheck","keys","_filtering","equals","obj1","obj2","Array","isArray","read","list","start","peek","__index","readIndex","_readIndex","index","readNull","__read","slice","remain","readAll","entry","readNamed","getNamed","hasObject","filtered","_filtered","_hasObject","hasNamed","isPlainValue","asString","compact","dictionary","root","formatter","precision","definitions","references","add","item","id","ref","unshift","_serialize","_compact","deserialize","json","_data","_isDictionary","isRoot","isDictionary","args","JSON","stringify","importJSON","target","parse","isTarget","Item","Layer","insert","splice","items","amount","append","_index","removed","capitalize","str","replace","toUpperCase","camelize","all","chr","hyphenate","Emitter","on","func","types","_eventTypes","handlers","_callbacks","indexOf","install","off","uninstall","once","emit","stop","responds","attach","detach","fire","_installEvents","events","_events","isString","PaperScope","settings","applyMatrix","handleSize","hitTolerance","project","projects","tools","palettes","_scopes","support","ctx","CanvasProvider","getContext","nativeDash","nativeBlendModes","BlendMode","nativeModes","release","browser","agent","navigator","userAgent","platform","exec","v1","v2","rv","chrome","version","versionNumber","parseFloat","webkit","atom","getView","getPaper","execute","code","url","PaperScript","View","updateFocus","scope","that","element","Project","activate","clear","handleAttribute","el","attr","getAttribute","hasAttribute","PaperScopeItem","_scope","_list","_reference","isActive","multiplier","Math","pow","round","pair","val1","val2","separator","rectangle","Numerical","clip","min","max","abscissas","weights","abs","sqrt","EPSILON","MACHINE_EPSILON","TOLERANCE","CURVETIME_EPSILON","GEOMETRIC_EPSILON","WINDING_EPSILON","TRIGONOMETRIC_EPSILON","CLIPPING_EPSILON","KAPPA","isZero","integrate","f","A","B","m","sum","Ax","findRoot","df","tolerance","fx","dx","nx","solveQuadratic","c","roots","x1","D","count","eMin","eMax","x2","Infinity","gmC","mult","floor","LOG10E","isFinite","Q","solveCubic","d","b1","c2","x0","q","qd","r","s","tmp","ec","UID","_pools","pool","arg0","arg1","hasY","angle","setAngle","setLength","_angle","cos","sin","getAngle","getAngleInRadians","PI","setAngleInRadians","getAngleInDegrees","setAngleInDegrees","div","NaN","dot","acos","atan2","getQuadrant","getDirectedAngle","cross","getDistance","squared","normalize","rotate","subtract","transform","matrix","_transformPoint","multiply","divide","modulo","negate","isInside","contains","isClose","isCollinear","isColinear","isOrthogonal","isNaN","point1","point2","random","y1","y2","op","LinkedPoint","owner","setter","_x","_y","_owner","_setter","_dontNotify","getX","setX","getY","setY","Size","hasHeight","size1","size2","LinkedSize","_width","_height","getWidth","setWidth","getHeight","setHeight","arg2","arg3","from","to","rt","getPoint","_dontLink","setPoint","getSize","setSize","_fixX","_fixY","_fixW","_fixH","getLeft","setLeft","left","getTop","setTop","top","getRight","setRight","right","getBottom","setBottom","bottom","getCenterX","setCenterX","getCenterY","setCenterY","getCenter","setCenter","getArea","isEmpty","_containsRectangle","_containsPoint","intersects","touches","intersect","unite","include","expand","hor","ver","parts","xFirst","LinkedRectangle","internal","isSelected","_boundsSelected","setSelected","selected","_selectedSegmentState","Matrix","ok","_a","_c","_b","_d","_tx","_ty","reset","Error","tx","ty","_changed","getValues","_applyMatrix","mx","recursively","_setApplyMatrix","isIdentity","translate","shear","skew","toRadians","tan","concatenate","a1","c1","d1","a2","b2","d2","tx2","ty2","preConcatenate","tx1","ty1","chain","orNullIfIdentity","isInvertible","_getDeterminant","isSingular","dst","_transformCoordinates","j","_transformCorners","coords","_transformBounds","inverseTransform","_inverseTransform","det","decompose","scaleX","scaleY","scaling","rotation","shearing","getTranslation","getScaling","getRotation","inverted","shiftless","applyToContext","Line","arg4","asVector","_px","_py","_vx","_vy","getVector","line","isInfinite","getSide","getSignedDistance","p1x","p1y","v1x","v1y","p2x","p2y","v2x","v2y","dy","u1","u2","epsilon","uMin","uMax","px","py","vx","vy","ccw","layers","_activeLayer","symbols","_currentStyle","Style","_view","getCanvas","_selectedItems","_selectedItemCount","_updateVersion","getCurrentStyle","setCurrentStyle","style","getIndex","getOptions","getActiveLayer","getSelectedItems","isInserted","insertChild","_preserve","_remove","_setProject","_changes","NO_INSERT","_updateSelection","selectedItems","_selected","selectAll","setFullySelected","deselectAll","hitTest","HitResult","_hitTest","getItems","_getItems","getItem","layer","pixelRatio","save","param","offset","viewMatrix","matrices","updateMatrix","restore","strokeWidth","_drawSelection","Symbol","dontCenter","setDefinition","_definition","flags","_clearBoundsCache","_needsUpdate","getDefinition","_dontCenter","_parentSymbol","place","PlacedSymbol","symbol","definition","_serializeFields","_canApplyMatrix","_selectChildren","pivot","locked","blendMode","opacity","guide","clipMask","data","_initialize","hasProps","_matrix","_style","_project","parent","setParent","_installEvent","_uninstallEvent","onFrame","_animateItem","onLoad","fields","_defaults","cacheParent","_parent","_bounds","_position","_decomposed","_globalMatrix","_currentPath","_changesById","getId","getName","setName","unique","_removeNamed","children","_children","namedChildren","_namedChildren","orig","getStyle","setStyle","_locked","_visible","_blendMode","_opacity","_guide","noChildren","isFullySelected","isClipMask","_clipMask","setClipMask","setFillColor","setStrokeColor","getData","setData","getPosition","_pivot","getPivot","setPivot","getter","internalGetter","boundsGetter","_boundsGetter","_getCachedBounds","_getBounds","cacheItem","_updateBoundsCache","child","cache","cached","_internal","_boundsCache","ids","other","_decompose","decomposed","setRotation","setScaling","getMatrix","setMatrix","getGlobalMatrix","_dontClone","updateVersion","getApplyMatrix","setApplyMatrix","getTransformContent","setTransformContent","getProject","installEvents","getLayer","getParent","getChildren","setChildren","removeChildren","addChildren","getFirstChild","getLastChild","getNextSibling","getPreviousSibling","_equals","_clone","copy","includeMatrix","insertAbove","copyTo","itemOrProject","rasterize","resolution","getStrokeBounds","getResolution","topLeft","getTopLeft","bottomRight","getBottomRight","ceil","raster","setCanvas","_contains","getInternalBounds","_asPathItem","Path","getIntersections","checkBounds","pt","tolerancePadding","guides","parentTotalMatrix","_totalMatrix","totalMatrix","_tolerancePadding","_getPenPadding","getInternalRoughBounds","checkSelf","points","opts","_getChildHitTestOptions","_hitTestSelf","fill","hasFill","matches","compare","matchObject","RegExp","firstOnly","overlapping","inside","childMatrix","insertChildren","_proto","shift","notifySelf","_insertSibling","insertBelow","sendToBack","bringToFront","appendTop","appendBottom","moveAbove","moveBelow","reduce","namedArray","notifyParent","replaceWith","reverseChildren","reverse","isEditable","hasStroke","hasShadow","_getOrder","getList","list1","list2","hasChildren","isAbove","isBelow","isParent","isChild","isDescendant","isAncestor","isSibling","isGroupedWith","_applyRecursively","_transformContent","getFillColor","strokeColor","getStrokeColor","decomp","applyRecursively","globalToLocal","localToGlobal","parentToLocal","localToParent","fitBounds","itemRatio","rectRatio","newBounds","_setStyles","shadowColor","getShadowColor","fillStyle","toCanvasStyle","getStrokeWidth","strokeStyle","lineWidth","strokeJoin","getStrokeJoin","strokeCap","getStrokeCap","miterLimit","getMiterLimit","lineJoin","lineCap","dashArray","getDashArray","dashOffset","getDashOffset","setLineDash","lineDashOffset","mozDash","mozDashOffset","shadowBlur","getShadowBlur","getShadowOffset","shadowOffsetX","shadowOffsetY","parentStrokeMatrix","getViewMatrix","globalMatrix","mainCtx","itemOffset","prevOffset","normalBlend","nativeBlend","direct","dontStart","_canComposite","strokeMatrix","getStrokeScaling","clipItem","globalAlpha","globalCompositeOperation","setTransform","_draw","pop","dontFinish","process","_isUpdated","CompoundPath","updated","_drawSelected","color","getSelectedColor","half","beginPath","closePath","stroke","fillRect","hash","removeOn","sets","_removeSets","_clipItem","_getClipItem","isClipped","setClipped","clipped","currentPath","radius","_type","_size","_radius","setType","setRadius","getType","getShape","setShape","getRadius","rad","toPath","dontPaint","untransformed","isCircle","arc","rx","ry","kappa","cx","cy","moveTo","bezierCurveTo","lineTo","getWindingRule","getCornerCenter","halfSize","dir","corner","getEllipseRadius","hit","outer","inner","createShape","Circle","Ellipse","ellipse","_readEllipse","crossOrigin","source","object","setSource","setImage","_loaded","getSource","image","_image","_canvas","copyCanvas","drawImage","_crossOrigin","getElement","u","getPpi","getImage","complete","naturalWidth","naturalHeight","_context","setContext","context","toDataURL","loaded","Image","DomEvent","load","getCrossOrigin","setCrossOrigin","getSubCanvas","getSubRaster","getAverageColor","PathItem","sampleSize","_sampleContext","clearRect","pixels","getImageData","channels","total","alpha","Color","getPixel","setPixel","components","_convert","_alpha","imageData","createImageData","putImageData","setImageData","setSymbol","_symbol","getSymbol","values","segments","handles","ends","Segment","arg5","handleIn","handleOut","SegmentPoint","hasHandles","_point","_handleIn","_handleOut","_path","curve","curves","_curves","_closed","getHandleIn","setHandleIn","getHandleOut","setHandleOut","clearHandles","_selectionState","state","oldState","flag","getPath","getCurve","_segments","getCurves","getLocation","CurveLocation","_segment1","getNext","getPrevious","isFirst","isLast","inX","inY","reversed","removeSegment","segment","change","Curve","arg6","arg7","seg1","seg2","handle1","handle2","segment1","segment2","_segment2","getPoint1","getHandle1","getHandle2","getPoint2","_length","setPoint1","setPoint2","setHandle1","setHandle2","getSegment1","getSegment2","getPoints","getLine","getPart","getPartLength","_getIntersections","_getParameter","isParameter","parameter","getParameterAt","_setHandles","tMin","tMax","subdivide","setHandles","split","p1","h1","h2","p2","c1x","c1y","c2x","c2y","p3x","p3y","p4x","p4y","p5x","p5y","p6x","p6y","p7x","p7y","p8x","p8y","coord","getParameterOf","geomEpsilon","getNearestParameter","refine","dist","minDist","minT","isStraight","step","flip","isFlatEnough","ux","uy","h1x","h1y","h2x","h2y","_addBounds","v0","v3","isLinear","third","isHorizontal","getTangentAt","isVertical","getLocationAt","getLocationOf","getOffsetOf","loc","getOffset","getNearestLocation","getNearestPoint","methods","evaluateMethods","getLengthIntegrand","ax","bx","ay","by","getIterations","evaluate","normalized","ds","forward","rangeLength","guess","getTangent","getWeightedTangent","getNormal","getWeightedNormal","getCurvature","addLocation","locations","t1","t2","overlap","startConnected","endConnected","renormalize","loc1","loc2","_intersection","addCurveIntersections","oldTDiff","recursion","tMinClip","tMaxClip","q0x","q0y","q3x","q3y","factor","dMin","dMax","dp0","dp1","dp2","dp3","hull","getConvexHull","clipConvexHull","tDiff","tMinNew","tMaxNew","dq0","dq1","dq2","dq3","p0","p3","dist1","dist2","distRatio","hullTop","hullBottom","clipConvexHullPart","threshold","qx","qy","addCurveLineIntersections","vc","vl","lx1","ly1","lx2","ly2","ldx","ldy","rvc","tc","pc","tl","pl","addLineIntersection","_getSelfIntersection","c1p1x","c1p1y","c1p2x","c1p2y","c2p1x","c2p1y","c2p2x","c2p2y","c1s1x","c1s1y","c1s2x","c1s2y","c2s1x","c2s1y","c2s2x","c2s2y","overlaps","getOverlaps","straight1","straight2","straight","before","c1p1","c1p2","c2p1","c2p2","side1","side2","edgeSum","ac","ab","bc","tSplit","maxCurvature","curvature","getCurvatureAt","getLineLengthSquared","timeEpsilon","l1","l2","pairs","o1","o2","_overlap","_distance","_setCurve","_parameter","getPointAt","_next","_prev","_version","_curve","_segment","_setSegment","getSegment","getParameter","trySegment","_offset","getCurveOffset","getIntersection","_ignoreOther","diff","isTouching","inter","curve1","curve2","isCrossing","isInRange","c4","c3","a3","a4","isOverlap","merge","search","found","path1","path2","expanded","_returnFirst","self","matrix1","matrix2","curves1","curves2","length1","length2","values2","arrays","values1","getCrossings","setPathData","getCoord","relative","previous","control","command","lower","move","cubicCurveTo","quadraticCurveTo","arcTo","winding","_getWinding","closed","setSegments","_clockwise","_area","_monoCurves","getSegments","fullySelected","_add","getFirstSegment","getLastSegment","_countCurves","getFirstCurve","getLastCurve","isClosed","setClosed","getPathData","_precision","addSegment","skipLine","curX","curY","first","outX","prevX","outY","prevY","segs","concat","_adjustCurves","insertSegment","addSegments","insertSegments","removeSegments","_includeCurves","last","area","isClockwise","setClockwise","clockwise","_selectSegments","newState","flatten","maxDistance","iterator","PathIterator","pos","end","simplify","fitter","PathFitter","fit","last1","last2","first2","first1","toShape","seg3","seg4","isArc","pt1","pt2","topCenter","shape","isCloseEnough","checkSegmentPoint","seg","anchor","strokePadding","checkSegmentPoints","addToArea","checkSegmentStroke","cap","numSegments","_addBevelJoin","_addSquareCap","hitStroke","hitFill","hitCurves","minLoc","drawHandles","drawHandle","hX","hY","pX","pY","drawSegments","drawSegment","handle","dashLength","drawPart","getFirstControlPoints","rhs","smooth","knots","f1","f2","ie","je","getCurrentSegment","moveBy","curveTo","through","extent","vector","middle","large","rxSq","rySq","xSq","ySq","throughSide","centerSide","ext","inc","z","out","_in","lineBy","curveBy","cubicCurveBy","quadraticCurveBy","arcBy","processSegment","prevCoords","addRound","joinBounds","addJoin","addCap","phi","atan","addPoint","normal1","getNormalAt","normal2","normal","getHandleBounds","joinPadding","paddingX","paddingY","xn","xx","yn","yx","getRoughBounds","strokeRadius","joinRadius","createPath","createEllipse","ellipseSegments","bl","getBottomLeft","tr","getTopRight","br","hx","hy","RoundRectangle","Oval","Arc","RegularPolygon","sides","three","Star","radius1","radius2","paths","getCurrentPath","check","preparePath","resolve","resolveCrossings","reorient","finishBoolean","result","computeBoolean","operation","collect","monoCurves","_getMonoCurves","computeOpenBoolean","_path1","_path2","intersections","divideLocations","propagateWinding","_winding","tracePaths","addPath","sub","linkIntersections","prevCurve","prevT","noHandles","clearSegments","origT","getWinding","horizontal","testContains","windLeft","windRight","yTop","yBottom","yBefore","yAfter","xBefore","xAfter","startCounted","slope","counted","totalLength","windingSum","k","node","curveLength","isValid","adjusted","_visited","operator","overlapWinding","isStart","otherStart","findBestIntersection","strict","nextSeg","nextInter","findStartSegment","operators",1,2,"finished","firstSegment","error","crossings","insertCurve","y0","handleCurve","y3","sort","getInteriorPoint","xIntercepts","counters","maxRecursion","addCurve","computeParts","maxT","minDifference","halfT","prevVal","prevLen","weighted","fitCubic","tan1","tan2","uPrime","chordLengthParameterize","maxError","parametersInOrder","generateBezier","findMaxError","reparameterize","V1","V2","tanCenter","C","X","b0","b3","alpha1","alpha2","detC0C1","detC0X","detXC1","c0","segLength","eps","degree","maxDist","P","TextItem","_content","_lines","setContent","getContent","getCharacterStyle","setCharacterStyle","getParagraphStyle","setParagraphStyle","lines","leading","getLeading","font","getFontStyle","textAlign","getJustification","fillText","strokeText","numLines","getTextWidth","fromCSS","string","parseInt","colorCache","colorCtx","gray","rgb","hsb","hsl","gradient","componentParsers","hsbIndices","converters","rgb-hsb","g","delta","hsb-rgb","rgb-hsl","achromatic","hsl-rgb","t3s","t3","rgb-gray","gray-rgb","gray-hsb","gray-hsl","gradient-rgb","rgb-gradient","properties","hasOverlap","parser","_components","Gradient","_removeOwner","_addOwner","_properties","argType","parsers","stops","radial","getComponents","_canvasStyle","converter","convert","getAlpha","setAlpha","hasAlpha","col","isGradient","toCSS","hex","canvasGradient","_stops","origin","destination","_radial","highlight","createRadialGradient","createLinearGradient","addColorStop","_rampPoint","_color","_types","components1","components2","setStops","setRadial","_owners","getStops","GradientStop","_defaultRamp","setRampPoint","getRadial","rampPoint","setColor","getRampPoint","getColor","defaults","strokeScaling","windingRule","shadowOffset","selectedColor","_textDefaults","isColor","isPoint","_values","_dontMerge","childValue","isStyle","getFontSize","getFontWeight","getFontFamily","getFont","setFont","getPixelSize","DomElement","handlePrefix","prefixes","suffix","prefix","getStyles","doc","nodeType","ownerDocument","defaultView","getComputedStyle","viewport","body","html","documentElement","getBoundingClientRect","clientLeft","clientTop","pageXOffset","scrollLeft","pageYOffset","scrollTop","getViewportBounds","clientWidth","clientHeight","isInvisible","isInView","getPrefixed","setPrefixed","removeEventListener","targetTouches","changedTouches","pageX","clientX","pageY","clientY","getTarget","srcElement","getRelatedTarget","relatedTarget","toElement","stopPropagation","preventDefault","requestAnimationFrame","handleCallbacks","callbacks","focused","nativeRequest","requested","timer","focus","blur","callback","setInterval","getCanvasSize","_element","_pixelRatio","devicePixelRatio","setAttribute","_viewEvents","none","userSelect","touchAction","touchCallout","contentZooming","userDrag","tapHighlightColor","_windowEvents","_setViewSize","Stats","_stats","stats","domElement","_views","_viewsById","_viewSize","_zoom","_focused","_frameItems","_frameItemCount","_animate","pause","_time","_count","_requestFrame","_requested","_handleFrame","now","Date","_before","_handlingFrame","time","animate","_handleFrameItems","_update","_transform","getPixelRatio","getViewSize","scrollBy","getZoom","setZoom","zoom","isVisible","projectToView","viewToProject","CanvasView","tempFocus","handleMouseMove","_handleEvent","tool","dragging","prevFocus","mousedown","mousemove","mouseup","pointerEnabled","msPointerEnabled","viewEvents","selectstart dragstart","docEvents","mouseout","nodeName","scroll","mouseFlags","mousedrag","click","doubleclick","mouseenter","mouseleave","_eventCounters","HTMLCanvasElement","deviceRatio","backingStoreRatio","firefox","parentNode","temp","createElement","removeChild","prevFont","measureText","force","callEvent","lastPoint","mouseEvent","MouseEvent","isStopped","downPoint","overPoint","downItem","lastItem","overItem","dragItem","dblClick","clickTime","stopped","Event","isPrevented","getModifiers","Key","modifiers","KeyEvent","down","character","handleKey","keyCode","charCode","String","fromCharCode","specialKey","specialKeys","keyMap","charCodeMap","mac","commandFixMap","downCode",8,9,13,16,17,18,19,20,27,32,35,36,37,38,39,40,46,91,93,224,"specialChars","option","capsLock","space","keydown","which","keypress","keyup","isDown","ToolEvent","_item","_choosePoint","toolPoint","getLastPoint","_lastPoint","setLastPoint","getDownPoint","_downPoint","setDownPoint","getMiddlePoint","_middlePoint","setMiddlePoint","middlePoint","getDelta","_delta","setDelta","getCount","_downCount","setCount","setItem","Tool","_firstMove","getMinDistance","_minDistance","setMinDistance","minDistance","_maxDistance","getMaxDistance","setMaxDistance","getFixedDistance","setFixedDistance","distance","_updateEvent","needsChange","matchMaxDistance","_fireEvent","called","Http","request","method","async","xhr","ActiveXObject","XMLHttpRequest","open","overrideMimeType","onreadystatechange","readyState","status","responseText","send","canvases","getLum","setLum","dr","dg","db","mn","lmn","ln","mxl","getSat","setSat","md","sr","sg","sb","sa","bg","bb","ba","modes","screen","overlay","soft-light","hard-light","color-dodge","color-burn","darken","lighten","difference","exclusion","hue","saturation","luminosity","average","negation","mode","srcContext","dstContext","srcCanvas","dstData","SVGStyles","true","false","lookup","property","attribute","toSVG","fromSVG","exportFilter","SVGNamespaces","xlink","setAttributes","attrs","namespace","setAttributeNS","tag","createElementNS","getTransform","coordinates","trans","exportGroup","childNode","exportSVG","clip-path","exportRaster","embedImages","exportPath","matchShapes","exportShape","exportCompoundPath","exportPlacedSymbol","symbolNode","viewBox","overflow","exportGradient","gradientNode","getGradient","getOrigin","getDestination","getHighlight","fy","gradientUnits","stopColor","stop-color","exportText","textContent","applyStyle","visibility","svgs","exportDefinitions","svg","defs","insertBefore","firstChild","XMLSerializer","serializeToString","exporter","exporters","onExport","setOptions","xmlns","xmlns:xlink","getValue","allowNull","getAttributeNS","convertValue","importGroup","nodes","childNodes","isClip","currentStyle","applyAttributes","querySelectorAll","importPoly","importPath","pathData","importGradient","isRadial","applyTransform","transforms","applyOpacity","styles","attributes","onLoadCallback","File","reader","FileReader","onload","readAsText","DOMParser","parseFromString","importer","importers","onImport","expandShapes","#document","nextSibling","clippath","polygon","polyline","lineargradient","radialgradient","use","circle","trim","gradientTransform","fill-opacity","stroke-opacity","setVisible","display","stop-opacity","percentage","__$__","handler","binaryOperators","$__","unaryOperators","acorn","compile","insertions","insertion","getCode","range","getBetween","replaceCode","walkAST","argument","between","parentType","computed","exp","sourceMap","lineBreaks","getElementsByTagName","innerHTML","substr","mappings","file","names","sourceRoot","sources","sourcesContent","ranges","btoa","unescape","encodeURIComponent","expose","params","toolHandlers","script","head","createTextNode","_execute","Function","onResize","setOnResize","setOnFrame","loadScript","canvasId","scopeAttribute","baseURI","loadAll","amd","fr","mr","hr","sourceFile","vr","column","SyntaxError","raisedAt","Ar","Sr","Er","gr","kr","wr","Cr","beforeExpr","onComment","Kt","lastIndex","charCodeAt","pr","Jt","E","xt","Et","wt","Dt","Lt","Ut","Rt","Tt","Vt","Gt","Lr","St","At","jt","Ot","qt","Ct","It","mt","vt","yt","bt","ft","dt","ht","gt","kt","yr","xr","Br","Qt","L","$t","charAt","I","jr","Or","Tr","Dr","S","Bt","Yt","Fr","Wt","lt","forbidReserved","ecmaVersion","Mt","zt","Xt","U","Ir","Ur","lastIndexOf","V","T","O","expression","F","strictSemicolons","M","N","Nt","W","Rr","Vr","J","Mr","Nr","label","lr","kind","keyword","Wr","Pr","Zt","tt","_r","$","G","declarations","ut","_","K","Gr","cr","Kr","consequent","alternate","Hr","Qr","Yr","discriminant","cases","en","zr","Jr","Zr","et","block","H","Xr","guard","guardedHandlers","qr","finalizer","$r","nt","isLoop","init","expressions","Y","isAssign","Z","er","rr","binop","isUpdate","postfix","nr","ar","callee","ur","ot","raw","it","st","ct","atomValue","elements","ir","at","or","allowTrailingCommas","program","defaultOptions","getLineInfo","tokenize","startLoc","endLoc","jumpTo","break","case","catch","continue","debugger","do","else","finally","for","function","if","return","switch","throw","try","var","while","with","null","new","in","instanceof","typeof","void","delete","tokTypes","bracketL","bracketR","braceL","braceR","parenL","parenR","comma","semi","colon","question","slash","eq","eof","num","regexp","Ft","Pt","Ht","_t","isIdentifierStart","isIdentifierChar","+","-","*","/","%","==","!=","createVideo","find","propEq","vid","loop","_classCallCheck2","_classCallCheck3","_createClass2","_createClass3","_dialogue","_dialogue2","scene","dialogue","Story","bool","_this","fn","exists","onAfter","select","switchTo","__","@@functional/placeholder","_arity","a0","a5","a6","a7","a8","a9","_arrayFromIterator","done","_cloneRegExp","pattern","global","ignoreCase","multiline","sticky","unicode","_complement","_concat","set1","set2","idx","len1","len2","_containsWith","pred","_filter","_forceReduced","@@transducer/value","@@transducer/reduced","_has","_identity","_isArguments","_isArray","_isInteger","Number","isInteger","_isNumber","_isObject","_isPlaceholder","_isRegExp","_isString","_isTransformer","_map","functor","_of","_pipe","_pipeP","then","_quote","escaped","_reduced","_slice","_toISOString","pad","toISOString","getUTCFullYear","getUTCMonth","getUTCDate","getUTCHours","getUTCMinutes","getUTCSeconds","getUTCMilliseconds","toFixed","_xfBase","xf","_xwrap","XWrap","acc","_aperture","limit","_checkForMethod","methodname","_curry1","_curry2","_curry3","f3","_curryN","received","combined","argsIdx","combinedIdx","_dispatchable","transducer","_dropLastWhile","_xall","XAll","input","_xany","XAny","any","_xaperture","XAperture","full","store","getCopy","_xdrop","XDrop","_xdropLast","XDropLast","_xdropRepeatsWith","XDropRepeatsWith","lastValue","seenFirstValue","sameAsLast","_xdropWhile","XDropWhile","_xfilter","XFilter","_xfind","XFind","_xfindIndex","XFindIndex","_xfindLast","XFindLast","_xfindLastIndex","XFindLastIndex","lastIdx","_xmap","XMap","_xtake","XTake","_xtakeWhile","XTakeWhile","adjust","_idx","always","and","aperture","assoc","assocPath","thisObj","both","comparator","cond","countBy","counts","curryN","dec","defaultTo","differenceWith","second","firstLen","dissoc","dissocPath","tail","dropWhile","either","empty","evolve","transformations","transformation","findIndex","findLast","findLastIndex","fromPairs","gte","has","hasIn","identical","identity","ifElse","condition","onTrue","onFalse","elt","insertAll","elts","intersperse","is","Ctor","isNil","hasEnumBug","propertyIsEnumerable","nonEnumerableProps","hasArgsEnumBug","nIdx","ks","checkArgsLength","keysIn","lte","mapAccum","tuple","mapAccumRight","mathMod","maxBy","mergeWithKey","minBy","nAry","not","nth","nthArg","objOf","of","over","Identity","lens","fst","snd","pathOr","pathSatisfies","propPath","pickAll","pickBy","prepend","propOr","propSatisfies","ps","TypeError","reduceRight","reduced","regex","replacement","scan","fromIndex","toIndex","sortBy","aa","splitAt","array","splitEvery","splitWhen","take","xs","takeLastWhile","takeWhile","tap","times","RangeError","toPairs","toPairsIn","transpose","outerlist","innerlist","ws","zeroWidth","hasProtoTrim","beginRx","endRx","unapply","unary","uncurryN","depth","endIdx","currentDepth","unfold","seed","uniqWith","unless","whenFalseFn","useWith","transformers","vals","valuesIn","vs","Const","when","whenTrueFn","where","spec","testObj","wrap","wrapper","xprod","ilen","jlen","zip","zipObj","zipWith","refFrom","refTo","copiedValue","valueOf","_createPartialApplicator","_dropLast","stackA","stackB","message","entries","keysA","_makeFlat","recursive","flatt","_reduce","_arrayReduce","_iterableReduce","_methodReduce","symIterator","_xdropLastWhile","XDropLastWhile","retained","retain","flush","_xgroupBy","XGroupBy","inputs","addIndex","origFn","binary","curry","drop","dropLast","dropLastWhile","filter","filterable","groupBy","indexBy","elem","intersectionWith","results","invert","invertObj","mapObjIndexed","mergeWith","_l","partial","partialRight","partition","pathEq","propIs","reject","repeat","takeLast","transduce","unionWith","whereEq","_flatCat","preservingReduced","@@transducer/init","@@transducer/result","@@transducer/step","ret","rxf","_indexOf","inf","_xchain","allPass","preds","allUniq","anyPass","ap","applicative","monad","commuteMap","consF","constructN","Fn","$0","$1","$2","$3","$4","$5","$6","$7","$8","$9","converge","after","fns","dropRepeatsWith","eqBy","eqProps","juxt","lensIndex","lensPath","liftN","arity","lifted","mean","median","mergeAll","pipe","pipeP","product","sequence","traversable","traverse","unnest","_stepCat","_stepCatArray","_stepCatString","_stepCatObject","_toString","seen","recur","mapPairs","repr","commute","compose","composeK","composeP","construct","dropRepeats","into","lift","omit","pipeK","uniqBy","Set","appliedItem","applied","newSetSize","prevSetSize","nullExists","negZeroExists","without","complement","invoker","memoize","toLower","toUpper","uniq","intersection","symmetricDifference","symmetricDifferenceWith","union","answer","Dialogue","currentDialogue","currentPhrase","phrase","factory","createObj","inherit","Child","Parent","arr","findByPred","cloneArray","fillArray","slide","callSubscriber","ANY","VALUE","ERROR","Dispatcher","_items","_inLoop","_removedItems","_dispatcher","_active","_alive","_activating","_logHandlers","Stream","Property","_currentEvent","never","neverS","timeBased","mixin","AnonymousStream","wait","_wait","_intervalId","_$onTick","_onTick","_init","_free","_onActivation","_onDeactivation","clearInterval","_clear","later","interval","S$1","sequentially","S$2","fromPoll","S$3","emitter","obs","_emitValue","_emitError","_emitEnd","_emit","emitEvent","withInterval","S$4","S$5","_fn","_unsubscribe","stream","fromCallback","callbackConsumer","fromNodeCallback","spread","aLength","fromSubUnsub","unsub","transformer","eventName","constant","P$1","constantError","createConstructor","BaseClass","_source","_$handleAny","_handleAny","createClassMethods","_handleValue","_handleError","_handleEnd","END","onAny","offAny","createStream","createProperty","P$2","changes","S$6","fromPromise","promise","onError","_promise","getGlodalPromise","Promise","toPromise","symbol_","fromESObservable","_observable","observable","subscribe","unsubscribe","ESObservable","takeErrors","toESObservable","map$1","_ofSameType","S$7","P$3","id$1","S$8","P$4","S$9","P$5","S$10","P$6","id$2","S$11","P$7","S$12","P$8","skip","S$13","P$9","skipWhile","id$3","S$14","P$10","skipDuplicates","S$15","P$11","defaultFn","NOTHING","S$16","P$12","P$13","id$4","S$17","delay","S$18","P$14","throttle","_ref2","_ref2$leading","_ref2$trailing","trailing","S$19","P$15","debounce","_ref2$immediate","immediate","S$20","P$16","mapErrors","id$5","S$21","P$17","filterErrors","id$6","S$22","P$18","ignoreValues","S$23","P$19","ignoreErrors","S$24","P$20","ignoreEnd","S$25","P$21","beforeEnd","S$26","P$22","slidingWindow","S$27","P$23","bufferWhile","_ref2$flushOnEnd","flushOnEnd","S$28","P$24","id$7","bufferWhile$1","S$29","P$25","bufferWithTimeOrCount","S$30","P$26","xformForObs","S$31","P$27","withHandler","S$32","P$28","defaultErrorsCombinator","errors","latestError","Combine","active","passive","combinator","_activeCount","_sources","_combinator","_aliveCount","_latestValues","_latestErrors","_emitAfterActivation","_endAfterActivation","_latestErrorIndex","_$handlers","_loop","combine","Zip","_buffers","observables","AbstractPool","_ref","_ref$queueLim","queueLim","_ref$concurLim","concurLim","_ref$drop","_queueLim","_concurLim","_drop","_queue","_curSources","_$handleSubAny","_handleSubAny","_$endHandlers","_currentlyAdding","Merge","_addAll","_initialised","S$33","generator","_generator","_iteration","concat$1","Pool","FlatMap","_mainEnded","_lastCurrent","_$handleMain","_handleMain","FlatMapErrors","createConstructor$1","primary","secondary","_primary","_secondary","_lastSecondary","_$handleSecondaryAny","_handleSecondaryAny","_$handlePrimaryAny","_handlePrimaryAny","createClassMethods$1","_handlePrimaryValue","_handlePrimaryError","_handlePrimaryEnd","_handleSecondaryValue","_handleSecondaryError","_handleSecondaryEnd","_removeSecondary","createStream$1","createProperty$1","filterBy","S$34","P$29","sampledBy","id2","skipUntilBy","S$35","P$30","takeUntilBy","S$36","P$31","bufferBy","S$37","P$32","bufferWhileBy","S$38","P$33","awaiting","valuesToErrors","defFn","S$39","P$34","errorsToValues","defFn$1","S$40","P$35","endOnError","S$41","P$36","warn","msg","DEPRECATION_WARNINGS","msg2","dispatch","cleanup","_setActive","_on","_off","onEnd","offValue","offError","offEnd","sourceObs","selfName","isCurrent","offLog","handlerIndex","_xs","_emitter","_callUnsubscribe","_getInitialCurrent","getInitial","observer","mixin$1","mixin$2","_n","mixin$3","mixin$4","mixin$5","_lastValue","mixin$6","mixin$7","mixin$8","mixin$9","_seed","mixin$10","END_MARKER","mixin$11","_buff","_$shiftBuff","getTime","mixin$12","_leading","_trailing","_trailingValue","_timeoutId","_endLater","_lastCallTime","_$trailingCall","_trailingCall","curTime","remaining","_cancelTrailing","mixin$13","_immediate","_lastAttempt","_laterValue","_$later","_later","mixin$14","mixin$15","mixin$16","mixin$17","mixin$18","mixin$19","mixin$20","_max","_min","mixin$21","_flushOnEnd","_flush","mixin$22","mixin$23","mixin$24","_xform","mixin$25","_handler","_emitIfFull","hasAllValues","hasErrors","valuesCopy","errorsCopy","_isFull","id$8","toObs","_addToCur","_addToQueue","_removeOldest","obss","_this2","_removeCur","_removeQueue","_subToEnd","_this3","_subscribe","onEndI","_pullQueue","_onEmpty","_isEmpty","_getSource","plug","unplug","_hadNoEvSinceDeact","sameCurr","mixin$26","mixin$27","mixin$28","mixin$29","_ref$flushOnEnd","mixin$30","_ref$flushOnChange","flushOnChange","_flushOnChange","mixin$31","mixin$32","mixin$33","bufferWithCount","flatMap","flatMapLatest","flatMapFirst","flatMapConcat","flatMapConcurLimit","flatMapErrors","_classCallCheck","Constructor","_possibleConstructorReturn","ReferenceError","_inherits","subClass","superClass","setPrototypeOf","Atom","LensedAtom","AbstractMutable","_createClass","defineProperties","descriptor","protoProps","staticProps","_partial","_partial2","_Kefir$Property","getPrototypeOf","_len","ls","_key","_len2","_key2","_AbstractMutable","_lens","_$handleValue","_maybeEmitValue","handleValue","_AbstractMutable2","_this4","_toConsumableArray","arr2","_defineProperty","_extends","assign","_typeof","deleteKey","setKey","dropped","toPartial","conserve","toConserve","deleteAll","x2x","choose","x2yL","toFunctor","firstOf","lls","inn","required","predicate","findWith","_len3","_key3","ys","augment","template","toNode","mutationMacro","fragment","createDocumentFragment","ElementPrototype","Element","isSupported","replaceChild","locals"],"mappings":"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,OACAC,aACA1iB,cACA2iB,kBACAG,UACAC,cACAtnE,UACAkxE,QACAC,YACAC,iBACA2F,eACAjC,mBACAtN,aACAC,UACAC,SACAqN,QACAC,WACA9kF,UACAy3E,UACA0J,UACApU,QACA6K,aACAC,YACAC,iBACAtrC,WACA3P,QACAnjC,WACAq+E,aACAsJ,WACAjf,MACA4V,OACAC,OACAC,SACA3Z,QACA4Z,aACAC,YACAC,UACArnC,OACAswC,WACAv8E,WACAyiE,QACA/jE,UACAi1E,aACAuP,gBACAzG,oBACA5I,eACAkO,QACApF,UACAC,aACAiG,WACA/O,MACAxlF,eACAihB,WACAykE,SACAz5E,QACAylF,QACAjlF,QACAy5E,UACAttC,QACA+3B,eACA7uE,UACAqlF,QACAwK,aACAC,YACA7tF,YACA2vF,QACA7B,SACA3hB,MACAiW,OACAjmF,OACAkmF,YACAE,iBACAiI,iBACA1lF,SACA09E,WACAxvE,OACAyvE,SACAwL,QACAC,UACAuC,WACA7/C,SACAu9C,YACA1D,aACA/H,gBACA3vE,OACA4vE,SACAhqE,UACAF,YACAmqE,QACAhqE,UACAo2C,QACA6zB,OACAC,OACAC,UACAC,SACAC,MACA2M,QACA7hF,QACA4jE,MACAuR,QACA1wE,QACAm4E,WACAC,gBACAC,aACA9pF,QACA+pF,UACAvH,UACAC,iBACAl8E,QACAo8E,WACAC,UACAyK,QACAyB,SACAxB,SACAvuF,SACA8jF,WACA0K,WACAv/E,WACAxU,QACAq7E,UACAmV,UACAlH,UACAC,iBACA/9E,SACAw/D,SACArzC,UACA+xD,eACAC,WACA8G,UACAnsF,UACAosF,UACAn+E,WACAylB,WACA8xD,QACAkK,YACAj0F,OACAqP,SACA63C,QACAgjC,UACA9gD,SACAghD,WACAE,cACAC,aACAxsE,YACAjE,OACA08E,uBACAC,2BACA9Q,QACA6E,QACAoG,YACAlG,iBACAC,aACAC,OACA3/E,QACA4/E,SACAuL,WACArL,WACAC,aACA79E,YACAkpF,WACAxF,aACA5F,aACAkJ,YACApqB,Q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","file":"main.bundle.js","sourcesContent":["webpackJsonp([0],[\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t\n\tvar _paper = __webpack_require__(1);\n\t\n\tvar _paper2 = _interopRequireDefault(_paper);\n\t\n\tvar _story = __webpack_require__(2);\n\t\n\tvar _story2 = _interopRequireDefault(_story);\n\t\n\tvar _kefir = __webpack_require__(10);\n\t\n\tvar _kefir2 = __webpack_require__(11);\n\t\n\tvar _kefir3 = _interopRequireDefault(_kefir2);\n\t\n\tvar _ramda = __webpack_require__(8);\n\t\n\tvar _ramda2 = _interopRequireDefault(_ramda);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\t__webpack_require__(13);\n\t\n\twindow.R = _ramda2.default;\n\twindow.p = _paper2.default;\n\t\n\t__webpack_require__(14);\n\t\n\t_kefir.Kefir.Observable.prototype.pluck = function (prop) {\n\t\treturn this.map(_ramda2.default.view(_ramda2.default.lensProp(prop)));\n\t};\n\t\n\tvar story = new _story2.default();\n\t\n\tvar canvas = null;\n\tvar container = null;\n\t\n\t//var planet = null;\n\tvar graphene = null;\n\tvar carbon = null;\n\t\n\tvar video = null;\n\t\n\tvar gobjects = [];\n\t\n\tvar talk_text = null;\n\t\n\tvar font_size = 22;\n\t\n\tvar g_text = null;\n\tvar c_text = null;\n\t\n\tvar timeout_id = 0;\n\t\n\tvar main_button = null;\n\t\n\tvar volume = new _kefir3.default(0.5);\n\t\n\tstory.onBefore(\"end_true\", function () {\n\t\n\t\tstory.showDialogue = true;\n\t\n\t\ttoggleCharacters(false);\n\t\tgraphene.visible = true;\n\t\ttalk_text.visible = true;\n\t\n\t\tgraphene.setPosition(_paper2.default.view.center);\n\t\ttalk_text.content = \"А ти какво научи от всико това?\";\n\t\t_paper2.default.view.update(true);\n\t});\n\t\n\t//gala --replace\n\t\n\tstory.onBefore(\"test\", function () {\n\t\twindow.location.href = \"./test.html\";\n\t});\n\t\n\tvar resize = _kefir.Kefir.fromEvents(window, \"resize\").toProperty(function () {\n\t\treturn null;\n\t}).map(function () {\n\t\treturn { height: window.innerHeight, width: window.innerWidth };\n\t});\n\t\n\tvar center = resize.map(function () {\n\t\treturn _paper2.default.view.center;\n\t}).toProperty(function () {\n\t\treturn _paper2.default.view.center;\n\t});\n\t\n\tfunction set(obj, prop) {\n\t\treturn function (val) {\n\t\t\tobj[prop] = val;\n\t\t};\n\t}\n\t\n\twindow.createVolumeCtrl = function () {\n\t\tvar size = {\n\t\t\tx: 20,\n\t\t\ty: 20,\n\t\t\tw: 60\n\t\t};\n\t\tsize.h = 3 * size.w;\n\t\n\t\tvar path = {\n\t\t\tmw: 23, // margin width,x\n\t\t\tmh: 15 // margin height,y\n\t\t};\n\t\tvar volCtrlGroup = new _paper2.default.Group();\n\t\n\t\tvar rect_out_box = new _paper2.default.Rectangle(size.x, size.y, size.w, size.h);\n\t\tvar box = new _paper2.default.Shape.Rectangle(rect_out_box);\n\t\tbox.fillColor = \"black\";\n\t\n\t\tvolCtrlGroup.addChild(box);\n\t\n\t\tvar rect_blue_path = new _paper2.default.Rectangle(size.x + path.mw, size.y + path.mh, size.w - path.mw * 2, size.h - 20 - path.mh * 2);\n\t\tvar path_blue = new _paper2.default.Shape.Rectangle(rect_blue_path);\n\t\tpath_blue.fillColor = \"#000080\";\n\t\n\t\tvolCtrlGroup.addChild(path_blue);\n\t\n\t\tvar vol = volume.get() * 100 | 0;\n\t\n\t\tvar rect_white_path = new _paper2.default.Rectangle(size.x + path.mw, size.y + path.mh, size.w - path.mw * 2, (size.h - 20 - path.mh * 2) * (1 - volume.get()) | 0);\n\t\tvar path_white = new _paper2.default.Shape.Rectangle(rect_white_path);\n\t\tpath_white.fillColor = \"white\";\n\t\n\t\tvolCtrlGroup.addChild(path_white);\n\t\n\t\tvar text = new _paper2.default.PointText({\n\t\t\tpoint: new _paper2.default.Point(size.x + size.w / 2, size.w + (size.h - 25 - path.mh * 2)),\n\t\t\tcontent: vol + \"%\",\n\t\t\tfillColor: \"white\",\n\t\t\tfontFamily: \"Sans Serif\",\n\t\t\tfontWeight: \"bold\",\n\t\t\tfontSize: 13,\n\t\t\tjustification: \"center\"\n\t\t});\n\t\n\t\tvolCtrlGroup.addChild(text);\n\t\n\t\tvolCtrlGroup.visible = false;\n\t\n\t\twindow.vcg = volCtrlGroup;\n\t\n\t\tvar black_line = new _paper2.default.Shape.Rectangle(new _paper2.default.Rectangle(size.x + path.mw, size.y + path.mh, size.w - path.mw * 2, 1));\n\t\tblack_line.fillColor = \"black\";\n\t\n\t\tvolume.onValue(function (value) {\n\t\t\tvolCtrlGroup.visible = true;\n\t\t\tclearTimeout(window.vol_timout);\n\t\n\t\t\tvar vol = value * 100 | 0;\n\t\t\tvar bounds = new _paper2.default.Rectangle(size.x + path.mw, size.y + path.mh, size.w - path.mw * 2, (size.h - 20 - path.mh * 2) * (1 - value) | 0);\n\t\n\t\t\tif (bounds.height < 1) {\n\t\t\t\tbounds.height = 1;\n\t\t\t}\n\t\n\t\t\tpath_white.setBounds(bounds);\n\t\t\ttext.content = vol + \"%\";\n\t\t\t_paper2.default.view.draw();\n\t\n\t\t\twindow.vol_timout = setTimeout(function () {\n\t\t\t\tvolCtrlGroup.visible = false;\n\t\t\t\t_paper2.default.view.draw();\n\t\t\t}, 500);\n\t\t});\n\t\n\t\t_paper2.default.view.draw();\n\t};\n\t\n\tfunction toggleCharacters(val) {\n\t\tgraphene.visible = val;\n\t\tcarbon.visible = val;\n\t\ttalk_text.visible = val;\n\t\tg_text.visible = val;\n\t\tc_text.visible = val;\n\t\t_paper2.default.view.draw();\n\t\t_paper2.default.view.update(true);\n\t}\n\t\n\tfunction calculateButtonSize(rect) {\n\t\tvar res_rect = _ramda2.default.clone(rect);\n\t\tvar margin = 10;\n\t\tres_rect.x -= margin / 2;\n\t\tres_rect.y -= margin / 2;\n\t\tres_rect.width += margin;\n\t\tres_rect.height += margin;\n\t\n\t\treturn res_rect;\n\t}\n\t\n\tfunction showDialogue() {\n\t\tvar choices = story.choices();\n\t\n\t\tif (_ramda2.default.isArrayLike(choices)) {\n\t\t\t(function () {\n\t\t\t\t//\tconsole.log(choices)\n\t\t\t\tgobjects = [];\n\t\n\t\t\t\tvar width = 0;\n\t\t\t\tgobjects = choices.map(function (choice, n) {\n\t\t\t\t\tvar group = new _paper2.default.Group();\n\t\n\t\t\t\t\tvar text = new _paper2.default.PointText({\n\t\t\t\t\t\t//\tpoint: point,\n\t\t\t\t\t\tcontent: choice,\n\t\t\t\t\t\tfillColor: \"#000080\",\n\t\t\t\t\t\tfontFamily: \"Courier New\",\n\t\t\t\t\t\tfontWeight: \"bold\",\n\t\t\t\t\t\tfontSize: font_size,\n\t\t\t\t\t\tjustification: \"left\"\n\t\t\t\t\t});\n\t\t\t\t\ttext.onClick = function () {\n\t\t\t\t\t\treturn window.next(n);\n\t\t\t\t\t};\n\t\n\t\t\t\t\tvar button = main_button.clone();\n\t\t\t\t\tbutton.visible = true;\n\t\t\t\t\tbutton.setBounds(calculateButtonSize(text.bounds));\n\t\n\t\t\t\t\tgroup.addChild(button);\n\t\t\t\t\tgroup.addChild(text);\n\t\n\t\t\t\t\twidth += group.getBounds().width;\n\t\n\t\t\t\t\treturn group;\n\t\t\t\t});\n\t\n\t\t\t\tresize.onValue(function (size) {\n\t\t\t\t\tvar rem = size.width - width;\n\t\t\t\t\tvar padding = rem / (gobjects.length + 1);\n\t\t\t\t\tvar cur = padding;\n\t\t\t\t\tfor (var i = 0; i < gobjects.length; i++) {\n\t\t\t\t\t\tvar group = gobjects[i];\n\t\t\t\t\t\tgroup.bounds.x = cur;\n\t\t\t\t\t\tgroup.bounds.y = size.height - 75;\n\t\n\t\t\t\t\t\tcur += group.bounds.width + padding;\n\t\t\t\t\t}\n\t\n\t\t\t\t\t_paper2.default.view.draw();\n\t\t\t\t});\n\t\n\t\t\t\t_paper2.default.view.draw();\n\t\t\t})();\n\t\t} else {\n\t\n\t\t\ttalk_text.content = choices.who + \": \" + choices.say;\n\t\t\tvar len = choices.say.length;\n\t\t\tvar t = 0;\n\t\t\tif (len < 10) {\n\t\t\t\tt = 5000;\n\t\t\t} else {\n\t\t\t\tt = len * 200;\n\t\t\t}\n\t\n\t\t\ttimeout_id = setTimeout(function () {\n\t\t\t\twindow.next();\n\t\t\t}, t);\n\t\t}\n\t\t_paper2.default.view.draw();\n\t}\n\t\n\tfunction show(current) {\n\t\tvar video = story.current.video;\n\t\tif (video == current) {\n\t\t\treturn video;\n\t\t} else {\n\t\t\tif (current) {\n\t\t\t\tconsole.log(\"Removeing: \", video);\n\t\t\t\tcurrent.remove();\n\t\t\t}\n\t\t}\n\t\n\t\tvideo.addEventListener(\"ended\", function () {\n\t\t\treturn window.next();\n\t\t});\n\t\n\t\tcontainer.appendChild(video);\n\t\tvideo.play();\n\t\treturn video;\n\t}\n\t\n\twindow.next = function (arg) {\n\t\tclearTimeout(timeout_id);\n\t\tif (story.hasChoices() && arg == null) {\n\t\t\treturn;\n\t\t}\n\t\n\t\tgobjects.forEach(function (o) {\n\t\t\treturn o.remove();\n\t\t});\n\t\n\t\tstory.next(arg);\n\t\n\t\tif (story.hasDialogue()) {\n\t\n\t\t\tshowDialogue();\n\t\t\ttoggleCharacters(true);\n\t\t} else {\n\t\t\ttoggleCharacters(false);\n\t\t}\n\t\t_paper2.default.view.update(true);\n\t\n\t\tvideo = show(video);\n\t\tvideo.volume = volume.get();\n\t\n\t\tconsole.log(video);\n\t};\n\t\n\tvar volumeModifier = 0.05;\n\t\n\twindow.addEventListener(\"load\", function (event) {\n\t\tconsole.log(\"Loading\");\n\t\n\t\tcanvas = document.getElementById(\"drawSurf\");\n\t\tcontainer = document.getElementById(\"container\");\n\t\n\t\t_kefir.Kefir.fromEvents(canvas, \"mousewheel\").map(function (e) {\n\t\t\treturn e.wheelDelta < 0 ? -volumeModifier : volumeModifier;\n\t\t}).onValue(function (mod) {\n\t\t\tvolume.modify(function (old) {\n\t\t\t\tvar volume = old + mod;\n\t\t\t\tif (volume < 0) {\n\t\t\t\t\tvolume = 0;\n\t\t\t\t} else if (volume > 1) {\n\t\t\t\t\tvolume = 1;\n\t\t\t\t}\n\t\t\t\treturn volume;\n\t\t\t});\n\t\t});\n\t\n\t\t_paper2.default.setup(canvas);\n\t\n\t\tvolume.onValue(function (vol) {\n\t\t\tif (video != null) video.volume = vol;\n\t\t});\n\t\n\t\tresize.onValue(function (size) {\n\t\t\tcanvas.width = size.width;\n\t\t\tcanvas.height = size.height;\n\t\t\t_paper2.default.view.setViewSize(size.width, size.height);\n\t\n\t\t\t_paper2.default.view.draw();\n\t\t\t_paper2.default.view.update(true);\n\t\t});\n\t\n\t\t//planet = new paper.Raster(\"./mercury.png\")\n\t\n\t\tgraphene = new _paper2.default.Raster(\"./Graphene.png\");\n\t\tcarbon = new _paper2.default.Raster(\"./Carbon1.png\");\n\t\tgraphene.scale(-1, 1);\n\t\n\t\tresize.pluck(\"width\").toProperty().map(function (v) {\n\t\t\treturn v - 100;\n\t\t}).onValue(set(graphene.position, \"x\"));\n\t\tcarbon.position.x = 100;\n\t\n\t\tcarbon.scale(0.8, 0.8);\n\t\tgraphene.scale(0.8, 0.8);\n\t\n\t\ttalk_text = new _paper2.default.PointText({\n\t\t\tpoint: _paper2.default.view.center,\n\t\t\t//\tcontent: choices.who +\": \"+ choices.say,\n\t\t\tfillColor: 'white',\n\t\t\tfontFamily: 'Courier New',\n\t\t\tfontWeight: 'bold',\n\t\t\tfontSize: font_size,\n\t\t\tjustification: \"center\"\n\t\t});\n\t\n\t\tg_text = new _paper2.default.PointText({\n\t\t\tpoint: _paper2.default.view.center,\n\t\t\tcontent: \"Графен\",\n\t\t\tfillColor: 'white',\n\t\t\tfontFamily: 'Courier New',\n\t\t\tfontWeight: 'bold',\n\t\t\tfontSize: font_size,\n\t\t\tjustification: \"center\"\n\t\t});\n\t\n\t\tc_text = new _paper2.default.PointText({\n\t\t\tpoint: _paper2.default.view.center,\n\t\t\tcontent: \"Карбон\",\n\t\t\tfillColor: 'white',\n\t\t\tfontFamily: 'Courier New',\n\t\t\tfontWeight: 'bold',\n\t\t\tfontSize: font_size,\n\t\t\tjustification: \"center\"\n\t\t});\n\t\n\t\ttalk_text.importSVG(\"button.svg\", function (e) {\n\t\t\tmain_button = e;\n\t\t\tmain_button.visible = false;\n\t\t});\n\t\n\t\tresize.pluck(\"width\").toProperty().map(function (v) {\n\t\t\treturn v - 100;\n\t\t}).onValue(set(g_text.position, \"x\"));\n\t\n\t\tc_text.position.x = 100;\n\t\n\t\tcenter.onValue(function (center) {\n\t\t\tcarbon.position.y = center.y - 100;\n\t\t\tgraphene.position.y = center.y - 100;\n\t\t\tg_text.position.y = center.y + 200;\n\t\t\tc_text.position.y = center.y + 200;\n\t\t});\n\t\n\t\tcenter.map(function (point) {\n\t\t\treturn new _paper2.default.Point(point.x, point.y * 2 - 100);\n\t\t}).onValue(set(talk_text, \"point\"));\n\t\n\t\t//planet.position = paper.view.center;\n\t\n\t\t_paper2.default.view.onMouseDown = function () {\n\t\t\twindow.next();\n\t\t};\n\t\n\t\t//center.onValue(set(planet, \"position\"))\n\t\n\t\tvideo = show();\n\t\ttoggleCharacters(false);\n\t\n\t\tcreateVolumeCtrl();\n\t\n\t\tconsole.log(\"Loaded\");\n\t}, false);\n\n/***/ },\n/* 1 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!\n\t * Paper.js v0.9.25 - The Swiss Army Knife of Vector Graphics Scripting.\n\t * http://paperjs.org/\n\t *\n\t * Copyright (c) 2011 - 2014, Juerg Lehni & Jonathan Puckey\n\t * http://scratchdisk.com/ & http://jonathanpuckey.com/\n\t *\n\t * Distributed under the MIT license. See LICENSE file for details.\n\t *\n\t * All rights reserved.\n\t *\n\t * Date: Sun Oct 25 11:23:38 2015 +0100\n\t *\n\t ***\n\t *\n\t * Straps.js - Class inheritance library with support for bean-style accessors\n\t *\n\t * Copyright (c) 2006 - 2013 Juerg Lehni\n\t * http://scratchdisk.com/\n\t *\n\t * Distributed under the MIT license.\n\t *\n\t ***\n\t *\n\t * Acorn.js\n\t * http://marijnhaverbeke.nl/acorn/\n\t *\n\t * Acorn is a tiny, fast JavaScript parser written in JavaScript,\n\t * created by Marijn Haverbeke and released under an MIT license.\n\t *\n\t */\n\t\n\tvar paper = new function(undefined) {\n\t\n\tvar Base = new function() {\n\t\tvar hidden = /^(statics|enumerable|beans|preserve)$/,\n\t\n\t\t\tforEach = [].forEach || function(iter, bind) {\n\t\t\t\tfor (var i = 0, l = this.length; i < l; i++)\n\t\t\t\t\titer.call(bind, this[i], i, this);\n\t\t\t},\n\t\n\t\t\tforIn = function(iter, bind) {\n\t\t\t\tfor (var i in this)\n\t\t\t\t\tif (this.hasOwnProperty(i))\n\t\t\t\t\t\titer.call(bind, this[i], i, this);\n\t\t\t},\n\t\n\t\t\tcreate = Object.create || function(proto) {\n\t\t\t\treturn { __proto__: proto };\n\t\t\t},\n\t\n\t\t\tdescribe = Object.getOwnPropertyDescriptor || function(obj, name) {\n\t\t\t\tvar get = obj.__lookupGetter__ && obj.__lookupGetter__(name);\n\t\t\t\treturn get\n\t\t\t\t\t\t? { get: get, set: obj.__lookupSetter__(name),\n\t\t\t\t\t\t\tenumerable: true, configurable: true }\n\t\t\t\t\t\t: obj.hasOwnProperty(name)\n\t\t\t\t\t\t\t? { value: obj[name], enumerable: true,\n\t\t\t\t\t\t\t\tconfigurable: true, writable: true }\n\t\t\t\t\t\t\t: null;\n\t\t\t},\n\t\n\t\t\t_define = Object.defineProperty || function(obj, name, desc) {\n\t\t\t\tif ((desc.get || desc.set) && obj.__defineGetter__) {\n\t\t\t\t\tif (desc.get)\n\t\t\t\t\t\tobj.__defineGetter__(name, desc.get);\n\t\t\t\t\tif (desc.set)\n\t\t\t\t\t\tobj.__defineSetter__(name, desc.set);\n\t\t\t\t} else {\n\t\t\t\t\tobj[name] = desc.value;\n\t\t\t\t}\n\t\t\t\treturn obj;\n\t\t\t},\n\t\n\t\t\tdefine = function(obj, name, desc) {\n\t\t\t\tdelete obj[name];\n\t\t\t\treturn _define(obj, name, desc);\n\t\t\t};\n\t\n\t\tfunction inject(dest, src, enumerable, beans, preserve) {\n\t\t\tvar beansNames = {};\n\t\n\t\t\tfunction field(name, val) {\n\t\t\t\tval = val || (val = describe(src, name))\n\t\t\t\t\t\t&& (val.get ? val : val.value);\n\t\t\t\tif (typeof val === 'string' && val[0] === '#')\n\t\t\t\t\tval = dest[val.substring(1)] || val;\n\t\t\t\tvar isFunc = typeof val === 'function',\n\t\t\t\t\tres = val,\n\t\t\t\t\tprev = preserve || isFunc && !val.base\n\t\t\t\t\t\t\t? (val && val.get ? name in dest : dest[name])\n\t\t\t\t\t\t\t: null,\n\t\t\t\t\tbean;\n\t\t\t\tif (!preserve || !prev) {\n\t\t\t\t\tif (isFunc && prev)\n\t\t\t\t\t\tval.base = prev;\n\t\t\t\t\tif (isFunc && beans !== false\n\t\t\t\t\t\t\t&& (bean = name.match(/^([gs]et|is)(([A-Z])(.*))$/)))\n\t\t\t\t\t\tbeansNames[bean[3].toLowerCase() + bean[4]] = bean[2];\n\t\t\t\t\tif (!res || isFunc || !res.get || typeof res.get !== 'function'\n\t\t\t\t\t\t\t|| !Base.isPlainObject(res))\n\t\t\t\t\t\tres = { value: res, writable: true };\n\t\t\t\t\tif ((describe(dest, name)\n\t\t\t\t\t\t\t|| { configurable: true }).configurable) {\n\t\t\t\t\t\tres.configurable = true;\n\t\t\t\t\t\tres.enumerable = enumerable;\n\t\t\t\t\t}\n\t\t\t\t\tdefine(dest, name, res);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (src) {\n\t\t\t\tfor (var name in src) {\n\t\t\t\t\tif (src.hasOwnProperty(name) && !hidden.test(name))\n\t\t\t\t\t\tfield(name);\n\t\t\t\t}\n\t\t\t\tfor (var name in beansNames) {\n\t\t\t\t\tvar part = beansNames[name],\n\t\t\t\t\t\tset = dest['set' + part],\n\t\t\t\t\t\tget = dest['get' + part] || set && dest['is' + part];\n\t\t\t\t\tif (get && (beans === true || get.length === 0))\n\t\t\t\t\t\tfield(name, { get: get, set: set });\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn dest;\n\t\t}\n\t\n\t\tfunction each(obj, iter, bind) {\n\t\t\tif (obj)\n\t\t\t\t('length' in obj && !obj.getLength\n\t\t\t\t\t\t&& typeof obj.length === 'number'\n\t\t\t\t\t? forEach\n\t\t\t\t\t: forIn).call(obj, iter, bind = bind || obj);\n\t\t\treturn bind;\n\t\t}\n\t\n\t\tfunction set(obj, props, exclude) {\n\t\t\tfor (var key in props)\n\t\t\t\tif (props.hasOwnProperty(key) && !(exclude && exclude[key]))\n\t\t\t\t\tobj[key] = props[key];\n\t\t\treturn obj;\n\t\t}\n\t\n\t\treturn inject(function Base() {\n\t\t\tfor (var i = 0, l = arguments.length; i < l; i++)\n\t\t\t\tset(this, arguments[i]);\n\t\t}, {\n\t\t\tinject: function(src) {\n\t\t\t\tif (src) {\n\t\t\t\t\tvar statics = src.statics === true ? src : src.statics,\n\t\t\t\t\t\tbeans = src.beans,\n\t\t\t\t\t\tpreserve = src.preserve;\n\t\t\t\t\tif (statics !== src)\n\t\t\t\t\t\tinject(this.prototype, src, src.enumerable, beans, preserve);\n\t\t\t\t\tinject(this, statics, true, beans, preserve);\n\t\t\t\t}\n\t\t\t\tfor (var i = 1, l = arguments.length; i < l; i++)\n\t\t\t\t\tthis.inject(arguments[i]);\n\t\t\t\treturn this;\n\t\t\t},\n\t\n\t\t\textend: function() {\n\t\t\t\tvar base = this,\n\t\t\t\t\tctor,\n\t\t\t\t\tproto;\n\t\t\t\tfor (var i = 0, l = arguments.length; i < l; i++)\n\t\t\t\t\tif (ctor = arguments[i].initialize)\n\t\t\t\t\t\tbreak;\n\t\t\t\tctor = ctor || function() {\n\t\t\t\t\tbase.apply(this, arguments);\n\t\t\t\t};\n\t\t\t\tproto = ctor.prototype = create(this.prototype);\n\t\t\t\tdefine(proto, 'constructor',\n\t\t\t\t\t\t{ value: ctor, writable: true, configurable: true });\n\t\t\t\tinject(ctor, this, true);\n\t\t\t\tif (arguments.length)\n\t\t\t\t\tthis.inject.apply(ctor, arguments);\n\t\t\t\tctor.base = base;\n\t\t\t\treturn ctor;\n\t\t\t}\n\t\t}, true).inject({\n\t\t\tinject: function() {\n\t\t\t\tfor (var i = 0, l = arguments.length; i < l; i++) {\n\t\t\t\t\tvar src = arguments[i];\n\t\t\t\t\tif (src)\n\t\t\t\t\t\tinject(this, src, src.enumerable, src.beans, src.preserve);\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t},\n\t\n\t\t\textend: function() {\n\t\t\t\tvar res = create(this);\n\t\t\t\treturn res.inject.apply(res, arguments);\n\t\t\t},\n\t\n\t\t\teach: function(iter, bind) {\n\t\t\t\treturn each(this, iter, bind);\n\t\t\t},\n\t\n\t\t\tset: function(props) {\n\t\t\t\treturn set(this, props);\n\t\t\t},\n\t\n\t\t\tclone: function() {\n\t\t\t\treturn new this.constructor(this);\n\t\t\t},\n\t\n\t\t\tstatics: {\n\t\t\t\teach: each,\n\t\t\t\tcreate: create,\n\t\t\t\tdefine: define,\n\t\t\t\tdescribe: describe,\n\t\t\t\tset: set,\n\t\n\t\t\t\tclone: function(obj) {\n\t\t\t\t\treturn set(new obj.constructor(), obj);\n\t\t\t\t},\n\t\n\t\t\t\tisPlainObject: function(obj) {\n\t\t\t\t\tvar ctor = obj != null && obj.constructor;\n\t\t\t\t\treturn ctor && (ctor === Object || ctor === Base\n\t\t\t\t\t\t\t|| ctor.name === 'Object');\n\t\t\t\t},\n\t\n\t\t\t\tpick: function(a, b) {\n\t\t\t\t\treturn a !== undefined ? a : b;\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t};\n\t\n\tif (true)\n\t\tmodule.exports = Base;\n\t\n\tBase.inject({\n\t\ttoString: function() {\n\t\t\treturn this._id != null\n\t\t\t\t?  (this._class || 'Object') + (this._name\n\t\t\t\t\t? \" '\" + this._name + \"'\"\n\t\t\t\t\t: ' @' + this._id)\n\t\t\t\t: '{ ' + Base.each(this, function(value, key) {\n\t\t\t\t\tif (!/^_/.test(key)) {\n\t\t\t\t\t\tvar type = typeof value;\n\t\t\t\t\t\tthis.push(key + ': ' + (type === 'number'\n\t\t\t\t\t\t\t\t? Formatter.instance.number(value)\n\t\t\t\t\t\t\t\t: type === 'string' ? \"'\" + value + \"'\" : value));\n\t\t\t\t\t}\n\t\t\t\t}, []).join(', ') + ' }';\n\t\t},\n\t\n\t\tgetClassName: function() {\n\t\t\treturn this._class || '';\n\t\t},\n\t\n\t\texportJSON: function(options) {\n\t\t\treturn Base.exportJSON(this, options);\n\t\t},\n\t\n\t\ttoJSON: function() {\n\t\t\treturn Base.serialize(this);\n\t\t},\n\t\n\t\t_set: function(props, exclude, dontCheck) {\n\t\t\tif (props && (dontCheck || Base.isPlainObject(props))) {\n\t\t\t\tvar keys = Object.keys(props._filtering || props);\n\t\t\t\tfor (var i = 0, l = keys.length; i < l; i++) {\n\t\t\t\t\tvar key = keys[i];\n\t\t\t\t\tif (!(exclude && exclude[key])) {\n\t\t\t\t\t\tvar value = props[key];\n\t\t\t\t\t\tif (value !== undefined)\n\t\t\t\t\t\t\tthis[key] = value;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t}\n\t\t},\n\t\n\t\tstatics: {\n\t\n\t\t\texports: {\n\t\t\t\tenumerable: true\n\t\t\t},\n\t\n\t\t\textend: function extend() {\n\t\t\t\tvar res = extend.base.apply(this, arguments),\n\t\t\t\t\tname = res.prototype._class;\n\t\t\t\tif (name && !Base.exports[name])\n\t\t\t\t\tBase.exports[name] = res;\n\t\t\t\treturn res;\n\t\t\t},\n\t\n\t\t\tequals: function(obj1, obj2) {\n\t\t\t\tif (obj1 === obj2)\n\t\t\t\t\treturn true;\n\t\t\t\tif (obj1 && obj1.equals)\n\t\t\t\t\treturn obj1.equals(obj2);\n\t\t\t\tif (obj2 && obj2.equals)\n\t\t\t\t\treturn obj2.equals(obj1);\n\t\t\t\tif (obj1 && obj2\n\t\t\t\t\t\t&& typeof obj1 === 'object' && typeof obj2 === 'object') {\n\t\t\t\t\tif (Array.isArray(obj1) && Array.isArray(obj2)) {\n\t\t\t\t\t\tvar length = obj1.length;\n\t\t\t\t\t\tif (length !== obj2.length)\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\twhile (length--) {\n\t\t\t\t\t\t\tif (!Base.equals(obj1[length], obj2[length]))\n\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tvar keys = Object.keys(obj1),\n\t\t\t\t\t\t\tlength = keys.length;\n\t\t\t\t\t\tif (length !== Object.keys(obj2).length)\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\twhile (length--) {\n\t\t\t\t\t\t\tvar key = keys[length];\n\t\t\t\t\t\t\tif (!(obj2.hasOwnProperty(key)\n\t\t\t\t\t\t\t\t\t&& Base.equals(obj1[key], obj2[key])))\n\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\treturn false;\n\t\t\t},\n\t\n\t\t\tread: function(list, start, options, length) {\n\t\t\t\tif (this === Base) {\n\t\t\t\t\tvar value = this.peek(list, start);\n\t\t\t\t\tlist.__index++;\n\t\t\t\t\treturn value;\n\t\t\t\t}\n\t\t\t\tvar proto = this.prototype,\n\t\t\t\t\treadIndex = proto._readIndex,\n\t\t\t\t\tindex = start || readIndex && list.__index || 0;\n\t\t\t\tif (!length)\n\t\t\t\t\tlength = list.length - index;\n\t\t\t\tvar obj = list[index];\n\t\t\t\tif (obj instanceof this\n\t\t\t\t\t|| options && options.readNull && obj == null && length <= 1) {\n\t\t\t\t\tif (readIndex)\n\t\t\t\t\t\tlist.__index = index + 1;\n\t\t\t\t\treturn obj && options && options.clone ? obj.clone() : obj;\n\t\t\t\t}\n\t\t\t\tobj = Base.create(this.prototype);\n\t\t\t\tif (readIndex)\n\t\t\t\t\tobj.__read = true;\n\t\t\t\tobj = obj.initialize.apply(obj, index > 0 || length < list.length\n\t\t\t\t\t? Array.prototype.slice.call(list, index, index + length)\n\t\t\t\t\t: list) || obj;\n\t\t\t\tif (readIndex) {\n\t\t\t\t\tlist.__index = index + obj.__read;\n\t\t\t\t\tobj.__read = undefined;\n\t\t\t\t}\n\t\t\t\treturn obj;\n\t\t\t},\n\t\n\t\t\tpeek: function(list, start) {\n\t\t\t\treturn list[list.__index = start || list.__index || 0];\n\t\t\t},\n\t\n\t\t\tremain: function(list) {\n\t\t\t\treturn list.length - (list.__index || 0);\n\t\t\t},\n\t\n\t\t\treadAll: function(list, start, options) {\n\t\t\t\tvar res = [],\n\t\t\t\t\tentry;\n\t\t\t\tfor (var i = start || 0, l = list.length; i < l; i++) {\n\t\t\t\t\tres.push(Array.isArray(entry = list[i])\n\t\t\t\t\t\t\t? this.read(entry, 0, options)\n\t\t\t\t\t\t\t: this.read(list, i, options, 1));\n\t\t\t\t}\n\t\t\t\treturn res;\n\t\t\t},\n\t\n\t\t\treadNamed: function(list, name, start, options, length) {\n\t\t\t\tvar value = this.getNamed(list, name),\n\t\t\t\t\thasObject = value !== undefined;\n\t\t\t\tif (hasObject) {\n\t\t\t\t\tvar filtered = list._filtered;\n\t\t\t\t\tif (!filtered) {\n\t\t\t\t\t\tfiltered = list._filtered = Base.create(list[0]);\n\t\t\t\t\t\tfiltered._filtering = list[0];\n\t\t\t\t\t}\n\t\t\t\t\tfiltered[name] = undefined;\n\t\t\t\t}\n\t\t\t\treturn this.read(hasObject ? [value] : list, start, options, length);\n\t\t\t},\n\t\n\t\t\tgetNamed: function(list, name) {\n\t\t\t\tvar arg = list[0];\n\t\t\t\tif (list._hasObject === undefined)\n\t\t\t\t\tlist._hasObject = list.length === 1 && Base.isPlainObject(arg);\n\t\t\t\tif (list._hasObject)\n\t\t\t\t\treturn name ? arg[name] : list._filtered || arg;\n\t\t\t},\n\t\n\t\t\thasNamed: function(list, name) {\n\t\t\t\treturn !!this.getNamed(list, name);\n\t\t\t},\n\t\n\t\t\tisPlainValue: function(obj, asString) {\n\t\t\t\treturn this.isPlainObject(obj) || Array.isArray(obj)\n\t\t\t\t\t\t|| asString && typeof obj === 'string';\n\t\t\t},\n\t\n\t\t\tserialize: function(obj, options, compact, dictionary) {\n\t\t\t\toptions = options || {};\n\t\n\t\t\t\tvar root = !dictionary,\n\t\t\t\t\tres;\n\t\t\t\tif (root) {\n\t\t\t\t\toptions.formatter = new Formatter(options.precision);\n\t\t\t\t\tdictionary = {\n\t\t\t\t\t\tlength: 0,\n\t\t\t\t\t\tdefinitions: {},\n\t\t\t\t\t\treferences: {},\n\t\t\t\t\t\tadd: function(item, create) {\n\t\t\t\t\t\t\tvar id = '#' + item._id,\n\t\t\t\t\t\t\t\tref = this.references[id];\n\t\t\t\t\t\t\tif (!ref) {\n\t\t\t\t\t\t\t\tthis.length++;\n\t\t\t\t\t\t\t\tvar res = create.call(item),\n\t\t\t\t\t\t\t\t\tname = item._class;\n\t\t\t\t\t\t\t\tif (name && res[0] !== name)\n\t\t\t\t\t\t\t\t\tres.unshift(name);\n\t\t\t\t\t\t\t\tthis.definitions[id] = res;\n\t\t\t\t\t\t\t\tref = this.references[id] = [id];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn ref;\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t\tif (obj && obj._serialize) {\n\t\t\t\t\tres = obj._serialize(options, dictionary);\n\t\t\t\t\tvar name = obj._class;\n\t\t\t\t\tif (name && !compact && !res._compact && res[0] !== name)\n\t\t\t\t\t\tres.unshift(name);\n\t\t\t\t} else if (Array.isArray(obj)) {\n\t\t\t\t\tres = [];\n\t\t\t\t\tfor (var i = 0, l = obj.length; i < l; i++)\n\t\t\t\t\t\tres[i] = Base.serialize(obj[i], options, compact,\n\t\t\t\t\t\t\t\tdictionary);\n\t\t\t\t\tif (compact)\n\t\t\t\t\t\tres._compact = true;\n\t\t\t\t} else if (Base.isPlainObject(obj)) {\n\t\t\t\t\tres = {};\n\t\t\t\t\tvar keys = Object.keys(obj);\n\t\t\t\t\tfor (var i = 0, l = keys.length; i < l; i++) {\n\t\t\t\t\t\tvar key = keys[i];\n\t\t\t\t\t\tres[key] = Base.serialize(obj[key], options, compact,\n\t\t\t\t\t\t\t\tdictionary);\n\t\t\t\t\t}\n\t\t\t\t} else if (typeof obj === 'number') {\n\t\t\t\t\tres = options.formatter.number(obj, options.precision);\n\t\t\t\t} else {\n\t\t\t\t\tres = obj;\n\t\t\t\t}\n\t\t\t\treturn root && dictionary.length > 0\n\t\t\t\t\t\t? [['dictionary', dictionary.definitions], res]\n\t\t\t\t\t\t: res;\n\t\t\t},\n\t\n\t\t\tdeserialize: function(json, create, _data, _isDictionary) {\n\t\t\t\tvar res = json,\n\t\t\t\t\tisRoot = !_data;\n\t\t\t\t_data = _data || {};\n\t\t\t\tif (Array.isArray(json)) {\n\t\t\t\t\tvar type = json[0],\n\t\t\t\t\t\tisDictionary = type === 'dictionary';\n\t\t\t\t\tif (json.length == 1 && /^#/.test(type))\n\t\t\t\t\t\treturn _data.dictionary[type];\n\t\t\t\t\ttype = Base.exports[type];\n\t\t\t\t\tres = [];\n\t\t\t\t\tif (_isDictionary)\n\t\t\t\t\t\t_data.dictionary = res;\n\t\t\t\t\tfor (var i = type ? 1 : 0, l = json.length; i < l; i++)\n\t\t\t\t\t\tres.push(Base.deserialize(json[i], create, _data,\n\t\t\t\t\t\t\t\tisDictionary));\n\t\t\t\t\tif (type) {\n\t\t\t\t\t\tvar args = res;\n\t\t\t\t\t\tif (create) {\n\t\t\t\t\t\t\tres = create(type, args);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tres = Base.create(type.prototype);\n\t\t\t\t\t\t\ttype.apply(res, args);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else if (Base.isPlainObject(json)) {\n\t\t\t\t\tres = {};\n\t\t\t\t\tif (_isDictionary)\n\t\t\t\t\t\t_data.dictionary = res;\n\t\t\t\t\tfor (var key in json)\n\t\t\t\t\t\tres[key] = Base.deserialize(json[key], create, _data);\n\t\t\t\t}\n\t\t\t\treturn isRoot && json && json.length && json[0][0] === 'dictionary'\n\t\t\t\t\t\t? res[1]\n\t\t\t\t\t\t: res;\n\t\t\t},\n\t\n\t\t\texportJSON: function(obj, options) {\n\t\t\t\tvar json = Base.serialize(obj, options);\n\t\t\t\treturn options && options.asString === false\n\t\t\t\t\t\t? json\n\t\t\t\t\t\t: JSON.stringify(json);\n\t\t\t},\n\t\n\t\t\timportJSON: function(json, target) {\n\t\t\t\treturn Base.deserialize(\n\t\t\t\t\t\ttypeof json === 'string' ? JSON.parse(json) : json,\n\t\t\t\t\t\tfunction(type, args) {\n\t\t\t\t\t\t\tvar obj = target && target.constructor === type\n\t\t\t\t\t\t\t\t\t? target\n\t\t\t\t\t\t\t\t\t: Base.create(type.prototype),\n\t\t\t\t\t\t\t\tisTarget = obj === target;\n\t\t\t\t\t\t\tif (args.length === 1 && obj instanceof Item\n\t\t\t\t\t\t\t\t\t&& (isTarget || !(obj instanceof Layer))) {\n\t\t\t\t\t\t\t\tvar arg = args[0];\n\t\t\t\t\t\t\t\tif (Base.isPlainObject(arg))\n\t\t\t\t\t\t\t\t\targ.insert = false;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ttype.apply(obj, args);\n\t\t\t\t\t\t\tif (isTarget)\n\t\t\t\t\t\t\t\ttarget = null;\n\t\t\t\t\t\t\treturn obj;\n\t\t\t\t\t\t});\n\t\t\t},\n\t\n\t\t\tsplice: function(list, items, index, remove) {\n\t\t\t\tvar amount = items && items.length,\n\t\t\t\t\tappend = index === undefined;\n\t\t\t\tindex = append ? list.length : index;\n\t\t\t\tif (index > list.length)\n\t\t\t\t\tindex = list.length;\n\t\t\t\tfor (var i = 0; i < amount; i++)\n\t\t\t\t\titems[i]._index = index + i;\n\t\t\t\tif (append) {\n\t\t\t\t\tlist.push.apply(list, items);\n\t\t\t\t\treturn [];\n\t\t\t\t} else {\n\t\t\t\t\tvar args = [index, remove];\n\t\t\t\t\tif (items)\n\t\t\t\t\t\targs.push.apply(args, items);\n\t\t\t\t\tvar removed = list.splice.apply(list, args);\n\t\t\t\t\tfor (var i = 0, l = removed.length; i < l; i++)\n\t\t\t\t\t\tremoved[i]._index = undefined;\n\t\t\t\t\tfor (var i = index + amount, l = list.length; i < l; i++)\n\t\t\t\t\t\tlist[i]._index = i;\n\t\t\t\t\treturn removed;\n\t\t\t\t}\n\t\t\t},\n\t\n\t\t\tcapitalize: function(str) {\n\t\t\t\treturn str.replace(/\\b[a-z]/g, function(match) {\n\t\t\t\t\treturn match.toUpperCase();\n\t\t\t\t});\n\t\t\t},\n\t\n\t\t\tcamelize: function(str) {\n\t\t\t\treturn str.replace(/-(.)/g, function(all, chr) {\n\t\t\t\t\treturn chr.toUpperCase();\n\t\t\t\t});\n\t\t\t},\n\t\n\t\t\thyphenate: function(str) {\n\t\t\t\treturn str.replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase();\n\t\t\t}\n\t\t}\n\t});\n\t\n\tvar Emitter = {\n\t\ton: function(type, func) {\n\t\t\tif (typeof type !== 'string') {\n\t\t\t\tBase.each(type, function(value, key) {\n\t\t\t\t\tthis.on(key, value);\n\t\t\t\t}, this);\n\t\t\t} else {\n\t\t\t\tvar types = this._eventTypes,\n\t\t\t\t\tentry = types && types[type],\n\t\t\t\t\thandlers = this._callbacks = this._callbacks || {};\n\t\t\t\thandlers = handlers[type] = handlers[type] || [];\n\t\t\t\tif (handlers.indexOf(func) === -1) {\n\t\t\t\t\thandlers.push(func);\n\t\t\t\t\tif (entry && entry.install && handlers.length === 1)\n\t\t\t\t\t\tentry.install.call(this, type);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn this;\n\t\t},\n\t\n\t\toff: function(type, func) {\n\t\t\tif (typeof type !== 'string') {\n\t\t\t\tBase.each(type, function(value, key) {\n\t\t\t\t\tthis.off(key, value);\n\t\t\t\t}, this);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvar types = this._eventTypes,\n\t\t\t\tentry = types && types[type],\n\t\t\t\thandlers = this._callbacks && this._callbacks[type],\n\t\t\t\tindex;\n\t\t\tif (handlers) {\n\t\t\t\tif (!func || (index = handlers.indexOf(func)) !== -1\n\t\t\t\t\t\t&& handlers.length === 1) {\n\t\t\t\t\tif (entry && entry.uninstall)\n\t\t\t\t\t\tentry.uninstall.call(this, type);\n\t\t\t\t\tdelete this._callbacks[type];\n\t\t\t\t} else if (index !== -1) {\n\t\t\t\t\thandlers.splice(index, 1);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn this;\n\t\t},\n\t\n\t\tonce: function(type, func) {\n\t\t\treturn this.on(type, function() {\n\t\t\t\tfunc.apply(this, arguments);\n\t\t\t\tthis.off(type, func);\n\t\t\t});\n\t\t},\n\t\n\t\temit: function(type, event) {\n\t\t\tvar handlers = this._callbacks && this._callbacks[type];\n\t\t\tif (!handlers)\n\t\t\t\treturn false;\n\t\t\tvar args = [].slice.call(arguments, 1);\n\t\t\thandlers = handlers.slice();\n\t\t\tfor (var i = 0, l = handlers.length; i < l; i++) {\n\t\t\t\tif (handlers[i].apply(this, args) === false) {\n\t\t\t\t\tif (event && event.stop)\n\t\t\t\t\t\tevent.stop();\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t},\n\t\n\t\tresponds: function(type) {\n\t\t\treturn !!(this._callbacks && this._callbacks[type]);\n\t\t},\n\t\n\t\tattach: '#on',\n\t\tdetach: '#off',\n\t\tfire: '#emit',\n\t\n\t\t_installEvents: function(install) {\n\t\t\tvar handlers = this._callbacks,\n\t\t\t\tkey = install ? 'install' : 'uninstall';\n\t\t\tfor (var type in handlers) {\n\t\t\t\tif (handlers[type].length > 0) {\n\t\t\t\t\tvar types = this._eventTypes,\n\t\t\t\t\t\tentry = types && types[type],\n\t\t\t\t\t\tfunc = entry && entry[key];\n\t\t\t\t\tif (func)\n\t\t\t\t\t\tfunc.call(this, type);\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\n\t\tstatics: {\n\t\t\tinject: function inject(src) {\n\t\t\t\tvar events = src._events;\n\t\t\t\tif (events) {\n\t\t\t\t\tvar types = {};\n\t\t\t\t\tBase.each(events, function(entry, key) {\n\t\t\t\t\t\tvar isString = typeof entry === 'string',\n\t\t\t\t\t\t\tname = isString ? entry : key,\n\t\t\t\t\t\t\tpart = Base.capitalize(name),\n\t\t\t\t\t\t\ttype = name.substring(2).toLowerCase();\n\t\t\t\t\t\ttypes[type] = isString ? {} : entry;\n\t\t\t\t\t\tname = '_' + name;\n\t\t\t\t\t\tsrc['get' + part] = function() {\n\t\t\t\t\t\t\treturn this[name];\n\t\t\t\t\t\t};\n\t\t\t\t\t\tsrc['set' + part] = function(func) {\n\t\t\t\t\t\t\tvar prev = this[name];\n\t\t\t\t\t\t\tif (prev)\n\t\t\t\t\t\t\t\tthis.off(type, prev);\n\t\t\t\t\t\t\tif (func)\n\t\t\t\t\t\t\t\tthis.on(type, func);\n\t\t\t\t\t\t\tthis[name] = func;\n\t\t\t\t\t\t};\n\t\t\t\t\t});\n\t\t\t\t\tsrc._eventTypes = types;\n\t\t\t\t}\n\t\t\t\treturn inject.base.apply(this, arguments);\n\t\t\t}\n\t\t}\n\t};\n\t\n\tvar PaperScope = Base.extend({\n\t\t_class: 'PaperScope',\n\t\n\t\tinitialize: function PaperScope() {\n\t\t\tpaper = this;\n\t\t\tthis.settings = new Base({\n\t\t\t\tapplyMatrix: true,\n\t\t\t\thandleSize: 4,\n\t\t\t\thitTolerance: 0\n\t\t\t});\n\t\t\tthis.project = null;\n\t\t\tthis.projects = [];\n\t\t\tthis.tools = [];\n\t\t\tthis.palettes = [];\n\t\t\tthis._id = PaperScope._id++;\n\t\t\tPaperScope._scopes[this._id] = this;\n\t\t\tvar proto = PaperScope.prototype;\n\t\t\tif (!this.support) {\n\t\t\t\tvar ctx = CanvasProvider.getContext(1, 1);\n\t\t\t\tproto.support = {\n\t\t\t\t\tnativeDash: 'setLineDash' in ctx || 'mozDash' in ctx,\n\t\t\t\t\tnativeBlendModes: BlendMode.nativeModes\n\t\t\t\t};\n\t\t\t\tCanvasProvider.release(ctx);\n\t\t\t}\n\t\n\t\t\tif (!this.browser) {\n\t\t\t\tvar agent = navigator.userAgent.toLowerCase(),\n\t\t\t\t\tplatform = (/(win)/.exec(agent)\n\t\t\t\t\t\t\t|| /(mac)/.exec(agent)\n\t\t\t\t\t\t\t|| /(linux)/.exec(agent)\n\t\t\t\t\t\t\t|| [])[0],\n\t\t\t\t\tbrowser = proto.browser = { platform: platform };\n\t\t\t\tif (platform)\n\t\t\t\t\tbrowser[platform] = true;\n\t\t\t\tagent.replace(\n\t\t\t\t\t/(opera|chrome|safari|webkit|firefox|msie|trident|atom)\\/?\\s*([.\\d]+)(?:.*version\\/([.\\d]+))?(?:.*rv\\:([.\\d]+))?/g,\n\t\t\t\t\tfunction(all, n, v1, v2, rv) {\n\t\t\t\t\t\tif (!browser.chrome) {\n\t\t\t\t\t\t\tvar v = n === 'opera' ? v2 : v1;\n\t\t\t\t\t\t\tif (n === 'trident') {\n\t\t\t\t\t\t\t\tv = rv;\n\t\t\t\t\t\t\t\tn = 'msie';\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbrowser.version = v;\n\t\t\t\t\t\t\tbrowser.versionNumber = parseFloat(v);\n\t\t\t\t\t\t\tbrowser.name = n;\n\t\t\t\t\t\t\tbrowser[n] = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t);\n\t\t\t\tif (browser.chrome)\n\t\t\t\t\tdelete browser.webkit;\n\t\t\t\tif (browser.atom)\n\t\t\t\t\tdelete browser.chrome;\n\t\t\t}\n\t\t},\n\t\n\t\tversion: \"0.9.25\",\n\t\n\t\tgetView: function() {\n\t\t\treturn this.project && this.project.getView();\n\t\t},\n\t\n\t\tgetPaper: function() {\n\t\t\treturn this;\n\t\t},\n\t\n\t\texecute: function(code, url, options) {\n\t\t\tpaper.PaperScript.execute(code, this, url, options);\n\t\t\tView.updateFocus();\n\t\t},\n\t\n\t\tinstall: function(scope) {\n\t\t\tvar that = this;\n\t\t\tBase.each(['project', 'view', 'tool'], function(key) {\n\t\t\t\tBase.define(scope, key, {\n\t\t\t\t\tconfigurable: true,\n\t\t\t\t\tget: function() {\n\t\t\t\t\t\treturn that[key];\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t});\n\t\t\tfor (var key in this)\n\t\t\t\tif (!/^_/.test(key) && this[key])\n\t\t\t\t\tscope[key] = this[key];\n\t\t},\n\t\n\t\tsetup: function(element) {\n\t\t\tpaper = this;\n\t\t\tthis.project = new Project(element);\n\t\t\treturn this;\n\t\t},\n\t\n\t\tactivate: function() {\n\t\t\tpaper = this;\n\t\t},\n\t\n\t\tclear: function() {\n\t\t\tfor (var i = this.projects.length - 1; i >= 0; i--)\n\t\t\t\tthis.projects[i].remove();\n\t\t\tfor (var i = this.tools.length - 1; i >= 0; i--)\n\t\t\t\tthis.tools[i].remove();\n\t\t\tfor (var i = this.palettes.length - 1; i >= 0; i--)\n\t\t\t\tthis.palettes[i].remove();\n\t\t},\n\t\n\t\tremove: function() {\n\t\t\tthis.clear();\n\t\t\tdelete PaperScope._scopes[this._id];\n\t\t},\n\t\n\t\tstatics: new function() {\n\t\t\tfunction handleAttribute(name) {\n\t\t\t\tname += 'Attribute';\n\t\t\t\treturn function(el, attr) {\n\t\t\t\t\treturn el[name](attr) || el[name]('data-paper-' + attr);\n\t\t\t\t};\n\t\t\t}\n\t\n\t\t\treturn {\n\t\t\t\t_scopes: {},\n\t\t\t\t_id: 0,\n\t\n\t\t\t\tget: function(id) {\n\t\t\t\t\treturn this._scopes[id] || null;\n\t\t\t\t},\n\t\n\t\t\t\tgetAttribute: handleAttribute('get'),\n\t\t\t\thasAttribute: handleAttribute('has')\n\t\t\t};\n\t\t}\n\t});\n\t\n\tvar PaperScopeItem = Base.extend(Emitter, {\n\t\n\t\tinitialize: function(activate) {\n\t\t\tthis._scope = paper;\n\t\t\tthis._index = this._scope[this._list].push(this) - 1;\n\t\t\tif (activate || !this._scope[this._reference])\n\t\t\t\tthis.activate();\n\t\t},\n\t\n\t\tactivate: function() {\n\t\t\tif (!this._scope)\n\t\t\t\treturn false;\n\t\t\tvar prev = this._scope[this._reference];\n\t\t\tif (prev && prev !== this)\n\t\t\t\tprev.emit('deactivate');\n\t\t\tthis._scope[this._reference] = this;\n\t\t\tthis.emit('activate', prev);\n\t\t\treturn true;\n\t\t},\n\t\n\t\tisActive: function() {\n\t\t\treturn this._scope[this._reference] === this;\n\t\t},\n\t\n\t\tremove: function() {\n\t\t\tif (this._index == null)\n\t\t\t\treturn false;\n\t\t\tBase.splice(this._scope[this._list], null, this._index, 1);\n\t\t\tif (this._scope[this._reference] == this)\n\t\t\t\tthis._scope[this._reference] = null;\n\t\t\tthis._scope = null;\n\t\t\treturn true;\n\t\t}\n\t});\n\t\n\tvar Formatter = Base.extend({\n\t\tinitialize: function(precision) {\n\t\t\tthis.precision = precision || 5;\n\t\t\tthis.multiplier = Math.pow(10, this.precision);\n\t\t},\n\t\n\t\tnumber: function(val) {\n\t\t\treturn Math.round(val * this.multiplier) / this.multiplier;\n\t\t},\n\t\n\t\tpair: function(val1, val2, separator) {\n\t\t\treturn this.number(val1) + (separator || ',') + this.number(val2);\n\t\t},\n\t\n\t\tpoint: function(val, separator) {\n\t\t\treturn this.number(val.x) + (separator || ',') + this.number(val.y);\n\t\t},\n\t\n\t\tsize: function(val, separator) {\n\t\t\treturn this.number(val.width) + (separator || ',')\n\t\t\t\t\t+ this.number(val.height);\n\t\t},\n\t\n\t\trectangle: function(val, separator) {\n\t\t\treturn this.point(val, separator) + (separator || ',')\n\t\t\t\t\t+ this.size(val, separator);\n\t\t}\n\t});\n\t\n\tFormatter.instance = new Formatter();\n\t\n\tvar Numerical = new function() {\n\t\n\t\tvar abscissas = [\n\t\t\t[  0.5773502691896257645091488],\n\t\t\t[0,0.7745966692414833770358531],\n\t\t\t[  0.3399810435848562648026658,0.8611363115940525752239465],\n\t\t\t[0,0.5384693101056830910363144,0.9061798459386639927976269],\n\t\t\t[  0.2386191860831969086305017,0.6612093864662645136613996,0.9324695142031520278123016],\n\t\t\t[0,0.4058451513773971669066064,0.7415311855993944398638648,0.9491079123427585245261897],\n\t\t\t[  0.1834346424956498049394761,0.5255324099163289858177390,0.7966664774136267395915539,0.9602898564975362316835609],\n\t\t\t[0,0.3242534234038089290385380,0.6133714327005903973087020,0.8360311073266357942994298,0.9681602395076260898355762],\n\t\t\t[  0.1488743389816312108848260,0.4333953941292471907992659,0.6794095682990244062343274,0.8650633666889845107320967,0.9739065285171717200779640],\n\t\t\t[0,0.2695431559523449723315320,0.5190961292068118159257257,0.7301520055740493240934163,0.8870625997680952990751578,0.9782286581460569928039380],\n\t\t\t[  0.1252334085114689154724414,0.3678314989981801937526915,0.5873179542866174472967024,0.7699026741943046870368938,0.9041172563704748566784659,0.9815606342467192506905491],\n\t\t\t[0,0.2304583159551347940655281,0.4484927510364468528779129,0.6423493394403402206439846,0.8015780907333099127942065,0.9175983992229779652065478,0.9841830547185881494728294],\n\t\t\t[  0.1080549487073436620662447,0.3191123689278897604356718,0.5152486363581540919652907,0.6872929048116854701480198,0.8272013150697649931897947,0.9284348836635735173363911,0.9862838086968123388415973],\n\t\t\t[0,0.2011940939974345223006283,0.3941513470775633698972074,0.5709721726085388475372267,0.7244177313601700474161861,0.8482065834104272162006483,0.9372733924007059043077589,0.9879925180204854284895657],\n\t\t\t[  0.0950125098376374401853193,0.2816035507792589132304605,0.4580167776572273863424194,0.6178762444026437484466718,0.7554044083550030338951012,0.8656312023878317438804679,0.9445750230732325760779884,0.9894009349916499325961542]\n\t\t];\n\t\n\t\tvar weights = [\n\t\t\t[1],\n\t\t\t[0.8888888888888888888888889,0.5555555555555555555555556],\n\t\t\t[0.6521451548625461426269361,0.3478548451374538573730639],\n\t\t\t[0.5688888888888888888888889,0.4786286704993664680412915,0.2369268850561890875142640],\n\t\t\t[0.4679139345726910473898703,0.3607615730481386075698335,0.1713244923791703450402961],\n\t\t\t[0.4179591836734693877551020,0.3818300505051189449503698,0.2797053914892766679014678,0.1294849661688696932706114],\n\t\t\t[0.3626837833783619829651504,0.3137066458778872873379622,0.2223810344533744705443560,0.1012285362903762591525314],\n\t\t\t[0.3302393550012597631645251,0.3123470770400028400686304,0.2606106964029354623187429,0.1806481606948574040584720,0.0812743883615744119718922],\n\t\t\t[0.2955242247147528701738930,0.2692667193099963550912269,0.2190863625159820439955349,0.1494513491505805931457763,0.0666713443086881375935688],\n\t\t\t[0.2729250867779006307144835,0.2628045445102466621806889,0.2331937645919904799185237,0.1862902109277342514260976,0.1255803694649046246346943,0.0556685671161736664827537],\n\t\t\t[0.2491470458134027850005624,0.2334925365383548087608499,0.2031674267230659217490645,0.1600783285433462263346525,0.1069393259953184309602547,0.0471753363865118271946160],\n\t\t\t[0.2325515532308739101945895,0.2262831802628972384120902,0.2078160475368885023125232,0.1781459807619457382800467,0.1388735102197872384636018,0.0921214998377284479144218,0.0404840047653158795200216],\n\t\t\t[0.2152638534631577901958764,0.2051984637212956039659241,0.1855383974779378137417166,0.1572031671581935345696019,0.1215185706879031846894148,0.0801580871597602098056333,0.0351194603317518630318329],\n\t\t\t[0.2025782419255612728806202,0.1984314853271115764561183,0.1861610000155622110268006,0.1662692058169939335532009,0.1395706779261543144478048,0.1071592204671719350118695,0.0703660474881081247092674,0.0307532419961172683546284],\n\t\t\t[0.1894506104550684962853967,0.1826034150449235888667637,0.1691565193950025381893121,0.1495959888165767320815017,0.1246289712555338720524763,0.0951585116824927848099251,0.0622535239386478928628438,0.0271524594117540948517806]\n\t\t];\n\t\n\t\tvar abs = Math.abs,\n\t\t\tsqrt = Math.sqrt,\n\t\t\tpow = Math.pow,\n\t\t\tEPSILON = 1e-12,\n\t\t\tMACHINE_EPSILON = 1.12e-16;\n\t\n\t\tfunction clip(value, min, max) {\n\t\t\treturn value < min ? min : value > max ? max : value;\n\t\t}\n\t\n\t\treturn {\n\t\t\tTOLERANCE: 1e-6,\n\t\t\tEPSILON: EPSILON,\n\t\t\tMACHINE_EPSILON: MACHINE_EPSILON,\n\t\t\tCURVETIME_EPSILON: 4e-7,\n\t\t\tGEOMETRIC_EPSILON: 2e-7,\n\t\t\tWINDING_EPSILON: 2e-7,\n\t\t\tTRIGONOMETRIC_EPSILON: 1e-7,\n\t\t\tCLIPPING_EPSILON: 1e-7,\n\t\t\tKAPPA: 4 * (sqrt(2) - 1) / 3,\n\t\n\t\t\tisZero: function(val) {\n\t\t\t\treturn val >= -EPSILON && val <= EPSILON;\n\t\t\t},\n\t\n\t\t\tintegrate: function(f, a, b, n) {\n\t\t\t\tvar x = abscissas[n - 2],\n\t\t\t\t\tw = weights[n - 2],\n\t\t\t\t\tA = (b - a) * 0.5,\n\t\t\t\t\tB = A + a,\n\t\t\t\t\ti = 0,\n\t\t\t\t\tm = (n + 1) >> 1,\n\t\t\t\t\tsum = n & 1 ? w[i++] * f(B) : 0;\n\t\t\t\twhile (i < m) {\n\t\t\t\t\tvar Ax = A * x[i];\n\t\t\t\t\tsum += w[i++] * (f(B + Ax) + f(B - Ax));\n\t\t\t\t}\n\t\t\t\treturn A * sum;\n\t\t\t},\n\t\n\t\t\tfindRoot: function(f, df, x, a, b, n, tolerance) {\n\t\t\t\tfor (var i = 0; i < n; i++) {\n\t\t\t\t\tvar fx = f(x),\n\t\t\t\t\t\tdx = fx / df(x),\n\t\t\t\t\t\tnx = x - dx;\n\t\t\t\t\tif (abs(dx) < tolerance)\n\t\t\t\t\t\treturn nx;\n\t\t\t\t\tif (fx > 0) {\n\t\t\t\t\t\tb = x;\n\t\t\t\t\t\tx = nx <= a ? (a + b) * 0.5 : nx;\n\t\t\t\t\t} else {\n\t\t\t\t\t\ta = x;\n\t\t\t\t\t\tx = nx >= b ? (a + b) * 0.5 : nx;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn x;\n\t\t\t},\n\t\n\t\t\tsolveQuadratic: function(a, b, c, roots, min, max) {\n\t\t\t\tvar count = 0,\n\t\t\t\t\teMin = min - EPSILON,\n\t\t\t\t\teMax = max + EPSILON,\n\t\t\t\t\tx1, x2 = Infinity,\n\t\t\t\t\tB = b,\n\t\t\t\t\tD;\n\t\t\t\tb /= -2;\n\t\t\t\tD = b * b - a * c;\n\t\t\t\tif (D !== 0 && abs(D) < MACHINE_EPSILON) {\n\t\t\t\t\tvar gmC = pow(abs(a * b * c), 1 / 3);\n\t\t\t\t\tif (gmC < 1e-8) {\n\t\t\t\t\t\tvar mult = pow(10,\n\t\t\t\t\t\t\t\tabs(Math.floor(Math.log(gmC) * Math.LOG10E)));\n\t\t\t\t\t\tif (!isFinite(mult))\n\t\t\t\t\t\t\tmult = 0;\n\t\t\t\t\t\ta *= mult;\n\t\t\t\t\t\tb *= mult;\n\t\t\t\t\t\tc *= mult;\n\t\t\t\t\t\tD = b * b - a * c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (abs(a) < EPSILON) {\n\t\t\t\t\tif (abs(B) < EPSILON)\n\t\t\t\t\t\treturn abs(c) < EPSILON ? -1 : 0;\n\t\t\t\t\tx1 = -c / B;\n\t\t\t\t} else if (D >= -MACHINE_EPSILON) {\n\t\t\t\t\tvar Q = D < 0 ? 0 : sqrt(D),\n\t\t\t\t\t\tR = b + (b < 0 ? -Q : Q);\n\t\t\t\t\tif (R === 0) {\n\t\t\t\t\t\tx1 = c / a;\n\t\t\t\t\t\tx2 = -x1;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tx1 = R / a;\n\t\t\t\t\t\tx2 = c / R;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (isFinite(x1) && (min == null || x1 > eMin && x1 < eMax))\n\t\t\t\t\troots[count++] = min == null ? x1 : clip(x1, min, max);\n\t\t\t\tif (x2 !== x1\n\t\t\t\t\t\t&& isFinite(x2) && (min == null || x2 > eMin && x2 < eMax))\n\t\t\t\t\troots[count++] = min == null ? x2 : clip(x2, min, max);\n\t\t\t\treturn count;\n\t\t\t},\n\t\n\t\t\tsolveCubic: function(a, b, c, d, roots, min, max) {\n\t\t\t\tvar count = 0,\n\t\t\t\t\tx, b1, c2;\n\t\t\t\tif (abs(a) < EPSILON) {\n\t\t\t\t\ta = b;\n\t\t\t\t\tb1 = c;\n\t\t\t\t\tc2 = d;\n\t\t\t\t\tx = Infinity;\n\t\t\t\t} else if (abs(d) < EPSILON) {\n\t\t\t\t\tb1 = b;\n\t\t\t\t\tc2 = c;\n\t\t\t\t\tx = 0;\n\t\t\t\t} else {\n\t\t\t\t\tvar ec = 1 + MACHINE_EPSILON,\n\t\t\t\t\t\tx0, q, qd, t, r, s, tmp;\n\t\t\t\t\tx = -(b / a) / 3;\n\t\t\t\t\ttmp = a * x,\n\t\t\t\t\tb1 = tmp + b,\n\t\t\t\t\tc2 = b1 * x + c,\n\t\t\t\t\tqd = (tmp + b1) * x + c2,\n\t\t\t\t\tq = c2 * x + d;\n\t\t\t\t\tt = q /a;\n\t\t\t\t\tr = pow(abs(t), 1/3);\n\t\t\t\t\ts = t < 0 ? -1 : 1;\n\t\t\t\t\tt = -qd / a;\n\t\t\t\t\tr = t > 0 ? 1.3247179572 * Math.max(r, sqrt(t)) : r;\n\t\t\t\t\tx0 = x - s * r;\n\t\t\t\t\tif (x0 !== x) {\n\t\t\t\t\t\tdo {\n\t\t\t\t\t\t\tx = x0;\n\t\t\t\t\t\t\ttmp = a * x,\n\t\t\t\t\t\t\tb1 = tmp + b,\n\t\t\t\t\t\t\tc2 = b1 * x + c,\n\t\t\t\t\t\t\tqd = (tmp + b1) * x + c2,\n\t\t\t\t\t\t\tq = c2 * x + d;\n\t\t\t\t\t\t\tx0 = qd === 0 ? x : x - q / qd / ec;\n\t\t\t\t\t\t\tif (x0 === x) {\n\t\t\t\t\t\t\t\tx = x0;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} while (s * x0 > s * x);\n\t\t\t\t\t\tif (abs(a) * x * x > abs(d / x)) {\n\t\t\t\t\t\t\tc2 = -d / x;\n\t\t\t\t\t\t\tb1 = (c2 - c) / x;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tvar count = Numerical.solveQuadratic(a, b1, c2, roots, min, max);\n\t\t\t\tif (isFinite(x) && (count === 0 || x !== roots[count - 1])\n\t\t\t\t\t\t&& (min == null || x > min - EPSILON && x < max + EPSILON))\n\t\t\t\t\troots[count++] = min == null ? x : clip(x, min, max);\n\t\t\t\treturn count;\n\t\t\t}\n\t\t};\n\t};\n\t\n\tvar UID = {\n\t\t_id: 1,\n\t\t_pools: {},\n\t\n\t\tget: function(ctor) {\n\t\t\tif (ctor) {\n\t\t\t\tvar name = ctor._class,\n\t\t\t\t\tpool = this._pools[name];\n\t\t\t\tif (!pool)\n\t\t\t\t\tpool = this._pools[name] = { _id: 1 };\n\t\t\t\treturn pool._id++;\n\t\t\t} else {\n\t\t\t\treturn this._id++;\n\t\t\t}\n\t\t}\n\t};\n\t\n\tvar Point = Base.extend({\n\t\t_class: 'Point',\n\t\t_readIndex: true,\n\t\n\t\tinitialize: function Point(arg0, arg1) {\n\t\t\tvar type = typeof arg0;\n\t\t\tif (type === 'number') {\n\t\t\t\tvar hasY = typeof arg1 === 'number';\n\t\t\t\tthis.x = arg0;\n\t\t\t\tthis.y = hasY ? arg1 : arg0;\n\t\t\t\tif (this.__read)\n\t\t\t\t\tthis.__read = hasY ? 2 : 1;\n\t\t\t} else if (type === 'undefined' || arg0 === null) {\n\t\t\t\tthis.x = this.y = 0;\n\t\t\t\tif (this.__read)\n\t\t\t\t\tthis.__read = arg0 === null ? 1 : 0;\n\t\t\t} else {\n\t\t\t\tif (Array.isArray(arg0)) {\n\t\t\t\t\tthis.x = arg0[0];\n\t\t\t\t\tthis.y = arg0.length > 1 ? arg0[1] : arg0[0];\n\t\t\t\t} else if (arg0.x != null) {\n\t\t\t\t\tthis.x = arg0.x;\n\t\t\t\t\tthis.y = arg0.y;\n\t\t\t\t} else if (arg0.width != null) {\n\t\t\t\t\tthis.x = arg0.width;\n\t\t\t\t\tthis.y = arg0.height;\n\t\t\t\t} else if (arg0.angle != null) {\n\t\t\t\t\tthis.x = arg0.length;\n\t\t\t\t\tthis.y = 0;\n\t\t\t\t\tthis.setAngle(arg0.angle);\n\t\t\t\t} else {\n\t\t\t\t\tthis.x = this.y = 0;\n\t\t\t\t\tif (this.__read)\n\t\t\t\t\t\tthis.__read = 0;\n\t\t\t\t}\n\t\t\t\tif (this.__read)\n\t\t\t\t\tthis.__read = 1;\n\t\t\t}\n\t\t},\n\t\n\t\tset: function(x, y) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t\treturn this;\n\t\t},\n\t\n\t\tequals: function(point) {\n\t\t\treturn this === point || point\n\t\t\t\t\t&& (this.x === point.x && this.y === point.y\n\t\t\t\t\t\t|| Array.isArray(point)\n\t\t\t\t\t\t\t&& this.x === point[0] && this.y === point[1])\n\t\t\t\t\t|| false;\n\t\t},\n\t\n\t\tclone: function() {\n\t\t\treturn new Point(this.x, this.y);\n\t\t},\n\t\n\t\ttoString: function() {\n\t\t\tvar f = Formatter.instance;\n\t\t\treturn '{ x: ' + f.number(this.x) + ', y: ' + f.number(this.y) + ' }';\n\t\t},\n\t\n\t\t_serialize: function(options) {\n\t\t\tvar f = options.formatter;\n\t\t\treturn [f.number(this.x), f.number(this.y)];\n\t\t},\n\t\n\t\tgetLength: function() {\n\t\t\treturn Math.sqrt(this.x * this.x + this.y * this.y);\n\t\t},\n\t\n\t\tsetLength: function(length) {\n\t\t\tif (this.isZero()) {\n\t\t\t\tvar angle = this._angle || 0;\n\t\t\t\tthis.set(\n\t\t\t\t\tMath.cos(angle) * length,\n\t\t\t\t\tMath.sin(angle) * length\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\tvar scale = length / this.getLength();\n\t\t\t\tif (Numerical.isZero(scale))\n\t\t\t\t\tthis.getAngle();\n\t\t\t\tthis.set(\n\t\t\t\t\tthis.x * scale,\n\t\t\t\t\tthis.y * scale\n\t\t\t\t);\n\t\t\t}\n\t\t},\n\t\tgetAngle: function() {\n\t\t\treturn this.getAngleInRadians.apply(this, arguments) * 180 / Math.PI;\n\t\t},\n\t\n\t\tsetAngle: function(angle) {\n\t\t\tthis.setAngleInRadians.call(this, angle * Math.PI / 180);\n\t\t},\n\t\n\t\tgetAngleInDegrees: '#getAngle',\n\t\tsetAngleInDegrees: '#setAngle',\n\t\n\t\tgetAngleInRadians: function() {\n\t\t\tif (!arguments.length) {\n\t\t\t\treturn this.isZero()\n\t\t\t\t\t\t? this._angle || 0\n\t\t\t\t\t\t: this._angle = Math.atan2(this.y, this.x);\n\t\t\t} else {\n\t\t\t\tvar point = Point.read(arguments),\n\t\t\t\t\tdiv = this.getLength() * point.getLength();\n\t\t\t\tif (Numerical.isZero(div)) {\n\t\t\t\t\treturn NaN;\n\t\t\t\t} else {\n\t\t\t\t\tvar a = this.dot(point) / div;\n\t\t\t\t\treturn Math.acos(a < -1 ? -1 : a > 1 ? 1 : a);\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\n\t\tsetAngleInRadians: function(angle) {\n\t\t\tthis._angle = angle;\n\t\t\tif (!this.isZero()) {\n\t\t\t\tvar length = this.getLength();\n\t\t\t\tthis.set(\n\t\t\t\t\tMath.cos(angle) * length,\n\t\t\t\t\tMath.sin(angle) * length\n\t\t\t\t);\n\t\t\t}\n\t\t},\n\t\n\t\tgetQuadrant: function() {\n\t\t\treturn this.x >= 0 ? this.y >= 0 ? 1 : 4 : this.y >= 0 ? 2 : 3;\n\t\t}\n\t}, {\n\t\tbeans: false,\n\t\n\t\tgetDirectedAngle: function() {\n\t\t\tvar point = Point.read(arguments);\n\t\t\treturn Math.atan2(this.cross(point), this.dot(point)) * 180 / Math.PI;\n\t\t},\n\t\n\t\tgetDistance: function() {\n\t\t\tvar point = Point.read(arguments),\n\t\t\t\tx = point.x - this.x,\n\t\t\t\ty = point.y - this.y,\n\t\t\t\td = x * x + y * y,\n\t\t\t\tsquared = Base.read(arguments);\n\t\t\treturn squared ? d : Math.sqrt(d);\n\t\t},\n\t\n\t\tnormalize: function(length) {\n\t\t\tif (length === undefined)\n\t\t\t\tlength = 1;\n\t\t\tvar current = this.getLength(),\n\t\t\t\tscale = current !== 0 ? length / current : 0,\n\t\t\t\tpoint = new Point(this.x * scale, this.y * scale);\n\t\t\tif (scale >= 0)\n\t\t\t\tpoint._angle = this._angle;\n\t\t\treturn point;\n\t\t},\n\t\n\t\trotate: function(angle, center) {\n\t\t\tif (angle === 0)\n\t\t\t\treturn this.clone();\n\t\t\tangle = angle * Math.PI / 180;\n\t\t\tvar point = center ? this.subtract(center) : this,\n\t\t\t\tsin = Math.sin(angle),\n\t\t\t\tcos = Math.cos(angle);\n\t\t\tpoint = new Point(\n\t\t\t\tpoint.x * cos - point.y * sin,\n\t\t\t\tpoint.x * sin + point.y * cos\n\t\t\t);\n\t\t\treturn center ? point.add(center) : point;\n\t\t},\n\t\n\t\ttransform: function(matrix) {\n\t\t\treturn matrix ? matrix._transformPoint(this) : this;\n\t\t},\n\t\n\t\tadd: function() {\n\t\t\tvar point = Point.read(arguments);\n\t\t\treturn new Point(this.x + point.x, this.y + point.y);\n\t\t},\n\t\n\t\tsubtract: function() {\n\t\t\tvar point = Point.read(arguments);\n\t\t\treturn new Point(this.x - point.x, this.y - point.y);\n\t\t},\n\t\n\t\tmultiply: function() {\n\t\t\tvar point = Point.read(arguments);\n\t\t\treturn new Point(this.x * point.x, this.y * point.y);\n\t\t},\n\t\n\t\tdivide: function() {\n\t\t\tvar point = Point.read(arguments);\n\t\t\treturn new Point(this.x / point.x, this.y / point.y);\n\t\t},\n\t\n\t\tmodulo: function() {\n\t\t\tvar point = Point.read(arguments);\n\t\t\treturn new Point(this.x % point.x, this.y % point.y);\n\t\t},\n\t\n\t\tnegate: function() {\n\t\t\treturn new Point(-this.x, -this.y);\n\t\t},\n\t\n\t\tisInside: function() {\n\t\t\treturn Rectangle.read(arguments).contains(this);\n\t\t},\n\t\n\t\tisClose: function() {\n\t\t\tvar point = Point.read(arguments),\n\t\t\t\ttolerance = Base.read(arguments);\n\t\t\treturn this.getDistance(point) < tolerance;\n\t\t},\n\t\n\t\tisCollinear: function() {\n\t\t\tvar point = Point.read(arguments);\n\t\t\treturn Point.isCollinear(this.x, this.y, point.x, point.y);\n\t\t},\n\t\n\t\tisColinear: '#isCollinear',\n\t\n\t\tisOrthogonal: function() {\n\t\t\tvar point = Point.read(arguments);\n\t\t\treturn Point.isOrthogonal(this.x, this.y, point.x, point.y);\n\t\t},\n\t\n\t\tisZero: function() {\n\t\t\treturn Numerical.isZero(this.x) && Numerical.isZero(this.y);\n\t\t},\n\t\n\t\tisNaN: function() {\n\t\t\treturn isNaN(this.x) || isNaN(this.y);\n\t\t},\n\t\n\t\tdot: function() {\n\t\t\tvar point = Point.read(arguments);\n\t\t\treturn this.x * point.x + this.y * point.y;\n\t\t},\n\t\n\t\tcross: function() {\n\t\t\tvar point = Point.read(arguments);\n\t\t\treturn this.x * point.y - this.y * point.x;\n\t\t},\n\t\n\t\tproject: function() {\n\t\t\tvar point = Point.read(arguments),\n\t\t\t\tscale = point.isZero() ? 0 : this.dot(point) / point.dot(point);\n\t\t\treturn new Point(\n\t\t\t\tpoint.x * scale,\n\t\t\t\tpoint.y * scale\n\t\t\t);\n\t\t},\n\t\n\t\tstatics: {\n\t\t\tmin: function() {\n\t\t\t\tvar point1 = Point.read(arguments),\n\t\t\t\t\tpoint2 = Point.read(arguments);\n\t\t\t\treturn new Point(\n\t\t\t\t\tMath.min(point1.x, point2.x),\n\t\t\t\t\tMath.min(point1.y, point2.y)\n\t\t\t\t);\n\t\t\t},\n\t\n\t\t\tmax: function() {\n\t\t\t\tvar point1 = Point.read(arguments),\n\t\t\t\t\tpoint2 = Point.read(arguments);\n\t\t\t\treturn new Point(\n\t\t\t\t\tMath.max(point1.x, point2.x),\n\t\t\t\t\tMath.max(point1.y, point2.y)\n\t\t\t\t);\n\t\t\t},\n\t\n\t\t\trandom: function() {\n\t\t\t\treturn new Point(Math.random(), Math.random());\n\t\t\t},\n\t\n\t\t\tisCollinear: function(x1, y1, x2, y2) {\n\t\t\t\treturn Math.abs(x1 * y2 - y1 * x2)\n\t\t\t\t\t\t<= Math.sqrt((x1 * x1 + y1 * y1) * (x2 * x2 + y2 * y2))\n\t\t\t\t\t\t\t* 1e-7;\n\t\t\t},\n\t\n\t\t\tisOrthogonal: function(x1, y1, x2, y2) {\n\t\t\t\treturn Math.abs(x1 * x2 + y1 * y2)\n\t\t\t\t\t\t<= Math.sqrt((x1 * x1 + y1 * y1) * (x2 * x2 + y2 * y2))\n\t\t\t\t\t\t\t* 1e-7;\n\t\t\t}\n\t\t}\n\t}, Base.each(['round', 'ceil', 'floor', 'abs'], function(name) {\n\t\tvar op = Math[name];\n\t\tthis[name] = function() {\n\t\t\treturn new Point(op(this.x), op(this.y));\n\t\t};\n\t}, {}));\n\t\n\tvar LinkedPoint = Point.extend({\n\t\tinitialize: function Point(x, y, owner, setter) {\n\t\t\tthis._x = x;\n\t\t\tthis._y = y;\n\t\t\tthis._owner = owner;\n\t\t\tthis._setter = setter;\n\t\t},\n\t\n\t\tset: function(x, y, _dontNotify) {\n\t\t\tthis._x = x;\n\t\t\tthis._y = y;\n\t\t\tif (!_dontNotify)\n\t\t\t\tthis._owner[this._setter](this);\n\t\t\treturn this;\n\t\t},\n\t\n\t\tgetX: function() {\n\t\t\treturn this._x;\n\t\t},\n\t\n\t\tsetX: function(x) {\n\t\t\tthis._x = x;\n\t\t\tthis._owner[this._setter](this);\n\t\t},\n\t\n\t\tgetY: function() {\n\t\t\treturn this._y;\n\t\t},\n\t\n\t\tsetY: function(y) {\n\t\t\tthis._y = y;\n\t\t\tthis._owner[this._setter](this);\n\t\t}\n\t});\n\t\n\tvar Size = Base.extend({\n\t\t_class: 'Size',\n\t\t_readIndex: true,\n\t\n\t\tinitialize: function Size(arg0, arg1) {\n\t\t\tvar type = typeof arg0;\n\t\t\tif (type === 'number') {\n\t\t\t\tvar hasHeight = typeof arg1 === 'number';\n\t\t\t\tthis.width = arg0;\n\t\t\t\tthis.height = hasHeight ? arg1 : arg0;\n\t\t\t\tif (this.__read)\n\t\t\t\t\tthis.__read = hasHeight ? 2 : 1;\n\t\t\t} else if (type === 'undefined' || arg0 === null) {\n\t\t\t\tthis.width = this.height = 0;\n\t\t\t\tif (this.__read)\n\t\t\t\t\tthis.__read = arg0 === null ? 1 : 0;\n\t\t\t} else {\n\t\t\t\tif (Array.isArray(arg0)) {\n\t\t\t\t\tthis.width = arg0[0];\n\t\t\t\t\tthis.height = arg0.length > 1 ? arg0[1] : arg0[0];\n\t\t\t\t} else if (arg0.width != null) {\n\t\t\t\t\tthis.width = arg0.width;\n\t\t\t\t\tthis.height = arg0.height;\n\t\t\t\t} else if (arg0.x != null) {\n\t\t\t\t\tthis.width = arg0.x;\n\t\t\t\t\tthis.height = arg0.y;\n\t\t\t\t} else {\n\t\t\t\t\tthis.width = this.height = 0;\n\t\t\t\t\tif (this.__read)\n\t\t\t\t\t\tthis.__read = 0;\n\t\t\t\t}\n\t\t\t\tif (this.__read)\n\t\t\t\t\tthis.__read = 1;\n\t\t\t}\n\t\t},\n\t\n\t\tset: function(width, height) {\n\t\t\tthis.width = width;\n\t\t\tthis.height = height;\n\t\t\treturn this;\n\t\t},\n\t\n\t\tequals: function(size) {\n\t\t\treturn size === this || size && (this.width === size.width\n\t\t\t\t\t&& this.height === size.height\n\t\t\t\t\t|| Array.isArray(size) && this.width === size[0]\n\t\t\t\t\t\t&& this.height === size[1]) || false;\n\t\t},\n\t\n\t\tclone: function() {\n\t\t\treturn new Size(this.width, this.height);\n\t\t},\n\t\n\t\ttoString: function() {\n\t\t\tvar f = Formatter.instance;\n\t\t\treturn '{ width: ' + f.number(this.width)\n\t\t\t\t\t+ ', height: ' + f.number(this.height) + ' }';\n\t\t},\n\t\n\t\t_serialize: function(options) {\n\t\t\tvar f = options.formatter;\n\t\t\treturn [f.number(this.width),\n\t\t\t\t\tf.number(this.height)];\n\t\t},\n\t\n\t\tadd: function() {\n\t\t\tvar size = Size.read(arguments);\n\t\t\treturn new Size(this.width + size.width, this.height + size.height);\n\t\t},\n\t\n\t\tsubtract: function() {\n\t\t\tvar size = Size.read(arguments);\n\t\t\treturn new Size(this.width - size.width, this.height - size.height);\n\t\t},\n\t\n\t\tmultiply: function() {\n\t\t\tvar size = Size.read(arguments);\n\t\t\treturn new Size(this.width * size.width, this.height * size.height);\n\t\t},\n\t\n\t\tdivide: function() {\n\t\t\tvar size = Size.read(arguments);\n\t\t\treturn new Size(this.width / size.width, this.height / size.height);\n\t\t},\n\t\n\t\tmodulo: function() {\n\t\t\tvar size = Size.read(arguments);\n\t\t\treturn new Size(this.width % size.width, this.height % size.height);\n\t\t},\n\t\n\t\tnegate: function() {\n\t\t\treturn new Size(-this.width, -this.height);\n\t\t},\n\t\n\t\tisZero: function() {\n\t\t\treturn Numerical.isZero(this.width) && Numerical.isZero(this.height);\n\t\t},\n\t\n\t\tisNaN: function() {\n\t\t\treturn isNaN(this.width) || isNaN(this.height);\n\t\t},\n\t\n\t\tstatics: {\n\t\t\tmin: function(size1, size2) {\n\t\t\t\treturn new Size(\n\t\t\t\t\tMath.min(size1.width, size2.width),\n\t\t\t\t\tMath.min(size1.height, size2.height));\n\t\t\t},\n\t\n\t\t\tmax: function(size1, size2) {\n\t\t\t\treturn new Size(\n\t\t\t\t\tMath.max(size1.width, size2.width),\n\t\t\t\t\tMath.max(size1.height, size2.height));\n\t\t\t},\n\t\n\t\t\trandom: function() {\n\t\t\t\treturn new Size(Math.random(), Math.random());\n\t\t\t}\n\t\t}\n\t}, Base.each(['round', 'ceil', 'floor', 'abs'], function(name) {\n\t\tvar op = Math[name];\n\t\tthis[name] = function() {\n\t\t\treturn new Size(op(this.width), op(this.height));\n\t\t};\n\t}, {}));\n\t\n\tvar LinkedSize = Size.extend({\n\t\tinitialize: function Size(width, height, owner, setter) {\n\t\t\tthis._width = width;\n\t\t\tthis._height = height;\n\t\t\tthis._owner = owner;\n\t\t\tthis._setter = setter;\n\t\t},\n\t\n\t\tset: function(width, height, _dontNotify) {\n\t\t\tthis._width = width;\n\t\t\tthis._height = height;\n\t\t\tif (!_dontNotify)\n\t\t\t\tthis._owner[this._setter](this);\n\t\t\treturn this;\n\t\t},\n\t\n\t\tgetWidth: function() {\n\t\t\treturn this._width;\n\t\t},\n\t\n\t\tsetWidth: function(width) {\n\t\t\tthis._width = width;\n\t\t\tthis._owner[this._setter](this);\n\t\t},\n\t\n\t\tgetHeight: function() {\n\t\t\treturn this._height;\n\t\t},\n\t\n\t\tsetHeight: function(height) {\n\t\t\tthis._height = height;\n\t\t\tthis._owner[this._setter](this);\n\t\t}\n\t});\n\t\n\tvar Rectangle = Base.extend({\n\t\t_class: 'Rectangle',\n\t\t_readIndex: true,\n\t\tbeans: true,\n\t\n\t\tinitialize: function Rectangle(arg0, arg1, arg2, arg3) {\n\t\t\tvar type = typeof arg0,\n\t\t\t\tread = 0;\n\t\t\tif (type === 'number') {\n\t\t\t\tthis.x = arg0;\n\t\t\t\tthis.y = arg1;\n\t\t\t\tthis.width = arg2;\n\t\t\t\tthis.height = arg3;\n\t\t\t\tread = 4;\n\t\t\t} else if (type === 'undefined' || arg0 === null) {\n\t\t\t\tthis.x = this.y = this.width = this.height = 0;\n\t\t\t\tread = arg0 === null ? 1 : 0;\n\t\t\t} else if (arguments.length === 1) {\n\t\t\t\tif (Array.isArray(arg0)) {\n\t\t\t\t\tthis.x = arg0[0];\n\t\t\t\t\tthis.y = arg0[1];\n\t\t\t\t\tthis.width = arg0[2];\n\t\t\t\t\tthis.height = arg0[3];\n\t\t\t\t\tread = 1;\n\t\t\t\t} else if (arg0.x !== undefined || arg0.width !== undefined) {\n\t\t\t\t\tthis.x = arg0.x || 0;\n\t\t\t\t\tthis.y = arg0.y || 0;\n\t\t\t\t\tthis.width = arg0.width || 0;\n\t\t\t\t\tthis.height = arg0.height || 0;\n\t\t\t\t\tread = 1;\n\t\t\t\t} else if (arg0.from === undefined && arg0.to === undefined) {\n\t\t\t\t\tthis.x = this.y = this.width = this.height = 0;\n\t\t\t\t\tthis._set(arg0);\n\t\t\t\t\tread = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!read) {\n\t\t\t\tvar point = Point.readNamed(arguments, 'from'),\n\t\t\t\t\tnext = Base.peek(arguments);\n\t\t\t\tthis.x = point.x;\n\t\t\t\tthis.y = point.y;\n\t\t\t\tif (next && next.x !== undefined || Base.hasNamed(arguments, 'to')) {\n\t\t\t\t\tvar to = Point.readNamed(arguments, 'to');\n\t\t\t\t\tthis.width = to.x - point.x;\n\t\t\t\t\tthis.height = to.y - point.y;\n\t\t\t\t\tif (this.width < 0) {\n\t\t\t\t\t\tthis.x = to.x;\n\t\t\t\t\t\tthis.width = -this.width;\n\t\t\t\t\t}\n\t\t\t\t\tif (this.height < 0) {\n\t\t\t\t\t\tthis.y = to.y;\n\t\t\t\t\t\tthis.height = -this.height;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tvar size = Size.read(arguments);\n\t\t\t\t\tthis.width = size.width;\n\t\t\t\t\tthis.height = size.height;\n\t\t\t\t}\n\t\t\t\tread = arguments.__index;\n\t\t\t}\n\t\t\tif (this.__read)\n\t\t\t\tthis.__read = read;\n\t\t},\n\t\n\t\tset: function(x, y, width, height) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t\tthis.width = width;\n\t\t\tthis.height = height;\n\t\t\treturn this;\n\t\t},\n\t\n\t\tclone: function() {\n\t\t\treturn new Rectangle(this.x, this.y, this.width, this.height);\n\t\t},\n\t\n\t\tequals: function(rect) {\n\t\t\tvar rt = Base.isPlainValue(rect)\n\t\t\t\t\t? Rectangle.read(arguments)\n\t\t\t\t\t: rect;\n\t\t\treturn rt === this\n\t\t\t\t\t|| rt && this.x === rt.x && this.y === rt.y\n\t\t\t\t\t\t&& this.width === rt.width && this.height === rt.height\n\t\t\t\t\t|| false;\n\t\t},\n\t\n\t\ttoString: function() {\n\t\t\tvar f = Formatter.instance;\n\t\t\treturn '{ x: ' + f.number(this.x)\n\t\t\t\t\t+ ', y: ' + f.number(this.y)\n\t\t\t\t\t+ ', width: ' + f.number(this.width)\n\t\t\t\t\t+ ', height: ' + f.number(this.height)\n\t\t\t\t\t+ ' }';\n\t\t},\n\t\n\t\t_serialize: function(options) {\n\t\t\tvar f = options.formatter;\n\t\t\treturn [f.number(this.x),\n\t\t\t\t\tf.number(this.y),\n\t\t\t\t\tf.number(this.width),\n\t\t\t\t\tf.number(this.height)];\n\t\t},\n\t\n\t\tgetPoint: function(_dontLink) {\n\t\t\tvar ctor = _dontLink ? Point : LinkedPoint;\n\t\t\treturn new ctor(this.x, this.y, this, 'setPoint');\n\t\t},\n\t\n\t\tsetPoint: function() {\n\t\t\tvar point = Point.read(arguments);\n\t\t\tthis.x = point.x;\n\t\t\tthis.y = point.y;\n\t\t},\n\t\n\t\tgetSize: function(_dontLink) {\n\t\t\tvar ctor = _dontLink ? Size : LinkedSize;\n\t\t\treturn new ctor(this.width, this.height, this, 'setSize');\n\t\t},\n\t\n\t\tsetSize: function() {\n\t\t\tvar size = Size.read(arguments);\n\t\t\tif (this._fixX)\n\t\t\t\tthis.x += (this.width - size.width) * this._fixX;\n\t\t\tif (this._fixY)\n\t\t\t\tthis.y += (this.height - size.height) * this._fixY;\n\t\t\tthis.width = size.width;\n\t\t\tthis.height = size.height;\n\t\t\tthis._fixW = 1;\n\t\t\tthis._fixH = 1;\n\t\t},\n\t\n\t\tgetLeft: function() {\n\t\t\treturn this.x;\n\t\t},\n\t\n\t\tsetLeft: function(left) {\n\t\t\tif (!this._fixW)\n\t\t\t\tthis.width -= left - this.x;\n\t\t\tthis.x = left;\n\t\t\tthis._fixX = 0;\n\t\t},\n\t\n\t\tgetTop: function() {\n\t\t\treturn this.y;\n\t\t},\n\t\n\t\tsetTop: function(top) {\n\t\t\tif (!this._fixH)\n\t\t\t\tthis.height -= top - this.y;\n\t\t\tthis.y = top;\n\t\t\tthis._fixY = 0;\n\t\t},\n\t\n\t\tgetRight: function() {\n\t\t\treturn this.x + this.width;\n\t\t},\n\t\n\t\tsetRight: function(right) {\n\t\t\tif (this._fixX !== undefined && this._fixX !== 1)\n\t\t\t\tthis._fixW = 0;\n\t\t\tif (this._fixW)\n\t\t\t\tthis.x = right - this.width;\n\t\t\telse\n\t\t\t\tthis.width = right - this.x;\n\t\t\tthis._fixX = 1;\n\t\t},\n\t\n\t\tgetBottom: function() {\n\t\t\treturn this.y + this.height;\n\t\t},\n\t\n\t\tsetBottom: function(bottom) {\n\t\t\tif (this._fixY !== undefined && this._fixY !== 1)\n\t\t\t\tthis._fixH = 0;\n\t\t\tif (this._fixH)\n\t\t\t\tthis.y = bottom - this.height;\n\t\t\telse\n\t\t\t\tthis.height = bottom - this.y;\n\t\t\tthis._fixY = 1;\n\t\t},\n\t\n\t\tgetCenterX: function() {\n\t\t\treturn this.x + this.width * 0.5;\n\t\t},\n\t\n\t\tsetCenterX: function(x) {\n\t\t\tthis.x = x - this.width * 0.5;\n\t\t\tthis._fixX = 0.5;\n\t\t},\n\t\n\t\tgetCenterY: function() {\n\t\t\treturn this.y + this.height * 0.5;\n\t\t},\n\t\n\t\tsetCenterY: function(y) {\n\t\t\tthis.y = y - this.height * 0.5;\n\t\t\tthis._fixY = 0.5;\n\t\t},\n\t\n\t\tgetCenter: function(_dontLink) {\n\t\t\tvar ctor = _dontLink ? Point : LinkedPoint;\n\t\t\treturn new ctor(this.getCenterX(), this.getCenterY(), this, 'setCenter');\n\t\t},\n\t\n\t\tsetCenter: function() {\n\t\t\tvar point = Point.read(arguments);\n\t\t\tthis.setCenterX(point.x);\n\t\t\tthis.setCenterY(point.y);\n\t\t\treturn this;\n\t\t},\n\t\n\t\tgetArea: function() {\n\t\t\treturn this.width * this.height;\n\t\t},\n\t\n\t\tisEmpty: function() {\n\t\t\treturn this.width === 0 || this.height === 0;\n\t\t},\n\t\n\t\tcontains: function(arg) {\n\t\t\treturn arg && arg.width !== undefined\n\t\t\t\t\t|| (Array.isArray(arg) ? arg : arguments).length == 4\n\t\t\t\t\t? this._containsRectangle(Rectangle.read(arguments))\n\t\t\t\t\t: this._containsPoint(Point.read(arguments));\n\t\t},\n\t\n\t\t_containsPoint: function(point) {\n\t\t\tvar x = point.x,\n\t\t\t\ty = point.y;\n\t\t\treturn x >= this.x && y >= this.y\n\t\t\t\t\t&& x <= this.x + this.width\n\t\t\t\t\t&& y <= this.y + this.height;\n\t\t},\n\t\n\t\t_containsRectangle: function(rect) {\n\t\t\tvar x = rect.x,\n\t\t\t\ty = rect.y;\n\t\t\treturn x >= this.x && y >= this.y\n\t\t\t\t\t&& x + rect.width <= this.x + this.width\n\t\t\t\t\t&& y + rect.height <= this.y + this.height;\n\t\t},\n\t\n\t\tintersects: function() {\n\t\t\tvar rect = Rectangle.read(arguments);\n\t\t\treturn rect.x + rect.width > this.x\n\t\t\t\t\t&& rect.y + rect.height > this.y\n\t\t\t\t\t&& rect.x < this.x + this.width\n\t\t\t\t\t&& rect.y < this.y + this.height;\n\t\t},\n\t\n\t\ttouches: function() {\n\t\t\tvar rect = Rectangle.read(arguments);\n\t\t\treturn rect.x + rect.width >= this.x\n\t\t\t\t\t&& rect.y + rect.height >= this.y\n\t\t\t\t\t&& rect.x <= this.x + this.width\n\t\t\t\t\t&& rect.y <= this.y + this.height;\n\t\t},\n\t\n\t\tintersect: function() {\n\t\t\tvar rect = Rectangle.read(arguments),\n\t\t\t\tx1 = Math.max(this.x, rect.x),\n\t\t\t\ty1 = Math.max(this.y, rect.y),\n\t\t\t\tx2 = Math.min(this.x + this.width, rect.x + rect.width),\n\t\t\t\ty2 = Math.min(this.y + this.height, rect.y + rect.height);\n\t\t\treturn new Rectangle(x1, y1, x2 - x1, y2 - y1);\n\t\t},\n\t\n\t\tunite: function() {\n\t\t\tvar rect = Rectangle.read(arguments),\n\t\t\t\tx1 = Math.min(this.x, rect.x),\n\t\t\t\ty1 = Math.min(this.y, rect.y),\n\t\t\t\tx2 = Math.max(this.x + this.width, rect.x + rect.width),\n\t\t\t\ty2 = Math.max(this.y + this.height, rect.y + rect.height);\n\t\t\treturn new Rectangle(x1, y1, x2 - x1, y2 - y1);\n\t\t},\n\t\n\t\tinclude: function() {\n\t\t\tvar point = Point.read(arguments);\n\t\t\tvar x1 = Math.min(this.x, point.x),\n\t\t\t\ty1 = Math.min(this.y, point.y),\n\t\t\t\tx2 = Math.max(this.x + this.width, point.x),\n\t\t\t\ty2 = Math.max(this.y + this.height, point.y);\n\t\t\treturn new Rectangle(x1, y1, x2 - x1, y2 - y1);\n\t\t},\n\t\n\t\texpand: function() {\n\t\t\tvar amount = Size.read(arguments),\n\t\t\t\thor = amount.width,\n\t\t\t\tver = amount.height;\n\t\t\treturn new Rectangle(this.x - hor / 2, this.y - ver / 2,\n\t\t\t\t\tthis.width + hor, this.height + ver);\n\t\t},\n\t\n\t\tscale: function(hor, ver) {\n\t\t\treturn this.expand(this.width * hor - this.width,\n\t\t\t\t\tthis.height * (ver === undefined ? hor : ver) - this.height);\n\t\t}\n\t}, Base.each([\n\t\t\t['Top', 'Left'], ['Top', 'Right'],\n\t\t\t['Bottom', 'Left'], ['Bottom', 'Right'],\n\t\t\t['Left', 'Center'], ['Top', 'Center'],\n\t\t\t['Right', 'Center'], ['Bottom', 'Center']\n\t\t],\n\t\tfunction(parts, index) {\n\t\t\tvar part = parts.join('');\n\t\t\tvar xFirst = /^[RL]/.test(part);\n\t\t\tif (index >= 4)\n\t\t\t\tparts[1] += xFirst ? 'Y' : 'X';\n\t\t\tvar x = parts[xFirst ? 0 : 1],\n\t\t\t\ty = parts[xFirst ? 1 : 0],\n\t\t\t\tgetX = 'get' + x,\n\t\t\t\tgetY = 'get' + y,\n\t\t\t\tsetX = 'set' + x,\n\t\t\t\tsetY = 'set' + y,\n\t\t\t\tget = 'get' + part,\n\t\t\t\tset = 'set' + part;\n\t\t\tthis[get] = function(_dontLink) {\n\t\t\t\tvar ctor = _dontLink ? Point : LinkedPoint;\n\t\t\t\treturn new ctor(this[getX](), this[getY](), this, set);\n\t\t\t};\n\t\t\tthis[set] = function() {\n\t\t\t\tvar point = Point.read(arguments);\n\t\t\t\tthis[setX](point.x);\n\t\t\t\tthis[setY](point.y);\n\t\t\t};\n\t\t}, {\n\t\t\tbeans: true\n\t\t}\n\t));\n\t\n\tvar LinkedRectangle = Rectangle.extend({\n\t\tinitialize: function Rectangle(x, y, width, height, owner, setter) {\n\t\t\tthis.set(x, y, width, height, true);\n\t\t\tthis._owner = owner;\n\t\t\tthis._setter = setter;\n\t\t},\n\t\n\t\tset: function(x, y, width, height, _dontNotify) {\n\t\t\tthis._x = x;\n\t\t\tthis._y = y;\n\t\t\tthis._width = width;\n\t\t\tthis._height = height;\n\t\t\tif (!_dontNotify)\n\t\t\t\tthis._owner[this._setter](this);\n\t\t\treturn this;\n\t\t}\n\t},\n\tnew function() {\n\t\tvar proto = Rectangle.prototype;\n\t\n\t\treturn Base.each(['x', 'y', 'width', 'height'], function(key) {\n\t\t\tvar part = Base.capitalize(key);\n\t\t\tvar internal = '_' + key;\n\t\t\tthis['get' + part] = function() {\n\t\t\t\treturn this[internal];\n\t\t\t};\n\t\n\t\t\tthis['set' + part] = function(value) {\n\t\t\t\tthis[internal] = value;\n\t\t\t\tif (!this._dontNotify)\n\t\t\t\t\tthis._owner[this._setter](this);\n\t\t\t};\n\t\t}, Base.each(['Point', 'Size', 'Center',\n\t\t\t\t'Left', 'Top', 'Right', 'Bottom', 'CenterX', 'CenterY',\n\t\t\t\t'TopLeft', 'TopRight', 'BottomLeft', 'BottomRight',\n\t\t\t\t'LeftCenter', 'TopCenter', 'RightCenter', 'BottomCenter'],\n\t\t\tfunction(key) {\n\t\t\t\tvar name = 'set' + key;\n\t\t\t\tthis[name] = function() {\n\t\t\t\t\tthis._dontNotify = true;\n\t\t\t\t\tproto[name].apply(this, arguments);\n\t\t\t\t\tthis._dontNotify = false;\n\t\t\t\t\tthis._owner[this._setter](this);\n\t\t\t\t};\n\t\t\t}, {\n\t\t\t\tisSelected: function() {\n\t\t\t\t\treturn this._owner._boundsSelected;\n\t\t\t\t},\n\t\n\t\t\t\tsetSelected: function(selected) {\n\t\t\t\t\tvar owner = this._owner;\n\t\t\t\t\tif (owner.setSelected) {\n\t\t\t\t\t\towner._boundsSelected = selected;\n\t\t\t\t\t\towner.setSelected(selected || owner._selectedSegmentState > 0);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t})\n\t\t);\n\t});\n\t\n\tvar Matrix = Base.extend({\n\t\t_class: 'Matrix',\n\t\n\t\tinitialize: function Matrix(arg) {\n\t\t\tvar count = arguments.length,\n\t\t\t\tok = true;\n\t\t\tif (count === 6) {\n\t\t\t\tthis.set.apply(this, arguments);\n\t\t\t} else if (count === 1) {\n\t\t\t\tif (arg instanceof Matrix) {\n\t\t\t\t\tthis.set(arg._a, arg._c, arg._b, arg._d, arg._tx, arg._ty);\n\t\t\t\t} else if (Array.isArray(arg)) {\n\t\t\t\t\tthis.set.apply(this, arg);\n\t\t\t\t} else {\n\t\t\t\t\tok = false;\n\t\t\t\t}\n\t\t\t} else if (count === 0) {\n\t\t\t\tthis.reset();\n\t\t\t} else {\n\t\t\t\tok = false;\n\t\t\t}\n\t\t\tif (!ok)\n\t\t\t\tthrow new Error('Unsupported matrix parameters');\n\t\t},\n\t\n\t\tset: function(a, c, b, d, tx, ty, _dontNotify) {\n\t\t\tthis._a = a;\n\t\t\tthis._c = c;\n\t\t\tthis._b = b;\n\t\t\tthis._d = d;\n\t\t\tthis._tx = tx;\n\t\t\tthis._ty = ty;\n\t\t\tif (!_dontNotify)\n\t\t\t\tthis._changed();\n\t\t\treturn this;\n\t\t},\n\t\n\t\t_serialize: function(options) {\n\t\t\treturn Base.serialize(this.getValues(), options);\n\t\t},\n\t\n\t\t_changed: function() {\n\t\t\tvar owner = this._owner;\n\t\t\tif (owner) {\n\t\t\t\tif (owner._applyMatrix) {\n\t\t\t\t\towner.transform(null, true);\n\t\t\t\t} else {\n\t\t\t\t\towner._changed(9);\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\n\t\tclone: function() {\n\t\t\treturn new Matrix(this._a, this._c, this._b, this._d,\n\t\t\t\t\tthis._tx, this._ty);\n\t\t},\n\t\n\t\tequals: function(mx) {\n\t\t\treturn mx === this || mx && this._a === mx._a && this._b === mx._b\n\t\t\t\t\t&& this._c === mx._c && this._d === mx._d\n\t\t\t\t\t&& this._tx === mx._tx && this._ty === mx._ty\n\t\t\t\t\t|| false;\n\t\t},\n\t\n\t\ttoString: function() {\n\t\t\tvar f = Formatter.instance;\n\t\t\treturn '[[' + [f.number(this._a), f.number(this._b),\n\t\t\t\t\t\tf.number(this._tx)].join(', ') + '], ['\n\t\t\t\t\t+ [f.number(this._c), f.number(this._d),\n\t\t\t\t\t\tf.number(this._ty)].join(', ') + ']]';\n\t\t},\n\t\n\t\treset: function(_dontNotify) {\n\t\t\tthis._a = this._d = 1;\n\t\t\tthis._c = this._b = this._tx = this._ty = 0;\n\t\t\tif (!_dontNotify)\n\t\t\t\tthis._changed();\n\t\t\treturn this;\n\t\t},\n\t\n\t\tapply: function(recursively, _setApplyMatrix) {\n\t\t\tvar owner = this._owner;\n\t\t\tif (owner) {\n\t\t\t\towner.transform(null, true, Base.pick(recursively, true),\n\t\t\t\t\t\t_setApplyMatrix);\n\t\t\t\treturn this.isIdentity();\n\t\t\t}\n\t\t\treturn false;\n\t\t},\n\t\n\t\ttranslate: function() {\n\t\t\tvar point = Point.read(arguments),\n\t\t\t\tx = point.x,\n\t\t\t\ty = point.y;\n\t\t\tthis._tx += x * this._a + y * this._b;\n\t\t\tthis._ty += x * this._c + y * this._d;\n\t\t\tthis._changed();\n\t\t\treturn this;\n\t\t},\n\t\n\t\tscale: function() {\n\t\t\tvar scale = Point.read(arguments),\n\t\t\t\tcenter = Point.read(arguments, 0, { readNull: true });\n\t\t\tif (center)\n\t\t\t\tthis.translate(center);\n\t\t\tthis._a *= scale.x;\n\t\t\tthis._c *= scale.x;\n\t\t\tthis._b *= scale.y;\n\t\t\tthis._d *= scale.y;\n\t\t\tif (center)\n\t\t\t\tthis.translate(center.negate());\n\t\t\tthis._changed();\n\t\t\treturn this;\n\t\t},\n\t\n\t\trotate: function(angle ) {\n\t\t\tangle *= Math.PI / 180;\n\t\t\tvar center = Point.read(arguments, 1),\n\t\t\t\tx = center.x,\n\t\t\t\ty = center.y,\n\t\t\t\tcos = Math.cos(angle),\n\t\t\t\tsin = Math.sin(angle),\n\t\t\t\ttx = x - x * cos + y * sin,\n\t\t\t\tty = y - x * sin - y * cos,\n\t\t\t\ta = this._a,\n\t\t\t\tb = this._b,\n\t\t\t\tc = this._c,\n\t\t\t\td = this._d;\n\t\t\tthis._a = cos * a + sin * b;\n\t\t\tthis._b = -sin * a + cos * b;\n\t\t\tthis._c = cos * c + sin * d;\n\t\t\tthis._d = -sin * c + cos * d;\n\t\t\tthis._tx += tx * a + ty * b;\n\t\t\tthis._ty += tx * c + ty * d;\n\t\t\tthis._changed();\n\t\t\treturn this;\n\t\t},\n\t\n\t\tshear: function() {\n\t\t\tvar shear = Point.read(arguments),\n\t\t\t\tcenter = Point.read(arguments, 0, { readNull: true });\n\t\t\tif (center)\n\t\t\t\tthis.translate(center);\n\t\t\tvar a = this._a,\n\t\t\t\tc = this._c;\n\t\t\tthis._a += shear.y * this._b;\n\t\t\tthis._c += shear.y * this._d;\n\t\t\tthis._b += shear.x * a;\n\t\t\tthis._d += shear.x * c;\n\t\t\tif (center)\n\t\t\t\tthis.translate(center.negate());\n\t\t\tthis._changed();\n\t\t\treturn this;\n\t\t},\n\t\n\t\tskew: function() {\n\t\t\tvar skew = Point.read(arguments),\n\t\t\t\tcenter = Point.read(arguments, 0, { readNull: true }),\n\t\t\t\ttoRadians = Math.PI / 180,\n\t\t\t\tshear = new Point(Math.tan(skew.x * toRadians),\n\t\t\t\t\tMath.tan(skew.y * toRadians));\n\t\t\treturn this.shear(shear, center);\n\t\t},\n\t\n\t\tconcatenate: function(mx) {\n\t\t\tvar a1 = this._a,\n\t\t\t\tb1 = this._b,\n\t\t\t\tc1 = this._c,\n\t\t\t\td1 = this._d,\n\t\t\t\ta2 = mx._a,\n\t\t\t\tb2 = mx._b,\n\t\t\t\tc2 = mx._c,\n\t\t\t\td2 = mx._d,\n\t\t\t\ttx2 = mx._tx,\n\t\t\t\tty2 = mx._ty;\n\t\t\tthis._a = a2 * a1 + c2 * b1;\n\t\t\tthis._b = b2 * a1 + d2 * b1;\n\t\t\tthis._c = a2 * c1 + c2 * d1;\n\t\t\tthis._d = b2 * c1 + d2 * d1;\n\t\t\tthis._tx += tx2 * a1 + ty2 * b1;\n\t\t\tthis._ty += tx2 * c1 + ty2 * d1;\n\t\t\tthis._changed();\n\t\t\treturn this;\n\t\t},\n\t\n\t\tpreConcatenate: function(mx) {\n\t\t\tvar a1 = this._a,\n\t\t\t\tb1 = this._b,\n\t\t\t\tc1 = this._c,\n\t\t\t\td1 = this._d,\n\t\t\t\ttx1 = this._tx,\n\t\t\t\tty1 = this._ty,\n\t\t\t\ta2 = mx._a,\n\t\t\t\tb2 = mx._b,\n\t\t\t\tc2 = mx._c,\n\t\t\t\td2 = mx._d,\n\t\t\t\ttx2 = mx._tx,\n\t\t\t\tty2 = mx._ty;\n\t\t\tthis._a = a2 * a1 + b2 * c1;\n\t\t\tthis._b = a2 * b1 + b2 * d1;\n\t\t\tthis._c = c2 * a1 + d2 * c1;\n\t\t\tthis._d = c2 * b1 + d2 * d1;\n\t\t\tthis._tx = a2 * tx1 + b2 * ty1 + tx2;\n\t\t\tthis._ty = c2 * tx1 + d2 * ty1 + ty2;\n\t\t\tthis._changed();\n\t\t\treturn this;\n\t\t},\n\t\n\t\tchain: function(mx) {\n\t\t\tvar a1 = this._a,\n\t\t\t\tb1 = this._b,\n\t\t\t\tc1 = this._c,\n\t\t\t\td1 = this._d,\n\t\t\t\ttx1 = this._tx,\n\t\t\t\tty1 = this._ty,\n\t\t\t\ta2 = mx._a,\n\t\t\t\tb2 = mx._b,\n\t\t\t\tc2 = mx._c,\n\t\t\t\td2 = mx._d,\n\t\t\t\ttx2 = mx._tx,\n\t\t\t\tty2 = mx._ty;\n\t\t\treturn new Matrix(\n\t\t\t\t\ta2 * a1 + c2 * b1,\n\t\t\t\t\ta2 * c1 + c2 * d1,\n\t\t\t\t\tb2 * a1 + d2 * b1,\n\t\t\t\t\tb2 * c1 + d2 * d1,\n\t\t\t\t\ttx1 + tx2 * a1 + ty2 * b1,\n\t\t\t\t\tty1 + tx2 * c1 + ty2 * d1);\n\t\t},\n\t\n\t\tisIdentity: function() {\n\t\t\treturn this._a === 1 && this._c === 0 && this._b === 0 && this._d === 1\n\t\t\t\t\t&& this._tx === 0 && this._ty === 0;\n\t\t},\n\t\n\t\torNullIfIdentity: function() {\n\t\t\treturn this.isIdentity() ? null : this;\n\t\t},\n\t\n\t\tisInvertible: function() {\n\t\t\treturn !!this._getDeterminant();\n\t\t},\n\t\n\t\tisSingular: function() {\n\t\t\treturn !this._getDeterminant();\n\t\t},\n\t\n\t\ttransform: function( src, dst, count) {\n\t\t\treturn arguments.length < 3\n\t\t\t\t? this._transformPoint(Point.read(arguments))\n\t\t\t\t: this._transformCoordinates(src, dst, count);\n\t\t},\n\t\n\t\t_transformPoint: function(point, dest, _dontNotify) {\n\t\t\tvar x = point.x,\n\t\t\t\ty = point.y;\n\t\t\tif (!dest)\n\t\t\t\tdest = new Point();\n\t\t\treturn dest.set(\n\t\t\t\tx * this._a + y * this._b + this._tx,\n\t\t\t\tx * this._c + y * this._d + this._ty,\n\t\t\t\t_dontNotify\n\t\t\t);\n\t\t},\n\t\n\t\t_transformCoordinates: function(src, dst, count) {\n\t\t\tvar i = 0,\n\t\t\t\tj = 0,\n\t\t\t\tmax = 2 * count;\n\t\t\twhile (i < max) {\n\t\t\t\tvar x = src[i++],\n\t\t\t\t\ty = src[i++];\n\t\t\t\tdst[j++] = x * this._a + y * this._b + this._tx;\n\t\t\t\tdst[j++] = x * this._c + y * this._d + this._ty;\n\t\t\t}\n\t\t\treturn dst;\n\t\t},\n\t\n\t\t_transformCorners: function(rect) {\n\t\t\tvar x1 = rect.x,\n\t\t\t\ty1 = rect.y,\n\t\t\t\tx2 = x1 + rect.width,\n\t\t\t\ty2 = y1 + rect.height,\n\t\t\t\tcoords = [ x1, y1, x2, y1, x2, y2, x1, y2 ];\n\t\t\treturn this._transformCoordinates(coords, coords, 4);\n\t\t},\n\t\n\t\t_transformBounds: function(bounds, dest, _dontNotify) {\n\t\t\tvar coords = this._transformCorners(bounds),\n\t\t\t\tmin = coords.slice(0, 2),\n\t\t\t\tmax = min.slice();\n\t\t\tfor (var i = 2; i < 8; i++) {\n\t\t\t\tvar val = coords[i],\n\t\t\t\t\tj = i & 1;\n\t\t\t\tif (val < min[j])\n\t\t\t\t\tmin[j] = val;\n\t\t\t\telse if (val > max[j])\n\t\t\t\t\tmax[j] = val;\n\t\t\t}\n\t\t\tif (!dest)\n\t\t\t\tdest = new Rectangle();\n\t\t\treturn dest.set(min[0], min[1], max[0] - min[0], max[1] - min[1],\n\t\t\t\t\t_dontNotify);\n\t\t},\n\t\n\t\tinverseTransform: function() {\n\t\t\treturn this._inverseTransform(Point.read(arguments));\n\t\t},\n\t\n\t\t_getDeterminant: function() {\n\t\t\tvar det = this._a * this._d - this._b * this._c;\n\t\t\treturn isFinite(det) && !Numerical.isZero(det)\n\t\t\t\t\t&& isFinite(this._tx) && isFinite(this._ty)\n\t\t\t\t\t? det : null;\n\t\t},\n\t\n\t\t_inverseTransform: function(point, dest, _dontNotify) {\n\t\t\tvar det = this._getDeterminant();\n\t\t\tif (!det)\n\t\t\t\treturn null;\n\t\t\tvar x = point.x - this._tx,\n\t\t\t\ty = point.y - this._ty;\n\t\t\tif (!dest)\n\t\t\t\tdest = new Point();\n\t\t\treturn dest.set(\n\t\t\t\t(x * this._d - y * this._b) / det,\n\t\t\t\t(y * this._a - x * this._c) / det,\n\t\t\t\t_dontNotify\n\t\t\t);\n\t\t},\n\t\n\t\tdecompose: function() {\n\t\t\tvar a = this._a, b = this._b, c = this._c, d = this._d;\n\t\t\tif (Numerical.isZero(a * d - b * c))\n\t\t\t\treturn null;\n\t\n\t\t\tvar scaleX = Math.sqrt(a * a + b * b);\n\t\t\ta /= scaleX;\n\t\t\tb /= scaleX;\n\t\n\t\t\tvar shear = a * c + b * d;\n\t\t\tc -= a * shear;\n\t\t\td -= b * shear;\n\t\n\t\t\tvar scaleY = Math.sqrt(c * c + d * d);\n\t\t\tc /= scaleY;\n\t\t\td /= scaleY;\n\t\t\tshear /= scaleY;\n\t\n\t\t\tif (a * d < b * c) {\n\t\t\t\ta = -a;\n\t\t\t\tb = -b;\n\t\t\t\tshear = -shear;\n\t\t\t\tscaleX = -scaleX;\n\t\t\t}\n\t\n\t\t\treturn {\n\t\t\t\tscaling: new Point(scaleX, scaleY),\n\t\t\t\trotation: -Math.atan2(b, a) * 180 / Math.PI,\n\t\t\t\tshearing: shear\n\t\t\t};\n\t\t},\n\t\n\t\tgetValues: function() {\n\t\t\treturn [ this._a, this._c, this._b, this._d, this._tx, this._ty ];\n\t\t},\n\t\n\t\tgetTranslation: function() {\n\t\t\treturn new Point(this._tx, this._ty);\n\t\t},\n\t\n\t\tgetScaling: function() {\n\t\t\treturn (this.decompose() || {}).scaling;\n\t\t},\n\t\n\t\tgetRotation: function() {\n\t\t\treturn (this.decompose() || {}).rotation;\n\t\t},\n\t\n\t\tinverted: function() {\n\t\t\tvar det = this._getDeterminant();\n\t\t\treturn det && new Matrix(\n\t\t\t\t\tthis._d / det,\n\t\t\t\t\t-this._c / det,\n\t\t\t\t\t-this._b / det,\n\t\t\t\t\tthis._a / det,\n\t\t\t\t\t(this._b * this._ty - this._d * this._tx) / det,\n\t\t\t\t\t(this._c * this._tx - this._a * this._ty) / det);\n\t\t},\n\t\n\t\tshiftless: function() {\n\t\t\treturn new Matrix(this._a, this._c, this._b, this._d, 0, 0);\n\t\t},\n\t\n\t\tapplyToContext: function(ctx) {\n\t\t\tctx.transform(this._a, this._c, this._b, this._d, this._tx, this._ty);\n\t\t}\n\t}, Base.each(['a', 'c', 'b', 'd', 'tx', 'ty'], function(name) {\n\t\tvar part = Base.capitalize(name),\n\t\t\tprop = '_' + name;\n\t\tthis['get' + part] = function() {\n\t\t\treturn this[prop];\n\t\t};\n\t\tthis['set' + part] = function(value) {\n\t\t\tthis[prop] = value;\n\t\t\tthis._changed();\n\t\t};\n\t}, {}));\n\t\n\tvar Line = Base.extend({\n\t\t_class: 'Line',\n\t\n\t\tinitialize: function Line(arg0, arg1, arg2, arg3, arg4) {\n\t\t\tvar asVector = false;\n\t\t\tif (arguments.length >= 4) {\n\t\t\t\tthis._px = arg0;\n\t\t\t\tthis._py = arg1;\n\t\t\t\tthis._vx = arg2;\n\t\t\t\tthis._vy = arg3;\n\t\t\t\tasVector = arg4;\n\t\t\t} else {\n\t\t\t\tthis._px = arg0.x;\n\t\t\t\tthis._py = arg0.y;\n\t\t\t\tthis._vx = arg1.x;\n\t\t\t\tthis._vy = arg1.y;\n\t\t\t\tasVector = arg2;\n\t\t\t}\n\t\t\tif (!asVector) {\n\t\t\t\tthis._vx -= this._px;\n\t\t\t\tthis._vy -= this._py;\n\t\t\t}\n\t\t},\n\t\n\t\tgetPoint: function() {\n\t\t\treturn new Point(this._px, this._py);\n\t\t},\n\t\n\t\tgetVector: function() {\n\t\t\treturn new Point(this._vx, this._vy);\n\t\t},\n\t\n\t\tgetLength: function() {\n\t\t\treturn this.getVector().getLength();\n\t\t},\n\t\n\t\tintersect: function(line, isInfinite) {\n\t\t\treturn Line.intersect(\n\t\t\t\t\tthis._px, this._py, this._vx, this._vy,\n\t\t\t\t\tline._px, line._py, line._vx, line._vy,\n\t\t\t\t\ttrue, isInfinite);\n\t\t},\n\t\n\t\tgetSide: function(point, isInfinite) {\n\t\t\treturn Line.getSide(\n\t\t\t\t\tthis._px, this._py, this._vx, this._vy,\n\t\t\t\t\tpoint.x, point.y, true, isInfinite);\n\t\t},\n\t\n\t\tgetDistance: function(point) {\n\t\t\treturn Math.abs(Line.getSignedDistance(\n\t\t\t\t\tthis._px, this._py, this._vx, this._vy,\n\t\t\t\t\tpoint.x, point.y, true));\n\t\t},\n\t\n\t\tisCollinear: function(line) {\n\t\t\treturn Point.isCollinear(this._vx, this._vy, line._vx, line._vy);\n\t\t},\n\t\n\t\tisOrthogonal: function(line) {\n\t\t\treturn Point.isOrthogonal(this._vx, this._vy, line._vx, line._vy);\n\t\t},\n\t\n\t\tstatics: {\n\t\t\tintersect: function(p1x, p1y, v1x, v1y, p2x, p2y, v2x, v2y, asVector,\n\t\t\t\t\tisInfinite) {\n\t\t\t\tif (!asVector) {\n\t\t\t\t\tv1x -= p1x;\n\t\t\t\t\tv1y -= p1y;\n\t\t\t\t\tv2x -= p2x;\n\t\t\t\t\tv2y -= p2y;\n\t\t\t\t}\n\t\t\t\tvar cross = v1x * v2y - v1y * v2x;\n\t\t\t\tif (!Numerical.isZero(cross)) {\n\t\t\t\t\tvar dx = p1x - p2x,\n\t\t\t\t\t\tdy = p1y - p2y,\n\t\t\t\t\t\tu1 = (v2x * dy - v2y * dx) / cross,\n\t\t\t\t\t\tu2 = (v1x * dy - v1y * dx) / cross,\n\t\t\t\t\t\tepsilon = 1e-12,\n\t\t\t\t\t\tuMin = -epsilon,\n\t\t\t\t\t\tuMax = 1 + epsilon;\n\t\t\t\t\tif (isInfinite\n\t\t\t\t\t\t\t|| uMin < u1 && u1 < uMax && uMin < u2 && u2 < uMax) {\n\t\t\t\t\t\tif (!isInfinite) {\n\t\t\t\t\t\t\tu1 = u1 <= 0 ? 0 : u1 >= 1 ? 1 : u1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn new Point(\n\t\t\t\t\t\t\t\tp1x + u1 * v1x,\n\t\t\t\t\t\t\t\tp1y + u1 * v1y);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\n\t\t\tgetSide: function(px, py, vx, vy, x, y, asVector, isInfinite) {\n\t\t\t\tif (!asVector) {\n\t\t\t\t\tvx -= px;\n\t\t\t\t\tvy -= py;\n\t\t\t\t}\n\t\t\t\tvar v2x = x - px,\n\t\t\t\t\tv2y = y - py,\n\t\t\t\t\tccw = v2x * vy - v2y * vx;\n\t\t\t\tif (ccw === 0 && !isInfinite) {\n\t\t\t\t\tccw = (v2x * vx + v2x * vx) / (vx * vx + vy * vy);\n\t\t\t\t\tif (ccw >= 0 && ccw <= 1)\n\t\t\t\t\t\tccw = 0;\n\t\t\t\t}\n\t\t\t\treturn ccw < 0 ? -1 : ccw > 0 ? 1 : 0;\n\t\t\t},\n\t\n\t\t\tgetSignedDistance: function(px, py, vx, vy, x, y, asVector) {\n\t\t\t\tif (!asVector) {\n\t\t\t\t\tvx -= px;\n\t\t\t\t\tvy -= py;\n\t\t\t\t}\n\t\t\t\treturn vx === 0 ? vy > 0 ? x - px : px - x\n\t\t\t\t\t : vy === 0 ? vx < 0 ? y - py : py - y\n\t\t\t\t\t : ((x-px) * vy - (y-py) * vx) / Math.sqrt(vx * vx + vy * vy);\n\t\t\t}\n\t\t}\n\t});\n\t\n\tvar Project = PaperScopeItem.extend({\n\t\t_class: 'Project',\n\t\t_list: 'projects',\n\t\t_reference: 'project',\n\t\n\t\tinitialize: function Project(element) {\n\t\t\tPaperScopeItem.call(this, true);\n\t\t\tthis.layers = [];\n\t\t\tthis._activeLayer = null;\n\t\t\tthis.symbols = [];\n\t\t\tthis._currentStyle = new Style(null, null, this);\n\t\t\tthis._view = View.create(this,\n\t\t\t\t\telement || CanvasProvider.getCanvas(1, 1));\n\t\t\tthis._selectedItems = {};\n\t\t\tthis._selectedItemCount = 0;\n\t\t\tthis._updateVersion = 0;\n\t\t},\n\t\n\t\t_serialize: function(options, dictionary) {\n\t\t\treturn Base.serialize(this.layers, options, true, dictionary);\n\t\t},\n\t\n\t\tclear: function() {\n\t\t\tfor (var i = this.layers.length - 1; i >= 0; i--)\n\t\t\t\tthis.layers[i].remove();\n\t\t\tthis.symbols = [];\n\t\t},\n\t\n\t\tisEmpty: function() {\n\t\t\treturn this.layers.length === 0;\n\t\t},\n\t\n\t\tremove: function remove() {\n\t\t\tif (!remove.base.call(this))\n\t\t\t\treturn false;\n\t\t\tif (this._view)\n\t\t\t\tthis._view.remove();\n\t\t\treturn true;\n\t\t},\n\t\n\t\tgetView: function() {\n\t\t\treturn this._view;\n\t\t},\n\t\n\t\tgetCurrentStyle: function() {\n\t\t\treturn this._currentStyle;\n\t\t},\n\t\n\t\tsetCurrentStyle: function(style) {\n\t\t\tthis._currentStyle.initialize(style);\n\t\t},\n\t\n\t\tgetIndex: function() {\n\t\t\treturn this._index;\n\t\t},\n\t\n\t\tgetOptions: function() {\n\t\t\treturn this._scope.settings;\n\t\t},\n\t\n\t\tgetActiveLayer: function() {\n\t\t\treturn this._activeLayer || new Layer({ project: this });\n\t\t},\n\t\n\t\tgetSelectedItems: function() {\n\t\t\tvar items = [];\n\t\t\tfor (var id in this._selectedItems) {\n\t\t\t\tvar item = this._selectedItems[id];\n\t\t\t\tif (item.isInserted())\n\t\t\t\t\titems.push(item);\n\t\t\t}\n\t\t\treturn items;\n\t\t},\n\t\n\t\tinsertChild: function(index, item, _preserve) {\n\t\t\tif (item instanceof Layer) {\n\t\t\t\titem._remove(false, true);\n\t\t\t\tBase.splice(this.layers, [item], index, 0);\n\t\t\t\titem._setProject(this, true);\n\t\t\t\tif (this._changes)\n\t\t\t\t\titem._changed(5);\n\t\t\t\tif (!this._activeLayer)\n\t\t\t\t\tthis._activeLayer = item;\n\t\t\t} else if (item instanceof Item) {\n\t\t\t\t(this._activeLayer\n\t\t\t\t\t|| this.insertChild(index, new Layer(Item.NO_INSERT)))\n\t\t\t\t\t\t.insertChild(index, item, _preserve);\n\t\t\t} else {\n\t\t\t\titem = null;\n\t\t\t}\n\t\t\treturn item;\n\t\t},\n\t\n\t\taddChild: function(item, _preserve) {\n\t\t\treturn this.insertChild(undefined, item, _preserve);\n\t\t},\n\t\n\t\t_updateSelection: function(item) {\n\t\t\tvar id = item._id,\n\t\t\t\tselectedItems = this._selectedItems;\n\t\t\tif (item._selected) {\n\t\t\t\tif (selectedItems[id] !== item) {\n\t\t\t\t\tthis._selectedItemCount++;\n\t\t\t\t\tselectedItems[id] = item;\n\t\t\t\t}\n\t\t\t} else if (selectedItems[id] === item) {\n\t\t\t\tthis._selectedItemCount--;\n\t\t\t\tdelete selectedItems[id];\n\t\t\t}\n\t\t},\n\t\n\t\tselectAll: function() {\n\t\t\tvar layers = this.layers;\n\t\t\tfor (var i = 0, l = layers.length; i < l; i++)\n\t\t\t\tlayers[i].setFullySelected(true);\n\t\t},\n\t\n\t\tdeselectAll: function() {\n\t\t\tvar selectedItems = this._selectedItems;\n\t\t\tfor (var i in selectedItems)\n\t\t\t\tselectedItems[i].setFullySelected(false);\n\t\t},\n\t\n\t\thitTest: function() {\n\t\t\tvar point = Point.read(arguments),\n\t\t\t\toptions = HitResult.getOptions(Base.read(arguments));\n\t\t\tfor (var i = this.layers.length - 1; i >= 0; i--) {\n\t\t\t\tvar res = this.layers[i]._hitTest(point, options);\n\t\t\t\tif (res) return res;\n\t\t\t}\n\t\t\treturn null;\n\t\t},\n\t\n\t\tgetItems: function(match) {\n\t\t\treturn Item._getItems(this.layers, match);\n\t\t},\n\t\n\t\tgetItem: function(match) {\n\t\t\treturn Item._getItems(this.layers, match, null, null, true)[0] || null;\n\t\t},\n\t\n\t\timportJSON: function(json) {\n\t\t\tthis.activate();\n\t\t\tvar layer = this._activeLayer;\n\t\t\treturn Base.importJSON(json, layer && layer.isEmpty() && layer);\n\t\t},\n\t\n\t\tdraw: function(ctx, matrix, pixelRatio) {\n\t\t\tthis._updateVersion++;\n\t\t\tctx.save();\n\t\t\tmatrix.applyToContext(ctx);\n\t\t\tvar param = new Base({\n\t\t\t\toffset: new Point(0, 0),\n\t\t\t\tpixelRatio: pixelRatio,\n\t\t\t\tviewMatrix: matrix.isIdentity() ? null : matrix,\n\t\t\t\tmatrices: [new Matrix()],\n\t\t\t\tupdateMatrix: true\n\t\t\t});\n\t\t\tfor (var i = 0, layers = this.layers, l = layers.length; i < l; i++)\n\t\t\t\tlayers[i].draw(ctx, param);\n\t\t\tctx.restore();\n\t\n\t\t\tif (this._selectedItemCount > 0) {\n\t\t\t\tctx.save();\n\t\t\t\tctx.strokeWidth = 1;\n\t\t\t\tvar items = this._selectedItems,\n\t\t\t\t\tsize = this._scope.settings.handleSize,\n\t\t\t\t\tversion = this._updateVersion;\n\t\t\t\tfor (var id in items)\n\t\t\t\t\titems[id]._drawSelection(ctx, matrix, size, items, version);\n\t\t\t\tctx.restore();\n\t\t\t}\n\t\t}\n\t});\n\t\n\tvar Symbol = Base.extend({\n\t\t_class: 'Symbol',\n\t\n\t\tinitialize: function Symbol(item, dontCenter) {\n\t\t\tthis._id = UID.get();\n\t\t\tthis.project = paper.project;\n\t\t\tthis.project.symbols.push(this);\n\t\t\tif (item)\n\t\t\t\tthis.setDefinition(item, dontCenter);\n\t\t},\n\t\n\t\t_serialize: function(options, dictionary) {\n\t\t\treturn dictionary.add(this, function() {\n\t\t\t\treturn Base.serialize([this._class, this._definition],\n\t\t\t\t\t\toptions, false, dictionary);\n\t\t\t});\n\t\t},\n\t\n\t\t_changed: function(flags) {\n\t\t\tif (flags & 8) {\n\t\t\t\tItem._clearBoundsCache(this);\n\t\t\t}\n\t\t\tif (flags & 1) {\n\t\t\t\tthis.project._needsUpdate = true;\n\t\t\t}\n\t\t},\n\t\n\t\tgetDefinition: function() {\n\t\t\treturn this._definition;\n\t\t},\n\t\n\t\tsetDefinition: function(item, _dontCenter) {\n\t\t\tif (item._parentSymbol)\n\t\t\t\titem = item.clone();\n\t\t\tif (this._definition)\n\t\t\t\tthis._definition._parentSymbol = null;\n\t\t\tthis._definition = item;\n\t\t\titem.remove();\n\t\t\titem.setSelected(false);\n\t\t\tif (!_dontCenter)\n\t\t\t\titem.setPosition(new Point());\n\t\t\titem._parentSymbol = this;\n\t\t\tthis._changed(9);\n\t\t},\n\t\n\t\tplace: function(position) {\n\t\t\treturn new PlacedSymbol(this, position);\n\t\t},\n\t\n\t\tclone: function() {\n\t\t\treturn new Symbol(this._definition.clone(false));\n\t\t},\n\t\n\t\tequals: function(symbol) {\n\t\t\treturn symbol === this\n\t\t\t\t\t|| symbol && this.definition.equals(symbol.definition)\n\t\t\t\t\t|| false;\n\t\t}\n\t});\n\t\n\tvar Item = Base.extend(Emitter, {\n\t\tstatics: {\n\t\t\textend: function extend(src) {\n\t\t\t\tif (src._serializeFields)\n\t\t\t\t\tsrc._serializeFields = new Base(\n\t\t\t\t\t\t\tthis.prototype._serializeFields, src._serializeFields);\n\t\t\t\treturn extend.base.apply(this, arguments);\n\t\t\t},\n\t\n\t\t\tNO_INSERT: { insert: false }\n\t\t},\n\t\n\t\t_class: 'Item',\n\t\t_applyMatrix: true,\n\t\t_canApplyMatrix: true,\n\t\t_boundsSelected: false,\n\t\t_selectChildren: false,\n\t\t_serializeFields: {\n\t\t\tname: null,\n\t\t\tapplyMatrix: null,\n\t\t\tmatrix: new Matrix(),\n\t\t\tpivot: null,\n\t\t\tlocked: false,\n\t\t\tvisible: true,\n\t\t\tblendMode: 'normal',\n\t\t\topacity: 1,\n\t\t\tguide: false,\n\t\t\tselected: false,\n\t\t\tclipMask: false,\n\t\t\tdata: {}\n\t\t},\n\t\n\t\tinitialize: function Item() {\n\t\t},\n\t\n\t\t_initialize: function(props, point) {\n\t\t\tvar hasProps = props && Base.isPlainObject(props),\n\t\t\t\tinternal = hasProps && props.internal === true,\n\t\t\t\tmatrix = this._matrix = new Matrix(),\n\t\t\t\tproject = hasProps && props.project || paper.project;\n\t\t\tif (!internal)\n\t\t\t\tthis._id = UID.get();\n\t\t\tthis._applyMatrix = this._canApplyMatrix && paper.settings.applyMatrix;\n\t\t\tif (point)\n\t\t\t\tmatrix.translate(point);\n\t\t\tmatrix._owner = this;\n\t\t\tthis._style = new Style(project._currentStyle, this, project);\n\t\t\tif (!this._project) {\n\t\t\t\tif (internal || hasProps && props.insert === false) {\n\t\t\t\t\tthis._setProject(project);\n\t\t\t\t} else if (hasProps && props.parent) {\n\t\t\t\t\tthis.setParent(props.parent);\n\t\t\t\t} else {\n\t\t\t\t\t(project._activeLayer || new Layer()).addChild(this);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (hasProps && props !== Item.NO_INSERT)\n\t\t\t\tthis._set(props, { insert: true, project: true, parent: true },\n\t\t\t\t\t\ttrue);\n\t\t\treturn hasProps;\n\t\t},\n\t\n\t\t_events: Base.each(['onMouseDown', 'onMouseUp', 'onMouseDrag', 'onClick',\n\t\t\t\t'onDoubleClick', 'onMouseMove', 'onMouseEnter', 'onMouseLeave'],\n\t\t\tfunction(name) {\n\t\t\t\tthis[name] = {\n\t\t\t\t\tinstall: function(type) {\n\t\t\t\t\t\tthis.getView()._installEvent(type);\n\t\t\t\t\t},\n\t\n\t\t\t\t\tuninstall: function(type) {\n\t\t\t\t\t\tthis.getView()._uninstallEvent(type);\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t}, {\n\t\t\t\tonFrame: {\n\t\t\t\t\tinstall: function() {\n\t\t\t\t\t\tthis.getView()._animateItem(this, true);\n\t\t\t\t\t},\n\t\n\t\t\t\t\tuninstall: function() {\n\t\t\t\t\t\tthis.getView()._animateItem(this, false);\n\t\t\t\t\t}\n\t\t\t\t},\n\t\n\t\t\t\tonLoad: {}\n\t\t\t}\n\t\t),\n\t\n\t\t_serialize: function(options, dictionary) {\n\t\t\tvar props = {},\n\t\t\t\tthat = this;\n\t\n\t\t\tfunction serialize(fields) {\n\t\t\t\tfor (var key in fields) {\n\t\t\t\t\tvar value = that[key];\n\t\t\t\t\tif (!Base.equals(value, key === 'leading'\n\t\t\t\t\t\t\t? fields.fontSize * 1.2 : fields[key])) {\n\t\t\t\t\t\tprops[key] = Base.serialize(value, options,\n\t\t\t\t\t\t\t\tkey !== 'data', dictionary);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\tserialize(this._serializeFields);\n\t\t\tif (!(this instanceof Group))\n\t\t\t\tserialize(this._style._defaults);\n\t\t\treturn [ this._class, props ];\n\t\t},\n\t\n\t\t_changed: function(flags) {\n\t\t\tvar symbol = this._parentSymbol,\n\t\t\t\tcacheParent = this._parent || symbol,\n\t\t\t\tproject = this._project;\n\t\t\tif (flags & 8) {\n\t\t\t\tthis._bounds = this._position = this._decomposed =\n\t\t\t\t\t\tthis._globalMatrix = this._currentPath = undefined;\n\t\t\t}\n\t\t\tif (cacheParent\n\t\t\t\t\t&& (flags & 40)) {\n\t\t\t\tItem._clearBoundsCache(cacheParent);\n\t\t\t}\n\t\t\tif (flags & 2) {\n\t\t\t\tItem._clearBoundsCache(this);\n\t\t\t}\n\t\t\tif (project) {\n\t\t\t\tif (flags & 1) {\n\t\t\t\t\tproject._needsUpdate = true;\n\t\t\t\t}\n\t\t\t\tif (project._changes) {\n\t\t\t\t\tvar entry = project._changesById[this._id];\n\t\t\t\t\tif (entry) {\n\t\t\t\t\t\tentry.flags |= flags;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tentry = { item: this, flags: flags };\n\t\t\t\t\t\tproject._changesById[this._id] = entry;\n\t\t\t\t\t\tproject._changes.push(entry);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (symbol)\n\t\t\t\tsymbol._changed(flags);\n\t\t},\n\t\n\t\tset: function(props) {\n\t\t\tif (props)\n\t\t\t\tthis._set(props);\n\t\t\treturn this;\n\t\t},\n\t\n\t\tgetId: function() {\n\t\t\treturn this._id;\n\t\t},\n\t\n\t\tgetName: function() {\n\t\t\treturn this._name;\n\t\t},\n\t\n\t\tsetName: function(name, unique) {\n\t\n\t\t\tif (this._name)\n\t\t\t\tthis._removeNamed();\n\t\t\tif (name === (+name) + '')\n\t\t\t\tthrow new Error(\n\t\t\t\t\t\t'Names consisting only of numbers are not supported.');\n\t\t\tvar parent = this._parent;\n\t\t\tif (name && parent) {\n\t\t\t\tvar children = parent._children,\n\t\t\t\t\tnamedChildren = parent._namedChildren,\n\t\t\t\t\torig = name,\n\t\t\t\t\ti = 1;\n\t\t\t\twhile (unique && children[name])\n\t\t\t\t\tname = orig + ' ' + (i++);\n\t\t\t\t(namedChildren[name] = namedChildren[name] || []).push(this);\n\t\t\t\tchildren[name] = this;\n\t\t\t}\n\t\t\tthis._name = name || undefined;\n\t\t\tthis._changed(128);\n\t\t},\n\t\n\t\tgetStyle: function() {\n\t\t\treturn this._style;\n\t\t},\n\t\n\t\tsetStyle: function(style) {\n\t\t\tthis.getStyle().set(style);\n\t\t}\n\t}, Base.each(['locked', 'visible', 'blendMode', 'opacity', 'guide'],\n\t\tfunction(name) {\n\t\t\tvar part = Base.capitalize(name),\n\t\t\t\tname = '_' + name;\n\t\t\tthis['get' + part] = function() {\n\t\t\t\treturn this[name];\n\t\t\t};\n\t\t\tthis['set' + part] = function(value) {\n\t\t\t\tif (value != this[name]) {\n\t\t\t\t\tthis[name] = value;\n\t\t\t\t\tthis._changed(name === '_locked'\n\t\t\t\t\t\t\t? 128 : 129);\n\t\t\t\t}\n\t\t\t};\n\t\t},\n\t{}), {\n\t\tbeans: true,\n\t\n\t\t_locked: false,\n\t\n\t\t_visible: true,\n\t\n\t\t_blendMode: 'normal',\n\t\n\t\t_opacity: 1,\n\t\n\t\t_guide: false,\n\t\n\t\tisSelected: function() {\n\t\t\tif (this._selectChildren) {\n\t\t\t\tvar children = this._children;\n\t\t\t\tfor (var i = 0, l = children.length; i < l; i++)\n\t\t\t\t\tif (children[i].isSelected())\n\t\t\t\t\t\treturn true;\n\t\t\t}\n\t\t\treturn this._selected;\n\t\t},\n\t\n\t\tsetSelected: function(selected, noChildren) {\n\t\t\tif (!noChildren && this._selectChildren) {\n\t\t\t\tvar children = this._children;\n\t\t\t\tfor (var i = 0, l = children.length; i < l; i++)\n\t\t\t\t\tchildren[i].setSelected(selected);\n\t\t\t}\n\t\t\tif ((selected = !!selected) ^ this._selected) {\n\t\t\t\tthis._selected = selected;\n\t\t\t\tthis._project._updateSelection(this);\n\t\t\t\tthis._changed(129);\n\t\t\t}\n\t\t},\n\t\n\t\t_selected: false,\n\t\n\t\tisFullySelected: function() {\n\t\t\tvar children = this._children;\n\t\t\tif (children && this._selected) {\n\t\t\t\tfor (var i = 0, l = children.length; i < l; i++)\n\t\t\t\t\tif (!children[i].isFullySelected())\n\t\t\t\t\t\treturn false;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\treturn this._selected;\n\t\t},\n\t\n\t\tsetFullySelected: function(selected) {\n\t\t\tvar children = this._children;\n\t\t\tif (children) {\n\t\t\t\tfor (var i = 0, l = children.length; i < l; i++)\n\t\t\t\t\tchildren[i].setFullySelected(selected);\n\t\t\t}\n\t\t\tthis.setSelected(selected, true);\n\t\t},\n\t\n\t\tisClipMask: function() {\n\t\t\treturn this._clipMask;\n\t\t},\n\t\n\t\tsetClipMask: function(clipMask) {\n\t\t\tif (this._clipMask != (clipMask = !!clipMask)) {\n\t\t\t\tthis._clipMask = clipMask;\n\t\t\t\tif (clipMask) {\n\t\t\t\t\tthis.setFillColor(null);\n\t\t\t\t\tthis.setStrokeColor(null);\n\t\t\t\t}\n\t\t\t\tthis._changed(129);\n\t\t\t\tif (this._parent)\n\t\t\t\t\tthis._parent._changed(1024);\n\t\t\t}\n\t\t},\n\t\n\t\t_clipMask: false,\n\t\n\t\tgetData: function() {\n\t\t\tif (!this._data)\n\t\t\t\tthis._data = {};\n\t\t\treturn this._data;\n\t\t},\n\t\n\t\tsetData: function(data) {\n\t\t\tthis._data = data;\n\t\t},\n\t\n\t\tgetPosition: function(_dontLink) {\n\t\t\tvar position = this._position,\n\t\t\t\tctor = _dontLink ? Point : LinkedPoint;\n\t\t\tif (!position) {\n\t\t\t\tvar pivot = this._pivot;\n\t\t\t\tposition = this._position = pivot\n\t\t\t\t\t\t? this._matrix._transformPoint(pivot)\n\t\t\t\t\t\t: this.getBounds().getCenter(true);\n\t\t\t}\n\t\t\treturn new ctor(position.x, position.y, this, 'setPosition');\n\t\t},\n\t\n\t\tsetPosition: function() {\n\t\t\tthis.translate(Point.read(arguments).subtract(this.getPosition(true)));\n\t\t},\n\t\n\t\tgetPivot: function(_dontLink) {\n\t\t\tvar pivot = this._pivot;\n\t\t\tif (pivot) {\n\t\t\t\tvar ctor = _dontLink ? Point : LinkedPoint;\n\t\t\t\tpivot = new ctor(pivot.x, pivot.y, this, 'setPivot');\n\t\t\t}\n\t\t\treturn pivot;\n\t\t},\n\t\n\t\tsetPivot: function() {\n\t\t\tthis._pivot = Point.read(arguments, 0, { clone: true, readNull: true });\n\t\t\tthis._position = undefined;\n\t\t},\n\t\n\t\t_pivot: null,\n\t}, Base.each(['bounds', 'strokeBounds', 'handleBounds', 'roughBounds',\n\t\t\t'internalBounds', 'internalRoughBounds'],\n\t\tfunction(key) {\n\t\t\tvar getter = 'get' + Base.capitalize(key),\n\t\t\t\tmatch = key.match(/^internal(.*)$/),\n\t\t\t\tinternalGetter = match ? 'get' + match[1] : null;\n\t\t\tthis[getter] = function(_matrix) {\n\t\t\t\tvar boundsGetter = this._boundsGetter,\n\t\t\t\t\tname = !internalGetter && (typeof boundsGetter === 'string'\n\t\t\t\t\t\t\t? boundsGetter : boundsGetter && boundsGetter[getter])\n\t\t\t\t\t\t\t|| getter,\n\t\t\t\t\tbounds = this._getCachedBounds(name, _matrix, this,\n\t\t\t\t\t\t\tinternalGetter);\n\t\t\t\treturn key === 'bounds'\n\t\t\t\t\t\t? new LinkedRectangle(bounds.x, bounds.y, bounds.width,\n\t\t\t\t\t\t\t\tbounds.height, this, 'setBounds')\n\t\t\t\t\t\t: bounds;\n\t\t\t};\n\t\t},\n\t{\n\t\tbeans: true,\n\t\n\t\t_getBounds: function(getter, matrix, cacheItem) {\n\t\t\tvar children = this._children;\n\t\t\tif (!children || children.length == 0)\n\t\t\t\treturn new Rectangle();\n\t\t\tItem._updateBoundsCache(this, cacheItem);\n\t\t\tvar x1 = Infinity,\n\t\t\t\tx2 = -x1,\n\t\t\t\ty1 = x1,\n\t\t\t\ty2 = x2;\n\t\t\tfor (var i = 0, l = children.length; i < l; i++) {\n\t\t\t\tvar child = children[i];\n\t\t\t\tif (child._visible && !child.isEmpty()) {\n\t\t\t\t\tvar rect = child._getCachedBounds(getter,\n\t\t\t\t\t\t\tmatrix && matrix.chain(child._matrix), cacheItem);\n\t\t\t\t\tx1 = Math.min(rect.x, x1);\n\t\t\t\t\ty1 = Math.min(rect.y, y1);\n\t\t\t\t\tx2 = Math.max(rect.x + rect.width, x2);\n\t\t\t\t\ty2 = Math.max(rect.y + rect.height, y2);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn isFinite(x1)\n\t\t\t\t\t? new Rectangle(x1, y1, x2 - x1, y2 - y1)\n\t\t\t\t\t: new Rectangle();\n\t\t},\n\t\n\t\tsetBounds: function() {\n\t\t\tvar rect = Rectangle.read(arguments),\n\t\t\t\tbounds = this.getBounds(),\n\t\t\t\tmatrix = new Matrix(),\n\t\t\t\tcenter = rect.getCenter();\n\t\t\tmatrix.translate(center);\n\t\t\tif (rect.width != bounds.width || rect.height != bounds.height) {\n\t\t\t\tmatrix.scale(\n\t\t\t\t\t\tbounds.width != 0 ? rect.width / bounds.width : 1,\n\t\t\t\t\t\tbounds.height != 0 ? rect.height / bounds.height : 1);\n\t\t\t}\n\t\t\tcenter = bounds.getCenter();\n\t\t\tmatrix.translate(-center.x, -center.y);\n\t\t\tthis.transform(matrix);\n\t\t},\n\t\n\t\t_getCachedBounds: function(getter, matrix, cacheItem, internalGetter) {\n\t\t\tmatrix = matrix && matrix.orNullIfIdentity();\n\t\t\tvar _matrix = internalGetter ? null : this._matrix.orNullIfIdentity(),\n\t\t\t\tcache = (!matrix || matrix.equals(_matrix)) && getter;\n\t\t\tItem._updateBoundsCache(this._parent || this._parentSymbol, cacheItem);\n\t\t\tif (cache && this._bounds && this._bounds[cache])\n\t\t\t\treturn this._bounds[cache].clone();\n\t\t\tvar bounds = this._getBounds(internalGetter || getter,\n\t\t\t\t\tmatrix || _matrix, cacheItem);\n\t\t\tif (cache) {\n\t\t\t\tif (!this._bounds)\n\t\t\t\t\tthis._bounds = {};\n\t\t\t\tvar cached = this._bounds[cache] = bounds.clone();\n\t\t\t\tcached._internal = !!internalGetter;\n\t\t\t}\n\t\t\treturn bounds;\n\t\t},\n\t\n\t\tstatics: {\n\t\t\t_updateBoundsCache: function(parent, item) {\n\t\t\t\tif (parent) {\n\t\t\t\t\tvar id = item._id,\n\t\t\t\t\t\tref = parent._boundsCache = parent._boundsCache || {\n\t\t\t\t\t\t\tids: {},\n\t\t\t\t\t\t\tlist: []\n\t\t\t\t\t\t};\n\t\t\t\t\tif (!ref.ids[id]) {\n\t\t\t\t\t\tref.list.push(item);\n\t\t\t\t\t\tref.ids[id] = item;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\n\t\t\t_clearBoundsCache: function(item) {\n\t\t\t\tvar cache = item._boundsCache;\n\t\t\t\tif (cache) {\n\t\t\t\t\titem._bounds = item._position = item._boundsCache = undefined;\n\t\t\t\t\tfor (var i = 0, list = cache.list, l = list.length; i < l; i++){\n\t\t\t\t\t\tvar other = list[i];\n\t\t\t\t\t\tif (other !== item) {\n\t\t\t\t\t\t\tother._bounds = other._position = undefined;\n\t\t\t\t\t\t\tif (other._boundsCache)\n\t\t\t\t\t\t\t\tItem._clearBoundsCache(other);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\n\t}), {\n\t\tbeans: true,\n\t\n\t\t_decompose: function() {\n\t\t\treturn this._decomposed = this._matrix.decompose();\n\t\t},\n\t\n\t\tgetRotation: function() {\n\t\t\tvar decomposed = this._decomposed || this._decompose();\n\t\t\treturn decomposed && decomposed.rotation;\n\t\t},\n\t\n\t\tsetRotation: function(rotation) {\n\t\t\tvar current = this.getRotation();\n\t\t\tif (current != null && rotation != null) {\n\t\t\t\tvar decomposed = this._decomposed;\n\t\t\t\tthis.rotate(rotation - current);\n\t\t\t\tdecomposed.rotation = rotation;\n\t\t\t\tthis._decomposed = decomposed;\n\t\t\t}\n\t\t},\n\t\n\t\tgetScaling: function(_dontLink) {\n\t\t\tvar decomposed = this._decomposed || this._decompose(),\n\t\t\t\tscaling = decomposed && decomposed.scaling,\n\t\t\t\tctor = _dontLink ? Point : LinkedPoint;\n\t\t\treturn scaling && new ctor(scaling.x, scaling.y, this, 'setScaling');\n\t\t},\n\t\n\t\tsetScaling: function() {\n\t\t\tvar current = this.getScaling();\n\t\t\tif (current) {\n\t\t\t\tvar scaling = Point.read(arguments, 0, { clone: true }),\n\t\t\t\t\tdecomposed = this._decomposed;\n\t\t\t\tthis.scale(scaling.x / current.x, scaling.y / current.y);\n\t\t\t\tdecomposed.scaling = scaling;\n\t\t\t\tthis._decomposed = decomposed;\n\t\t\t}\n\t\t},\n\t\n\t\tgetMatrix: function() {\n\t\t\treturn this._matrix;\n\t\t},\n\t\n\t\tsetMatrix: function() {\n\t\t\tvar matrix = this._matrix;\n\t\t\tmatrix.initialize.apply(matrix, arguments);\n\t\t\tif (this._applyMatrix) {\n\t\t\t\tthis.transform(null, true);\n\t\t\t} else {\n\t\t\t\tthis._changed(9);\n\t\t\t}\n\t\t},\n\t\n\t\tgetGlobalMatrix: function(_dontClone) {\n\t\t\tvar matrix = this._globalMatrix,\n\t\t\t\tupdateVersion = this._project._updateVersion;\n\t\t\tif (matrix && matrix._updateVersion !== updateVersion)\n\t\t\t\tmatrix = null;\n\t\t\tif (!matrix) {\n\t\t\t\tmatrix = this._globalMatrix = this._matrix.clone();\n\t\t\t\tvar parent = this._parent;\n\t\t\t\tif (parent)\n\t\t\t\t\tmatrix.preConcatenate(parent.getGlobalMatrix(true));\n\t\t\t\tmatrix._updateVersion = updateVersion;\n\t\t\t}\n\t\t\treturn _dontClone ? matrix : matrix.clone();\n\t\t},\n\t\n\t\tgetApplyMatrix: function() {\n\t\t\treturn this._applyMatrix;\n\t\t},\n\t\n\t\tsetApplyMatrix: function(apply) {\n\t\t\tif (this._applyMatrix = this._canApplyMatrix && !!apply)\n\t\t\t\tthis.transform(null, true);\n\t\t},\n\t\n\t\tgetTransformContent: '#getApplyMatrix',\n\t\tsetTransformContent: '#setApplyMatrix',\n\t}, {\n\t\tgetProject: function() {\n\t\t\treturn this._project;\n\t\t},\n\t\n\t\t_setProject: function(project, installEvents) {\n\t\t\tif (this._project !== project) {\n\t\t\t\tif (this._project)\n\t\t\t\t\tthis._installEvents(false);\n\t\t\t\tthis._project = project;\n\t\t\t\tvar children = this._children;\n\t\t\t\tfor (var i = 0, l = children && children.length; i < l; i++)\n\t\t\t\t\tchildren[i]._setProject(project);\n\t\t\t\tinstallEvents = true;\n\t\t\t}\n\t\t\tif (installEvents)\n\t\t\t\tthis._installEvents(true);\n\t\t},\n\t\n\t\tgetView: function() {\n\t\t\treturn this._project.getView();\n\t\t},\n\t\n\t\t_installEvents: function _installEvents(install) {\n\t\t\t_installEvents.base.call(this, install);\n\t\t\tvar children = this._children;\n\t\t\tfor (var i = 0, l = children && children.length; i < l; i++)\n\t\t\t\tchildren[i]._installEvents(install);\n\t\t},\n\t\n\t\tgetLayer: function() {\n\t\t\tvar parent = this;\n\t\t\twhile (parent = parent._parent) {\n\t\t\t\tif (parent instanceof Layer)\n\t\t\t\t\treturn parent;\n\t\t\t}\n\t\t\treturn null;\n\t\t},\n\t\n\t\tgetParent: function() {\n\t\t\treturn this._parent;\n\t\t},\n\t\n\t\tsetParent: function(item) {\n\t\t\treturn item.addChild(this);\n\t\t},\n\t\n\t\tgetChildren: function() {\n\t\t\treturn this._children;\n\t\t},\n\t\n\t\tsetChildren: function(items) {\n\t\t\tthis.removeChildren();\n\t\t\tthis.addChildren(items);\n\t\t},\n\t\n\t\tgetFirstChild: function() {\n\t\t\treturn this._children && this._children[0] || null;\n\t\t},\n\t\n\t\tgetLastChild: function() {\n\t\t\treturn this._children && this._children[this._children.length - 1]\n\t\t\t\t\t|| null;\n\t\t},\n\t\n\t\tgetNextSibling: function() {\n\t\t\treturn this._parent && this._parent._children[this._index + 1] || null;\n\t\t},\n\t\n\t\tgetPreviousSibling: function() {\n\t\t\treturn this._parent && this._parent._children[this._index - 1] || null;\n\t\t},\n\t\n\t\tgetIndex: function() {\n\t\t\treturn this._index;\n\t\t},\n\t\n\t\tequals: function(item) {\n\t\t\treturn item === this || item && this._class === item._class\n\t\t\t\t\t&& this._style.equals(item._style)\n\t\t\t\t\t&& this._matrix.equals(item._matrix)\n\t\t\t\t\t&& this._locked === item._locked\n\t\t\t\t\t&& this._visible === item._visible\n\t\t\t\t\t&& this._blendMode === item._blendMode\n\t\t\t\t\t&& this._opacity === item._opacity\n\t\t\t\t\t&& this._clipMask === item._clipMask\n\t\t\t\t\t&& this._guide === item._guide\n\t\t\t\t\t&& this._equals(item)\n\t\t\t\t\t|| false;\n\t\t},\n\t\n\t\t_equals: function(item) {\n\t\t\treturn Base.equals(this._children, item._children);\n\t\t},\n\t\n\t\tclone: function(insert) {\n\t\t\treturn this._clone(new this.constructor(Item.NO_INSERT), insert);\n\t\t},\n\t\n\t\t_clone: function(copy, insert, includeMatrix) {\n\t\t\tvar keys = ['_locked', '_visible', '_blendMode', '_opacity',\n\t\t\t\t\t'_clipMask', '_guide'],\n\t\t\t\tchildren = this._children;\n\t\t\tcopy.setStyle(this._style);\n\t\t\tfor (var i = 0, l = children && children.length; i < l; i++) {\n\t\t\t\tcopy.addChild(children[i].clone(false), true);\n\t\t\t}\n\t\t\tfor (var i = 0, l = keys.length; i < l; i++) {\n\t\t\t\tvar key = keys[i];\n\t\t\t\tif (this.hasOwnProperty(key))\n\t\t\t\t\tcopy[key] = this[key];\n\t\t\t}\n\t\t\tif (includeMatrix !== false)\n\t\t\t\tcopy._matrix.initialize(this._matrix);\n\t\t\tcopy.setApplyMatrix(this._applyMatrix);\n\t\t\tcopy.setPivot(this._pivot);\n\t\t\tcopy.setSelected(this._selected);\n\t\t\tcopy._data = this._data ? Base.clone(this._data) : null;\n\t\t\tif (insert || insert === undefined)\n\t\t\t\tcopy.insertAbove(this);\n\t\t\tif (this._name)\n\t\t\t\tcopy.setName(this._name, true);\n\t\t\treturn copy;\n\t\t},\n\t\n\t\tcopyTo: function(itemOrProject) {\n\t\t\treturn itemOrProject.addChild(this.clone(false));\n\t\t},\n\t\n\t\trasterize: function(resolution) {\n\t\t\tvar bounds = this.getStrokeBounds(),\n\t\t\t\tscale = (resolution || this.getView().getResolution()) / 72,\n\t\t\t\ttopLeft = bounds.getTopLeft().floor(),\n\t\t\t\tbottomRight = bounds.getBottomRight().ceil(),\n\t\t\t\tsize = new Size(bottomRight.subtract(topLeft)),\n\t\t\t\tcanvas = CanvasProvider.getCanvas(size.multiply(scale)),\n\t\t\t\tctx = canvas.getContext('2d'),\n\t\t\t\tmatrix = new Matrix().scale(scale).translate(topLeft.negate());\n\t\t\tctx.save();\n\t\t\tmatrix.applyToContext(ctx);\n\t\t\tthis.draw(ctx, new Base({ matrices: [matrix] }));\n\t\t\tctx.restore();\n\t\t\tvar raster = new Raster(Item.NO_INSERT);\n\t\t\traster.setCanvas(canvas);\n\t\t\traster.transform(new Matrix().translate(topLeft.add(size.divide(2)))\n\t\t\t\t\t.scale(1 / scale));\n\t\t\traster.insertAbove(this);\n\t\t\treturn raster;\n\t\t},\n\t\n\t\tcontains: function() {\n\t\t\treturn !!this._contains(\n\t\t\t\t\tthis._matrix._inverseTransform(Point.read(arguments)));\n\t\t},\n\t\n\t\t_contains: function(point) {\n\t\t\tif (this._children) {\n\t\t\t\tfor (var i = this._children.length - 1; i >= 0; i--) {\n\t\t\t\t\tif (this._children[i].contains(point))\n\t\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\treturn point.isInside(this.getInternalBounds());\n\t\t},\n\t\n\t\tisInside: function() {\n\t\t\treturn Rectangle.read(arguments).contains(this.getBounds());\n\t\t},\n\t\n\t\t_asPathItem: function() {\n\t\t\treturn new Path.Rectangle({\n\t\t\t\trectangle: this.getInternalBounds(),\n\t\t\t\tmatrix: this._matrix,\n\t\t\t\tinsert: false,\n\t\t\t});\n\t\t},\n\t\n\t\tintersects: function(item, _matrix) {\n\t\t\tif (!(item instanceof Item))\n\t\t\t\treturn false;\n\t\t\treturn this._asPathItem().getIntersections(item._asPathItem(), null,\n\t\t\t\t\t_matrix || item._matrix, true).length > 0;\n\t\t},\n\t\n\t\thitTest: function() {\n\t\t\treturn this._hitTest(\n\t\t\t\t\tPoint.read(arguments),\n\t\t\t\t\tHitResult.getOptions(Base.read(arguments)));\n\t\t},\n\t\n\t\t_hitTest: function(point, options) {\n\t\t\tif (this._locked || !this._visible || this._guide && !options.guides\n\t\t\t\t\t|| this.isEmpty())\n\t\t\t\treturn null;\n\t\n\t\t\tvar matrix = this._matrix,\n\t\t\t\tparentTotalMatrix = options._totalMatrix,\n\t\t\t\tview = this.getView(),\n\t\t\t\ttotalMatrix = options._totalMatrix = parentTotalMatrix\n\t\t\t\t\t\t? parentTotalMatrix.chain(matrix)\n\t\t\t\t\t\t: this.getGlobalMatrix().preConcatenate(view._matrix),\n\t\t\t\ttolerancePadding = options._tolerancePadding = new Size(\n\t\t\t\t\t\t\tPath._getPenPadding(1, totalMatrix.inverted())\n\t\t\t\t\t\t).multiply(\n\t\t\t\t\t\t\tMath.max(options.tolerance, 1e-6)\n\t\t\t\t\t\t);\n\t\t\tpoint = matrix._inverseTransform(point);\n\t\n\t\t\tif (!this._children && !this.getInternalRoughBounds()\n\t\t\t\t\t.expand(tolerancePadding.multiply(2))._containsPoint(point))\n\t\t\t\treturn null;\n\t\t\tvar checkSelf = !(options.guides && !this._guide\n\t\t\t\t\t|| options.selected && !this._selected\n\t\t\t\t\t|| options.type && options.type !== Base.hyphenate(this._class)\n\t\t\t\t\t|| options.class && !(this instanceof options.class)),\n\t\t\t\tthat = this,\n\t\t\t\tres;\n\t\n\t\t\tfunction checkBounds(type, part) {\n\t\t\t\tvar pt = bounds['get' + part]();\n\t\t\t\tif (point.subtract(pt).divide(tolerancePadding).length <= 1)\n\t\t\t\t\treturn new HitResult(type, that,\n\t\t\t\t\t\t\t{ name: Base.hyphenate(part), point: pt });\n\t\t\t}\n\t\n\t\t\tif (checkSelf && (options.center || options.bounds) && this._parent) {\n\t\t\t\tvar bounds = this.getInternalBounds();\n\t\t\t\tif (options.center)\n\t\t\t\t\tres = checkBounds('center', 'Center');\n\t\t\t\tif (!res && options.bounds) {\n\t\t\t\t\tvar points = [\n\t\t\t\t\t\t'TopLeft', 'TopRight', 'BottomLeft', 'BottomRight',\n\t\t\t\t\t\t'LeftCenter', 'TopCenter', 'RightCenter', 'BottomCenter'\n\t\t\t\t\t];\n\t\t\t\t\tfor (var i = 0; i < 8 && !res; i++)\n\t\t\t\t\t\tres = checkBounds('bounds', points[i]);\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\tvar children = !res && this._children;\n\t\t\tif (children) {\n\t\t\t\tvar opts = this._getChildHitTestOptions(options);\n\t\t\t\tfor (var i = children.length - 1; i >= 0 && !res; i--)\n\t\t\t\t\tres = children[i]._hitTest(point, opts);\n\t\t\t}\n\t\t\tif (!res && checkSelf)\n\t\t\t\tres = this._hitTestSelf(point, options);\n\t\t\tif (res && res.point)\n\t\t\t\tres.point = matrix.transform(res.point);\n\t\t\toptions._totalMatrix = parentTotalMatrix;\n\t\t\treturn res;\n\t\t},\n\t\n\t\t_getChildHitTestOptions: function(options) {\n\t\t\treturn options;\n\t\t},\n\t\n\t\t_hitTestSelf: function(point, options) {\n\t\t\tif (options.fill && this.hasFill() && this._contains(point))\n\t\t\t\treturn new HitResult('fill', this);\n\t\t},\n\t\n\t\tmatches: function(name, compare) {\n\t\t\tfunction matchObject(obj1, obj2) {\n\t\t\t\tfor (var i in obj1) {\n\t\t\t\t\tif (obj1.hasOwnProperty(i)) {\n\t\t\t\t\t\tvar val1 = obj1[i],\n\t\t\t\t\t\t\tval2 = obj2[i];\n\t\t\t\t\t\tif (Base.isPlainObject(val1) && Base.isPlainObject(val2)) {\n\t\t\t\t\t\t\tif (!matchObject(val1, val2))\n\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t} else if (!Base.equals(val1, val2)) {\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tvar type = typeof name;\n\t\t\tif (type === 'object') {\n\t\t\t\tfor (var key in name) {\n\t\t\t\t\tif (name.hasOwnProperty(key) && !this.matches(key, name[key]))\n\t\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t} else if (type === 'function') {\n\t\t\t\treturn name(this);\n\t\t\t} else {\n\t\t\t\tvar value = /^(empty|editable)$/.test(name)\n\t\t\t\t\t\t? this['is' + Base.capitalize(name)]()\n\t\t\t\t\t\t: name === 'type'\n\t\t\t\t\t\t\t? Base.hyphenate(this._class)\n\t\t\t\t\t\t\t: this[name];\n\t\t\t\tif (/^(constructor|class)$/.test(name)) {\n\t\t\t\t\tif (!(this instanceof compare))\n\t\t\t\t\t\treturn false;\n\t\t\t\t} else if (compare instanceof RegExp) {\n\t\t\t\t\tif (!compare.test(value))\n\t\t\t\t\t\treturn false;\n\t\t\t\t} else if (typeof compare === 'function') {\n\t\t\t\t\tif (!compare(value))\n\t\t\t\t\t\treturn false;\n\t\t\t\t} else if (Base.isPlainObject(compare)) {\n\t\t\t\t\tif (!matchObject(compare, value))\n\t\t\t\t\t\treturn false;\n\t\t\t\t} else if (!Base.equals(value, compare)) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t},\n\t\n\t\tgetItems: function(match) {\n\t\t\treturn Item._getItems(this._children, match, this._matrix);\n\t\t},\n\t\n\t\tgetItem: function(match) {\n\t\t\treturn Item._getItems(this._children, match, this._matrix, null, true)\n\t\t\t\t\t[0] || null;\n\t\t},\n\t\n\t\tstatics: {\n\t\t\t_getItems: function _getItems(children, match, matrix, param,\n\t\t\t\t\tfirstOnly) {\n\t\t\t\tif (!param && typeof match === 'object') {\n\t\t\t\t\tvar overlapping = match.overlapping,\n\t\t\t\t\t\tinside = match.inside,\n\t\t\t\t\t\tbounds = overlapping || inside,\n\t\t\t\t\t\trect = bounds && Rectangle.read([bounds]);\n\t\t\t\t\tparam = {\n\t\t\t\t\t\titems: [],\n\t\t\t\t\t\tinside: !!inside,\n\t\t\t\t\t\toverlapping: !!overlapping,\n\t\t\t\t\t\trect: rect,\n\t\t\t\t\t\tpath: overlapping && new Path.Rectangle({\n\t\t\t\t\t\t\trectangle: rect,\n\t\t\t\t\t\t\tinsert: false\n\t\t\t\t\t\t})\n\t\t\t\t\t};\n\t\t\t\t\tif (bounds)\n\t\t\t\t\t\tmatch = Base.set({}, match,\n\t\t\t\t\t\t\t\t{ inside: true, overlapping: true });\n\t\t\t\t}\n\t\t\t\tvar items = param && param.items,\n\t\t\t\t\trect = param && param.rect;\n\t\t\t\tmatrix = rect && (matrix || new Matrix());\n\t\t\t\tfor (var i = 0, l = children && children.length; i < l; i++) {\n\t\t\t\t\tvar child = children[i],\n\t\t\t\t\t\tchildMatrix = matrix && matrix.chain(child._matrix),\n\t\t\t\t\t\tadd = true;\n\t\t\t\t\tif (rect) {\n\t\t\t\t\t\tvar bounds = child.getBounds(childMatrix);\n\t\t\t\t\t\tif (!rect.intersects(bounds))\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\tif (!(param.inside && rect.contains(bounds))\n\t\t\t\t\t\t\t\t&& !(param.overlapping && (bounds.contains(rect)\n\t\t\t\t\t\t\t\t\t|| param.path.intersects(child, childMatrix))))\n\t\t\t\t\t\t\tadd = false;\n\t\t\t\t\t}\n\t\t\t\t\tif (add && child.matches(match)) {\n\t\t\t\t\t\titems.push(child);\n\t\t\t\t\t\tif (firstOnly)\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t_getItems(child._children, match,\n\t\t\t\t\t\t\tchildMatrix, param,\n\t\t\t\t\t\t\tfirstOnly);\n\t\t\t\t\tif (firstOnly && items.length > 0)\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\treturn items;\n\t\t\t}\n\t\t}\n\t}, {\n\t\n\t\timportJSON: function(json) {\n\t\t\tvar res = Base.importJSON(json, this);\n\t\t\treturn res !== this\n\t\t\t\t\t? this.addChild(res)\n\t\t\t\t\t: res;\n\t\t},\n\t\n\t\taddChild: function(item, _preserve) {\n\t\t\treturn this.insertChild(undefined, item, _preserve);\n\t\t},\n\t\n\t\tinsertChild: function(index, item, _preserve) {\n\t\t\tvar res = item ? this.insertChildren(index, [item], _preserve) : null;\n\t\t\treturn res && res[0];\n\t\t},\n\t\n\t\taddChildren: function(items, _preserve) {\n\t\t\treturn this.insertChildren(this._children.length, items, _preserve);\n\t\t},\n\t\n\t\tinsertChildren: function(index, items, _preserve, _proto) {\n\t\t\tvar children = this._children;\n\t\t\tif (children && items && items.length > 0) {\n\t\t\t\titems = Array.prototype.slice.apply(items);\n\t\t\t\tfor (var i = items.length - 1; i >= 0; i--) {\n\t\t\t\t\tvar item = items[i];\n\t\t\t\t\tif (_proto && !(item instanceof _proto)) {\n\t\t\t\t\t\titems.splice(i, 1);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tvar shift = item._parent === this && item._index < index;\n\t\t\t\t\t\tif (item._remove(false, true) && shift)\n\t\t\t\t\t\t\tindex--;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tBase.splice(children, items, index, 0);\n\t\t\t\tvar project = this._project,\n\t\t\t\t\tnotifySelf = project && project._changes;\n\t\t\t\tfor (var i = 0, l = items.length; i < l; i++) {\n\t\t\t\t\tvar item = items[i];\n\t\t\t\t\titem._parent = this;\n\t\t\t\t\titem._setProject(this._project, true);\n\t\t\t\t\tif (item._name)\n\t\t\t\t\t\titem.setName(item._name);\n\t\t\t\t\tif (notifySelf)\n\t\t\t\t\t\tthis._changed(5);\n\t\t\t\t}\n\t\t\t\tthis._changed(11);\n\t\t\t} else {\n\t\t\t\titems = null;\n\t\t\t}\n\t\t\treturn items;\n\t\t},\n\t\n\t\t_insertSibling: function(index, item, _preserve) {\n\t\t\treturn this._parent\n\t\t\t\t\t? this._parent.insertChild(index, item, _preserve)\n\t\t\t\t\t: null;\n\t\t},\n\t\n\t\tinsertAbove: function(item, _preserve) {\n\t\t\treturn item._insertSibling(item._index + 1, this, _preserve);\n\t\t},\n\t\n\t\tinsertBelow: function(item, _preserve) {\n\t\t\treturn item._insertSibling(item._index, this, _preserve);\n\t\t},\n\t\n\t\tsendToBack: function() {\n\t\t\treturn (this._parent || this instanceof Layer && this._project)\n\t\t\t\t\t.insertChild(0, this);\n\t\t},\n\t\n\t\tbringToFront: function() {\n\t\t\treturn (this._parent || this instanceof Layer && this._project)\n\t\t\t\t\t.addChild(this);\n\t\t},\n\t\n\t\tappendTop: '#addChild',\n\t\n\t\tappendBottom: function(item) {\n\t\t\treturn this.insertChild(0, item);\n\t\t},\n\t\n\t\tmoveAbove: '#insertAbove',\n\t\n\t\tmoveBelow: '#insertBelow',\n\t\n\t\treduce: function() {\n\t\t\tif (this._children && this._children.length === 1) {\n\t\t\t\tvar child = this._children[0].reduce();\n\t\t\t\tchild.insertAbove(this);\n\t\t\t\tchild.setStyle(this._style);\n\t\t\t\tthis.remove();\n\t\t\t\treturn child;\n\t\t\t}\n\t\t\treturn this;\n\t\t},\n\t\n\t\t_removeNamed: function() {\n\t\t\tvar parent = this._parent;\n\t\t\tif (parent) {\n\t\t\t\tvar children = parent._children,\n\t\t\t\t\tnamedChildren = parent._namedChildren,\n\t\t\t\t\tname = this._name,\n\t\t\t\t\tnamedArray = namedChildren[name],\n\t\t\t\t\tindex = namedArray ? namedArray.indexOf(this) : -1;\n\t\t\t\tif (index !== -1) {\n\t\t\t\t\tif (children[name] == this)\n\t\t\t\t\t\tdelete children[name];\n\t\t\t\t\tnamedArray.splice(index, 1);\n\t\t\t\t\tif (namedArray.length) {\n\t\t\t\t\t\tchildren[name] = namedArray[namedArray.length - 1];\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdelete namedChildren[name];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\n\t\t_remove: function(notifySelf, notifyParent) {\n\t\t\tvar parent = this._parent;\n\t\t\tif (parent) {\n\t\t\t\tif (this._name)\n\t\t\t\t\tthis._removeNamed();\n\t\t\t\tif (this._index != null)\n\t\t\t\t\tBase.splice(parent._children, null, this._index, 1);\n\t\t\t\tthis._installEvents(false);\n\t\t\t\tif (notifySelf) {\n\t\t\t\t\tvar project = this._project;\n\t\t\t\t\tif (project && project._changes)\n\t\t\t\t\t\tthis._changed(5);\n\t\t\t\t}\n\t\t\t\tif (notifyParent)\n\t\t\t\t\tparent._changed(11);\n\t\t\t\tthis._parent = null;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\treturn false;\n\t\t},\n\t\n\t\tremove: function() {\n\t\t\treturn this._remove(true, true);\n\t\t},\n\t\n\t\treplaceWith: function(item) {\n\t\t\tvar ok = item && item.insertBelow(this);\n\t\t\tif (ok)\n\t\t\t\tthis.remove();\n\t\t\treturn ok;\n\t\t},\n\t\n\t\tremoveChildren: function(from, to) {\n\t\t\tif (!this._children)\n\t\t\t\treturn null;\n\t\t\tfrom = from || 0;\n\t\t\tto = Base.pick(to, this._children.length);\n\t\t\tvar removed = Base.splice(this._children, null, from, to - from);\n\t\t\tfor (var i = removed.length - 1; i >= 0; i--) {\n\t\t\t\tremoved[i]._remove(true, false);\n\t\t\t}\n\t\t\tif (removed.length > 0)\n\t\t\t\tthis._changed(11);\n\t\t\treturn removed;\n\t\t},\n\t\n\t\tclear: '#removeChildren',\n\t\n\t\treverseChildren: function() {\n\t\t\tif (this._children) {\n\t\t\t\tthis._children.reverse();\n\t\t\t\tfor (var i = 0, l = this._children.length; i < l; i++)\n\t\t\t\t\tthis._children[i]._index = i;\n\t\t\t\tthis._changed(11);\n\t\t\t}\n\t\t},\n\t\n\t\tisEmpty: function() {\n\t\t\treturn !this._children || this._children.length === 0;\n\t\t},\n\t\n\t\tisEditable: function() {\n\t\t\tvar item = this;\n\t\t\twhile (item) {\n\t\t\t\tif (!item._visible || item._locked)\n\t\t\t\t\treturn false;\n\t\t\t\titem = item._parent;\n\t\t\t}\n\t\t\treturn true;\n\t\t},\n\t\n\t\thasFill: function() {\n\t\t\treturn this.getStyle().hasFill();\n\t\t},\n\t\n\t\thasStroke: function() {\n\t\t\treturn this.getStyle().hasStroke();\n\t\t},\n\t\n\t\thasShadow: function() {\n\t\t\treturn this.getStyle().hasShadow();\n\t\t},\n\t\n\t\t_getOrder: function(item) {\n\t\t\tfunction getList(item) {\n\t\t\t\tvar list = [];\n\t\t\t\tdo {\n\t\t\t\t\tlist.unshift(item);\n\t\t\t\t} while (item = item._parent);\n\t\t\t\treturn list;\n\t\t\t}\n\t\t\tvar list1 = getList(this),\n\t\t\t\tlist2 = getList(item);\n\t\t\tfor (var i = 0, l = Math.min(list1.length, list2.length); i < l; i++) {\n\t\t\t\tif (list1[i] != list2[i]) {\n\t\t\t\t\treturn list1[i]._index < list2[i]._index ? 1 : -1;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn 0;\n\t\t},\n\t\n\t\thasChildren: function() {\n\t\t\treturn this._children && this._children.length > 0;\n\t\t},\n\t\n\t\tisInserted: function() {\n\t\t\treturn this._parent ? this._parent.isInserted() : false;\n\t\t},\n\t\n\t\tisAbove: function(item) {\n\t\t\treturn this._getOrder(item) === -1;\n\t\t},\n\t\n\t\tisBelow: function(item) {\n\t\t\treturn this._getOrder(item) === 1;\n\t\t},\n\t\n\t\tisParent: function(item) {\n\t\t\treturn this._parent === item;\n\t\t},\n\t\n\t\tisChild: function(item) {\n\t\t\treturn item && item._parent === this;\n\t\t},\n\t\n\t\tisDescendant: function(item) {\n\t\t\tvar parent = this;\n\t\t\twhile (parent = parent._parent) {\n\t\t\t\tif (parent == item)\n\t\t\t\t\treturn true;\n\t\t\t}\n\t\t\treturn false;\n\t\t},\n\t\n\t\tisAncestor: function(item) {\n\t\t\treturn item ? item.isDescendant(this) : false;\n\t\t},\n\t\n\t\tisSibling: function(item) {\n\t\t\treturn this._parent === item._parent;\n\t\t},\n\t\n\t\tisGroupedWith: function(item) {\n\t\t\tvar parent = this._parent;\n\t\t\twhile (parent) {\n\t\t\t\tif (parent._parent\n\t\t\t\t\t&& /^(Group|Layer|CompoundPath)$/.test(parent._class)\n\t\t\t\t\t&& item.isDescendant(parent))\n\t\t\t\t\t\treturn true;\n\t\t\t\tparent = parent._parent;\n\t\t\t}\n\t\t\treturn false;\n\t\t},\n\t\n\t\ttranslate: function() {\n\t\t\tvar mx = new Matrix();\n\t\t\treturn this.transform(mx.translate.apply(mx, arguments));\n\t\t},\n\t\n\t\trotate: function(angle ) {\n\t\t\treturn this.transform(new Matrix().rotate(angle,\n\t\t\t\t\tPoint.read(arguments, 1, { readNull: true })\n\t\t\t\t\t\t|| this.getPosition(true)));\n\t\t}\n\t}, Base.each(['scale', 'shear', 'skew'], function(name) {\n\t\tthis[name] = function() {\n\t\t\tvar point = Point.read(arguments),\n\t\t\t\tcenter = Point.read(arguments, 0, { readNull: true });\n\t\t\treturn this.transform(new Matrix()[name](point,\n\t\t\t\t\tcenter || this.getPosition(true)));\n\t\t};\n\t}, {\n\t\n\t}), {\n\t\ttransform: function(matrix, _applyMatrix, _applyRecursively,\n\t\t\t\t_setApplyMatrix) {\n\t\t\tif (matrix && matrix.isIdentity())\n\t\t\t\tmatrix = null;\n\t\t\tvar _matrix = this._matrix,\n\t\t\t\tapplyMatrix = (_applyMatrix || this._applyMatrix)\n\t\t\t\t\t\t&& ((!_matrix.isIdentity() || matrix)\n\t\t\t\t\t\t\t|| _applyMatrix && _applyRecursively && this._children);\n\t\t\tif (!matrix && !applyMatrix)\n\t\t\t\treturn this;\n\t\t\tif (matrix)\n\t\t\t\t_matrix.preConcatenate(matrix);\n\t\t\tif (applyMatrix = applyMatrix && this._transformContent(_matrix,\n\t\t\t\t\t\t_applyRecursively, _setApplyMatrix)) {\n\t\t\t\tvar pivot = this._pivot,\n\t\t\t\t\tstyle = this._style,\n\t\t\t\t\tfillColor = style.getFillColor(true),\n\t\t\t\t\tstrokeColor = style.getStrokeColor(true);\n\t\t\t\tif (pivot)\n\t\t\t\t\t_matrix._transformPoint(pivot, pivot, true);\n\t\t\t\tif (fillColor)\n\t\t\t\t\tfillColor.transform(_matrix);\n\t\t\t\tif (strokeColor)\n\t\t\t\t\tstrokeColor.transform(_matrix);\n\t\t\t\t_matrix.reset(true);\n\t\t\t\tif (_setApplyMatrix && this._canApplyMatrix)\n\t\t\t\t\tthis._applyMatrix = true;\n\t\t\t}\n\t\t\tvar bounds = this._bounds,\n\t\t\t\tposition = this._position;\n\t\t\tthis._changed(9);\n\t\t\tvar decomp = bounds && matrix && matrix.decompose();\n\t\t\tif (decomp && !decomp.shearing && decomp.rotation % 90 === 0) {\n\t\t\t\tfor (var key in bounds) {\n\t\t\t\t\tvar rect = bounds[key];\n\t\t\t\t\tif (applyMatrix || !rect._internal)\n\t\t\t\t\t\tmatrix._transformBounds(rect, rect);\n\t\t\t\t}\n\t\t\t\tvar getter = this._boundsGetter,\n\t\t\t\t\trect = bounds[getter && getter.getBounds || getter || 'getBounds'];\n\t\t\t\tif (rect)\n\t\t\t\t\tthis._position = rect.getCenter(true);\n\t\t\t\tthis._bounds = bounds;\n\t\t\t} else if (matrix && position) {\n\t\t\t\tthis._position = matrix._transformPoint(position, position);\n\t\t\t}\n\t\t\treturn this;\n\t\t},\n\t\n\t\t_transformContent: function(matrix, applyRecursively, setApplyMatrix) {\n\t\t\tvar children = this._children;\n\t\t\tif (children) {\n\t\t\t\tfor (var i = 0, l = children.length; i < l; i++)\n\t\t\t\t\tchildren[i].transform(matrix, true, applyRecursively,\n\t\t\t\t\t\t\tsetApplyMatrix);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t},\n\t\n\t\tglobalToLocal: function() {\n\t\t\treturn this.getGlobalMatrix(true)._inverseTransform(\n\t\t\t\t\tPoint.read(arguments));\n\t\t},\n\t\n\t\tlocalToGlobal: function() {\n\t\t\treturn this.getGlobalMatrix(true)._transformPoint(\n\t\t\t\t\tPoint.read(arguments));\n\t\t},\n\t\n\t\tparentToLocal: function() {\n\t\t\treturn this._matrix._inverseTransform(Point.read(arguments));\n\t\t},\n\t\n\t\tlocalToParent: function() {\n\t\t\treturn this._matrix._transformPoint(Point.read(arguments));\n\t\t},\n\t\n\t\tfitBounds: function(rectangle, fill) {\n\t\t\trectangle = Rectangle.read(arguments);\n\t\t\tvar bounds = this.getBounds(),\n\t\t\t\titemRatio = bounds.height / bounds.width,\n\t\t\t\trectRatio = rectangle.height / rectangle.width,\n\t\t\t\tscale = (fill ? itemRatio > rectRatio : itemRatio < rectRatio)\n\t\t\t\t\t\t? rectangle.width / bounds.width\n\t\t\t\t\t\t: rectangle.height / bounds.height,\n\t\t\t\tnewBounds = new Rectangle(new Point(),\n\t\t\t\t\t\tnew Size(bounds.width * scale, bounds.height * scale));\n\t\t\tnewBounds.setCenter(rectangle.getCenter());\n\t\t\tthis.setBounds(newBounds);\n\t\t},\n\t\n\t\t_setStyles: function(ctx) {\n\t\t\tvar style = this._style,\n\t\t\t\tfillColor = style.getFillColor(),\n\t\t\t\tstrokeColor = style.getStrokeColor(),\n\t\t\t\tshadowColor = style.getShadowColor();\n\t\t\tif (fillColor)\n\t\t\t\tctx.fillStyle = fillColor.toCanvasStyle(ctx);\n\t\t\tif (strokeColor) {\n\t\t\t\tvar strokeWidth = style.getStrokeWidth();\n\t\t\t\tif (strokeWidth > 0) {\n\t\t\t\t\tctx.strokeStyle = strokeColor.toCanvasStyle(ctx);\n\t\t\t\t\tctx.lineWidth = strokeWidth;\n\t\t\t\t\tvar strokeJoin = style.getStrokeJoin(),\n\t\t\t\t\t\tstrokeCap = style.getStrokeCap(),\n\t\t\t\t\t\tmiterLimit = style.getMiterLimit();\n\t\t\t\t\tif (strokeJoin)\n\t\t\t\t\t\tctx.lineJoin = strokeJoin;\n\t\t\t\t\tif (strokeCap)\n\t\t\t\t\t\tctx.lineCap = strokeCap;\n\t\t\t\t\tif (miterLimit)\n\t\t\t\t\t\tctx.miterLimit = miterLimit;\n\t\t\t\t\tif (paper.support.nativeDash) {\n\t\t\t\t\t\tvar dashArray = style.getDashArray(),\n\t\t\t\t\t\t\tdashOffset = style.getDashOffset();\n\t\t\t\t\t\tif (dashArray && dashArray.length) {\n\t\t\t\t\t\t\tif ('setLineDash' in ctx) {\n\t\t\t\t\t\t\t\tctx.setLineDash(dashArray);\n\t\t\t\t\t\t\t\tctx.lineDashOffset = dashOffset;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tctx.mozDash = dashArray;\n\t\t\t\t\t\t\t\tctx.mozDashOffset = dashOffset;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (shadowColor) {\n\t\t\t\tvar shadowBlur = style.getShadowBlur();\n\t\t\t\tif (shadowBlur > 0) {\n\t\t\t\t\tctx.shadowColor = shadowColor.toCanvasStyle(ctx);\n\t\t\t\t\tctx.shadowBlur = shadowBlur;\n\t\t\t\t\tvar offset = this.getShadowOffset();\n\t\t\t\t\tctx.shadowOffsetX = offset.x;\n\t\t\t\t\tctx.shadowOffsetY = offset.y;\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\n\t\tdraw: function(ctx, param, parentStrokeMatrix) {\n\t\t\tvar updateVersion = this._updateVersion = this._project._updateVersion;\n\t\t\tif (!this._visible || this._opacity === 0)\n\t\t\t\treturn;\n\t\t\tvar matrices = param.matrices,\n\t\t\t\tviewMatrix = param.viewMatrix,\n\t\t\t\tmatrix = this._matrix,\n\t\t\t\tglobalMatrix = matrices[matrices.length - 1].chain(matrix);\n\t\t\tif (!globalMatrix.isInvertible())\n\t\t\t\treturn;\n\t\n\t\t\tfunction getViewMatrix(matrix) {\n\t\t\t\treturn viewMatrix ? viewMatrix.chain(matrix) : matrix;\n\t\t\t}\n\t\n\t\t\tmatrices.push(globalMatrix);\n\t\t\tif (param.updateMatrix) {\n\t\t\t\tglobalMatrix._updateVersion = updateVersion;\n\t\t\t\tthis._globalMatrix = globalMatrix;\n\t\t\t}\n\t\n\t\t\tvar blendMode = this._blendMode,\n\t\t\t\topacity = this._opacity,\n\t\t\t\tnormalBlend = blendMode === 'normal',\n\t\t\t\tnativeBlend = BlendMode.nativeModes[blendMode],\n\t\t\t\tdirect = normalBlend && opacity === 1\n\t\t\t\t\t\t|| param.dontStart\n\t\t\t\t\t\t|| param.clip\n\t\t\t\t\t\t|| (nativeBlend || normalBlend && opacity < 1)\n\t\t\t\t\t\t\t&& this._canComposite(),\n\t\t\t\tpixelRatio = param.pixelRatio || 1,\n\t\t\t\tmainCtx, itemOffset, prevOffset;\n\t\t\tif (!direct) {\n\t\t\t\tvar bounds = this.getStrokeBounds(getViewMatrix(globalMatrix));\n\t\t\t\tif (!bounds.width || !bounds.height)\n\t\t\t\t\treturn;\n\t\t\t\tprevOffset = param.offset;\n\t\t\t\titemOffset = param.offset = bounds.getTopLeft().floor();\n\t\t\t\tmainCtx = ctx;\n\t\t\t\tctx = CanvasProvider.getContext(bounds.getSize().ceil().add(1)\n\t\t\t\t\t\t.multiply(pixelRatio));\n\t\t\t\tif (pixelRatio !== 1)\n\t\t\t\t\tctx.scale(pixelRatio, pixelRatio);\n\t\t\t}\n\t\t\tctx.save();\n\t\t\tvar strokeMatrix = parentStrokeMatrix\n\t\t\t\t\t? parentStrokeMatrix.chain(matrix)\n\t\t\t\t\t: !this.getStrokeScaling(true) && getViewMatrix(globalMatrix),\n\t\t\t\tclip = !direct && param.clipItem,\n\t\t\t\ttransform = !strokeMatrix || clip;\n\t\t\tif (direct) {\n\t\t\t\tctx.globalAlpha = opacity;\n\t\t\t\tif (nativeBlend)\n\t\t\t\t\tctx.globalCompositeOperation = blendMode;\n\t\t\t} else if (transform) {\n\t\t\t\tctx.translate(-itemOffset.x, -itemOffset.y);\n\t\t\t}\n\t\t\tif (transform)\n\t\t\t\t(direct ? matrix : getViewMatrix(globalMatrix)).applyToContext(ctx);\n\t\t\tif (clip)\n\t\t\t\tparam.clipItem.draw(ctx, param.extend({ clip: true }));\n\t\t\tif (strokeMatrix) {\n\t\t\t\tctx.setTransform(pixelRatio, 0, 0, pixelRatio, 0, 0);\n\t\t\t\tvar offset = param.offset;\n\t\t\t\tif (offset)\n\t\t\t\t\tctx.translate(-offset.x, -offset.y);\n\t\t\t}\n\t\t\tthis._draw(ctx, param, strokeMatrix);\n\t\t\tctx.restore();\n\t\t\tmatrices.pop();\n\t\t\tif (param.clip && !param.dontFinish)\n\t\t\t\tctx.clip();\n\t\t\tif (!direct) {\n\t\t\t\tBlendMode.process(blendMode, ctx, mainCtx, opacity,\n\t\t\t\t\t\titemOffset.subtract(prevOffset).multiply(pixelRatio));\n\t\t\t\tCanvasProvider.release(ctx);\n\t\t\t\tparam.offset = prevOffset;\n\t\t\t}\n\t\t},\n\t\n\t\t_isUpdated: function(updateVersion) {\n\t\t\tvar parent = this._parent;\n\t\t\tif (parent instanceof CompoundPath)\n\t\t\t\treturn parent._isUpdated(updateVersion);\n\t\t\tvar updated = this._updateVersion === updateVersion;\n\t\t\tif (!updated && parent && parent._visible\n\t\t\t\t\t&& parent._isUpdated(updateVersion)) {\n\t\t\t\tthis._updateVersion = updateVersion;\n\t\t\t\tupdated = true;\n\t\t\t}\n\t\t\treturn updated;\n\t\t},\n\t\n\t\t_drawSelection: function(ctx, matrix, size, selectedItems, updateVersion) {\n\t\t\tif ((this._drawSelected || this._boundsSelected)\n\t\t\t\t\t&& this._isUpdated(updateVersion)) {\n\t\t\t\tvar color = this.getSelectedColor(true)\n\t\t\t\t\t\t|| this.getLayer().getSelectedColor(true),\n\t\t\t\t\tmx = matrix.chain(this.getGlobalMatrix(true));\n\t\t\t\tctx.strokeStyle = ctx.fillStyle = color\n\t\t\t\t\t\t? color.toCanvasStyle(ctx) : '#009dec';\n\t\t\t\tif (this._drawSelected)\n\t\t\t\t\tthis._drawSelected(ctx, mx, selectedItems);\n\t\t\t\tif (this._boundsSelected) {\n\t\t\t\t\tvar half = size / 2,\n\t\t\t\t\t\tcoords = mx._transformCorners(this.getInternalBounds());\n\t\t\t\t\tctx.beginPath();\n\t\t\t\t\tfor (var i = 0; i < 8; i++)\n\t\t\t\t\t\tctx[i === 0 ? 'moveTo' : 'lineTo'](coords[i], coords[++i]);\n\t\t\t\t\tctx.closePath();\n\t\t\t\t\tctx.stroke();\n\t\t\t\t\tfor (var i = 0; i < 8; i++)\n\t\t\t\t\t\tctx.fillRect(coords[i] - half, coords[++i] - half,\n\t\t\t\t\t\t\t\tsize, size);\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\n\t\t_canComposite: function() {\n\t\t\treturn false;\n\t\t}\n\t}, Base.each(['down', 'drag', 'up', 'move'], function(name) {\n\t\tthis['removeOn' + Base.capitalize(name)] = function() {\n\t\t\tvar hash = {};\n\t\t\thash[name] = true;\n\t\t\treturn this.removeOn(hash);\n\t\t};\n\t}, {\n\t\n\t\tremoveOn: function(obj) {\n\t\t\tfor (var name in obj) {\n\t\t\t\tif (obj[name]) {\n\t\t\t\t\tvar key = 'mouse' + name,\n\t\t\t\t\t\tproject = this._project,\n\t\t\t\t\t\tsets = project._removeSets = project._removeSets || {};\n\t\t\t\t\tsets[key] = sets[key] || {};\n\t\t\t\t\tsets[key][this._id] = this;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn this;\n\t\t}\n\t}));\n\t\n\tvar Group = Item.extend({\n\t\t_class: 'Group',\n\t\t_selectChildren: true,\n\t\t_serializeFields: {\n\t\t\tchildren: []\n\t\t},\n\t\n\t\tinitialize: function Group(arg) {\n\t\t\tthis._children = [];\n\t\t\tthis._namedChildren = {};\n\t\t\tif (!this._initialize(arg))\n\t\t\t\tthis.addChildren(Array.isArray(arg) ? arg : arguments);\n\t\t},\n\t\n\t\t_changed: function _changed(flags) {\n\t\t\t_changed.base.call(this, flags);\n\t\t\tif (flags & 1026) {\n\t\t\t\tthis._clipItem = undefined;\n\t\t\t}\n\t\t},\n\t\n\t\t_getClipItem: function() {\n\t\t\tvar clipItem = this._clipItem;\n\t\t\tif (clipItem === undefined) {\n\t\t\t\tclipItem = null;\n\t\t\t\tfor (var i = 0, l = this._children.length; i < l; i++) {\n\t\t\t\t\tvar child = this._children[i];\n\t\t\t\t\tif (child._clipMask) {\n\t\t\t\t\t\tclipItem = child;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tthis._clipItem = clipItem;\n\t\t\t}\n\t\t\treturn clipItem;\n\t\t},\n\t\n\t\tisClipped: function() {\n\t\t\treturn !!this._getClipItem();\n\t\t},\n\t\n\t\tsetClipped: function(clipped) {\n\t\t\tvar child = this.getFirstChild();\n\t\t\tif (child)\n\t\t\t\tchild.setClipMask(clipped);\n\t\t},\n\t\n\t\t_draw: function(ctx, param) {\n\t\t\tvar clip = param.clip,\n\t\t\t\tclipItem = !clip && this._getClipItem(),\n\t\t\t\tdraw = true;\n\t\t\tparam = param.extend({ clipItem: clipItem, clip: false });\n\t\t\tif (clip) {\n\t\t\t\tif (this._currentPath) {\n\t\t\t\t\tctx.currentPath = this._currentPath;\n\t\t\t\t\tdraw = false;\n\t\t\t\t} else {\n\t\t\t\t\tctx.beginPath();\n\t\t\t\t\tparam.dontStart = param.dontFinish = true;\n\t\t\t\t}\n\t\t\t} else if (clipItem) {\n\t\t\t\tclipItem.draw(ctx, param.extend({ clip: true }));\n\t\t\t}\n\t\t\tif (draw) {\n\t\t\t\tfor (var i = 0, l = this._children.length; i < l; i++) {\n\t\t\t\t\tvar item = this._children[i];\n\t\t\t\t\tif (item !== clipItem)\n\t\t\t\t\t\titem.draw(ctx, param);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (clip) {\n\t\t\t\tthis._currentPath = ctx.currentPath;\n\t\t\t}\n\t\t}\n\t});\n\t\n\tvar Layer = Group.extend({\n\t\t_class: 'Layer',\n\t\n\t\tinitialize: function Layer(arg) {\n\t\t\tvar props = Base.isPlainObject(arg)\n\t\t\t\t\t? new Base(arg)\n\t\t\t\t\t: { children: Array.isArray(arg) ? arg : arguments },\n\t\t\t\tinsert = props.insert;\n\t\t\tprops.insert = false;\n\t\t\tGroup.call(this, props);\n\t\t\tif (insert || insert === undefined) {\n\t\t\t\tthis._project.addChild(this);\n\t\t\t\tthis.activate();\n\t\t\t}\n\t\t},\n\t\n\t\t_remove: function _remove(notifySelf, notifyParent) {\n\t\t\tif (this._parent)\n\t\t\t\treturn _remove.base.call(this, notifySelf, notifyParent);\n\t\t\tif (this._index != null) {\n\t\t\t\tvar project = this._project;\n\t\t\t\tif (project._activeLayer === this)\n\t\t\t\t\tproject._activeLayer = this.getNextSibling()\n\t\t\t\t\t\t\t|| this.getPreviousSibling();\n\t\t\t\tBase.splice(project.layers, null, this._index, 1);\n\t\t\t\tthis._installEvents(false);\n\t\t\t\tif (notifySelf && project._changes)\n\t\t\t\t\tthis._changed(5);\n\t\t\t\tif (notifyParent) {\n\t\t\t\t\tproject._needsUpdate = true;\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\treturn false;\n\t\t},\n\t\n\t\tgetNextSibling: function getNextSibling() {\n\t\t\treturn this._parent ? getNextSibling.base.call(this)\n\t\t\t\t\t: this._project.layers[this._index + 1] || null;\n\t\t},\n\t\n\t\tgetPreviousSibling: function getPreviousSibling() {\n\t\t\treturn this._parent ? getPreviousSibling.base.call(this)\n\t\t\t\t\t: this._project.layers[this._index - 1] || null;\n\t\t},\n\t\n\t\tisInserted: function isInserted() {\n\t\t\treturn this._parent ? isInserted.base.call(this) : this._index != null;\n\t\t},\n\t\n\t\tactivate: function() {\n\t\t\tthis._project._activeLayer = this;\n\t\t},\n\t\n\t\t_insertSibling: function _insertSibling(index, item, _preserve) {\n\t\t\treturn !this._parent\n\t\t\t\t\t? this._project.insertChild(index, item, _preserve)\n\t\t\t\t\t: _insertSibling.base.call(this, index, item, _preserve);\n\t\t}\n\t});\n\t\n\tvar Shape = Item.extend({\n\t\t_class: 'Shape',\n\t\t_applyMatrix: false,\n\t\t_canApplyMatrix: false,\n\t\t_boundsSelected: true,\n\t\t_serializeFields: {\n\t\t\ttype: null,\n\t\t\tsize: null,\n\t\t\tradius: null\n\t\t},\n\t\n\t\tinitialize: function Shape(props) {\n\t\t\tthis._initialize(props);\n\t\t},\n\t\n\t\t_equals: function(item) {\n\t\t\treturn this._type === item._type\n\t\t\t\t&& this._size.equals(item._size)\n\t\t\t\t&& Base.equals(this._radius, item._radius);\n\t\t},\n\t\n\t\tclone: function(insert) {\n\t\t\tvar copy = new Shape(Item.NO_INSERT);\n\t\t\tcopy.setType(this._type);\n\t\t\tcopy.setSize(this._size);\n\t\t\tcopy.setRadius(this._radius);\n\t\t\treturn this._clone(copy, insert);\n\t\t},\n\t\n\t\tgetType: function() {\n\t\t\treturn this._type;\n\t\t},\n\t\n\t\tsetType: function(type) {\n\t\t\tthis._type = type;\n\t\t},\n\t\n\t\tgetShape: '#getType',\n\t\tsetShape: '#setType',\n\t\n\t\tgetSize: function() {\n\t\t\tvar size = this._size;\n\t\t\treturn new LinkedSize(size.width, size.height, this, 'setSize');\n\t\t},\n\t\n\t\tsetSize: function() {\n\t\t\tvar size = Size.read(arguments);\n\t\t\tif (!this._size) {\n\t\t\t\tthis._size = size.clone();\n\t\t\t} else if (!this._size.equals(size)) {\n\t\t\t\tvar type = this._type,\n\t\t\t\t\twidth = size.width,\n\t\t\t\t\theight = size.height;\n\t\t\t\tif (type === 'rectangle') {\n\t\t\t\t\tvar radius = Size.min(this._radius, size.divide(2));\n\t\t\t\t\tthis._radius.set(radius.width, radius.height);\n\t\t\t\t} else if (type === 'circle') {\n\t\t\t\t\twidth = height = (width + height) / 2;\n\t\t\t\t\tthis._radius = width / 2;\n\t\t\t\t} else if (type === 'ellipse') {\n\t\t\t\t\tthis._radius.set(width / 2, height / 2);\n\t\t\t\t}\n\t\t\t\tthis._size.set(width, height);\n\t\t\t\tthis._changed(9);\n\t\t\t}\n\t\t},\n\t\n\t\tgetRadius: function() {\n\t\t\tvar rad = this._radius;\n\t\t\treturn this._type === 'circle'\n\t\t\t\t\t? rad\n\t\t\t\t\t: new LinkedSize(rad.width, rad.height, this, 'setRadius');\n\t\t},\n\t\n\t\tsetRadius: function(radius) {\n\t\t\tvar type = this._type;\n\t\t\tif (type === 'circle') {\n\t\t\t\tif (radius === this._radius)\n\t\t\t\t\treturn;\n\t\t\t\tvar size = radius * 2;\n\t\t\t\tthis._radius = radius;\n\t\t\t\tthis._size.set(size, size);\n\t\t\t} else {\n\t\t\t\tradius = Size.read(arguments);\n\t\t\t\tif (!this._radius) {\n\t\t\t\t\tthis._radius = radius.clone();\n\t\t\t\t} else {\n\t\t\t\t\tif (this._radius.equals(radius))\n\t\t\t\t\t\treturn;\n\t\t\t\t\tthis._radius.set(radius.width, radius.height);\n\t\t\t\t\tif (type === 'rectangle') {\n\t\t\t\t\t\tvar size = Size.max(this._size, radius.multiply(2));\n\t\t\t\t\t\tthis._size.set(size.width, size.height);\n\t\t\t\t\t} else if (type === 'ellipse') {\n\t\t\t\t\t\tthis._size.set(radius.width * 2, radius.height * 2);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis._changed(9);\n\t\t},\n\t\n\t\tisEmpty: function() {\n\t\t\treturn false;\n\t\t},\n\t\n\t\ttoPath: function(insert) {\n\t\t\tvar path = this._clone(new Path[Base.capitalize(this._type)]({\n\t\t\t\tcenter: new Point(),\n\t\t\t\tsize: this._size,\n\t\t\t\tradius: this._radius,\n\t\t\t\tinsert: false\n\t\t\t}), insert);\n\t\t\tif (paper.settings.applyMatrix)\n\t\t\t\tpath.setApplyMatrix(true);\n\t\t\treturn path;\n\t\t},\n\t\n\t\t_draw: function(ctx, param, strokeMatrix) {\n\t\t\tvar style = this._style,\n\t\t\t\thasFill = style.hasFill(),\n\t\t\t\thasStroke = style.hasStroke(),\n\t\t\t\tdontPaint = param.dontFinish || param.clip,\n\t\t\t\tuntransformed = !strokeMatrix;\n\t\t\tif (hasFill || hasStroke || dontPaint) {\n\t\t\t\tvar type = this._type,\n\t\t\t\t\tradius = this._radius,\n\t\t\t\t\tisCircle = type === 'circle';\n\t\t\t\tif (!param.dontStart)\n\t\t\t\t\tctx.beginPath();\n\t\t\t\tif (untransformed && isCircle) {\n\t\t\t\t\tctx.arc(0, 0, radius, 0, Math.PI * 2, true);\n\t\t\t\t} else {\n\t\t\t\t\tvar rx = isCircle ? radius : radius.width,\n\t\t\t\t\t\try = isCircle ? radius : radius.height,\n\t\t\t\t\t\tsize = this._size,\n\t\t\t\t\t\twidth = size.width,\n\t\t\t\t\t\theight = size.height;\n\t\t\t\t\tif (untransformed && type === 'rectangle' && rx === 0 && ry === 0) {\n\t\t\t\t\t\tctx.rect(-width / 2, -height / 2, width, height);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tvar x = width / 2,\n\t\t\t\t\t\t\ty = height / 2,\n\t\t\t\t\t\t\tkappa = 1 - 0.5522847498307936,\n\t\t\t\t\t\t\tcx = rx * kappa,\n\t\t\t\t\t\t\tcy = ry * kappa,\n\t\t\t\t\t\t\tc = [\n\t\t\t\t\t\t\t\t-x, -y + ry,\n\t\t\t\t\t\t\t\t-x, -y + cy,\n\t\t\t\t\t\t\t\t-x + cx, -y,\n\t\t\t\t\t\t\t\t-x + rx, -y,\n\t\t\t\t\t\t\t\tx - rx, -y,\n\t\t\t\t\t\t\t\tx - cx, -y,\n\t\t\t\t\t\t\t\tx, -y + cy,\n\t\t\t\t\t\t\t\tx, -y + ry,\n\t\t\t\t\t\t\t\tx, y - ry,\n\t\t\t\t\t\t\t\tx, y - cy,\n\t\t\t\t\t\t\t\tx - cx, y,\n\t\t\t\t\t\t\t\tx - rx, y,\n\t\t\t\t\t\t\t\t-x + rx, y,\n\t\t\t\t\t\t\t\t-x + cx, y,\n\t\t\t\t\t\t\t\t-x, y - cy,\n\t\t\t\t\t\t\t\t-x, y - ry\n\t\t\t\t\t\t\t];\n\t\t\t\t\t\tif (strokeMatrix)\n\t\t\t\t\t\t\tstrokeMatrix.transform(c, c, 32);\n\t\t\t\t\t\tctx.moveTo(c[0], c[1]);\n\t\t\t\t\t\tctx.bezierCurveTo(c[2], c[3], c[4], c[5], c[6], c[7]);\n\t\t\t\t\t\tif (x !== rx)\n\t\t\t\t\t\t\tctx.lineTo(c[8], c[9]);\n\t\t\t\t\t\tctx.bezierCurveTo(c[10], c[11], c[12], c[13], c[14], c[15]);\n\t\t\t\t\t\tif (y !== ry)\n\t\t\t\t\t\t\tctx.lineTo(c[16], c[17]);\n\t\t\t\t\t\tctx.bezierCurveTo(c[18], c[19], c[20], c[21], c[22], c[23]);\n\t\t\t\t\t\tif (x !== rx)\n\t\t\t\t\t\t\tctx.lineTo(c[24], c[25]);\n\t\t\t\t\t\tctx.bezierCurveTo(c[26], c[27], c[28], c[29], c[30], c[31]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tctx.closePath();\n\t\t\t}\n\t\t\tif (!dontPaint && (hasFill || hasStroke)) {\n\t\t\t\tthis._setStyles(ctx);\n\t\t\t\tif (hasFill) {\n\t\t\t\t\tctx.fill(style.getWindingRule());\n\t\t\t\t\tctx.shadowColor = 'rgba(0,0,0,0)';\n\t\t\t\t}\n\t\t\t\tif (hasStroke)\n\t\t\t\t\tctx.stroke();\n\t\t\t}\n\t\t},\n\t\n\t\t_canComposite: function() {\n\t\t\treturn !(this.hasFill() && this.hasStroke());\n\t\t},\n\t\n\t\t_getBounds: function(getter, matrix) {\n\t\t\tvar rect = new Rectangle(this._size).setCenter(0, 0);\n\t\t\tif (getter !== 'getBounds' && this.hasStroke())\n\t\t\t\trect = rect.expand(this.getStrokeWidth());\n\t\t\treturn matrix ? matrix._transformBounds(rect) : rect;\n\t\t}\n\t},\n\tnew function() {\n\t\tfunction getCornerCenter(that, point, expand) {\n\t\t\tvar radius = that._radius;\n\t\t\tif (!radius.isZero()) {\n\t\t\t\tvar halfSize = that._size.divide(2);\n\t\t\t\tfor (var i = 0; i < 4; i++) {\n\t\t\t\t\tvar dir = new Point(i & 1 ? 1 : -1, i > 1 ? 1 : -1),\n\t\t\t\t\t\tcorner = dir.multiply(halfSize),\n\t\t\t\t\t\tcenter = corner.subtract(dir.multiply(radius)),\n\t\t\t\t\t\trect = new Rectangle(corner, center);\n\t\t\t\t\tif ((expand ? rect.expand(expand) : rect).contains(point))\n\t\t\t\t\t\treturn center;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\n\t\tfunction getEllipseRadius(point, radius) {\n\t\t\tvar angle = point.getAngleInRadians(),\n\t\t\t\twidth = radius.width * 2,\n\t\t\t\theight = radius.height * 2,\n\t\t\t\tx = width * Math.sin(angle),\n\t\t\t\ty = height * Math.cos(angle);\n\t\t\treturn width * height / (2 * Math.sqrt(x * x + y * y));\n\t\t}\n\t\n\t\treturn {\n\t\t\t_contains: function _contains(point) {\n\t\t\t\tif (this._type === 'rectangle') {\n\t\t\t\t\tvar center = getCornerCenter(this, point);\n\t\t\t\t\treturn center\n\t\t\t\t\t\t\t? point.subtract(center).divide(this._radius)\n\t\t\t\t\t\t\t\t.getLength() <= 1\n\t\t\t\t\t\t\t: _contains.base.call(this, point);\n\t\t\t\t} else {\n\t\t\t\t\treturn point.divide(this.size).getLength() <= 0.5;\n\t\t\t\t}\n\t\t\t},\n\t\n\t\t\t_hitTestSelf: function _hitTestSelf(point, options) {\n\t\t\t\tvar hit = false;\n\t\t\t\tif (this.hasStroke()) {\n\t\t\t\t\tvar type = this._type,\n\t\t\t\t\t\tradius = this._radius,\n\t\t\t\t\t\tstrokeWidth = this.getStrokeWidth() + 2 * options.tolerance;\n\t\t\t\t\tif (type === 'rectangle') {\n\t\t\t\t\t\tvar center = getCornerCenter(this, point, strokeWidth);\n\t\t\t\t\t\tif (center) {\n\t\t\t\t\t\t\tvar pt = point.subtract(center);\n\t\t\t\t\t\t\thit = 2 * Math.abs(pt.getLength()\n\t\t\t\t\t\t\t\t\t- getEllipseRadius(pt, radius)) <= strokeWidth;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tvar rect = new Rectangle(this._size).setCenter(0, 0),\n\t\t\t\t\t\t\t\touter = rect.expand(strokeWidth),\n\t\t\t\t\t\t\t\tinner = rect.expand(-strokeWidth);\n\t\t\t\t\t\t\thit = outer._containsPoint(point)\n\t\t\t\t\t\t\t\t\t&& !inner._containsPoint(point);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (type === 'ellipse')\n\t\t\t\t\t\t\tradius = getEllipseRadius(point, radius);\n\t\t\t\t\t\thit = 2 * Math.abs(point.getLength() - radius)\n\t\t\t\t\t\t\t\t<= strokeWidth;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn hit\n\t\t\t\t\t\t? new HitResult('stroke', this)\n\t\t\t\t\t\t: _hitTestSelf.base.apply(this, arguments);\n\t\t\t}\n\t\t};\n\t}, {\n\t\n\tstatics: new function() {\n\t\tfunction createShape(type, point, size, radius, args) {\n\t\t\tvar item = new Shape(Base.getNamed(args));\n\t\t\titem._type = type;\n\t\t\titem._size = size;\n\t\t\titem._radius = radius;\n\t\t\treturn item.translate(point);\n\t\t}\n\t\n\t\treturn {\n\t\t\tCircle: function() {\n\t\t\t\tvar center = Point.readNamed(arguments, 'center'),\n\t\t\t\t\tradius = Base.readNamed(arguments, 'radius');\n\t\t\t\treturn createShape('circle', center, new Size(radius * 2), radius,\n\t\t\t\t\t\targuments);\n\t\t\t},\n\t\n\t\t\tRectangle: function() {\n\t\t\t\tvar rect = Rectangle.readNamed(arguments, 'rectangle'),\n\t\t\t\t\tradius = Size.min(Size.readNamed(arguments, 'radius'),\n\t\t\t\t\t\t\trect.getSize(true).divide(2));\n\t\t\t\treturn createShape('rectangle', rect.getCenter(true),\n\t\t\t\t\t\trect.getSize(true), radius, arguments);\n\t\t\t},\n\t\n\t\t\tEllipse: function() {\n\t\t\t\tvar ellipse = Shape._readEllipse(arguments),\n\t\t\t\t\tradius = ellipse.radius;\n\t\t\t\treturn createShape('ellipse', ellipse.center, radius.multiply(2),\n\t\t\t\t\t\tradius, arguments);\n\t\t\t},\n\t\n\t\t\t_readEllipse: function(args) {\n\t\t\t\tvar center,\n\t\t\t\t\tradius;\n\t\t\t\tif (Base.hasNamed(args, 'radius')) {\n\t\t\t\t\tcenter = Point.readNamed(args, 'center');\n\t\t\t\t\tradius = Size.readNamed(args, 'radius');\n\t\t\t\t} else {\n\t\t\t\t\tvar rect = Rectangle.readNamed(args, 'rectangle');\n\t\t\t\t\tcenter = rect.getCenter(true);\n\t\t\t\t\tradius = rect.getSize(true).divide(2);\n\t\t\t\t}\n\t\t\t\treturn { center: center, radius: radius };\n\t\t\t}\n\t\t};\n\t}});\n\t\n\tvar Raster = Item.extend({\n\t\t_class: 'Raster',\n\t\t_applyMatrix: false,\n\t\t_canApplyMatrix: false,\n\t\t_boundsGetter: 'getBounds',\n\t\t_boundsSelected: true,\n\t\t_serializeFields: {\n\t\t\tcrossOrigin: null,\n\t\t\tsource: null\n\t\t},\n\t\n\t\tinitialize: function Raster(object, position) {\n\t\t\tif (!this._initialize(object,\n\t\t\t\t\tposition !== undefined && Point.read(arguments, 1))) {\n\t\t\t\tif (typeof object === 'string') {\n\t\t\t\t\tthis.setSource(object);\n\t\t\t\t} else {\n\t\t\t\t\tthis.setImage(object);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!this._size) {\n\t\t\t\tthis._size = new Size();\n\t\t\t\tthis._loaded = false;\n\t\t\t}\n\t\t},\n\t\n\t\t_equals: function(item) {\n\t\t\treturn this.getSource() === item.getSource();\n\t\t},\n\t\n\t\tclone: function(insert) {\n\t\t\tvar copy = new Raster(Item.NO_INSERT),\n\t\t\t\timage = this._image,\n\t\t\t\tcanvas = this._canvas;\n\t\t\tif (image) {\n\t\t\t\tcopy.setImage(image);\n\t\t\t} else if (canvas) {\n\t\t\t\tvar copyCanvas = CanvasProvider.getCanvas(this._size);\n\t\t\t\tcopyCanvas.getContext('2d').drawImage(canvas, 0, 0);\n\t\t\t\tcopy.setImage(copyCanvas);\n\t\t\t}\n\t\t\tcopy._crossOrigin = this._crossOrigin;\n\t\t\treturn this._clone(copy, insert);\n\t\t},\n\t\n\t\tgetSize: function() {\n\t\t\tvar size = this._size;\n\t\t\treturn new LinkedSize(size ? size.width : 0, size ? size.height : 0,\n\t\t\t\t\tthis, 'setSize');\n\t\t},\n\t\n\t\tsetSize: function() {\n\t\t\tvar size = Size.read(arguments);\n\t\t\tif (!size.equals(this._size)) {\n\t\t\t\tif (size.width > 0 && size.height > 0) {\n\t\t\t\t\tvar element = this.getElement();\n\t\t\t\t\tthis.setImage(CanvasProvider.getCanvas(size));\n\t\t\t\t\tif (element)\n\t\t\t\t\t\tthis.getContext(true).drawImage(element, 0, 0,\n\t\t\t\t\t\t\t\tsize.width, size.height);\n\t\t\t\t} else {\n\t\t\t\t\tif (this._canvas)\n\t\t\t\t\t\tCanvasProvider.release(this._canvas);\n\t\t\t\t\tthis._size = size.clone();\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\n\t\tgetWidth: function() {\n\t\t\treturn this._size ? this._size.width : 0;\n\t\t},\n\t\n\t\tsetWidth: function(width) {\n\t\t\tthis.setSize(width, this.getHeight());\n\t\t},\n\t\n\t\tgetHeight: function() {\n\t\t\treturn this._size ? this._size.height : 0;\n\t\t},\n\t\n\t\tsetHeight: function(height) {\n\t\t\tthis.setSize(this.getWidth(), height);\n\t\t},\n\t\n\t\tisEmpty: function() {\n\t\t\tvar size = this._size;\n\t\t\treturn !size || size.width === 0 && size.height === 0;\n\t\t},\n\t\n\t\tgetResolution: function() {\n\t\t\tvar matrix = this._matrix,\n\t\t\t\torig = new Point(0, 0).transform(matrix),\n\t\t\t\tu = new Point(1, 0).transform(matrix).subtract(orig),\n\t\t\t\tv = new Point(0, 1).transform(matrix).subtract(orig);\n\t\t\treturn new Size(\n\t\t\t\t72 / u.getLength(),\n\t\t\t\t72 / v.getLength()\n\t\t\t);\n\t\t},\n\t\n\t\tgetPpi: '#getResolution',\n\t\n\t\tgetImage: function() {\n\t\t\treturn this._image;\n\t\t},\n\t\n\t\tsetImage: function(image) {\n\t\t\tif (this._canvas)\n\t\t\t\tCanvasProvider.release(this._canvas);\n\t\t\tif (image && image.getContext) {\n\t\t\t\tthis._image = null;\n\t\t\t\tthis._canvas = image;\n\t\t\t\tthis._loaded = true;\n\t\t\t} else {\n\t\t\t\tthis._image = image;\n\t\t\t\tthis._canvas = null;\n\t\t\t\tthis._loaded = image && image.complete;\n\t\t\t}\n\t\t\tthis._size = new Size(\n\t\t\t\t\timage ? image.naturalWidth || image.width : 0,\n\t\t\t\t\timage ? image.naturalHeight || image.height : 0);\n\t\t\tthis._context = null;\n\t\t\tthis._changed(521);\n\t\t},\n\t\n\t\tgetCanvas: function() {\n\t\t\tif (!this._canvas) {\n\t\t\t\tvar ctx = CanvasProvider.getContext(this._size);\n\t\t\t\ttry {\n\t\t\t\t\tif (this._image)\n\t\t\t\t\t\tctx.drawImage(this._image, 0, 0);\n\t\t\t\t\tthis._canvas = ctx.canvas;\n\t\t\t\t} catch (e) {\n\t\t\t\t\tCanvasProvider.release(ctx);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn this._canvas;\n\t\t},\n\t\n\t\tsetCanvas: '#setImage',\n\t\n\t\tgetContext: function(modify) {\n\t\t\tif (!this._context)\n\t\t\t\tthis._context = this.getCanvas().getContext('2d');\n\t\t\tif (modify) {\n\t\t\t\tthis._image = null;\n\t\t\t\tthis._changed(513);\n\t\t\t}\n\t\t\treturn this._context;\n\t\t},\n\t\n\t\tsetContext: function(context) {\n\t\t\tthis._context = context;\n\t\t},\n\t\n\t\tgetSource: function() {\n\t\t\treturn this._image && this._image.src || this.toDataURL();\n\t\t},\n\t\n\t\tsetSource: function(src) {\n\t\t\tvar that = this,\n\t\t\t\tcrossOrigin = this._crossOrigin,\n\t\t\t\timage;\n\t\n\t\t\tfunction loaded() {\n\t\t\t\tvar view = that.getView();\n\t\t\t\tif (view) {\n\t\t\t\t\tpaper = view._scope;\n\t\t\t\t\tthat.setImage(image);\n\t\t\t\t\tthat.emit('load');\n\t\t\t\t\tview.update();\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\timage = document.getElementById(src) || new Image();\n\t\t\tif (crossOrigin)\n\t\t\t\timage.crossOrigin = crossOrigin;\n\t\t\tif (image.naturalWidth && image.naturalHeight) {\n\t\t\t\tsetTimeout(loaded, 0);\n\t\t\t} else {\n\t\t\t\tDomEvent.add(image, { load: loaded });\n\t\t\t\tif (!image.src)\n\t\t\t\t\timage.src = src;\n\t\t\t}\n\t\t\tthis.setImage(image);\n\t\t},\n\t\n\t\tgetCrossOrigin: function() {\n\t\t\treturn this._image && this._image.crossOrigin || this._crossOrigin || '';\n\t\t},\n\t\n\t\tsetCrossOrigin: function(crossOrigin) {\n\t\t\tthis._crossOrigin = crossOrigin;\n\t\t\tif (this._image)\n\t\t\t\tthis._image.crossOrigin = crossOrigin;\n\t\t},\n\t\n\t\tgetElement: function() {\n\t\t\treturn this._canvas || this._loaded && this._image;\n\t\t}\n\t}, {\n\t\tbeans: false,\n\t\n\t\tgetSubCanvas: function() {\n\t\t\tvar rect = Rectangle.read(arguments),\n\t\t\t\tctx = CanvasProvider.getContext(rect.getSize());\n\t\t\tctx.drawImage(this.getCanvas(), rect.x, rect.y,\n\t\t\t\t\trect.width, rect.height, 0, 0, rect.width, rect.height);\n\t\t\treturn ctx.canvas;\n\t\t},\n\t\n\t\tgetSubRaster: function() {\n\t\t\tvar rect = Rectangle.read(arguments),\n\t\t\t\traster = new Raster(Item.NO_INSERT);\n\t\t\traster.setImage(this.getSubCanvas(rect));\n\t\t\traster.translate(rect.getCenter().subtract(this.getSize().divide(2)));\n\t\t\traster._matrix.preConcatenate(this._matrix);\n\t\t\traster.insertAbove(this);\n\t\t\treturn raster;\n\t\t},\n\t\n\t\ttoDataURL: function() {\n\t\t\tvar src = this._image && this._image.src;\n\t\t\tif (/^data:/.test(src))\n\t\t\t\treturn src;\n\t\t\tvar canvas = this.getCanvas();\n\t\t\treturn canvas ? canvas.toDataURL.apply(canvas, arguments) : null;\n\t\t},\n\t\n\t\tdrawImage: function(image ) {\n\t\t\tvar point = Point.read(arguments, 1);\n\t\t\tthis.getContext(true).drawImage(image, point.x, point.y);\n\t\t},\n\t\n\t\tgetAverageColor: function(object) {\n\t\t\tvar bounds, path;\n\t\t\tif (!object) {\n\t\t\t\tbounds = this.getBounds();\n\t\t\t} else if (object instanceof PathItem) {\n\t\t\t\tpath = object;\n\t\t\t\tbounds = object.getBounds();\n\t\t\t} else if (object.width) {\n\t\t\t\tbounds = new Rectangle(object);\n\t\t\t} else if (object.x) {\n\t\t\t\tbounds = new Rectangle(object.x - 0.5, object.y - 0.5, 1, 1);\n\t\t\t}\n\t\t\tvar sampleSize = 32,\n\t\t\t\twidth = Math.min(bounds.width, sampleSize),\n\t\t\t\theight = Math.min(bounds.height, sampleSize);\n\t\t\tvar ctx = Raster._sampleContext;\n\t\t\tif (!ctx) {\n\t\t\t\tctx = Raster._sampleContext = CanvasProvider.getContext(\n\t\t\t\t\t\tnew Size(sampleSize));\n\t\t\t} else {\n\t\t\t\tctx.clearRect(0, 0, sampleSize + 1, sampleSize + 1);\n\t\t\t}\n\t\t\tctx.save();\n\t\t\tvar matrix = new Matrix()\n\t\t\t\t\t.scale(width / bounds.width, height / bounds.height)\n\t\t\t\t\t.translate(-bounds.x, -bounds.y);\n\t\t\tmatrix.applyToContext(ctx);\n\t\t\tif (path)\n\t\t\t\tpath.draw(ctx, new Base({ clip: true, matrices: [matrix] }));\n\t\t\tthis._matrix.applyToContext(ctx);\n\t\t\tvar element = this.getElement(),\n\t\t\t\tsize = this._size;\n\t\t\tif (element)\n\t\t\t\tctx.drawImage(element, -size.width / 2, -size.height / 2);\n\t\t\tctx.restore();\n\t\t\tvar pixels = ctx.getImageData(0.5, 0.5, Math.ceil(width),\n\t\t\t\t\tMath.ceil(height)).data,\n\t\t\t\tchannels = [0, 0, 0],\n\t\t\t\ttotal = 0;\n\t\t\tfor (var i = 0, l = pixels.length; i < l; i += 4) {\n\t\t\t\tvar alpha = pixels[i + 3];\n\t\t\t\ttotal += alpha;\n\t\t\t\talpha /= 255;\n\t\t\t\tchannels[0] += pixels[i] * alpha;\n\t\t\t\tchannels[1] += pixels[i + 1] * alpha;\n\t\t\t\tchannels[2] += pixels[i + 2] * alpha;\n\t\t\t}\n\t\t\tfor (var i = 0; i < 3; i++)\n\t\t\t\tchannels[i] /= total;\n\t\t\treturn total ? Color.read(channels) : null;\n\t\t},\n\t\n\t\tgetPixel: function() {\n\t\t\tvar point = Point.read(arguments);\n\t\t\tvar data = this.getContext().getImageData(point.x, point.y, 1, 1).data;\n\t\t\treturn new Color('rgb', [data[0] / 255, data[1] / 255, data[2] / 255],\n\t\t\t\t\tdata[3] / 255);\n\t\t},\n\t\n\t\tsetPixel: function() {\n\t\t\tvar point = Point.read(arguments),\n\t\t\t\tcolor = Color.read(arguments),\n\t\t\t\tcomponents = color._convert('rgb'),\n\t\t\t\talpha = color._alpha,\n\t\t\t\tctx = this.getContext(true),\n\t\t\t\timageData = ctx.createImageData(1, 1),\n\t\t\t\tdata = imageData.data;\n\t\t\tdata[0] = components[0] * 255;\n\t\t\tdata[1] = components[1] * 255;\n\t\t\tdata[2] = components[2] * 255;\n\t\t\tdata[3] = alpha != null ? alpha * 255 : 255;\n\t\t\tctx.putImageData(imageData, point.x, point.y);\n\t\t},\n\t\n\t\tcreateImageData: function() {\n\t\t\tvar size = Size.read(arguments);\n\t\t\treturn this.getContext().createImageData(size.width, size.height);\n\t\t},\n\t\n\t\tgetImageData: function() {\n\t\t\tvar rect = Rectangle.read(arguments);\n\t\t\tif (rect.isEmpty())\n\t\t\t\trect = new Rectangle(this._size);\n\t\t\treturn this.getContext().getImageData(rect.x, rect.y,\n\t\t\t\t\trect.width, rect.height);\n\t\t},\n\t\n\t\tsetImageData: function(data ) {\n\t\t\tvar point = Point.read(arguments, 1);\n\t\t\tthis.getContext(true).putImageData(data, point.x, point.y);\n\t\t},\n\t\n\t\t_getBounds: function(getter, matrix) {\n\t\t\tvar rect = new Rectangle(this._size).setCenter(0, 0);\n\t\t\treturn matrix ? matrix._transformBounds(rect) : rect;\n\t\t},\n\t\n\t\t_hitTestSelf: function(point) {\n\t\t\tif (this._contains(point)) {\n\t\t\t\tvar that = this;\n\t\t\t\treturn new HitResult('pixel', that, {\n\t\t\t\t\toffset: point.add(that._size.divide(2)).round(),\n\t\t\t\t\tcolor: {\n\t\t\t\t\t\tget: function() {\n\t\t\t\t\t\t\treturn that.getPixel(this.offset);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t},\n\t\n\t\t_draw: function(ctx) {\n\t\t\tvar element = this.getElement();\n\t\t\tif (element) {\n\t\t\t\tctx.globalAlpha = this._opacity;\n\t\t\t\tctx.drawImage(element,\n\t\t\t\t\t\t-this._size.width / 2, -this._size.height / 2);\n\t\t\t}\n\t\t},\n\t\n\t\t_canComposite: function() {\n\t\t\treturn true;\n\t\t}\n\t});\n\t\n\tvar PlacedSymbol = Item.extend({\n\t\t_class: 'PlacedSymbol',\n\t\t_applyMatrix: false,\n\t\t_canApplyMatrix: false,\n\t\t_boundsGetter: { getBounds: 'getStrokeBounds' },\n\t\t_boundsSelected: true,\n\t\t_serializeFields: {\n\t\t\tsymbol: null\n\t\t},\n\t\n\t\tinitialize: function PlacedSymbol(arg0, arg1) {\n\t\t\tif (!this._initialize(arg0,\n\t\t\t\t\targ1 !== undefined && Point.read(arguments, 1)))\n\t\t\t\tthis.setSymbol(arg0 instanceof Symbol ? arg0 : new Symbol(arg0));\n\t\t},\n\t\n\t\t_equals: function(item) {\n\t\t\treturn this._symbol === item._symbol;\n\t\t},\n\t\n\t\tgetSymbol: function() {\n\t\t\treturn this._symbol;\n\t\t},\n\t\n\t\tsetSymbol: function(symbol) {\n\t\t\tthis._symbol = symbol;\n\t\t\tthis._changed(9);\n\t\t},\n\t\n\t\tclone: function(insert) {\n\t\t\tvar copy = new PlacedSymbol(Item.NO_INSERT);\n\t\t\tcopy.setSymbol(this._symbol);\n\t\t\treturn this._clone(copy, insert);\n\t\t},\n\t\n\t\tisEmpty: function() {\n\t\t\treturn this._symbol._definition.isEmpty();\n\t\t},\n\t\n\t\t_getBounds: function(getter, matrix, cacheItem) {\n\t\t\tvar definition = this.symbol._definition;\n\t\t\treturn definition._getCachedBounds(getter,\n\t\t\t\t\tmatrix && matrix.chain(definition._matrix), cacheItem);\n\t\t},\n\t\n\t\t_hitTestSelf: function(point, options) {\n\t\t\tvar res = this._symbol._definition._hitTest(point, options);\n\t\t\tif (res)\n\t\t\t\tres.item = this;\n\t\t\treturn res;\n\t\t},\n\t\n\t\t_draw: function(ctx, param) {\n\t\t\tthis.symbol._definition.draw(ctx, param);\n\t\t}\n\t\n\t});\n\t\n\tvar HitResult = Base.extend({\n\t\t_class: 'HitResult',\n\t\n\t\tinitialize: function HitResult(type, item, values) {\n\t\t\tthis.type = type;\n\t\t\tthis.item = item;\n\t\t\tif (values) {\n\t\t\t\tvalues.enumerable = true;\n\t\t\t\tthis.inject(values);\n\t\t\t}\n\t\t},\n\t\n\t\tstatics: {\n\t\t\tgetOptions: function(options) {\n\t\t\t\treturn new Base({\n\t\t\t\t\ttype: null,\n\t\t\t\t\ttolerance: paper.settings.hitTolerance,\n\t\t\t\t\tfill: !options,\n\t\t\t\t\tstroke: !options,\n\t\t\t\t\tsegments: !options,\n\t\t\t\t\thandles: false,\n\t\t\t\t\tends: false,\n\t\t\t\t\tcenter: false,\n\t\t\t\t\tbounds: false,\n\t\t\t\t\tguides: false,\n\t\t\t\t\tselected: false\n\t\t\t\t}, options);\n\t\t\t}\n\t\t}\n\t});\n\t\n\tvar Segment = Base.extend({\n\t\t_class: 'Segment',\n\t\tbeans: true,\n\t\n\t\tinitialize: function Segment(arg0, arg1, arg2, arg3, arg4, arg5) {\n\t\t\tvar count = arguments.length,\n\t\t\t\tpoint, handleIn, handleOut;\n\t\t\tif (count === 0) {\n\t\t\t} else if (count === 1) {\n\t\t\t\tif ('point' in arg0) {\n\t\t\t\t\tpoint = arg0.point;\n\t\t\t\t\thandleIn = arg0.handleIn;\n\t\t\t\t\thandleOut = arg0.handleOut;\n\t\t\t\t} else {\n\t\t\t\t\tpoint = arg0;\n\t\t\t\t}\n\t\t\t} else if (count === 2 && typeof arg0 === 'number') {\n\t\t\t\tpoint = arguments;\n\t\t\t} else if (count <= 3) {\n\t\t\t\tpoint = arg0;\n\t\t\t\thandleIn = arg1;\n\t\t\t\thandleOut = arg2;\n\t\t\t} else {\n\t\t\t\tpoint = arg0 !== undefined ? [ arg0, arg1 ] : null;\n\t\t\t\thandleIn = arg2 !== undefined ? [ arg2, arg3 ] : null;\n\t\t\t\thandleOut = arg4 !== undefined ? [ arg4, arg5 ] : null;\n\t\t\t}\n\t\t\tnew SegmentPoint(point, this, '_point');\n\t\t\tnew SegmentPoint(handleIn, this, '_handleIn');\n\t\t\tnew SegmentPoint(handleOut, this, '_handleOut');\n\t\t},\n\t\n\t\t_serialize: function(options) {\n\t\t\treturn Base.serialize(this.hasHandles()\n\t\t\t\t\t? [this._point, this._handleIn, this._handleOut]\n\t\t\t\t\t: this._point,\n\t\t\t\t\toptions, true);\n\t\t},\n\t\n\t\t_changed: function(point) {\n\t\t\tvar path = this._path;\n\t\t\tif (!path)\n\t\t\t\treturn;\n\t\t\tvar curves = path._curves,\n\t\t\t\tindex = this._index,\n\t\t\t\tcurve;\n\t\t\tif (curves) {\n\t\t\t\tif ((!point || point === this._point || point === this._handleIn)\n\t\t\t\t\t\t&& (curve = index > 0 ? curves[index - 1] : path._closed\n\t\t\t\t\t\t\t? curves[curves.length - 1] : null))\n\t\t\t\t\tcurve._changed();\n\t\t\t\tif ((!point || point === this._point || point === this._handleOut)\n\t\t\t\t\t\t&& (curve = curves[index]))\n\t\t\t\t\tcurve._changed();\n\t\t\t}\n\t\t\tpath._changed(25);\n\t\t},\n\t\n\t\tgetPoint: function() {\n\t\t\treturn this._point;\n\t\t},\n\t\n\t\tsetPoint: function() {\n\t\t\tvar point = Point.read(arguments);\n\t\t\tthis._point.set(point.x, point.y);\n\t\t},\n\t\n\t\tgetHandleIn: function() {\n\t\t\treturn this._handleIn;\n\t\t},\n\t\n\t\tsetHandleIn: function() {\n\t\t\tvar point = Point.read(arguments);\n\t\t\tthis._handleIn.set(point.x, point.y);\n\t\t},\n\t\n\t\tgetHandleOut: function() {\n\t\t\treturn this._handleOut;\n\t\t},\n\t\n\t\tsetHandleOut: function() {\n\t\t\tvar point = Point.read(arguments);\n\t\t\tthis._handleOut.set(point.x, point.y);\n\t\t},\n\t\n\t\thasHandles: function() {\n\t\t\treturn !this._handleIn.isZero() || !this._handleOut.isZero();\n\t\t},\n\t\n\t\tclearHandles: function() {\n\t\t\tthis._handleIn.set(0, 0);\n\t\t\tthis._handleOut.set(0, 0);\n\t\t},\n\t\n\t\t_selectionState: 0,\n\t\n\t\tisSelected: function(_point) {\n\t\t\tvar state = this._selectionState;\n\t\t\treturn !_point ? !!(state & 7)\n\t\t\t\t: _point === this._point ? !!(state & 4)\n\t\t\t\t: _point === this._handleIn ? !!(state & 1)\n\t\t\t\t: _point === this._handleOut ? !!(state & 2)\n\t\t\t\t: false;\n\t\t},\n\t\n\t\tsetSelected: function(selected, _point) {\n\t\t\tvar path = this._path,\n\t\t\t\tselected = !!selected,\n\t\t\t\tstate = this._selectionState,\n\t\t\t\toldState = state,\n\t\t\t\tflag = !_point ? 7\n\t\t\t\t\t\t: _point === this._point ? 4\n\t\t\t\t\t\t: _point === this._handleIn ? 1\n\t\t\t\t\t\t: _point === this._handleOut ? 2\n\t\t\t\t\t\t: 0;\n\t\t\tif (selected) {\n\t\t\t\tstate |= flag;\n\t\t\t} else {\n\t\t\t\tstate &= ~flag;\n\t\t\t}\n\t\t\tthis._selectionState = state;\n\t\t\tif (path && state !== oldState) {\n\t\t\t\tpath._updateSelection(this, oldState, state);\n\t\t\t\tpath._changed(129);\n\t\t\t}\n\t\t},\n\t\n\t\tgetIndex: function() {\n\t\t\treturn this._index !== undefined ? this._index : null;\n\t\t},\n\t\n\t\tgetPath: function() {\n\t\t\treturn this._path || null;\n\t\t},\n\t\n\t\tgetCurve: function() {\n\t\t\tvar path = this._path,\n\t\t\t\tindex = this._index;\n\t\t\tif (path) {\n\t\t\t\tif (index > 0 && !path._closed\n\t\t\t\t\t\t&& index === path._segments.length - 1)\n\t\t\t\t\tindex--;\n\t\t\t\treturn path.getCurves()[index] || null;\n\t\t\t}\n\t\t\treturn null;\n\t\t},\n\t\n\t\tgetLocation: function() {\n\t\t\tvar curve = this.getCurve();\n\t\t\treturn curve\n\t\t\t\t\t? new CurveLocation(curve, this === curve._segment1 ? 0 : 1)\n\t\t\t\t\t: null;\n\t\t},\n\t\n\t\tgetNext: function() {\n\t\t\tvar segments = this._path && this._path._segments;\n\t\t\treturn segments && (segments[this._index + 1]\n\t\t\t\t\t|| this._path._closed && segments[0]) || null;\n\t\t},\n\t\n\t\tgetPrevious: function() {\n\t\t\tvar segments = this._path && this._path._segments;\n\t\t\treturn segments && (segments[this._index - 1]\n\t\t\t\t\t|| this._path._closed && segments[segments.length - 1]) || null;\n\t\t},\n\t\n\t\tisFirst: function() {\n\t\t\treturn this._index === 0;\n\t\t},\n\t\n\t\tisLast: function() {\n\t\t\tvar path = this._path;\n\t\t\treturn path && this._index === path._segments.length - 1 || false;\n\t\t},\n\t\n\t\treverse: function() {\n\t\t\tvar handleIn = this._handleIn,\n\t\t\t\thandleOut = this._handleOut,\n\t\t\t\tinX = handleIn._x,\n\t\t\t\tinY = handleIn._y;\n\t\t\thandleIn.set(handleOut._x, handleOut._y);\n\t\t\thandleOut.set(inX, inY);\n\t\t},\n\t\n\t\treversed: function() {\n\t\t\treturn new Segment(this._point, this._handleOut, this._handleIn);\n\t\t},\n\t\n\t\tremove: function() {\n\t\t\treturn this._path ? !!this._path.removeSegment(this._index) : false;\n\t\t},\n\t\n\t\tclone: function() {\n\t\t\treturn new Segment(this._point, this._handleIn, this._handleOut);\n\t\t},\n\t\n\t\tequals: function(segment) {\n\t\t\treturn segment === this || segment && this._class === segment._class\n\t\t\t\t\t&& this._point.equals(segment._point)\n\t\t\t\t\t&& this._handleIn.equals(segment._handleIn)\n\t\t\t\t\t&& this._handleOut.equals(segment._handleOut)\n\t\t\t\t\t|| false;\n\t\t},\n\t\n\t\ttoString: function() {\n\t\t\tvar parts = [ 'point: ' + this._point ];\n\t\t\tif (!this._handleIn.isZero())\n\t\t\t\tparts.push('handleIn: ' + this._handleIn);\n\t\t\tif (!this._handleOut.isZero())\n\t\t\t\tparts.push('handleOut: ' + this._handleOut);\n\t\t\treturn '{ ' + parts.join(', ') + ' }';\n\t\t},\n\t\n\t\ttransform: function(matrix) {\n\t\t\tthis._transformCoordinates(matrix, new Array(6), true);\n\t\t\tthis._changed();\n\t\t},\n\t\n\t\t_transformCoordinates: function(matrix, coords, change) {\n\t\t\tvar point = this._point,\n\t\t\t\thandleIn = !change || !this._handleIn.isZero()\n\t\t\t\t\t\t? this._handleIn : null,\n\t\t\t\thandleOut = !change || !this._handleOut.isZero()\n\t\t\t\t\t\t? this._handleOut : null,\n\t\t\t\tx = point._x,\n\t\t\t\ty = point._y,\n\t\t\t\ti = 2;\n\t\t\tcoords[0] = x;\n\t\t\tcoords[1] = y;\n\t\t\tif (handleIn) {\n\t\t\t\tcoords[i++] = handleIn._x + x;\n\t\t\t\tcoords[i++] = handleIn._y + y;\n\t\t\t}\n\t\t\tif (handleOut) {\n\t\t\t\tcoords[i++] = handleOut._x + x;\n\t\t\t\tcoords[i++] = handleOut._y + y;\n\t\t\t}\n\t\t\tif (matrix) {\n\t\t\t\tmatrix._transformCoordinates(coords, coords, i / 2);\n\t\t\t\tx = coords[0];\n\t\t\t\ty = coords[1];\n\t\t\t\tif (change) {\n\t\t\t\t\tpoint._x = x;\n\t\t\t\t\tpoint._y = y;\n\t\t\t\t\ti  = 2;\n\t\t\t\t\tif (handleIn) {\n\t\t\t\t\t\thandleIn._x = coords[i++] - x;\n\t\t\t\t\t\thandleIn._y = coords[i++] - y;\n\t\t\t\t\t}\n\t\t\t\t\tif (handleOut) {\n\t\t\t\t\t\thandleOut._x = coords[i++] - x;\n\t\t\t\t\t\thandleOut._y = coords[i++] - y;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (!handleIn) {\n\t\t\t\t\t\tcoords[i++] = x;\n\t\t\t\t\t\tcoords[i++] = y;\n\t\t\t\t\t}\n\t\t\t\t\tif (!handleOut) {\n\t\t\t\t\t\tcoords[i++] = x;\n\t\t\t\t\t\tcoords[i++] = y;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn coords;\n\t\t}\n\t});\n\t\n\tvar SegmentPoint = Point.extend({\n\t\tinitialize: function SegmentPoint(point, owner, key) {\n\t\t\tvar x, y, selected;\n\t\t\tif (!point) {\n\t\t\t\tx = y = 0;\n\t\t\t} else if ((x = point[0]) !== undefined) {\n\t\t\t\ty = point[1];\n\t\t\t} else {\n\t\t\t\tvar pt = point;\n\t\t\t\tif ((x = pt.x) === undefined) {\n\t\t\t\t\tpt = Point.read(arguments);\n\t\t\t\t\tx = pt.x;\n\t\t\t\t}\n\t\t\t\ty = pt.y;\n\t\t\t\tselected = pt.selected;\n\t\t\t}\n\t\t\tthis._x = x;\n\t\t\tthis._y = y;\n\t\t\tthis._owner = owner;\n\t\t\towner[key] = this;\n\t\t\tif (selected)\n\t\t\t\tthis.setSelected(true);\n\t\t},\n\t\n\t\tset: function(x, y) {\n\t\t\tthis._x = x;\n\t\t\tthis._y = y;\n\t\t\tthis._owner._changed(this);\n\t\t\treturn this;\n\t\t},\n\t\n\t\t_serialize: function(options) {\n\t\t\tvar f = options.formatter,\n\t\t\t\tx = f.number(this._x),\n\t\t\t\ty = f.number(this._y);\n\t\t\treturn this.isSelected()\n\t\t\t\t\t? { x: x, y: y, selected: true }\n\t\t\t\t\t: [x, y];\n\t\t},\n\t\n\t\tgetX: function() {\n\t\t\treturn this._x;\n\t\t},\n\t\n\t\tsetX: function(x) {\n\t\t\tthis._x = x;\n\t\t\tthis._owner._changed(this);\n\t\t},\n\t\n\t\tgetY: function() {\n\t\t\treturn this._y;\n\t\t},\n\t\n\t\tsetY: function(y) {\n\t\t\tthis._y = y;\n\t\t\tthis._owner._changed(this);\n\t\t},\n\t\n\t\tisZero: function() {\n\t\t\treturn Numerical.isZero(this._x) && Numerical.isZero(this._y);\n\t\t},\n\t\n\t\tsetSelected: function(selected) {\n\t\t\tthis._owner.setSelected(selected, this);\n\t\t},\n\t\n\t\tisSelected: function() {\n\t\t\treturn this._owner.isSelected(this);\n\t\t}\n\t});\n\t\n\tvar Curve = Base.extend({\n\t\t_class: 'Curve',\n\t\n\t\tinitialize: function Curve(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7) {\n\t\t\tvar count = arguments.length,\n\t\t\t\tseg1, seg2,\n\t\t\t\tpoint1, point2,\n\t\t\t\thandle1, handle2;\n\t\t\tif (count === 3) {\n\t\t\t\tthis._path = arg0;\n\t\t\t\tseg1 = arg1;\n\t\t\t\tseg2 = arg2;\n\t\t\t} else if (count === 0) {\n\t\t\t\tseg1 = new Segment();\n\t\t\t\tseg2 = new Segment();\n\t\t\t} else if (count === 1) {\n\t\t\t\tif ('segment1' in arg0) {\n\t\t\t\t\tseg1 = new Segment(arg0.segment1);\n\t\t\t\t\tseg2 = new Segment(arg0.segment2);\n\t\t\t\t} else if ('point1' in arg0) {\n\t\t\t\t\tpoint1 = arg0.point1;\n\t\t\t\t\thandle1 = arg0.handle1;\n\t\t\t\t\thandle2 = arg0.handle2;\n\t\t\t\t\tpoint2 = arg0.point2;\n\t\t\t\t} else if (Array.isArray(arg0)) {\n\t\t\t\t\tpoint1 = [arg0[0], arg0[1]];\n\t\t\t\t\tpoint2 = [arg0[6], arg0[7]];\n\t\t\t\t\thandle1 = [arg0[2] - arg0[0], arg0[3] - arg0[1]];\n\t\t\t\t\thandle2 = [arg0[4] - arg0[6], arg0[5] - arg0[7]];\n\t\t\t\t}\n\t\t\t} else if (count === 2) {\n\t\t\t\tseg1 = new Segment(arg0);\n\t\t\t\tseg2 = new Segment(arg1);\n\t\t\t} else if (count === 4) {\n\t\t\t\tpoint1 = arg0;\n\t\t\t\thandle1 = arg1;\n\t\t\t\thandle2 = arg2;\n\t\t\t\tpoint2 = arg3;\n\t\t\t} else if (count === 8) {\n\t\t\t\tpoint1 = [arg0, arg1];\n\t\t\t\tpoint2 = [arg6, arg7];\n\t\t\t\thandle1 = [arg2 - arg0, arg3 - arg1];\n\t\t\t\thandle2 = [arg4 - arg6, arg5 - arg7];\n\t\t\t}\n\t\t\tthis._segment1 = seg1 || new Segment(point1, null, handle1);\n\t\t\tthis._segment2 = seg2 || new Segment(point2, handle2, null);\n\t\t},\n\t\n\t\t_serialize: function(options) {\n\t\t\treturn Base.serialize(this.hasHandles()\n\t\t\t\t\t? [this.getPoint1(), this.getHandle1(), this.getHandle2(),\n\t\t\t\t\t\tthis.getPoint2()]\n\t\t\t\t\t: [this.getPoint1(), this.getPoint2()],\n\t\t\t\t\toptions, true);\n\t\t},\n\t\n\t\t_changed: function() {\n\t\t\tthis._length = this._bounds = undefined;\n\t\t},\n\t\n\t\tclone: function() {\n\t\t\treturn new Curve(this._segment1, this._segment2);\n\t\t},\n\t\n\t\ttoString: function() {\n\t\t\tvar parts = [ 'point1: ' + this._segment1._point ];\n\t\t\tif (!this._segment1._handleOut.isZero())\n\t\t\t\tparts.push('handle1: ' + this._segment1._handleOut);\n\t\t\tif (!this._segment2._handleIn.isZero())\n\t\t\t\tparts.push('handle2: ' + this._segment2._handleIn);\n\t\t\tparts.push('point2: ' + this._segment2._point);\n\t\t\treturn '{ ' + parts.join(', ') + ' }';\n\t\t},\n\t\n\t\tremove: function() {\n\t\t\tvar removed = false;\n\t\t\tif (this._path) {\n\t\t\t\tvar segment2 = this._segment2,\n\t\t\t\t\thandleOut = segment2._handleOut;\n\t\t\t\tremoved = segment2.remove();\n\t\t\t\tif (removed)\n\t\t\t\t\tthis._segment1._handleOut.set(handleOut.x, handleOut.y);\n\t\t\t}\n\t\t\treturn removed;\n\t\t},\n\t\n\t\tgetPoint1: function() {\n\t\t\treturn this._segment1._point;\n\t\t},\n\t\n\t\tsetPoint1: function() {\n\t\t\tvar point = Point.read(arguments);\n\t\t\tthis._segment1._point.set(point.x, point.y);\n\t\t},\n\t\n\t\tgetPoint2: function() {\n\t\t\treturn this._segment2._point;\n\t\t},\n\t\n\t\tsetPoint2: function() {\n\t\t\tvar point = Point.read(arguments);\n\t\t\tthis._segment2._point.set(point.x, point.y);\n\t\t},\n\t\n\t\tgetHandle1: function() {\n\t\t\treturn this._segment1._handleOut;\n\t\t},\n\t\n\t\tsetHandle1: function() {\n\t\t\tvar point = Point.read(arguments);\n\t\t\tthis._segment1._handleOut.set(point.x, point.y);\n\t\t},\n\t\n\t\tgetHandle2: function() {\n\t\t\treturn this._segment2._handleIn;\n\t\t},\n\t\n\t\tsetHandle2: function() {\n\t\t\tvar point = Point.read(arguments);\n\t\t\tthis._segment2._handleIn.set(point.x, point.y);\n\t\t},\n\t\n\t\tgetSegment1: function() {\n\t\t\treturn this._segment1;\n\t\t},\n\t\n\t\tgetSegment2: function() {\n\t\t\treturn this._segment2;\n\t\t},\n\t\n\t\tgetPath: function() {\n\t\t\treturn this._path;\n\t\t},\n\t\n\t\tgetIndex: function() {\n\t\t\treturn this._segment1._index;\n\t\t},\n\t\n\t\tgetNext: function() {\n\t\t\tvar curves = this._path && this._path._curves;\n\t\t\treturn curves && (curves[this._segment1._index + 1]\n\t\t\t\t\t|| this._path._closed && curves[0]) || null;\n\t\t},\n\t\n\t\tgetPrevious: function() {\n\t\t\tvar curves = this._path && this._path._curves;\n\t\t\treturn curves && (curves[this._segment1._index - 1]\n\t\t\t\t\t|| this._path._closed && curves[curves.length - 1]) || null;\n\t\t},\n\t\n\t\tisFirst: function() {\n\t\t\treturn this._segment1._index === 0;\n\t\t},\n\t\n\t\tisLast: function() {\n\t\t\tvar path = this._path;\n\t\t\treturn path && this._segment1._index === path._curves.length - 1\n\t\t\t\t\t|| false;\n\t\t},\n\t\n\t\tisSelected: function() {\n\t\t\treturn this.getPoint1().isSelected()\n\t\t\t\t\t&& this.getHandle2().isSelected()\n\t\t\t\t\t&& this.getHandle2().isSelected()\n\t\t\t\t\t&& this.getPoint2().isSelected();\n\t\t},\n\t\n\t\tsetSelected: function(selected) {\n\t\t\tthis.getPoint1().setSelected(selected);\n\t\t\tthis.getHandle1().setSelected(selected);\n\t\t\tthis.getHandle2().setSelected(selected);\n\t\t\tthis.getPoint2().setSelected(selected);\n\t\t},\n\t\n\t\tgetValues: function(matrix) {\n\t\t\treturn Curve.getValues(this._segment1, this._segment2, matrix);\n\t\t},\n\t\n\t\tgetPoints: function() {\n\t\t\tvar coords = this.getValues(),\n\t\t\t\tpoints = [];\n\t\t\tfor (var i = 0; i < 8; i += 2)\n\t\t\t\tpoints.push(new Point(coords[i], coords[i + 1]));\n\t\t\treturn points;\n\t\t},\n\t\n\t\tgetLength: function() {\n\t\t\tif (this._length == null)\n\t\t\t\tthis._length = Curve.getLength(this.getValues(), 0, 1);\n\t\t\treturn this._length;\n\t\t},\n\t\n\t\tgetArea: function() {\n\t\t\treturn Curve.getArea(this.getValues());\n\t\t},\n\t\n\t\tgetLine: function() {\n\t\t\treturn new Line(this._segment1._point, this._segment2._point);\n\t\t},\n\t\n\t\tgetPart: function(from, to) {\n\t\t\treturn new Curve(Curve.getPart(this.getValues(), from, to));\n\t\t},\n\t\n\t\tgetPartLength: function(from, to) {\n\t\t\treturn Curve.getLength(this.getValues(), from, to);\n\t\t},\n\t\n\t\tgetIntersections: function(curve) {\n\t\t\treturn Curve._getIntersections(this.getValues(),\n\t\t\t\t\tcurve && curve !== this ? curve.getValues() : null,\n\t\t\t\t\tthis, curve, [], {});\n\t\t},\n\t\n\t\t_getParameter: function(offset, isParameter) {\n\t\t\treturn isParameter\n\t\t\t\t\t? offset\n\t\t\t\t\t: offset && offset.curve === this\n\t\t\t\t\t\t? offset.parameter\n\t\t\t\t\t\t: offset === undefined && isParameter === undefined\n\t\t\t\t\t\t\t? 0.5\n\t\t\t\t\t\t\t: this.getParameterAt(offset, 0);\n\t\t},\n\t\n\t\tdivide: function(offset, isParameter, _setHandles) {\n\t\t\tvar parameter = this._getParameter(offset, isParameter),\n\t\t\t\ttMin = 4e-7,\n\t\t\t\ttMax = 1 - tMin,\n\t\t\t\tres = null;\n\t\t\tif (parameter >= tMin && parameter <= tMax) {\n\t\t\t\tvar parts = Curve.subdivide(this.getValues(), parameter),\n\t\t\t\t\tleft = parts[0],\n\t\t\t\t\tright = parts[1],\n\t\t\t\t\tsetHandles = _setHandles || this.hasHandles(),\n\t\t\t\t\tsegment1 = this._segment1,\n\t\t\t\t\tsegment2 = this._segment2,\n\t\t\t\t\tpath = this._path;\n\t\t\t\tif (setHandles) {\n\t\t\t\t\tsegment1._handleOut.set(left[2] - left[0],\n\t\t\t\t\t\t\tleft[3] - left[1]);\n\t\t\t\t\tsegment2._handleIn.set(right[4] - right[6],\n\t\t\t\t\t\t\tright[5] - right[7]);\n\t\t\t\t}\n\t\t\t\tvar x = left[6], y = left[7],\n\t\t\t\t\tsegment = new Segment(new Point(x, y),\n\t\t\t\t\t\t\tsetHandles && new Point(left[4] - x, left[5] - y),\n\t\t\t\t\t\t\tsetHandles && new Point(right[2] - x, right[3] - y));\n\t\t\t\tif (path) {\n\t\t\t\t\tpath.insert(segment1._index + 1, segment);\n\t\t\t\t\tres = this.getNext();\n\t\t\t\t} else {\n\t\t\t\t\tthis._segment2 = segment;\n\t\t\t\t\tres = new Curve(segment, segment2);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn res;\n\t\t},\n\t\n\t\tsplit: function(offset, isParameter) {\n\t\t\treturn this._path\n\t\t\t\t? this._path.split(this._segment1._index,\n\t\t\t\t\t\tthis._getParameter(offset, isParameter))\n\t\t\t\t: null;\n\t\t},\n\t\n\t\treversed: function() {\n\t\t\treturn new Curve(this._segment2.reversed(), this._segment1.reversed());\n\t\t},\n\t\n\t\tclearHandles: function() {\n\t\t\tthis._segment1._handleOut.set(0, 0);\n\t\t\tthis._segment2._handleIn.set(0, 0);\n\t\t},\n\t\n\tstatics: {\n\t\tgetValues: function(segment1, segment2, matrix) {\n\t\t\tvar p1 = segment1._point,\n\t\t\t\th1 = segment1._handleOut,\n\t\t\t\th2 = segment2._handleIn,\n\t\t\t\tp2 = segment2._point,\n\t\t\t\tvalues = [\n\t\t\t\t\tp1._x, p1._y,\n\t\t\t\t\tp1._x + h1._x, p1._y + h1._y,\n\t\t\t\t\tp2._x + h2._x, p2._y + h2._y,\n\t\t\t\t\tp2._x, p2._y\n\t\t\t\t];\n\t\t\tif (matrix)\n\t\t\t\tmatrix._transformCoordinates(values, values, 4);\n\t\t\treturn values;\n\t\t},\n\t\n\t\tsubdivide: function(v, t) {\n\t\t\tvar p1x = v[0], p1y = v[1],\n\t\t\t\tc1x = v[2], c1y = v[3],\n\t\t\t\tc2x = v[4], c2y = v[5],\n\t\t\t\tp2x = v[6], p2y = v[7];\n\t\t\tif (t === undefined)\n\t\t\t\tt = 0.5;\n\t\t\tvar u = 1 - t,\n\t\t\t\tp3x = u * p1x + t * c1x, p3y = u * p1y + t * c1y,\n\t\t\t\tp4x = u * c1x + t * c2x, p4y = u * c1y + t * c2y,\n\t\t\t\tp5x = u * c2x + t * p2x, p5y = u * c2y + t * p2y,\n\t\t\t\tp6x = u * p3x + t * p4x, p6y = u * p3y + t * p4y,\n\t\t\t\tp7x = u * p4x + t * p5x, p7y = u * p4y + t * p5y,\n\t\t\t\tp8x = u * p6x + t * p7x, p8y = u * p6y + t * p7y;\n\t\t\treturn [\n\t\t\t\t[p1x, p1y, p3x, p3y, p6x, p6y, p8x, p8y],\n\t\t\t\t[p8x, p8y, p7x, p7y, p5x, p5y, p2x, p2y]\n\t\t\t];\n\t\t},\n\t\n\t\tsolveCubic: function (v, coord, val, roots, min, max) {\n\t\t\tvar p1 = v[coord],\n\t\t\t\tc1 = v[coord + 2],\n\t\t\t\tc2 = v[coord + 4],\n\t\t\t\tp2 = v[coord + 6],\n\t\t\t\tc = 3 * (c1 - p1),\n\t\t\t\tb = 3 * (c2 - c1) - c,\n\t\t\t\ta = p2 - p1 - c - b;\n\t\t\treturn Numerical.solveCubic(a, b, c, p1 - val, roots, min, max);\n\t\t},\n\t\n\t\tgetParameterOf: function(v, point) {\n\t\t\tvar p1 = new Point(v[0], v[1]),\n\t\t\t\tp2 = new Point(v[6], v[7]),\n\t\t\t\tepsilon = 1e-12,\n\t\t\t\tt = point.isClose(p1, epsilon) ? 0\n\t\t\t\t  : point.isClose(p2, epsilon) ? 1\n\t\t\t\t  : null;\n\t\t\tif (t !== null)\n\t\t\t\treturn t;\n\t\t\tvar coords = [point.x, point.y],\n\t\t\t\troots = [],\n\t\t\t\tgeomEpsilon = 2e-7;\n\t\t\tfor (var c = 0; c < 2; c++) {\n\t\t\t\tvar count = Curve.solveCubic(v, c, coords[c], roots, 0, 1);\n\t\t\t\tfor (var i = 0; i < count; i++) {\n\t\t\t\t\tt = roots[i];\n\t\t\t\t\tif (point.isClose(Curve.getPoint(v, t), geomEpsilon))\n\t\t\t\t\t\treturn t;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn point.isClose(p1, geomEpsilon) ? 0\n\t\t\t\t : point.isClose(p2, geomEpsilon) ? 1\n\t\t\t\t : null;\n\t\t},\n\t\n\t\tgetNearestParameter: function(v, point) {\n\t\t\tif (Curve.isStraight(v)) {\n\t\t\t\tvar p1x = v[0], p1y = v[1],\n\t\t\t\t\tp2x = v[6], p2y = v[7],\n\t\t\t\t\tvx = p2x - p1x, vy = p2y - p1y,\n\t\t\t\t\tdet = vx * vx + vy * vy;\n\t\t\t\tif (det === 0)\n\t\t\t\t\treturn 0;\n\t\t\t\tvar u = ((point.x - p1x) * vx + (point.y - p1y) * vy) / det;\n\t\t\t\treturn u < 1e-12 ? 0\n\t\t\t\t\t : u > 0.999999999999 ? 1\n\t\t\t\t\t : Curve.getParameterOf(v,\n\t\t\t\t\t\tnew Point(p1x + u * vx, p1y + u * vy));\n\t\t\t}\n\t\n\t\t\tvar count = 100,\n\t\t\t\tminDist = Infinity,\n\t\t\t\tminT = 0;\n\t\n\t\t\tfunction refine(t) {\n\t\t\t\tif (t >= 0 && t <= 1) {\n\t\t\t\t\tvar dist = point.getDistance(Curve.getPoint(v, t), true);\n\t\t\t\t\tif (dist < minDist) {\n\t\t\t\t\t\tminDist = dist;\n\t\t\t\t\t\tminT = t;\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\tfor (var i = 0; i <= count; i++)\n\t\t\t\trefine(i / count);\n\t\n\t\t\tvar step = 1 / (count * 2);\n\t\t\twhile (step > 4e-7) {\n\t\t\t\tif (!refine(minT - step) && !refine(minT + step))\n\t\t\t\t\tstep /= 2;\n\t\t\t}\n\t\t\treturn minT;\n\t\t},\n\t\n\t\tgetPart: function(v, from, to) {\n\t\t\tvar flip = from > to;\n\t\t\tif (flip) {\n\t\t\t\tvar tmp = from;\n\t\t\t\tfrom = to;\n\t\t\t\tto = tmp;\n\t\t\t}\n\t\t\tif (from > 0)\n\t\t\t\tv = Curve.subdivide(v, from)[1];\n\t\t\tif (to < 1)\n\t\t\t\tv = Curve.subdivide(v, (to - from) / (1 - from))[0];\n\t\t\treturn flip\n\t\t\t\t\t? [v[6], v[7], v[4], v[5], v[2], v[3], v[0], v[1]]\n\t\t\t\t\t: v;\n\t\t},\n\t\n\t\thasHandles: function(v) {\n\t\t\tvar isZero = Numerical.isZero;\n\t\t\treturn !(isZero(v[0] - v[2]) && isZero(v[1] - v[3])\n\t\t\t\t\t&& isZero(v[4] - v[6]) && isZero(v[5] - v[7]));\n\t\t},\n\t\n\t\tisFlatEnough: function(v, tolerance) {\n\t\t\tvar p1x = v[0], p1y = v[1],\n\t\t\t\tc1x = v[2], c1y = v[3],\n\t\t\t\tc2x = v[4], c2y = v[5],\n\t\t\t\tp2x = v[6], p2y = v[7],\n\t\t\t\tux = 3 * c1x - 2 * p1x - p2x,\n\t\t\t\tuy = 3 * c1y - 2 * p1y - p2y,\n\t\t\t\tvx = 3 * c2x - 2 * p2x - p1x,\n\t\t\t\tvy = 3 * c2y - 2 * p2y - p1y;\n\t\t\treturn Math.max(ux * ux, vx * vx) + Math.max(uy * uy, vy * vy)\n\t\t\t\t\t< 10 * tolerance * tolerance;\n\t\t},\n\t\n\t\tgetArea: function(v) {\n\t\t\tvar p1x = v[0], p1y = v[1],\n\t\t\t\tp2x = v[6], p2y = v[7],\n\t\t\t\th1x = (v[2] + p1x) / 2,\n\t\t\t\th1y = (v[3] + p1y) / 2,\n\t\t\t\th2x = (v[4] + v[6]) / 2,\n\t\t\t\th2y = (v[5] + v[7]) / 2;\n\t\t\treturn 6 * ((p1x - h1x) * (h1y + p1y)\n\t\t\t\t\t  + (h1x - h2x) * (h2y + h1y)\n\t\t\t\t\t  + (h2x - p2x) * (p2y + h2y)) / 10;\n\t\t},\n\t\n\t\tgetBounds: function(v) {\n\t\t\tvar min = v.slice(0, 2),\n\t\t\t\tmax = min.slice(),\n\t\t\t\troots = [0, 0];\n\t\t\tfor (var i = 0; i < 2; i++)\n\t\t\t\tCurve._addBounds(v[i], v[i + 2], v[i + 4], v[i + 6],\n\t\t\t\t\t\ti, 0, min, max, roots);\n\t\t\treturn new Rectangle(min[0], min[1], max[0] - min[0], max[1] - min[1]);\n\t\t},\n\t\n\t\t_addBounds: function(v0, v1, v2, v3, coord, padding, min, max, roots) {\n\t\t\tfunction add(value, padding) {\n\t\t\t\tvar left = value - padding,\n\t\t\t\t\tright = value + padding;\n\t\t\t\tif (left < min[coord])\n\t\t\t\t\tmin[coord] = left;\n\t\t\t\tif (right > max[coord])\n\t\t\t\t\tmax[coord] = right;\n\t\t\t}\n\t\t\tvar a = 3 * (v1 - v2) - v0 + v3,\n\t\t\t\tb = 2 * (v0 + v2) - 4 * v1,\n\t\t\t\tc = v1 - v0,\n\t\t\t\tcount = Numerical.solveQuadratic(a, b, c, roots),\n\t\t\t\ttMin = 4e-7,\n\t\t\t\ttMax = 1 - tMin;\n\t\t\tadd(v3, 0);\n\t\t\tfor (var i = 0; i < count; i++) {\n\t\t\t\tvar t = roots[i],\n\t\t\t\t\tu = 1 - t;\n\t\t\t\tif (tMin < t && t < tMax)\n\t\t\t\t\tadd(u * u * u * v0\n\t\t\t\t\t\t+ 3 * u * u * t * v1\n\t\t\t\t\t\t+ 3 * u * t * t * v2\n\t\t\t\t\t\t+ t * t * t * v3,\n\t\t\t\t\t\tpadding);\n\t\t\t}\n\t\t}\n\t}}, Base.each(\n\t\t['getBounds', 'getStrokeBounds', 'getHandleBounds', 'getRoughBounds'],\n\t\tfunction(name) {\n\t\t\tthis[name] = function() {\n\t\t\t\tif (!this._bounds)\n\t\t\t\t\tthis._bounds = {};\n\t\t\t\tvar bounds = this._bounds[name];\n\t\t\t\tif (!bounds) {\n\t\t\t\t\tvar path = this._path;\n\t\t\t\t\tbounds = this._bounds[name] = Path[name](\n\t\t\t\t\t\t\t[this._segment1, this._segment2], false,\n\t\t\t\t\t\t\tpath && path.getStyle());\n\t\t\t\t}\n\t\t\t\treturn bounds.clone();\n\t\t\t};\n\t\t},\n\t{\n\t\n\t}), Base.each({\n\t\tisStraight: function(l, h1, h2) {\n\t\t\tif (h1.isZero() && h2.isZero()) {\n\t\t\t\treturn true;\n\t\t\t} else if (l.isZero()) {\n\t\t\t\treturn false;\n\t\t\t} else if (h1.isCollinear(l) && h2.isCollinear(l)) {\n\t\t\t\tvar div = l.dot(l),\n\t\t\t\t\tp1 = l.dot(h1) / div,\n\t\t\t\t\tp2 = l.dot(h2) / div;\n\t\t\t\treturn p1 >= 0 && p1 <= 1 && p2 <= 0 && p2 >= -1;\n\t\t\t}\n\t\t\treturn false;\n\t\t},\n\t\n\t\tisLinear: function(l, h1, h2) {\n\t\t\tvar third = l.divide(3);\n\t\t\treturn h1.equals(third) && h2.negate().equals(third);\n\t\t}\n\t}, function(test, name) {\n\t\tthis[name] = function() {\n\t\t\tvar seg1 = this._segment1,\n\t\t\t\tseg2 = this._segment2;\n\t\t\treturn test(seg2._point.subtract(seg1._point),\n\t\t\t\t\tseg1._handleOut, seg2._handleIn);\n\t\t};\n\t\n\t\tthis.statics[name] = function(v) {\n\t\t\tvar p1x = v[0], p1y = v[1],\n\t\t\t\tp2x = v[6], p2y = v[7];\n\t\t\treturn test(new Point(p2x - p1x, p2y - p1y),\n\t\t\t\t\tnew Point(v[2] - p1x, v[3] - p1y),\n\t\t\t\t\tnew Point(v[4] - p2x, v[5] - p2y));\n\t\t};\n\t}, {\n\t\tstatics: {},\n\t\n\t\thasHandles: function() {\n\t\t\treturn !this._segment1._handleOut.isZero()\n\t\t\t\t\t|| !this._segment2._handleIn.isZero();\n\t\t},\n\t\n\t\tisCollinear: function(curve) {\n\t\t\treturn curve && this.isStraight() && curve.isStraight()\n\t\t\t\t\t&& this.getLine().isCollinear(curve.getLine());\n\t\t},\n\t\n\t\tisHorizontal: function() {\n\t\t\treturn this.isStraight() && Math.abs(this.getTangentAt(0.5, true).y)\n\t\t\t\t\t< 1e-7;\n\t\t},\n\t\n\t\tisVertical: function() {\n\t\t\treturn this.isStraight() && Math.abs(this.getTangentAt(0.5, true).x)\n\t\t\t\t\t< 1e-7;\n\t\t}\n\t}), {\n\t\tbeans: false,\n\t\n\t\tgetParameterAt: function(offset, start) {\n\t\t\treturn Curve.getParameterAt(this.getValues(), offset, start);\n\t\t},\n\t\n\t\tgetParameterOf: function() {\n\t\t\treturn Curve.getParameterOf(this.getValues(), Point.read(arguments));\n\t\t},\n\t\n\t\tgetLocationAt: function(offset, isParameter) {\n\t\t\tvar t = isParameter ? offset : this.getParameterAt(offset);\n\t\t\treturn t != null && t >= 0 && t <= 1\n\t\t\t\t\t? new CurveLocation(this, t)\n\t\t\t\t\t: null;\n\t\t},\n\t\n\t\tgetLocationOf: function() {\n\t\t\treturn this.getLocationAt(this.getParameterOf(Point.read(arguments)),\n\t\t\t\t\ttrue);\n\t\t},\n\t\n\t\tgetOffsetOf: function() {\n\t\t\tvar loc = this.getLocationOf.apply(this, arguments);\n\t\t\treturn loc ? loc.getOffset() : null;\n\t\t},\n\t\n\t\tgetNearestLocation: function() {\n\t\t\tvar point = Point.read(arguments),\n\t\t\t\tvalues = this.getValues(),\n\t\t\t\tt = Curve.getNearestParameter(values, point),\n\t\t\t\tpt = Curve.getPoint(values, t);\n\t\t\treturn new CurveLocation(this, t, pt, null, point.getDistance(pt));\n\t\t},\n\t\n\t\tgetNearestPoint: function() {\n\t\t\treturn this.getNearestLocation.apply(this, arguments).getPoint();\n\t\t}\n\t\n\t},\n\tnew function() {\n\t\tvar methods = ['getPoint', 'getTangent', 'getNormal', 'getWeightedTangent',\n\t\t\t'getWeightedNormal', 'getCurvature'];\n\t\treturn Base.each(methods,\n\t\tfunction(name) {\n\t\t\tthis[name + 'At'] = function(offset, isParameter) {\n\t\t\t\tvar values = this.getValues();\n\t\t\t\treturn Curve[name](values, isParameter ? offset\n\t\t\t\t\t\t: Curve.getParameterAt(values, offset, 0));\n\t\t\t};\n\t\t}, {\n\t\t\tstatics: {\n\t\t\t\tevaluateMethods: methods\n\t\t\t}\n\t\t})\n\t},\n\tnew function() {\n\t\n\t\tfunction getLengthIntegrand(v) {\n\t\t\tvar p1x = v[0], p1y = v[1],\n\t\t\t\tc1x = v[2], c1y = v[3],\n\t\t\t\tc2x = v[4], c2y = v[5],\n\t\t\t\tp2x = v[6], p2y = v[7],\n\t\n\t\t\t\tax = 9 * (c1x - c2x) + 3 * (p2x - p1x),\n\t\t\t\tbx = 6 * (p1x + c2x) - 12 * c1x,\n\t\t\t\tcx = 3 * (c1x - p1x),\n\t\n\t\t\t\tay = 9 * (c1y - c2y) + 3 * (p2y - p1y),\n\t\t\t\tby = 6 * (p1y + c2y) - 12 * c1y,\n\t\t\t\tcy = 3 * (c1y - p1y);\n\t\n\t\t\treturn function(t) {\n\t\t\t\tvar dx = (ax * t + bx) * t + cx,\n\t\t\t\t\tdy = (ay * t + by) * t + cy;\n\t\t\t\treturn Math.sqrt(dx * dx + dy * dy);\n\t\t\t};\n\t\t}\n\t\n\t\tfunction getIterations(a, b) {\n\t\t\treturn Math.max(2, Math.min(16, Math.ceil(Math.abs(b - a) * 32)));\n\t\t}\n\t\n\t\tfunction evaluate(v, t, type, normalized) {\n\t\t\tif (t == null || t < 0 || t > 1)\n\t\t\t\treturn null;\n\t\t\tvar p1x = v[0], p1y = v[1],\n\t\t\t\tc1x = v[2], c1y = v[3],\n\t\t\t\tc2x = v[4], c2y = v[5],\n\t\t\t\tp2x = v[6], p2y = v[7],\n\t\t\t\ttMin = 4e-7,\n\t\t\t\ttMax = 1 - tMin,\n\t\t\t\tx, y;\n\t\n\t\t\tif (type === 0 && (t < tMin || t > tMax)) {\n\t\t\t\tvar isZero = t < tMin;\n\t\t\t\tx = isZero ? p1x : p2x;\n\t\t\t\ty = isZero ? p1y : p2y;\n\t\t\t} else {\n\t\t\t\tvar cx = 3 * (c1x - p1x),\n\t\t\t\t\tbx = 3 * (c2x - c1x) - cx,\n\t\t\t\t\tax = p2x - p1x - cx - bx,\n\t\n\t\t\t\t\tcy = 3 * (c1y - p1y),\n\t\t\t\t\tby = 3 * (c2y - c1y) - cy,\n\t\t\t\t\tay = p2y - p1y - cy - by;\n\t\t\t\tif (type === 0) {\n\t\t\t\t\tx = ((ax * t + bx) * t + cx) * t + p1x;\n\t\t\t\t\ty = ((ay * t + by) * t + cy) * t + p1y;\n\t\t\t\t} else {\n\t\t\t\t\tif (t < tMin) {\n\t\t\t\t\t\tx = cx;\n\t\t\t\t\t\ty = cy;\n\t\t\t\t\t} else if (t > tMax) {\n\t\t\t\t\t\tx = 3 * (p2x - c2x);\n\t\t\t\t\t\ty = 3 * (p2y - c2y);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tx = (3 * ax * t + 2 * bx) * t + cx;\n\t\t\t\t\t\ty = (3 * ay * t + 2 * by) * t + cy;\n\t\t\t\t\t}\n\t\t\t\t\tif (normalized) {\n\t\t\t\t\t\tif (x === 0 && y === 0 && (t < tMin || t > tMax)) {\n\t\t\t\t\t\t\tx = c2x - c1x;\n\t\t\t\t\t\t\ty = c2y - c1y;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tvar len = Math.sqrt(x * x + y * y);\n\t\t\t\t\t\tif (len) {\n\t\t\t\t\t\t\tx /= len;\n\t\t\t\t\t\t\ty /= len;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (type === 3) {\n\t\t\t\t\t\tvar x2 = 6 * ax * t + 2 * bx,\n\t\t\t\t\t\t\ty2 = 6 * ay * t + 2 * by,\n\t\t\t\t\t\t\td = Math.pow(x * x + y * y, 3 / 2);\n\t\t\t\t\t\tx = d !== 0 ? (x * y2 - y * x2) / d : 0;\n\t\t\t\t\t\ty = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn type === 2 ? new Point(y, -x) : new Point(x, y);\n\t\t}\n\t\n\t\treturn { statics: {\n\t\n\t\t\tgetLength: function(v, a, b) {\n\t\t\t\tif (a === undefined)\n\t\t\t\t\ta = 0;\n\t\t\t\tif (b === undefined)\n\t\t\t\t\tb = 1;\n\t\t\t\tif (a === 0 && b === 1 && Curve.isStraight(v)) {\n\t\t\t\t\tvar dx = v[6] - v[0],\n\t\t\t\t\t\tdy = v[7] - v[1];\n\t\t\t\t\treturn Math.sqrt(dx * dx + dy * dy);\n\t\t\t\t}\n\t\t\t\tvar ds = getLengthIntegrand(v);\n\t\t\t\treturn Numerical.integrate(ds, a, b, getIterations(a, b));\n\t\t\t},\n\t\n\t\t\tgetParameterAt: function(v, offset, start) {\n\t\t\t\tif (start === undefined)\n\t\t\t\t\tstart = offset < 0 ? 1 : 0\n\t\t\t\tif (offset === 0)\n\t\t\t\t\treturn start;\n\t\t\t\tvar abs = Math.abs,\n\t\t\t\t\tforward = offset > 0,\n\t\t\t\t\ta = forward ? start : 0,\n\t\t\t\t\tb = forward ? 1 : start,\n\t\t\t\t\tds = getLengthIntegrand(v),\n\t\t\t\t\trangeLength = Numerical.integrate(ds, a, b,\n\t\t\t\t\t\t\tgetIterations(a, b));\n\t\t\t\tif (abs(offset - rangeLength) < 1e-12) {\n\t\t\t\t\treturn forward ? b : a;\n\t\t\t\t} else if (abs(offset) > rangeLength) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\tvar guess = offset / rangeLength,\n\t\t\t\t\tlength = 0;\n\t\t\t\tfunction f(t) {\n\t\t\t\t\tlength += Numerical.integrate(ds, start, t,\n\t\t\t\t\t\t\tgetIterations(start, t));\n\t\t\t\t\tstart = t;\n\t\t\t\t\treturn length - offset;\n\t\t\t\t}\n\t\t\t\treturn Numerical.findRoot(f, ds, start + guess, a, b, 32,\n\t\t\t\t\t\t1e-12);\n\t\t\t},\n\t\n\t\t\tgetPoint: function(v, t) {\n\t\t\t\treturn evaluate(v, t, 0, false);\n\t\t\t},\n\t\n\t\t\tgetTangent: function(v, t) {\n\t\t\t\treturn evaluate(v, t, 1, true);\n\t\t\t},\n\t\n\t\t\tgetWeightedTangent: function(v, t) {\n\t\t\t\treturn evaluate(v, t, 1, false);\n\t\t\t},\n\t\n\t\t\tgetNormal: function(v, t) {\n\t\t\t\treturn evaluate(v, t, 2, true);\n\t\t\t},\n\t\n\t\t\tgetWeightedNormal: function(v, t) {\n\t\t\t\treturn evaluate(v, t, 2, false);\n\t\t\t},\n\t\n\t\t\tgetCurvature: function(v, t) {\n\t\t\t\treturn evaluate(v, t, 3, false).x;\n\t\t\t}\n\t\t}};\n\t},\n\tnew function() {\n\t\n\t\tfunction addLocation(locations, param, v1, c1, t1, p1, v2, c2, t2, p2,\n\t\t\t\toverlap) {\n\t\t\tvar startConnected = param.startConnected,\n\t\t\t\tendConnected = param.endConnected,\n\t\t\t\ttMin = 4e-7,\n\t\t\t\ttMax = 1 - tMin;\n\t\t\tif (t1 == null)\n\t\t\t\tt1 = Curve.getParameterOf(v1, p1);\n\t\t\tif (t1 !== null && t1 >= (startConnected ? tMin : 0) &&\n\t\t\t\tt1 <= (endConnected ? tMax : 1)) {\n\t\t\t\tif (t2 == null)\n\t\t\t\t\tt2 = Curve.getParameterOf(v2, p2);\n\t\t\t\tif (t2 !== null && t2 >= (endConnected ? tMin : 0) &&\n\t\t\t\t\tt2 <= (startConnected ? tMax : 1)) {\n\t\t\t\t\tvar renormalize = param.renormalize;\n\t\t\t\t\tif (renormalize) {\n\t\t\t\t\t\tvar res = renormalize(t1, t2);\n\t\t\t\t\t\tt1 = res[0];\n\t\t\t\t\t\tt2 = res[1];\n\t\t\t\t\t}\n\t\t\t\t\tvar loc1 = new CurveLocation(c1, t1,\n\t\t\t\t\t\t\tp1 || Curve.getPoint(v1, t1), overlap),\n\t\t\t\t\t\tloc2 = new CurveLocation(c2, t2,\n\t\t\t\t\t\t\tp2 || Curve.getPoint(v2, t2), overlap),\n\t\t\t\t\t\tflip = loc1.getPath() === loc2.getPath()\n\t\t\t\t\t\t\t&& loc1.getIndex() > loc2.getIndex(),\n\t\t\t\t\t\tloc = flip ? loc2 : loc1,\n\t\t\t\t\t\tinclude = param.include;\n\t\t\t\t\tloc1._intersection = loc2;\n\t\t\t\t\tloc2._intersection = loc1;\n\t\t\t\t\tif (!include || include(loc)) {\n\t\t\t\t\t\tCurveLocation.insert(locations, loc, true);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\n\t\tfunction addCurveIntersections(v1, v2, c1, c2, locations, param,\n\t\t\t\ttMin, tMax, uMin, uMax, oldTDiff, reverse, recursion) {\n\t\t\tif (++recursion >= 24)\n\t\t\t\treturn;\n\t\t\tvar q0x = v2[0], q0y = v2[1], q3x = v2[6], q3y = v2[7],\n\t\t\t\tgetSignedDistance = Line.getSignedDistance,\n\t\t\t\td1 = getSignedDistance(q0x, q0y, q3x, q3y, v2[2], v2[3]),\n\t\t\t\td2 = getSignedDistance(q0x, q0y, q3x, q3y, v2[4], v2[5]),\n\t\t\t\tfactor = d1 * d2 > 0 ? 3 / 4 : 4 / 9,\n\t\t\t\tdMin = factor * Math.min(0, d1, d2),\n\t\t\t\tdMax = factor * Math.max(0, d1, d2),\n\t\t\t\tdp0 = getSignedDistance(q0x, q0y, q3x, q3y, v1[0], v1[1]),\n\t\t\t\tdp1 = getSignedDistance(q0x, q0y, q3x, q3y, v1[2], v1[3]),\n\t\t\t\tdp2 = getSignedDistance(q0x, q0y, q3x, q3y, v1[4], v1[5]),\n\t\t\t\tdp3 = getSignedDistance(q0x, q0y, q3x, q3y, v1[6], v1[7]),\n\t\t\t\thull = getConvexHull(dp0, dp1, dp2, dp3),\n\t\t\t\ttop = hull[0],\n\t\t\t\tbottom = hull[1],\n\t\t\t\ttMinClip,\n\t\t\t\ttMaxClip;\n\t\t\tif ((tMinClip = clipConvexHull(top, bottom, dMin, dMax)) == null ||\n\t\t\t\t(tMaxClip = clipConvexHull(top.reverse(), bottom.reverse(),\n\t\t\t\t\tdMin, dMax)) == null)\n\t\t\t\treturn;\n\t\t\tv1 = Curve.getPart(v1, tMinClip, tMaxClip);\n\t\t\tvar tDiff = tMaxClip - tMinClip,\n\t\t\t\ttMinNew = tMin + (tMax - tMin) * tMinClip,\n\t\t\t\ttMaxNew = tMin + (tMax - tMin) * tMaxClip;\n\t\t\tif (oldTDiff > 0.5 && tDiff > 0.5) {\n\t\t\t\tif (tMaxNew - tMinNew > uMax - uMin) {\n\t\t\t\t\tvar parts = Curve.subdivide(v1, 0.5),\n\t\t\t\t\t\tt = tMinNew + (tMaxNew - tMinNew) / 2;\n\t\t\t\t\taddCurveIntersections(\n\t\t\t\t\t\tv2, parts[0], c2, c1, locations, param,\n\t\t\t\t\t\tuMin, uMax, tMinNew, t, tDiff, !reverse, recursion);\n\t\t\t\t\taddCurveIntersections(\n\t\t\t\t\t\tv2, parts[1], c2, c1, locations, param,\n\t\t\t\t\t\tuMin, uMax, t, tMaxNew, tDiff, !reverse, recursion);\n\t\t\t\t} else {\n\t\t\t\t\tvar parts = Curve.subdivide(v2, 0.5),\n\t\t\t\t\t\tt = uMin + (uMax - uMin) / 2;\n\t\t\t\t\taddCurveIntersections(\n\t\t\t\t\t\tparts[0], v1, c2, c1, locations, param,\n\t\t\t\t\t\tuMin, t, tMinNew, tMaxNew, tDiff, !reverse, recursion);\n\t\t\t\t\taddCurveIntersections(\n\t\t\t\t\t\tparts[1], v1, c2, c1, locations, param,\n\t\t\t\t\t\tt, uMax, tMinNew, tMaxNew, tDiff, !reverse, recursion);\n\t\t\t\t}\n\t\t\t} else if (Math.max(uMax - uMin, tMaxNew - tMinNew)\n\t\t\t\t\t< 1e-7) {\n\t\t\t\tvar t1 = tMinNew + (tMaxNew - tMinNew) / 2,\n\t\t\t\t\tt2 = uMin + (uMax - uMin) / 2;\n\t\t\t\tv1 = c1.getValues();\n\t\t\t\tv2 = c2.getValues();\n\t\t\t\taddLocation(locations, param,\n\t\t\t\t\treverse ? v2 : v1, reverse ? c2 : c1, reverse ? t2 : t1, null,\n\t\t\t\t\treverse ? v1 : v2, reverse ? c1 : c2, reverse ? t1 : t2, null);\n\t\t\t} else if (tDiff > 1e-12) {\n\t\t\t\taddCurveIntersections(v2, v1, c2, c1, locations, param,\n\t\t\t\t\t\tuMin, uMax, tMinNew, tMaxNew, tDiff, !reverse, recursion);\n\t\t\t}\n\t\t}\n\t\n\t\tfunction getConvexHull(dq0, dq1, dq2, dq3) {\n\t\t\tvar p0 = [ 0, dq0 ],\n\t\t\t\tp1 = [ 1 / 3, dq1 ],\n\t\t\t\tp2 = [ 2 / 3, dq2 ],\n\t\t\t\tp3 = [ 1, dq3 ],\n\t\t\t\tdist1 = dq1 - (2 * dq0 + dq3) / 3,\n\t\t\t\tdist2 = dq2 - (dq0 + 2 * dq3) / 3,\n\t\t\t\thull;\n\t\t\tif (dist1 * dist2 < 0) {\n\t\t\t\thull = [[p0, p1, p3], [p0, p2, p3]];\n\t\t\t} else {\n\t\t\t\tvar distRatio = dist1 / dist2;\n\t\t\t\thull = [\n\t\t\t\t\tdistRatio >= 2 ? [p0, p1, p3]\n\t\t\t\t\t: distRatio <= .5 ? [p0, p2, p3]\n\t\t\t\t\t: [p0, p1, p2, p3],\n\t\t\t\t\t[p0, p3]\n\t\t\t\t];\n\t\t\t}\n\t\t\treturn (dist1 || dist2) < 0 ? hull.reverse() : hull;\n\t\t}\n\t\n\t\tfunction clipConvexHull(hullTop, hullBottom, dMin, dMax) {\n\t\t\tif (hullTop[0][1] < dMin) {\n\t\t\t\treturn clipConvexHullPart(hullTop, true, dMin);\n\t\t\t} else if (hullBottom[0][1] > dMax) {\n\t\t\t\treturn clipConvexHullPart(hullBottom, false, dMax);\n\t\t\t} else {\n\t\t\t\treturn hullTop[0][0];\n\t\t\t}\n\t\t}\n\t\n\t\tfunction clipConvexHullPart(part, top, threshold) {\n\t\t\tvar px = part[0][0],\n\t\t\t\tpy = part[0][1];\n\t\t\tfor (var i = 1, l = part.length; i < l; i++) {\n\t\t\t\tvar qx = part[i][0],\n\t\t\t\t\tqy = part[i][1];\n\t\t\t\tif (top ? qy >= threshold : qy <= threshold) {\n\t\t\t\t\treturn qy === threshold ? qx\n\t\t\t\t\t\t\t: px + (threshold - py) * (qx - px) / (qy - py);\n\t\t\t\t}\n\t\t\t\tpx = qx;\n\t\t\t\tpy = qy;\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\t\n\t\tfunction addCurveLineIntersections(v1, v2, c1, c2, locations, param) {\n\t\t\tvar flip = Curve.isStraight(v1),\n\t\t\t\tvc = flip ? v2 : v1,\n\t\t\t\tvl = flip ? v1 : v2,\n\t\t\t\tlx1 = vl[0], ly1 = vl[1],\n\t\t\t\tlx2 = vl[6], ly2 = vl[7],\n\t\t\t\tldx = lx2 - lx1,\n\t\t\t\tldy = ly2 - ly1,\n\t\t\t\tangle = Math.atan2(-ldy, ldx),\n\t\t\t\tsin = Math.sin(angle),\n\t\t\t\tcos = Math.cos(angle),\n\t\t\t\trvc = [];\n\t\t\tfor(var i = 0; i < 8; i += 2) {\n\t\t\t\tvar x = vc[i] - lx1,\n\t\t\t\t\ty = vc[i + 1] - ly1;\n\t\t\t\trvc.push(\n\t\t\t\t\tx * cos - y * sin,\n\t\t\t\t\tx * sin + y * cos);\n\t\t\t}\n\t\t\tvar roots = [],\n\t\t\t\tcount = Curve.solveCubic(rvc, 1, 0, roots, 0, 1);\n\t\t\tfor (var i = 0; i < count; i++) {\n\t\t\t\tvar tc = roots[i],\n\t\t\t\t\tpc = Curve.getPoint(vc, tc),\n\t\t\t\t\ttl = Curve.getParameterOf(vl, pc);\n\t\t\t\tif (tl !== null) {\n\t\t\t\t\tvar pl = Curve.getPoint(vl, tl),\n\t\t\t\t\t\tt1 = flip ? tl : tc,\n\t\t\t\t\t\tt2 = flip ? tc : tl;\n\t\t\t\t\tif (!param.endConnected || t2 > Numerical.CURVETIME_EPSILON) {\n\t\t\t\t\t\taddLocation(locations, param,\n\t\t\t\t\t\t\t\tv1, c1, t1, flip ? pl : pc,\n\t\t\t\t\t\t\t\tv2, c2, t2, flip ? pc : pl);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\n\t\tfunction addLineIntersection(v1, v2, c1, c2, locations, param) {\n\t\t\tvar pt = Line.intersect(\n\t\t\t\t\tv1[0], v1[1], v1[6], v1[7],\n\t\t\t\t\tv2[0], v2[1], v2[6], v2[7]);\n\t\t\tif (pt) {\n\t\t\t\taddLocation(locations, param, v1, c1, null, pt, v2, c2, null, pt);\n\t\t\t}\n\t\t}\n\t\n\t\treturn { statics: {\n\t\t\t_getIntersections: function(v1, v2, c1, c2, locations, param) {\n\t\t\t\tif (!v2) {\n\t\t\t\t\treturn Curve._getSelfIntersection(v1, c1, locations, param);\n\t\t\t\t}\n\t\t\t\tvar c1p1x = v1[0], c1p1y = v1[1],\n\t\t\t\t\tc1p2x = v1[6], c1p2y = v1[7],\n\t\t\t\t\tc2p1x = v2[0], c2p1y = v2[1],\n\t\t\t\t\tc2p2x = v2[6], c2p2y = v2[7],\n\t\t\t\t\tc1s1x = (3 * v1[2] + c1p1x) / 4,\n\t\t\t\t\tc1s1y = (3 * v1[3] + c1p1y) / 4,\n\t\t\t\t\tc1s2x = (3 * v1[4] + c1p2x) / 4,\n\t\t\t\t\tc1s2y = (3 * v1[5] + c1p2y) / 4,\n\t\t\t\t\tc2s1x = (3 * v2[2] + c2p1x) / 4,\n\t\t\t\t\tc2s1y = (3 * v2[3] + c2p1y) / 4,\n\t\t\t\t\tc2s2x = (3 * v2[4] + c2p2x) / 4,\n\t\t\t\t\tc2s2y = (3 * v2[5] + c2p2y) / 4,\n\t\t\t\t\tmin = Math.min,\n\t\t\t\t\tmax = Math.max;\n\t\t\t\tif (!(\tmax(c1p1x, c1s1x, c1s2x, c1p2x) >=\n\t\t\t\t\t\tmin(c2p1x, c2s1x, c2s2x, c2p2x) &&\n\t\t\t\t\t\tmin(c1p1x, c1s1x, c1s2x, c1p2x) <=\n\t\t\t\t\t\tmax(c2p1x, c2s1x, c2s2x, c2p2x) &&\n\t\t\t\t\t\tmax(c1p1y, c1s1y, c1s2y, c1p2y) >=\n\t\t\t\t\t\tmin(c2p1y, c2s1y, c2s2y, c2p2y) &&\n\t\t\t\t\t\tmin(c1p1y, c1s1y, c1s2y, c1p2y) <=\n\t\t\t\t\t\tmax(c2p1y, c2s1y, c2s2y, c2p2y)))\n\t\t\t\t\treturn locations;\n\t\t\t\tif (!param.startConnected && !param.endConnected) {\n\t\t\t\t\tvar overlaps = Curve.getOverlaps(v1, v2);\n\t\t\t\t\tif (overlaps) {\n\t\t\t\t\t\tfor (var i = 0; i < 2; i++) {\n\t\t\t\t\t\t\tvar overlap = overlaps[i];\n\t\t\t\t\t\t\taddLocation(locations, param,\n\t\t\t\t\t\t\t\tv1, c1, overlap[0], null,\n\t\t\t\t\t\t\t\tv2, c2, overlap[1], null, true);\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn locations;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\n\t\t\t\tvar straight1 = Curve.isStraight(v1),\n\t\t\t\t\tstraight2 = Curve.isStraight(v2),\n\t\t\t\t\tstraight = straight1 && straight2,\n\t\t\t\t\tepsilon = 1e-12,\n\t\t\t\t\tbefore = locations.length;\n\t\t\t\t(straight\n\t\t\t\t\t? addLineIntersection\n\t\t\t\t\t: straight1 || straight2\n\t\t\t\t\t\t? addCurveLineIntersections\n\t\t\t\t\t\t: addCurveIntersections)(\n\t\t\t\t\t\t\tv1, v2, c1, c2, locations, param,\n\t\t\t\t\t\t\t0, 1, 0, 1, 0, false, 0);\n\t\t\t\tif (straight && locations.length > before)\n\t\t\t\t\treturn locations;\n\t\t\t\tvar c1p1 = new Point(c1p1x, c1p1y),\n\t\t\t\t\tc1p2 = new Point(c1p2x, c1p2y),\n\t\t\t\t\tc2p1 = new Point(c2p1x, c2p1y),\n\t\t\t\t\tc2p2 = new Point(c2p2x, c2p2y);\n\t\t\t\tif (c1p1.isClose(c2p1, epsilon))\n\t\t\t\t\taddLocation(locations, param, v1, c1, 0, c1p1, v2, c2, 0, c2p1);\n\t\t\t\tif (!param.startConnected && c1p1.isClose(c2p2, epsilon))\n\t\t\t\t\taddLocation(locations, param, v1, c1, 0, c1p1, v2, c2, 1, c2p2);\n\t\t\t\tif (!param.endConnected && c1p2.isClose(c2p1, epsilon))\n\t\t\t\t\taddLocation(locations, param, v1, c1, 1, c1p2, v2, c2, 0, c2p1);\n\t\t\t\tif (c1p2.isClose(c2p2, epsilon))\n\t\t\t\t\taddLocation(locations, param, v1, c1, 1, c1p2, v2, c2, 1, c2p2);\n\t\t\t\treturn locations;\n\t\t\t},\n\t\n\t\t\t_getSelfIntersection: function(v1, c1, locations, param) {\n\t\t\t\tvar p1x = v1[0], p1y = v1[1],\n\t\t\t\t\th1x = v1[2], h1y = v1[3],\n\t\t\t\t\th2x = v1[4], h2y = v1[5],\n\t\t\t\t\tp2x = v1[6], p2y = v1[7];\n\t\t\t\tvar line = new Line(p1x, p1y, p2x, p2y, false),\n\t\t\t\t\tside1 = line.getSide(new Point(h1x, h1y), true),\n\t\t\t\t\tside2 = line.getSide(new Point(h2x, h2y), true);\n\t\t\t\tif (side1 === side2) {\n\t\t\t\t\tvar edgeSum = (p1x - h2x) * (h1y - p2y)\n\t\t\t\t\t\t\t\t+ (h1x - p2x) * (h2y - p1y);\n\t\t\t\t\tif (edgeSum * side1 > 0)\n\t\t\t\t\t\treturn locations;\n\t\t\t\t}\n\t\t\t\tvar ax = p2x - 3 * h2x + 3 * h1x - p1x,\n\t\t\t\t\tbx = h2x - 2 * h1x + p1x,\n\t\t\t\t\tcx = h1x - p1x,\n\t\t\t\t\tay = p2y - 3 * h2y + 3 * h1y - p1y,\n\t\t\t\t\tby = h2y - 2 * h1y + p1y,\n\t\t\t\t\tcy = h1y - p1y,\n\t\t\t\t\tac = ay * cx - ax * cy,\n\t\t\t\t\tab = ay * bx - ax * by,\n\t\t\t\t\tbc = by * cx - bx * cy;\n\t\t\t\tif (ac * ac - 4 * ab * bc < 0) {\n\t\t\t\t\tvar roots = [],\n\t\t\t\t\t\ttSplit,\n\t\t\t\t\t\tcount = Numerical.solveCubic(\n\t\t\t\t\t\t\t\tax * ax\t + ay * ay,\n\t\t\t\t\t\t\t\t3 * (ax * bx + ay * by),\n\t\t\t\t\t\t\t\t2 * (bx * bx + by * by) + ax * cx + ay * cy,\n\t\t\t\t\t\t\t\tbx * cx + by * cy,\n\t\t\t\t\t\t\t\troots, 0, 1);\n\t\t\t\t\tif (count > 0) {\n\t\t\t\t\t\tfor (var i = 0, maxCurvature = 0; i < count; i++) {\n\t\t\t\t\t\t\tvar curvature = Math.abs(\n\t\t\t\t\t\t\t\t\tc1.getCurvatureAt(roots[i], true));\n\t\t\t\t\t\t\tif (curvature > maxCurvature) {\n\t\t\t\t\t\t\t\tmaxCurvature = curvature;\n\t\t\t\t\t\t\t\ttSplit = roots[i];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tvar parts = Curve.subdivide(v1, tSplit);\n\t\t\t\t\t\tparam.endConnected = true;\n\t\t\t\t\t\tparam.renormalize = function(t1, t2) {\n\t\t\t\t\t\t\treturn [t1 * tSplit, t2 * (1 - tSplit) + tSplit];\n\t\t\t\t\t\t};\n\t\t\t\t\t\tCurve._getIntersections(parts[0], parts[1], c1, c1,\n\t\t\t\t\t\t\t\tlocations, param);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn locations;\n\t\t\t},\n\t\n\t\t\tgetOverlaps: function(v1, v2) {\n\t\t\t\tvar abs = Math.abs,\n\t\t\t\t\ttimeEpsilon = 4e-7,\n\t\t\t\t\tgeomEpsilon = 2e-7,\n\t\t\t\t\tstraight1 = Curve.isStraight(v1),\n\t\t\t\t\tstraight2 = Curve.isStraight(v2),\n\t\t\t\t\tstraight =\tstraight1 && straight2;\n\t\n\t\t\t\tfunction getLineLengthSquared(v) {\n\t\t\t\t\tvar x = v[6] - v[0],\n\t\t\t\t\t\ty = v[7] - v[1];\n\t\t\t\t\treturn x * x + y * y;\n\t\t\t\t}\n\t\n\t\t\t\tif (straight) {\n\t\t\t\t\tvar flip = getLineLengthSquared(v1) < getLineLengthSquared(v2),\n\t\t\t\t\t\tl1 = flip ? v2 : v1,\n\t\t\t\t\t\tl2 = flip ? v1 : v2,\n\t\t\t\t\t\tline = new Line(l1[0], l1[1], l1[6], l1[7]);\n\t\t\t\t\tif (line.getDistance(new Point(l2[0], l2[1])) > geomEpsilon ||\n\t\t\t\t\t\tline.getDistance(new Point(l2[6], l2[7])) > geomEpsilon)\n\t\t\t\t\t\treturn null;\n\t\t\t\t} else if (straight1 ^ straight2) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\n\t\t\t\tvar v = [v1, v2],\n\t\t\t\t\tpairs = [];\n\t\t\t\tfor (var i = 0, t1 = 0;\n\t\t\t\t\t\ti < 2 && pairs.length < 2;\n\t\t\t\t\t\ti += t1 === 0 ? 0 : 1, t1 = t1 ^ 1) {\n\t\t\t\t\tvar t2 = Curve.getParameterOf(v[i ^ 1], new Point(\n\t\t\t\t\t\t\tv[i][t1 === 0 ? 0 : 6],\n\t\t\t\t\t\t\tv[i][t1 === 0 ? 1 : 7]));\n\t\t\t\t\tif (t2 != null) {\n\t\t\t\t\t\tvar pair = i === 0 ? [t1, t2] : [t2, t1];\n\t\t\t\t\t\tif (pairs.length === 0 ||\n\t\t\t\t\t\t\tabs(pair[0] - pairs[0][0]) > timeEpsilon &&\n\t\t\t\t\t\t\tabs(pair[1] - pairs[0][1]) > timeEpsilon)\n\t\t\t\t\t\t\tpairs.push(pair);\n\t\t\t\t\t}\n\t\t\t\t\tif (i === 1 && pairs.length === 0)\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (pairs.length !== 2) {\n\t\t\t\t\tpairs = null;\n\t\t\t\t} else if (!straight) {\n\t\t\t\t\tvar o1 = Curve.getPart(v1, pairs[0][0], pairs[1][0]),\n\t\t\t\t\t\to2 = Curve.getPart(v2, pairs[0][1], pairs[1][1]);\n\t\t\t\t\tif (abs(o2[2] - o1[2]) > geomEpsilon ||\n\t\t\t\t\t\tabs(o2[3] - o1[3]) > geomEpsilon ||\n\t\t\t\t\t\tabs(o2[4] - o1[4]) > geomEpsilon ||\n\t\t\t\t\t\tabs(o2[5] - o1[5]) > geomEpsilon)\n\t\t\t\t\t\tpairs = null;\n\t\t\t\t}\n\t\t\t\treturn pairs;\n\t\t\t}\n\t\t}};\n\t});\n\t\n\tvar CurveLocation = Base.extend({\n\t\t_class: 'CurveLocation',\n\t\tbeans: true,\n\t\n\t\tinitialize: function CurveLocation(curve, parameter, point,\n\t\t\t\t_overlap, _distance) {\n\t\t\tif (parameter > 0.9999996) {\n\t\t\t\tvar next = curve.getNext();\n\t\t\t\tif (next) {\n\t\t\t\t\tparameter = 0;\n\t\t\t\t\tcurve = next;\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis._id = UID.get(CurveLocation);\n\t\t\tthis._setCurve(curve);\n\t\t\tthis._parameter = parameter;\n\t\t\tthis._point = point || curve.getPointAt(parameter, true);\n\t\t\tthis._overlap = _overlap;\n\t\t\tthis._distance = _distance;\n\t\t\tthis._intersection = this._next = this._prev = null;\n\t\t},\n\t\n\t\t_setCurve: function(curve) {\n\t\t\tvar path = curve._path;\n\t\t\tthis._version = path ? path._version : 0;\n\t\t\tthis._curve = curve;\n\t\t\tthis._segment = null;\n\t\t\tthis._segment1 = curve._segment1;\n\t\t\tthis._segment2 = curve._segment2;\n\t\t},\n\t\n\t\t_setSegment: function(segment) {\n\t\t\tthis._setCurve(segment.getCurve());\n\t\t\tthis._segment = segment;\n\t\t\tthis._parameter = segment === this._segment1 ? 0 : 1;\n\t\t\tthis._point = segment._point.clone();\n\t\t},\n\t\n\t\tgetSegment: function() {\n\t\t\tvar curve = this.getCurve(),\n\t\t\t\tsegment = this._segment;\n\t\t\tif (!segment) {\n\t\t\t\tvar parameter = this.getParameter();\n\t\t\t\tif (parameter === 0) {\n\t\t\t\t\tsegment = curve._segment1;\n\t\t\t\t} else if (parameter === 1) {\n\t\t\t\t\tsegment = curve._segment2;\n\t\t\t\t} else if (parameter != null) {\n\t\t\t\t\tsegment = curve.getPartLength(0, parameter)\n\t\t\t\t\t\t< curve.getPartLength(parameter, 1)\n\t\t\t\t\t\t\t? curve._segment1\n\t\t\t\t\t\t\t: curve._segment2;\n\t\t\t\t}\n\t\t\t\tthis._segment = segment;\n\t\t\t}\n\t\t\treturn segment;\n\t\t},\n\t\n\t\tgetCurve: function() {\n\t\t\tvar curve = this._curve,\n\t\t\t\tpath = curve && curve._path,\n\t\t\t\tthat = this;\n\t\t\tif (path && path._version !== this._version) {\n\t\t\t\tcurve = this._parameter = this._curve = this._offset = null;\n\t\t\t}\n\t\n\t\t\tfunction trySegment(segment) {\n\t\t\t\tvar curve = segment && segment.getCurve();\n\t\t\t\tif (curve && (that._parameter = curve.getParameterOf(that._point))\n\t\t\t\t\t\t!= null) {\n\t\t\t\t\tthat._setCurve(curve);\n\t\t\t\t\tthat._segment = segment;\n\t\t\t\t\treturn curve;\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\treturn curve\n\t\t\t\t|| trySegment(this._segment)\n\t\t\t\t|| trySegment(this._segment1)\n\t\t\t\t|| trySegment(this._segment2.getPrevious());\n\t\t},\n\t\n\t\tgetPath: function() {\n\t\t\tvar curve = this.getCurve();\n\t\t\treturn curve && curve._path;\n\t\t},\n\t\n\t\tgetIndex: function() {\n\t\t\tvar curve = this.getCurve();\n\t\t\treturn curve && curve.getIndex();\n\t\t},\n\t\n\t\tgetParameter: function() {\n\t\t\tvar curve = this.getCurve(),\n\t\t\t\tparameter = this._parameter;\n\t\t\treturn curve && parameter == null\n\t\t\t\t? this._parameter = curve.getParameterOf(this._point)\n\t\t\t\t: parameter;\n\t\t},\n\t\n\t\tgetPoint: function() {\n\t\t\treturn this._point;\n\t\t},\n\t\n\t\tgetOffset: function() {\n\t\t\tvar offset = this._offset;\n\t\t\tif (offset == null) {\n\t\t\t\toffset = 0;\n\t\t\t\tvar path = this.getPath(),\n\t\t\t\t\tindex = this.getIndex();\n\t\t\t\tif (path && index != null) {\n\t\t\t\t\tvar curves = path.getCurves();\n\t\t\t\t\tfor (var i = 0; i < index; i++)\n\t\t\t\t\t\toffset += curves[i].getLength();\n\t\t\t\t}\n\t\t\t\tthis._offset = offset += this.getCurveOffset();\n\t\t\t}\n\t\t\treturn offset;\n\t\t},\n\t\n\t\tgetCurveOffset: function() {\n\t\t\tvar curve = this.getCurve(),\n\t\t\t\tparameter = this.getParameter();\n\t\t\treturn parameter != null && curve && curve.getPartLength(0, parameter);\n\t\t},\n\t\n\t\tgetIntersection: function() {\n\t\t\treturn this._intersection;\n\t\t},\n\t\n\t\tgetDistance: function() {\n\t\t\treturn this._distance;\n\t\t},\n\t\n\t\tdivide: function() {\n\t\t\tvar curve = this.getCurve(),\n\t\t\t\tres = null;\n\t\t\tif (curve) {\n\t\t\t\tres = curve.divide(this.getParameter(), true);\n\t\t\t\tif (res)\n\t\t\t\t\tthis._setSegment(res._segment1);\n\t\t\t}\n\t\t\treturn res;\n\t\t},\n\t\n\t\tsplit: function() {\n\t\t\tvar curve = this.getCurve();\n\t\t\treturn curve ? curve.split(this.getParameter(), true) : null;\n\t\t},\n\t\n\t\tequals: function(loc, _ignoreOther) {\n\t\t\tvar res = this === loc,\n\t\t\t\tepsilon = 2e-7;\n\t\t\tif (!res && loc instanceof CurveLocation\n\t\t\t\t\t&& this.getPath() === loc.getPath()\n\t\t\t\t\t&& this.getPoint().isClose(loc.getPoint(), epsilon)) {\n\t\t\t\tvar c1 = this.getCurve(),\n\t\t\t\t\tc2 = loc.getCurve(),\n\t\t\t\t\tabs = Math.abs,\n\t\t\t\t\tdiff = abs(\n\t\t\t\t\t\t((c1.isLast() && c2.isFirst() ? -1 : c1.getIndex())\n\t\t\t\t\t\t\t\t+ this.getParameter()) -\n\t\t\t\t\t\t((c2.isLast() && c1.isFirst() ? -1 : c2.getIndex())\n\t\t\t\t\t\t\t\t+ loc.getParameter()));\n\t\t\t\tres = (diff < 4e-7\n\t\t\t\t\t|| ((diff = abs(this.getOffset() - loc.getOffset())) < epsilon\n\t\t\t\t\t\t|| abs(this.getPath().getLength() - diff) < epsilon))\n\t\t\t\t\t&& (_ignoreOther\n\t\t\t\t\t\t|| (!this._intersection && !loc._intersection\n\t\t\t\t\t\t\t|| this._intersection && this._intersection.equals(\n\t\t\t\t\t\t\t\t\tloc._intersection, true)));\n\t\t\t}\n\t\t\treturn res;\n\t\t},\n\t\n\t\ttoString: function() {\n\t\t\tvar parts = [],\n\t\t\t\tpoint = this.getPoint(),\n\t\t\t\tf = Formatter.instance;\n\t\t\tif (point)\n\t\t\t\tparts.push('point: ' + point);\n\t\t\tvar index = this.getIndex();\n\t\t\tif (index != null)\n\t\t\t\tparts.push('index: ' + index);\n\t\t\tvar parameter = this.getParameter();\n\t\t\tif (parameter != null)\n\t\t\t\tparts.push('parameter: ' + f.number(parameter));\n\t\t\tif (this._distance != null)\n\t\t\t\tparts.push('distance: ' + f.number(this._distance));\n\t\t\treturn '{ ' + parts.join(', ') + ' }';\n\t\t},\n\t\n\t\tisTouching: function() {\n\t\t\tvar inter = this._intersection;\n\t\t\tif (inter && this.getTangent().isCollinear(inter.getTangent())) {\n\t\t\t\tvar curve1 = this.getCurve(),\n\t\t\t\t\tcurve2 = inter.getCurve();\n\t\t\t\treturn !(curve1.isStraight() && curve2.isStraight()\n\t\t\t\t\t\t&& curve1.getLine().intersect(curve2.getLine()));\n\t\t\t}\n\t\t\treturn false;\n\t\t},\n\t\n\t\tisCrossing: function() {\n\t\t\tvar inter = this._intersection;\n\t\t\tif (!inter)\n\t\t\t\treturn false;\n\t\t\tvar t1 = this.getParameter(),\n\t\t\t\tt2 = inter.getParameter(),\n\t\t\t\ttMin = 4e-7,\n\t\t\t\ttMax = 1 - tMin;\n\t\t\tif (t1 >= tMin && t1 <= tMax || t2 >= tMin && t2 <= tMax)\n\t\t\t\treturn !this.isTouching();\n\t\t\tvar c2 = this.getCurve(),\n\t\t\t\tc1 = c2.getPrevious(),\n\t\t\t\tc4 = inter.getCurve(),\n\t\t\t\tc3 = c4.getPrevious(),\n\t\t\t\tPI = Math.PI;\n\t\t\tif (!c1 || !c3)\n\t\t\t\treturn false;\n\t\n\t\t\tfunction isInRange(angle, min, max) {\n\t\t\t\treturn min < max\n\t\t\t\t\t? angle > min && angle < max\n\t\t\t\t\t: angle > min && angle <= PI || angle >= -PI && angle < max;\n\t\t\t}\n\t\n\t\t\tvar a1 = c1.getTangentAt(tMax, true).negate().getAngleInRadians(),\n\t\t\t\ta2 = c2.getTangentAt(tMin, true).getAngleInRadians(),\n\t\t\t\ta3 = c3.getTangentAt(tMax, true).negate().getAngleInRadians(),\n\t\t\t\ta4 = c4.getTangentAt(tMin, true).getAngleInRadians();\n\t\n\t\t\treturn (isInRange(a3, a1, a2) ^ isInRange(a4, a1, a2))\n\t\t\t\t&& (isInRange(a3, a2, a1) ^ isInRange(a4, a2, a1));\n\t\t},\n\t\n\t\tisOverlap: function() {\n\t\t\treturn !!this._overlap;\n\t\t}\n\t}, Base.each(Curve.evaluateMethods, function(name) {\n\t\tvar get = name + 'At';\n\t\tthis[name] = function() {\n\t\t\tvar parameter = this.getParameter(),\n\t\t\t\tcurve = this.getCurve();\n\t\t\treturn parameter != null && curve && curve[get](parameter, true);\n\t\t};\n\t}, {\n\t\tpreserve: true\n\t}),\n\tnew function() {\n\t\n\t\tfunction insert(locations, loc, merge) {\n\t\t\tvar length = locations.length,\n\t\t\t\tl = 0,\n\t\t\t\tr = length - 1;\n\t\n\t\t\tfunction search(index, dir) {\n\t\t\t\tfor (var i = index + dir; i >= -1 && i <= length; i += dir) {\n\t\t\t\t\tvar loc2 = locations[((i % length) + length) % length];\n\t\t\t\t\tif (!loc.getPoint().isClose(loc2.getPoint(),\n\t\t\t\t\t\t\t2e-7))\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tif (loc.equals(loc2))\n\t\t\t\t\t\treturn loc2;\n\t\t\t\t}\n\t\t\t\treturn null;\n\t\t\t}\n\t\n\t\t\twhile (l <= r) {\n\t\t\t\tvar m = (l + r) >>> 1,\n\t\t\t\t\tloc2 = locations[m],\n\t\t\t\t\tfound;\n\t\t\t\tif (merge && (found = loc.equals(loc2) ? loc2\n\t\t\t\t\t\t: (search(m, -1) || search(m, 1)))) {\n\t\t\t\t\tif (loc._overlap) {\n\t\t\t\t\t\tfound._overlap = found._intersection._overlap = true;\n\t\t\t\t\t}\n\t\t\t\t\treturn found;\n\t\t\t\t}\n\t\t\tvar path1 = loc.getPath(),\n\t\t\t\tpath2 = loc2.getPath(),\n\t\t\t\tdiff = path1 === path2\n\t\t\t\t\t? (loc.getIndex() + loc.getParameter())\n\t\t\t\t\t- (loc2.getIndex() + loc2.getParameter())\n\t\t\t\t\t: path1._id - path2._id;\n\t\t\t\tif (diff < 0) {\n\t\t\t\t\tr = m - 1;\n\t\t\t\t} else {\n\t\t\t\t\tl = m + 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tlocations.splice(l, 0, loc);\n\t\t\treturn loc;\n\t\t}\n\t\n\t\treturn { statics: {\n\t\t\tinsert: insert,\n\t\n\t\t\texpand: function(locations) {\n\t\t\t\tvar expanded = locations.slice();\n\t\t\t\tfor (var i = 0, l = locations.length; i < l; i++) {\n\t\t\t\t\tinsert(expanded, locations[i]._intersection, false);\n\t\t\t\t}\n\t\t\t\treturn expanded;\n\t\t\t}\n\t\t}};\n\t});\n\t\n\tvar PathItem = Item.extend({\n\t\t_class: 'PathItem',\n\t\n\t\tinitialize: function PathItem() {\n\t\t},\n\t\n\t\tgetIntersections: function(path, include, _matrix, _returnFirst) {\n\t\t\tvar self = this === path || !path,\n\t\t\t\tmatrix1 = this._matrix.orNullIfIdentity(),\n\t\t\t\tmatrix2 = self ? matrix1\n\t\t\t\t\t: (_matrix || path._matrix).orNullIfIdentity();\n\t\t\tif (!self && !this.getBounds(matrix1).touches(path.getBounds(matrix2)))\n\t\t\t\treturn [];\n\t\t\tvar curves1 = this.getCurves(),\n\t\t\t\tcurves2 = self ? curves1 : path.getCurves(),\n\t\t\t\tlength1 = curves1.length,\n\t\t\t\tlength2 = self ? length1 : curves2.length,\n\t\t\t\tvalues2 = [],\n\t\t\t\tarrays = [],\n\t\t\t\tlocations,\n\t\t\t\tpath;\n\t\t\tfor (var i = 0; i < length2; i++)\n\t\t\t\tvalues2[i] = curves2[i].getValues(matrix2);\n\t\t\tfor (var i = 0; i < length1; i++) {\n\t\t\t\tvar curve1 = curves1[i],\n\t\t\t\t\tvalues1 = self ? values2[i] : curve1.getValues(matrix1),\n\t\t\t\t\tpath1 = curve1.getPath();\n\t\t\t\tif (path1 !== path) {\n\t\t\t\t\tpath = path1;\n\t\t\t\t\tlocations = [];\n\t\t\t\t\tarrays.push(locations);\n\t\t\t\t}\n\t\t\t\tif (self) {\n\t\t\t\t\tCurve._getSelfIntersection(values1, curve1, locations, {\n\t\t\t\t\t\tinclude: include,\n\t\t\t\t\t\tstartConnected: length1 === 1 &&\n\t\t\t\t\t\t\t\tcurve1.getPoint1().equals(curve1.getPoint2())\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\tfor (var j = self ? i + 1 : 0; j < length2; j++) {\n\t\t\t\t\tif (_returnFirst && locations.length)\n\t\t\t\t\t\treturn locations;\n\t\t\t\t\tvar curve2 = curves2[j];\n\t\t\t\t\tCurve._getIntersections(\n\t\t\t\t\t\tvalues1, values2[j], curve1, curve2, locations,\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tinclude: include,\n\t\t\t\t\t\t\tstartConnected: self && curve1.getPrevious() === curve2,\n\t\t\t\t\t\t\tendConnected: self && curve1.getNext() === curve2\n\t\t\t\t\t\t}\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t\tlocations = [];\n\t\t\tfor (var i = 0, l = arrays.length; i < l; i++) {\n\t\t\t\tlocations.push.apply(locations, arrays[i]);\n\t\t\t}\n\t\t\treturn locations;\n\t\t},\n\t\n\t\tgetCrossings: function(path) {\n\t\t\treturn this.getIntersections(path, function(inter) {\n\t\t\t\treturn inter.isCrossing();\n\t\t\t});\n\t\t},\n\t\n\t\t_asPathItem: function() {\n\t\t\treturn this;\n\t\t},\n\t\n\t\tsetPathData: function(data) {\n\t\n\t\t\tvar parts = data.match(/[mlhvcsqtaz][^mlhvcsqtaz]*/ig),\n\t\t\t\tcoords,\n\t\t\t\trelative = false,\n\t\t\t\tprevious,\n\t\t\t\tcontrol,\n\t\t\t\tcurrent = new Point(),\n\t\t\t\tstart = new Point();\n\t\n\t\t\tfunction getCoord(index, coord) {\n\t\t\t\tvar val = +coords[index];\n\t\t\t\tif (relative)\n\t\t\t\t\tval += current[coord];\n\t\t\t\treturn val;\n\t\t\t}\n\t\n\t\t\tfunction getPoint(index) {\n\t\t\t\treturn new Point(\n\t\t\t\t\tgetCoord(index, 'x'),\n\t\t\t\t\tgetCoord(index + 1, 'y')\n\t\t\t\t);\n\t\t\t}\n\t\n\t\t\tthis.clear();\n\t\n\t\t\tfor (var i = 0, l = parts && parts.length; i < l; i++) {\n\t\t\t\tvar part = parts[i],\n\t\t\t\t\tcommand = part[0],\n\t\t\t\t\tlower = command.toLowerCase();\n\t\t\t\tcoords = part.match(/[+-]?(?:\\d*\\.\\d+|\\d+\\.?)(?:[eE][+-]?\\d+)?/g);\n\t\t\t\tvar length = coords && coords.length;\n\t\t\t\trelative = command === lower;\n\t\t\t\tif (previous === 'z' && !/[mz]/.test(lower))\n\t\t\t\t\tthis.moveTo(current = start);\n\t\t\t\tswitch (lower) {\n\t\t\t\tcase 'm':\n\t\t\t\tcase 'l':\n\t\t\t\t\tvar move = lower === 'm';\n\t\t\t\t\tfor (var j = 0; j < length; j += 2)\n\t\t\t\t\t\tthis[j === 0 && move ? 'moveTo' : 'lineTo'](\n\t\t\t\t\t\t\t\tcurrent = getPoint(j));\n\t\t\t\t\tcontrol = current;\n\t\t\t\t\tif (move)\n\t\t\t\t\t\tstart = current;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'h':\n\t\t\t\tcase 'v':\n\t\t\t\t\tvar coord = lower === 'h' ? 'x' : 'y';\n\t\t\t\t\tfor (var j = 0; j < length; j++) {\n\t\t\t\t\t\tcurrent[coord] = getCoord(j, coord);\n\t\t\t\t\t\tthis.lineTo(current);\n\t\t\t\t\t}\n\t\t\t\t\tcontrol = current;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'c':\n\t\t\t\t\tfor (var j = 0; j < length; j += 6) {\n\t\t\t\t\t\tthis.cubicCurveTo(\n\t\t\t\t\t\t\t\tgetPoint(j),\n\t\t\t\t\t\t\t\tcontrol = getPoint(j + 2),\n\t\t\t\t\t\t\t\tcurrent = getPoint(j + 4));\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 's':\n\t\t\t\t\tfor (var j = 0; j < length; j += 4) {\n\t\t\t\t\t\tthis.cubicCurveTo(\n\t\t\t\t\t\t\t\t/[cs]/.test(previous)\n\t\t\t\t\t\t\t\t\t\t? current.multiply(2).subtract(control)\n\t\t\t\t\t\t\t\t\t\t: current,\n\t\t\t\t\t\t\t\tcontrol = getPoint(j),\n\t\t\t\t\t\t\t\tcurrent = getPoint(j + 2));\n\t\t\t\t\t\tprevious = lower;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'q':\n\t\t\t\t\tfor (var j = 0; j < length; j += 4) {\n\t\t\t\t\t\tthis.quadraticCurveTo(\n\t\t\t\t\t\t\t\tcontrol = getPoint(j),\n\t\t\t\t\t\t\t\tcurrent = getPoint(j + 2));\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 't':\n\t\t\t\t\tfor (var j = 0; j < length; j += 2) {\n\t\t\t\t\t\tthis.quadraticCurveTo(\n\t\t\t\t\t\t\t\tcontrol = (/[qt]/.test(previous)\n\t\t\t\t\t\t\t\t\t\t? current.multiply(2).subtract(control)\n\t\t\t\t\t\t\t\t\t\t: current),\n\t\t\t\t\t\t\t\tcurrent = getPoint(j));\n\t\t\t\t\t\tprevious = lower;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'a':\n\t\t\t\t\tfor (var j = 0; j < length; j += 7) {\n\t\t\t\t\t\tthis.arcTo(current = getPoint(j + 5),\n\t\t\t\t\t\t\t\tnew Size(+coords[j], +coords[j + 1]),\n\t\t\t\t\t\t\t\t+coords[j + 2], +coords[j + 4], +coords[j + 3]);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'z':\n\t\t\t\t\tthis.closePath(true);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tprevious = lower;\n\t\t\t}\n\t\t},\n\t\n\t\t_canComposite: function() {\n\t\t\treturn !(this.hasFill() && this.hasStroke());\n\t\t},\n\t\n\t\t_contains: function(point) {\n\t\t\tvar winding = this._getWinding(point, false, true);\n\t\t\treturn !!(this.getWindingRule() === 'evenodd' ? winding & 1 : winding);\n\t\t}\n\t\n\t});\n\t\n\tvar Path = PathItem.extend({\n\t\t_class: 'Path',\n\t\t_serializeFields: {\n\t\t\tsegments: [],\n\t\t\tclosed: false\n\t\t},\n\t\n\t\tinitialize: function Path(arg) {\n\t\t\tthis._closed = false;\n\t\t\tthis._segments = [];\n\t\t\tthis._version = 0;\n\t\t\tvar segments = Array.isArray(arg)\n\t\t\t\t? typeof arg[0] === 'object'\n\t\t\t\t\t? arg\n\t\t\t\t\t: arguments\n\t\t\t\t: arg && (arg.size === undefined && (arg.x !== undefined\n\t\t\t\t\t\t|| arg.point !== undefined))\n\t\t\t\t\t? arguments\n\t\t\t\t\t: null;\n\t\t\tif (segments && segments.length > 0) {\n\t\t\t\tthis.setSegments(segments);\n\t\t\t} else {\n\t\t\t\tthis._curves = undefined;\n\t\t\t\tthis._selectedSegmentState = 0;\n\t\t\t\tif (!segments && typeof arg === 'string') {\n\t\t\t\t\tthis.setPathData(arg);\n\t\t\t\t\targ = null;\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis._initialize(!segments && arg);\n\t\t},\n\t\n\t\t_equals: function(item) {\n\t\t\treturn this._closed === item._closed\n\t\t\t\t\t&& Base.equals(this._segments, item._segments);\n\t\t},\n\t\n\t\tclone: function(insert) {\n\t\t\tvar copy = new Path(Item.NO_INSERT);\n\t\t\tcopy.setSegments(this._segments);\n\t\t\tcopy._closed = this._closed;\n\t\t\tif (this._clockwise !== undefined)\n\t\t\t\tcopy._clockwise = this._clockwise;\n\t\t\treturn this._clone(copy, insert);\n\t\t},\n\t\n\t\t_changed: function _changed(flags) {\n\t\t\t_changed.base.call(this, flags);\n\t\t\tif (flags & 8) {\n\t\t\t\tvar parent = this._parent;\n\t\t\t\tif (parent)\n\t\t\t\t\tparent._currentPath = undefined;\n\t\t\t\tthis._length = this._area = this._clockwise = this._monoCurves =\n\t\t\t\t\t\tundefined;\n\t\t\t\tif (flags & 16) {\n\t\t\t\t\tthis._version++;\n\t\t\t\t} else if (this._curves) {\n\t\t\t\t   for (var i = 0, l = this._curves.length; i < l; i++)\n\t\t\t\t\t\tthis._curves[i]._changed();\n\t\t\t\t}\n\t\t\t} else if (flags & 32) {\n\t\t\t\tthis._bounds = undefined;\n\t\t\t}\n\t\t},\n\t\n\t\tgetStyle: function() {\n\t\t\tvar parent = this._parent;\n\t\t\treturn (parent instanceof CompoundPath ? parent : this)._style;\n\t\t},\n\t\n\t\tgetSegments: function() {\n\t\t\treturn this._segments;\n\t\t},\n\t\n\t\tsetSegments: function(segments) {\n\t\t\tvar fullySelected = this.isFullySelected();\n\t\t\tthis._segments.length = 0;\n\t\t\tthis._selectedSegmentState = 0;\n\t\t\tthis._curves = undefined;\n\t\t\tif (segments && segments.length > 0)\n\t\t\t\tthis._add(Segment.readAll(segments));\n\t\t\tif (fullySelected)\n\t\t\t\tthis.setFullySelected(true);\n\t\t},\n\t\n\t\tgetFirstSegment: function() {\n\t\t\treturn this._segments[0];\n\t\t},\n\t\n\t\tgetLastSegment: function() {\n\t\t\treturn this._segments[this._segments.length - 1];\n\t\t},\n\t\n\t\tgetCurves: function() {\n\t\t\tvar curves = this._curves,\n\t\t\t\tsegments = this._segments;\n\t\t\tif (!curves) {\n\t\t\t\tvar length = this._countCurves();\n\t\t\t\tcurves = this._curves = new Array(length);\n\t\t\t\tfor (var i = 0; i < length; i++)\n\t\t\t\t\tcurves[i] = new Curve(this, segments[i],\n\t\t\t\t\t\tsegments[i + 1] || segments[0]);\n\t\t\t}\n\t\t\treturn curves;\n\t\t},\n\t\n\t\tgetFirstCurve: function() {\n\t\t\treturn this.getCurves()[0];\n\t\t},\n\t\n\t\tgetLastCurve: function() {\n\t\t\tvar curves = this.getCurves();\n\t\t\treturn curves[curves.length - 1];\n\t\t},\n\t\n\t\tisClosed: function() {\n\t\t\treturn this._closed;\n\t\t},\n\t\n\t\tsetClosed: function(closed) {\n\t\t\tif (this._closed != (closed = !!closed)) {\n\t\t\t\tthis._closed = closed;\n\t\t\t\tif (this._curves) {\n\t\t\t\t\tvar length = this._curves.length = this._countCurves();\n\t\t\t\t\tif (closed)\n\t\t\t\t\t\tthis._curves[length - 1] = new Curve(this,\n\t\t\t\t\t\t\tthis._segments[length - 1], this._segments[0]);\n\t\t\t\t}\n\t\t\t\tthis._changed(25);\n\t\t\t}\n\t\t}\n\t}, {\n\t\tbeans: true,\n\t\n\t\tgetPathData: function(_matrix, _precision) {\n\t\t\tvar segments = this._segments,\n\t\t\t\tlength = segments.length,\n\t\t\t\tf = new Formatter(_precision),\n\t\t\t\tcoords = new Array(6),\n\t\t\t\tfirst = true,\n\t\t\t\tcurX, curY,\n\t\t\t\tprevX, prevY,\n\t\t\t\tinX, inY,\n\t\t\t\toutX, outY,\n\t\t\t\tparts = [];\n\t\n\t\t\tfunction addSegment(segment, skipLine) {\n\t\t\t\tsegment._transformCoordinates(_matrix, coords, false);\n\t\t\t\tcurX = coords[0];\n\t\t\t\tcurY = coords[1];\n\t\t\t\tif (first) {\n\t\t\t\t\tparts.push('M' + f.pair(curX, curY));\n\t\t\t\t\tfirst = false;\n\t\t\t\t} else {\n\t\t\t\t\tinX = coords[2];\n\t\t\t\t\tinY = coords[3];\n\t\t\t\t\tif (inX === curX && inY === curY\n\t\t\t\t\t\t\t&& outX === prevX && outY === prevY) {\n\t\t\t\t\t\tif (!skipLine)\n\t\t\t\t\t\t\tparts.push('l' + f.pair(curX - prevX, curY - prevY));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tparts.push('c' + f.pair(outX - prevX, outY - prevY)\n\t\t\t\t\t\t\t\t+ ' ' + f.pair(inX - prevX, inY - prevY)\n\t\t\t\t\t\t\t\t+ ' ' + f.pair(curX - prevX, curY - prevY));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tprevX = curX;\n\t\t\t\tprevY = curY;\n\t\t\t\toutX = coords[4];\n\t\t\t\toutY = coords[5];\n\t\t\t}\n\t\n\t\t\tif (length === 0)\n\t\t\t\treturn '';\n\t\n\t\t\tfor (var i = 0; i < length; i++)\n\t\t\t\taddSegment(segments[i]);\n\t\t\tif (this._closed && length > 0) {\n\t\t\t\taddSegment(segments[0], true);\n\t\t\t\tparts.push('z');\n\t\t\t}\n\t\t\treturn parts.join('');\n\t\t}\n\t}, {\n\t\n\t\tisEmpty: function() {\n\t\t\treturn this._segments.length === 0;\n\t\t},\n\t\n\t\t_transformContent: function(matrix) {\n\t\t\tvar coords = new Array(6);\n\t\t\tfor (var i = 0, l = this._segments.length; i < l; i++)\n\t\t\t\tthis._segments[i]._transformCoordinates(matrix, coords, true);\n\t\t\treturn true;\n\t\t},\n\t\n\t\t_add: function(segs, index) {\n\t\t\tvar segments = this._segments,\n\t\t\t\tcurves = this._curves,\n\t\t\t\tamount = segs.length,\n\t\t\t\tappend = index == null,\n\t\t\t\tindex = append ? segments.length : index;\n\t\t\tfor (var i = 0; i < amount; i++) {\n\t\t\t\tvar segment = segs[i];\n\t\t\t\tif (segment._path)\n\t\t\t\t\tsegment = segs[i] = segment.clone();\n\t\t\t\tsegment._path = this;\n\t\t\t\tsegment._index = index + i;\n\t\t\t\tif (segment._selectionState)\n\t\t\t\t\tthis._updateSelection(segment, 0, segment._selectionState);\n\t\t\t}\n\t\t\tif (append) {\n\t\t\t\tsegments.push.apply(segments, segs);\n\t\t\t} else {\n\t\t\t\tsegments.splice.apply(segments, [index, 0].concat(segs));\n\t\t\t\tfor (var i = index + amount, l = segments.length; i < l; i++)\n\t\t\t\t\tsegments[i]._index = i;\n\t\t\t}\n\t\t\tif (curves) {\n\t\t\t\tvar total = this._countCurves(),\n\t\t\t\t\tfrom = index + amount - 1 === total ? index - 1 : index,\n\t\t\t\t\tstart = from,\n\t\t\t\t\tto = Math.min(from + amount, total);\n\t\t\t\tif (segs._curves) {\n\t\t\t\t\tcurves.splice.apply(curves, [from, 0].concat(segs._curves));\n\t\t\t\t\tstart += segs._curves.length;\n\t\t\t\t}\n\t\t\t\tfor (var i = start; i < to; i++)\n\t\t\t\t\tcurves.splice(i, 0, new Curve(this, null, null));\n\t\t\t\tthis._adjustCurves(from, to);\n\t\t\t}\n\t\t\tthis._changed(25);\n\t\t\treturn segs;\n\t\t},\n\t\n\t\t_adjustCurves: function(from, to) {\n\t\t\tvar segments = this._segments,\n\t\t\t\tcurves = this._curves,\n\t\t\t\tcurve;\n\t\t\tfor (var i = from; i < to; i++) {\n\t\t\t\tcurve = curves[i];\n\t\t\t\tcurve._path = this;\n\t\t\t\tcurve._segment1 = segments[i];\n\t\t\t\tcurve._segment2 = segments[i + 1] || segments[0];\n\t\t\t\tcurve._changed();\n\t\t\t}\n\t\t\tif (curve = curves[this._closed && from === 0 ? segments.length - 1\n\t\t\t\t\t: from - 1]) {\n\t\t\t\tcurve._segment2 = segments[from] || segments[0];\n\t\t\t\tcurve._changed();\n\t\t\t}\n\t\t\tif (curve = curves[to]) {\n\t\t\t\tcurve._segment1 = segments[to];\n\t\t\t\tcurve._changed();\n\t\t\t}\n\t\t},\n\t\n\t\t_countCurves: function() {\n\t\t\tvar length = this._segments.length;\n\t\t\treturn !this._closed && length > 0 ? length - 1 : length;\n\t\t},\n\t\n\t\tadd: function(segment1 ) {\n\t\t\treturn arguments.length > 1 && typeof segment1 !== 'number'\n\t\t\t\t? this._add(Segment.readAll(arguments))\n\t\t\t\t: this._add([ Segment.read(arguments) ])[0];\n\t\t},\n\t\n\t\tinsert: function(index, segment1 ) {\n\t\t\treturn arguments.length > 2 && typeof segment1 !== 'number'\n\t\t\t\t? this._add(Segment.readAll(arguments, 1), index)\n\t\t\t\t: this._add([ Segment.read(arguments, 1) ], index)[0];\n\t\t},\n\t\n\t\taddSegment: function() {\n\t\t\treturn this._add([ Segment.read(arguments) ])[0];\n\t\t},\n\t\n\t\tinsertSegment: function(index ) {\n\t\t\treturn this._add([ Segment.read(arguments, 1) ], index)[0];\n\t\t},\n\t\n\t\taddSegments: function(segments) {\n\t\t\treturn this._add(Segment.readAll(segments));\n\t\t},\n\t\n\t\tinsertSegments: function(index, segments) {\n\t\t\treturn this._add(Segment.readAll(segments), index);\n\t\t},\n\t\n\t\tremoveSegment: function(index) {\n\t\t\treturn this.removeSegments(index, index + 1)[0] || null;\n\t\t},\n\t\n\t\tremoveSegments: function(from, to, _includeCurves) {\n\t\t\tfrom = from || 0;\n\t\t\tto = Base.pick(to, this._segments.length);\n\t\t\tvar segments = this._segments,\n\t\t\t\tcurves = this._curves,\n\t\t\t\tcount = segments.length,\n\t\t\t\tremoved = segments.splice(from, to - from),\n\t\t\t\tamount = removed.length;\n\t\t\tif (!amount)\n\t\t\t\treturn removed;\n\t\t\tfor (var i = 0; i < amount; i++) {\n\t\t\t\tvar segment = removed[i];\n\t\t\t\tif (segment._selectionState)\n\t\t\t\t\tthis._updateSelection(segment, segment._selectionState, 0);\n\t\t\t\tsegment._index = segment._path = null;\n\t\t\t}\n\t\t\tfor (var i = from, l = segments.length; i < l; i++)\n\t\t\t\tsegments[i]._index = i;\n\t\t\tif (curves) {\n\t\t\t\tvar index = from > 0 && to === count + (this._closed ? 1 : 0)\n\t\t\t\t\t\t? from - 1\n\t\t\t\t\t\t: from,\n\t\t\t\t\tcurves = curves.splice(index, amount);\n\t\t\t\tif (_includeCurves)\n\t\t\t\t\tremoved._curves = curves.slice(1);\n\t\t\t\tthis._adjustCurves(index, index);\n\t\t\t}\n\t\t\tthis._changed(25);\n\t\t\treturn removed;\n\t\t},\n\t\n\t\tclear: '#removeSegments',\n\t\n\t\thasHandles: function() {\n\t\t\tvar segments = this._segments;\n\t\t\tfor (var i = 0, l = segments.length; i < l; i++) {\n\t\t\t\tif (segments[i].hasHandles())\n\t\t\t\t\treturn true;\n\t\t\t}\n\t\t\treturn false;\n\t\t},\n\t\n\t\tclearHandles: function() {\n\t\t\tvar segments = this._segments;\n\t\t\tfor (var i = 0, l = segments.length; i < l; i++)\n\t\t\t\tsegments[i].clearHandles();\n\t\t},\n\t\n\t\tgetLength: function() {\n\t\t\tif (this._length == null) {\n\t\t\t\tvar curves = this.getCurves(),\n\t\t\t\t\tlength = 0;\n\t\t\t\tfor (var i = 0, l = curves.length; i < l; i++)\n\t\t\t\t\tlength += curves[i].getLength();\n\t\t\t\tthis._length = length;\n\t\t\t}\n\t\t\treturn this._length;\n\t\t},\n\t\n\t\tgetArea: function() {\n\t\t\tif (this._area == null) {\n\t\t\t\tvar segments = this._segments,\n\t\t\t\t\tcount = segments.length,\n\t\t\t\t\tlast = count - 1,\n\t\t\t\t\tarea = 0;\n\t\t\t\tfor (var i = 0, l = this._closed ? count : last; i < l; i++) {\n\t\t\t\t\tarea += Curve.getArea(Curve.getValues(\n\t\t\t\t\t\t\tsegments[i], segments[i < last ? i + 1 : 0]));\n\t\t\t\t}\n\t\t\t\tthis._area = area;\n\t\t\t}\n\t\t\treturn this._area;\n\t\t},\n\t\n\t\tisClockwise: function() {\n\t\t\tif (this._clockwise !== undefined)\n\t\t\t\treturn this._clockwise;\n\t\t\treturn this.getArea() >= 0;\n\t\t},\n\t\n\t\tsetClockwise: function(clockwise) {\n\t\t\tif (this.isClockwise() != (clockwise = !!clockwise))\n\t\t\t\tthis.reverse();\n\t\t\tthis._clockwise = clockwise;\n\t\t},\n\t\n\t\tisFullySelected: function() {\n\t\t\tvar length = this._segments.length;\n\t\t\treturn this._selected && length > 0 && this._selectedSegmentState\n\t\t\t\t\t=== length * 7;\n\t\t},\n\t\n\t\tsetFullySelected: function(selected) {\n\t\t\tif (selected)\n\t\t\t\tthis._selectSegments(true);\n\t\t\tthis.setSelected(selected);\n\t\t},\n\t\n\t\tsetSelected: function setSelected(selected) {\n\t\t\tif (!selected)\n\t\t\t\tthis._selectSegments(false);\n\t\t\tsetSelected.base.call(this, selected);\n\t\t},\n\t\n\t\t_selectSegments: function(selected) {\n\t\t\tvar length = this._segments.length;\n\t\t\tthis._selectedSegmentState = selected\n\t\t\t\t\t? length * 7 : 0;\n\t\t\tfor (var i = 0; i < length; i++)\n\t\t\t\tthis._segments[i]._selectionState = selected\n\t\t\t\t\t\t? 7 : 0;\n\t\t},\n\t\n\t\t_updateSelection: function(segment, oldState, newState) {\n\t\t\tsegment._selectionState = newState;\n\t\t\tvar total = this._selectedSegmentState += newState - oldState;\n\t\t\tif (total > 0)\n\t\t\t\tthis.setSelected(true);\n\t\t},\n\t\n\t\tflatten: function(maxDistance) {\n\t\t\tvar iterator = new PathIterator(this, 64, 0.1),\n\t\t\t\tpos = 0,\n\t\t\t\tstep = iterator.length / Math.ceil(iterator.length / maxDistance),\n\t\t\t\tend = iterator.length + (this._closed ? -step : step) / 2;\n\t\t\tvar segments = [];\n\t\t\twhile (pos <= end) {\n\t\t\t\tsegments.push(new Segment(iterator.getPointAt(pos)));\n\t\t\t\tpos += step;\n\t\t\t}\n\t\t\tthis.setSegments(segments);\n\t\t},\n\t\n\t\treduce: function() {\n\t\t\tvar curves = this.getCurves();\n\t\t\tfor (var i = curves.length - 1; i >= 0; i--) {\n\t\t\t\tvar curve = curves[i];\n\t\t\t\tif (!curve.hasHandles() && (curve.getLength() === 0\n\t\t\t\t\t\t|| curve.isCollinear(curve.getNext())))\n\t\t\t\t\tcurve.remove();\n\t\t\t}\n\t\t\treturn this;\n\t\t},\n\t\n\t\tsimplify: function(tolerance) {\n\t\t\tif (this._segments.length > 2) {\n\t\t\t\tvar fitter = new PathFitter(this, tolerance || 2.5);\n\t\t\t\tthis.setSegments(fitter.fit());\n\t\t\t}\n\t\t},\n\t\n\t\tsplit: function(index, parameter) {\n\t\t\tif (parameter === null)\n\t\t\t\treturn null;\n\t\t\tif (arguments.length === 1) {\n\t\t\t\tvar arg = index;\n\t\t\t\tif (typeof arg === 'number')\n\t\t\t\t\targ = this.getLocationAt(arg);\n\t\t\t\tif (!arg)\n\t\t\t\t\treturn null\n\t\t\t\tindex = arg.index;\n\t\t\t\tparameter = arg.parameter;\n\t\t\t}\n\t\t\tvar tMin = 4e-7,\n\t\t\t\ttMax = 1 - tMin;\n\t\t\tif (parameter >= tMax) {\n\t\t\t\tindex++;\n\t\t\t\tparameter--;\n\t\t\t}\n\t\t\tvar curves = this.getCurves();\n\t\t\tif (index >= 0 && index < curves.length) {\n\t\t\t\tif (parameter >= tMin) {\n\t\t\t\t\tcurves[index++].divide(parameter, true);\n\t\t\t\t}\n\t\t\t\tvar segs = this.removeSegments(index, this._segments.length, true),\n\t\t\t\t\tpath;\n\t\t\t\tif (this._closed) {\n\t\t\t\t\tthis.setClosed(false);\n\t\t\t\t\tpath = this;\n\t\t\t\t} else {\n\t\t\t\t\tpath = new Path(Item.NO_INSERT);\n\t\t\t\t\tpath.insertAbove(this, true);\n\t\t\t\t\tthis._clone(path);\n\t\t\t\t}\n\t\t\t\tpath._add(segs, 0);\n\t\t\t\tthis.addSegment(segs[0]);\n\t\t\t\treturn path;\n\t\t\t}\n\t\t\treturn null;\n\t\t},\n\t\n\t\treverse: function() {\n\t\t\tthis._segments.reverse();\n\t\t\tfor (var i = 0, l = this._segments.length; i < l; i++) {\n\t\t\t\tvar segment = this._segments[i];\n\t\t\t\tvar handleIn = segment._handleIn;\n\t\t\t\tsegment._handleIn = segment._handleOut;\n\t\t\t\tsegment._handleOut = handleIn;\n\t\t\t\tsegment._index = i;\n\t\t\t}\n\t\t\tthis._curves = null;\n\t\t\tif (this._clockwise !== undefined)\n\t\t\t\tthis._clockwise = !this._clockwise;\n\t\t\tthis._changed(9);\n\t\t},\n\t\n\t\tjoin: function(path) {\n\t\t\tif (path) {\n\t\t\t\tvar segments = path._segments,\n\t\t\t\t\tlast1 = this.getLastSegment(),\n\t\t\t\t\tlast2 = path.getLastSegment();\n\t\t\t\tif (!last2)\n\t\t\t\t\treturn this;\n\t\t\t\tif (last1 && last1._point.equals(last2._point))\n\t\t\t\t\tpath.reverse();\n\t\t\t\tvar first2 = path.getFirstSegment();\n\t\t\t\tif (last1 && last1._point.equals(first2._point)) {\n\t\t\t\t\tlast1.setHandleOut(first2._handleOut);\n\t\t\t\t\tthis._add(segments.slice(1));\n\t\t\t\t} else {\n\t\t\t\t\tvar first1 = this.getFirstSegment();\n\t\t\t\t\tif (first1 && first1._point.equals(first2._point))\n\t\t\t\t\t\tpath.reverse();\n\t\t\t\t\tlast2 = path.getLastSegment();\n\t\t\t\t\tif (first1 && first1._point.equals(last2._point)) {\n\t\t\t\t\t\tfirst1.setHandleIn(last2._handleIn);\n\t\t\t\t\t\tthis._add(segments.slice(0, segments.length - 1), 0);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis._add(segments.slice());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (path._closed)\n\t\t\t\t\tthis._add([segments[0]]);\n\t\t\t\tpath.remove();\n\t\t\t}\n\t\t\tvar first = this.getFirstSegment(),\n\t\t\t\tlast = this.getLastSegment();\n\t\t\tif (first !== last && first._point.equals(last._point)) {\n\t\t\t\tfirst.setHandleIn(last._handleIn);\n\t\t\t\tlast.remove();\n\t\t\t\tthis.setClosed(true);\n\t\t\t}\n\t\t\treturn this;\n\t\t},\n\t\n\t\ttoShape: function(insert) {\n\t\t\tif (!this._closed)\n\t\t\t\treturn null;\n\t\n\t\t\tvar segments = this._segments,\n\t\t\t\ttype,\n\t\t\t\tsize,\n\t\t\t\tradius,\n\t\t\t\ttopCenter;\n\t\n\t\t\tfunction isCollinear(i, j) {\n\t\t\t\tvar seg1 = segments[i],\n\t\t\t\t\tseg2 = seg1.getNext(),\n\t\t\t\t\tseg3 = segments[j],\n\t\t\t\t\tseg4 = seg3.getNext();\n\t\t\t\treturn seg1._handleOut.isZero() && seg2._handleIn.isZero()\n\t\t\t\t\t\t&& seg3._handleOut.isZero() && seg4._handleIn.isZero()\n\t\t\t\t\t\t&& seg2._point.subtract(seg1._point).isCollinear(\n\t\t\t\t\t\t\tseg4._point.subtract(seg3._point));\n\t\t\t}\n\t\n\t\t\tfunction isOrthogonal(i) {\n\t\t\t\tvar seg2 = segments[i],\n\t\t\t\t\tseg1 = seg2.getPrevious(),\n\t\t\t\t\tseg3 = seg2.getNext();\n\t\t\t\treturn seg1._handleOut.isZero() && seg2._handleIn.isZero()\n\t\t\t\t\t\t&& seg2._handleOut.isZero() && seg3._handleIn.isZero()\n\t\t\t\t\t\t&& seg2._point.subtract(seg1._point).isOrthogonal(\n\t\t\t\t\t\t\tseg3._point.subtract(seg2._point));\n\t\t\t}\n\t\n\t\t\tfunction isArc(i) {\n\t\t\t\tvar seg1 = segments[i],\n\t\t\t\t\tseg2 = seg1.getNext(),\n\t\t\t\t\thandle1 = seg1._handleOut,\n\t\t\t\t\thandle2 = seg2._handleIn,\n\t\t\t\t\tkappa = 0.5522847498307936;\n\t\t\t\tif (handle1.isOrthogonal(handle2)) {\n\t\t\t\t\tvar pt1 = seg1._point,\n\t\t\t\t\t\tpt2 = seg2._point,\n\t\t\t\t\t\tcorner = new Line(pt1, handle1, true).intersect(\n\t\t\t\t\t\t\t\tnew Line(pt2, handle2, true), true);\n\t\t\t\t\treturn corner && Numerical.isZero(handle1.getLength() /\n\t\t\t\t\t\t\tcorner.subtract(pt1).getLength() - kappa)\n\t\t\t\t\t\t&& Numerical.isZero(handle2.getLength() /\n\t\t\t\t\t\t\tcorner.subtract(pt2).getLength() - kappa);\n\t\t\t\t}\n\t\t\t\treturn false;\n\t\t\t}\n\t\n\t\t\tfunction getDistance(i, j) {\n\t\t\t\treturn segments[i]._point.getDistance(segments[j]._point);\n\t\t\t}\n\t\n\t\t\tif (!this.hasHandles() && segments.length === 4\n\t\t\t\t\t&& isCollinear(0, 2) && isCollinear(1, 3) && isOrthogonal(1)) {\n\t\t\t\ttype = Shape.Rectangle;\n\t\t\t\tsize = new Size(getDistance(0, 3), getDistance(0, 1));\n\t\t\t\ttopCenter = segments[1]._point.add(segments[2]._point).divide(2);\n\t\t\t} else if (segments.length === 8 && isArc(0) && isArc(2) && isArc(4)\n\t\t\t\t\t&& isArc(6) && isCollinear(1, 5) && isCollinear(3, 7)) {\n\t\t\t\ttype = Shape.Rectangle;\n\t\t\t\tsize = new Size(getDistance(1, 6), getDistance(0, 3));\n\t\t\t\tradius = size.subtract(new Size(getDistance(0, 7),\n\t\t\t\t\t\tgetDistance(1, 2))).divide(2);\n\t\t\t\ttopCenter = segments[3]._point.add(segments[4]._point).divide(2);\n\t\t\t} else if (segments.length === 4\n\t\t\t\t\t&& isArc(0) && isArc(1) && isArc(2) && isArc(3)) {\n\t\t\t\tif (Numerical.isZero(getDistance(0, 2) - getDistance(1, 3))) {\n\t\t\t\t\ttype = Shape.Circle;\n\t\t\t\t\tradius = getDistance(0, 2) / 2;\n\t\t\t\t} else {\n\t\t\t\t\ttype = Shape.Ellipse;\n\t\t\t\t\tradius = new Size(getDistance(2, 0) / 2, getDistance(3, 1) / 2);\n\t\t\t\t}\n\t\t\t\ttopCenter = segments[1]._point;\n\t\t\t}\n\t\n\t\t\tif (type) {\n\t\t\t\tvar center = this.getPosition(true),\n\t\t\t\t\tshape = this._clone(new type({\n\t\t\t\t\t\tcenter: center,\n\t\t\t\t\t\tsize: size,\n\t\t\t\t\t\tradius: radius,\n\t\t\t\t\t\tinsert: false\n\t\t\t\t\t}), insert, false);\n\t\t\t\tshape.rotate(topCenter.subtract(center).getAngle() + 90);\n\t\t\t\treturn shape;\n\t\t\t}\n\t\t\treturn null;\n\t\t},\n\t\n\t\t_hitTestSelf: function(point, options) {\n\t\t\tvar that = this,\n\t\t\t\tstyle = this.getStyle(),\n\t\t\t\tsegments = this._segments,\n\t\t\t\tnumSegments = segments.length,\n\t\t\t\tclosed = this._closed,\n\t\t\t\ttolerancePadding = options._tolerancePadding,\n\t\t\t\tstrokePadding = tolerancePadding,\n\t\t\t\tjoin, cap, miterLimit,\n\t\t\t\tarea, loc, res,\n\t\t\t\thitStroke = options.stroke && style.hasStroke(),\n\t\t\t\thitFill = options.fill && style.hasFill(),\n\t\t\t\thitCurves = options.curves,\n\t\t\t\tradius = hitStroke\n\t\t\t\t\t\t? style.getStrokeWidth() / 2\n\t\t\t\t\t\t: hitFill && options.tolerance > 0 || hitCurves\n\t\t\t\t\t\t\t? 0 : null;\n\t\t\tif (radius !== null) {\n\t\t\t\tif (radius > 0) {\n\t\t\t\t\tjoin = style.getStrokeJoin();\n\t\t\t\t\tcap = style.getStrokeCap();\n\t\t\t\t\tmiterLimit = radius * style.getMiterLimit();\n\t\t\t\t\tstrokePadding = tolerancePadding.add(new Point(radius, radius));\n\t\t\t\t} else {\n\t\t\t\t\tjoin = cap = 'round';\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\tfunction isCloseEnough(pt, padding) {\n\t\t\t\treturn point.subtract(pt).divide(padding).length <= 1;\n\t\t\t}\n\t\n\t\t\tfunction checkSegmentPoint(seg, pt, name) {\n\t\t\t\tif (!options.selected || pt.isSelected()) {\n\t\t\t\t\tvar anchor = seg._point;\n\t\t\t\t\tif (pt !== anchor)\n\t\t\t\t\t\tpt = pt.add(anchor);\n\t\t\t\t\tif (isCloseEnough(pt, strokePadding)) {\n\t\t\t\t\t\treturn new HitResult(name, that, {\n\t\t\t\t\t\t\tsegment: seg,\n\t\t\t\t\t\t\tpoint: pt\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\tfunction checkSegmentPoints(seg, ends) {\n\t\t\t\treturn (ends || options.segments)\n\t\t\t\t\t&& checkSegmentPoint(seg, seg._point, 'segment')\n\t\t\t\t\t|| (!ends && options.handles) && (\n\t\t\t\t\t\tcheckSegmentPoint(seg, seg._handleIn, 'handle-in') ||\n\t\t\t\t\t\tcheckSegmentPoint(seg, seg._handleOut, 'handle-out'));\n\t\t\t}\n\t\n\t\t\tfunction addToArea(point) {\n\t\t\t\tarea.add(point);\n\t\t\t}\n\t\n\t\t\tfunction checkSegmentStroke(segment) {\n\t\t\t\tif (join !== 'round' || cap !== 'round') {\n\t\t\t\t\tarea = new Path({ internal: true, closed: true });\n\t\t\t\t\tif (closed || segment._index > 0\n\t\t\t\t\t\t\t&& segment._index < numSegments - 1) {\n\t\t\t\t\t\tif (join !== 'round' && (segment._handleIn.isZero()\n\t\t\t\t\t\t\t\t|| segment._handleOut.isZero()))\n\t\t\t\t\t\t\tPath._addBevelJoin(segment, join, radius, miterLimit,\n\t\t\t\t\t\t\t\t\taddToArea, true);\n\t\t\t\t\t} else if (cap !== 'round') {\n\t\t\t\t\t\tPath._addSquareCap(segment, cap, radius, addToArea, true);\n\t\t\t\t\t}\n\t\t\t\t\tif (!area.isEmpty()) {\n\t\t\t\t\t\tvar loc;\n\t\t\t\t\t\treturn area.contains(point)\n\t\t\t\t\t\t\t|| (loc = area.getNearestLocation(point))\n\t\t\t\t\t\t\t\t&& isCloseEnough(loc.getPoint(), tolerancePadding);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn isCloseEnough(segment._point, strokePadding);\n\t\t\t}\n\t\n\t\t\tif (options.ends && !options.segments && !closed) {\n\t\t\t\tif (res = checkSegmentPoints(segments[0], true)\n\t\t\t\t\t\t|| checkSegmentPoints(segments[numSegments - 1], true))\n\t\t\t\t\treturn res;\n\t\t\t} else if (options.segments || options.handles) {\n\t\t\t\tfor (var i = 0; i < numSegments; i++)\n\t\t\t\t\tif (res = checkSegmentPoints(segments[i]))\n\t\t\t\t\t\treturn res;\n\t\t\t}\n\t\t\tif (radius !== null) {\n\t\t\t\tloc = this.getNearestLocation(point);\n\t\t\t\tif (loc) {\n\t\t\t\t\tvar parameter = loc.getParameter();\n\t\t\t\t\tif (parameter === 0 || parameter === 1 && numSegments > 1) {\n\t\t\t\t\t\tif (!checkSegmentStroke(loc.getSegment()))\n\t\t\t\t\t\t\tloc = null;\n\t\t\t\t\t} else if (!isCloseEnough(loc.getPoint(), strokePadding)) {\n\t\t\t\t\t\tloc = null;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!loc && join === 'miter' && numSegments > 1) {\n\t\t\t\t\tfor (var i = 0; i < numSegments; i++) {\n\t\t\t\t\t\tvar segment = segments[i];\n\t\t\t\t\t\tif (point.getDistance(segment._point) <= miterLimit\n\t\t\t\t\t\t\t\t&& checkSegmentStroke(segment)) {\n\t\t\t\t\t\t\tloc = segment.getLocation();\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn !loc && hitFill && this._contains(point)\n\t\t\t\t\t|| loc && !hitStroke && !hitCurves\n\t\t\t\t\t\t? new HitResult('fill', this)\n\t\t\t\t\t\t: loc\n\t\t\t\t\t\t\t? new HitResult(hitStroke ? 'stroke' : 'curve', this, {\n\t\t\t\t\t\t\t\tlocation: loc,\n\t\t\t\t\t\t\t\tpoint: loc.getPoint()\n\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\t: null;\n\t\t}\n\t\n\t}, Base.each(Curve.evaluateMethods,\n\t\tfunction(name) {\n\t\t\tthis[name + 'At'] = function(offset, isParameter) {\n\t\t\t\tvar loc = this.getLocationAt(offset, isParameter);\n\t\t\t\treturn loc && loc[name]();\n\t\t\t};\n\t\t},\n\t{\n\t\tbeans: false,\n\t\n\t\tgetLocationOf: function() {\n\t\t\tvar point = Point.read(arguments),\n\t\t\t\tcurves = this.getCurves();\n\t\t\tfor (var i = 0, l = curves.length; i < l; i++) {\n\t\t\t\tvar loc = curves[i].getLocationOf(point);\n\t\t\t\tif (loc)\n\t\t\t\t\treturn loc;\n\t\t\t}\n\t\t\treturn null;\n\t\t},\n\t\n\t\tgetOffsetOf: function() {\n\t\t\tvar loc = this.getLocationOf.apply(this, arguments);\n\t\t\treturn loc ? loc.getOffset() : null;\n\t\t},\n\t\n\t\tgetLocationAt: function(offset, isParameter) {\n\t\t\tvar curves = this.getCurves(),\n\t\t\t\tlength = 0;\n\t\t\tif (isParameter) {\n\t\t\t\tvar index = ~~offset,\n\t\t\t\t\tcurve = curves[index];\n\t\t\t\treturn curve ? curve.getLocationAt(offset - index, true) : null;\n\t\t\t}\n\t\t\tfor (var i = 0, l = curves.length; i < l; i++) {\n\t\t\t\tvar start = length,\n\t\t\t\t\tcurve = curves[i];\n\t\t\t\tlength += curve.getLength();\n\t\t\t\tif (length > offset) {\n\t\t\t\t\treturn curve.getLocationAt(offset - start);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (curves.length > 0 && offset <= this.getLength())\n\t\t\t\treturn new CurveLocation(curves[curves.length - 1], 1);\n\t\t\treturn null;\n\t\t},\n\t\n\t\tgetNearestLocation: function() {\n\t\t\tvar point = Point.read(arguments),\n\t\t\t\tcurves = this.getCurves(),\n\t\t\t\tminDist = Infinity,\n\t\t\t\tminLoc = null;\n\t\t\tfor (var i = 0, l = curves.length; i < l; i++) {\n\t\t\t\tvar loc = curves[i].getNearestLocation(point);\n\t\t\t\tif (loc._distance < minDist) {\n\t\t\t\t\tminDist = loc._distance;\n\t\t\t\t\tminLoc = loc;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn minLoc;\n\t\t},\n\t\n\t\tgetNearestPoint: function() {\n\t\t\treturn this.getNearestLocation.apply(this, arguments).getPoint();\n\t\t}\n\t}),\n\tnew function() {\n\t\n\t\tfunction drawHandles(ctx, segments, matrix, size) {\n\t\t\tvar half = size / 2;\n\t\n\t\t\tfunction drawHandle(index) {\n\t\t\t\tvar hX = coords[index],\n\t\t\t\t\thY = coords[index + 1];\n\t\t\t\tif (pX != hX || pY != hY) {\n\t\t\t\t\tctx.beginPath();\n\t\t\t\t\tctx.moveTo(pX, pY);\n\t\t\t\t\tctx.lineTo(hX, hY);\n\t\t\t\t\tctx.stroke();\n\t\t\t\t\tctx.beginPath();\n\t\t\t\t\tctx.arc(hX, hY, half, 0, Math.PI * 2, true);\n\t\t\t\t\tctx.fill();\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\tvar coords = new Array(6);\n\t\t\tfor (var i = 0, l = segments.length; i < l; i++) {\n\t\t\t\tvar segment = segments[i];\n\t\t\t\tsegment._transformCoordinates(matrix, coords, false);\n\t\t\t\tvar state = segment._selectionState,\n\t\t\t\t\tpX = coords[0],\n\t\t\t\t\tpY = coords[1];\n\t\t\t\tif (state & 1)\n\t\t\t\t\tdrawHandle(2);\n\t\t\t\tif (state & 2)\n\t\t\t\t\tdrawHandle(4);\n\t\t\t\tctx.fillRect(pX - half, pY - half, size, size);\n\t\t\t\tif (!(state & 4)) {\n\t\t\t\t\tvar fillStyle = ctx.fillStyle;\n\t\t\t\t\tctx.fillStyle = '#ffffff';\n\t\t\t\t\tctx.fillRect(pX - half + 1, pY - half + 1, size - 2, size - 2);\n\t\t\t\t\tctx.fillStyle = fillStyle;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\n\t\tfunction drawSegments(ctx, path, matrix) {\n\t\t\tvar segments = path._segments,\n\t\t\t\tlength = segments.length,\n\t\t\t\tcoords = new Array(6),\n\t\t\t\tfirst = true,\n\t\t\t\tcurX, curY,\n\t\t\t\tprevX, prevY,\n\t\t\t\tinX, inY,\n\t\t\t\toutX, outY;\n\t\n\t\t\tfunction drawSegment(segment) {\n\t\t\t\tif (matrix) {\n\t\t\t\t\tsegment._transformCoordinates(matrix, coords, false);\n\t\t\t\t\tcurX = coords[0];\n\t\t\t\t\tcurY = coords[1];\n\t\t\t\t} else {\n\t\t\t\t\tvar point = segment._point;\n\t\t\t\t\tcurX = point._x;\n\t\t\t\t\tcurY = point._y;\n\t\t\t\t}\n\t\t\t\tif (first) {\n\t\t\t\t\tctx.moveTo(curX, curY);\n\t\t\t\t\tfirst = false;\n\t\t\t\t} else {\n\t\t\t\t\tif (matrix) {\n\t\t\t\t\t\tinX = coords[2];\n\t\t\t\t\t\tinY = coords[3];\n\t\t\t\t\t} else {\n\t\t\t\t\t\tvar handle = segment._handleIn;\n\t\t\t\t\t\tinX = curX + handle._x;\n\t\t\t\t\t\tinY = curY + handle._y;\n\t\t\t\t\t}\n\t\t\t\t\tif (inX === curX && inY === curY\n\t\t\t\t\t\t\t&& outX === prevX && outY === prevY) {\n\t\t\t\t\t\tctx.lineTo(curX, curY);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tctx.bezierCurveTo(outX, outY, inX, inY, curX, curY);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tprevX = curX;\n\t\t\t\tprevY = curY;\n\t\t\t\tif (matrix) {\n\t\t\t\t\toutX = coords[4];\n\t\t\t\t\toutY = coords[5];\n\t\t\t\t} else {\n\t\t\t\t\tvar handle = segment._handleOut;\n\t\t\t\t\toutX = prevX + handle._x;\n\t\t\t\t\toutY = prevY + handle._y;\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\tfor (var i = 0; i < length; i++)\n\t\t\t\tdrawSegment(segments[i]);\n\t\t\tif (path._closed && length > 0)\n\t\t\t\tdrawSegment(segments[0]);\n\t\t}\n\t\n\t\treturn {\n\t\t\t_draw: function(ctx, param, strokeMatrix) {\n\t\t\t\tvar dontStart = param.dontStart,\n\t\t\t\t\tdontPaint = param.dontFinish || param.clip,\n\t\t\t\t\tstyle = this.getStyle(),\n\t\t\t\t\thasFill = style.hasFill(),\n\t\t\t\t\thasStroke = style.hasStroke(),\n\t\t\t\t\tdashArray = style.getDashArray(),\n\t\t\t\t\tdashLength = !paper.support.nativeDash && hasStroke\n\t\t\t\t\t\t\t&& dashArray && dashArray.length;\n\t\n\t\t\t\tif (!dontStart)\n\t\t\t\t\tctx.beginPath();\n\t\n\t\t\t\tif (!dontStart && this._currentPath) {\n\t\t\t\t\tctx.currentPath = this._currentPath;\n\t\t\t\t} else if (hasFill || hasStroke && !dashLength || dontPaint) {\n\t\t\t\t\tdrawSegments(ctx, this, strokeMatrix);\n\t\t\t\t\tif (this._closed)\n\t\t\t\t\t\tctx.closePath();\n\t\t\t\t\tif (!dontStart)\n\t\t\t\t\t\tthis._currentPath = ctx.currentPath;\n\t\t\t\t}\n\t\n\t\t\t\tfunction getOffset(i) {\n\t\t\t\t\treturn dashArray[((i % dashLength) + dashLength) % dashLength];\n\t\t\t\t}\n\t\n\t\t\t\tif (!dontPaint && (hasFill || hasStroke)) {\n\t\t\t\t\tthis._setStyles(ctx);\n\t\t\t\t\tif (hasFill) {\n\t\t\t\t\t\tctx.fill(style.getWindingRule());\n\t\t\t\t\t\tctx.shadowColor = 'rgba(0,0,0,0)';\n\t\t\t\t\t}\n\t\t\t\t\tif (hasStroke) {\n\t\t\t\t\t\tif (dashLength) {\n\t\t\t\t\t\t\tif (!dontStart)\n\t\t\t\t\t\t\t\tctx.beginPath();\n\t\t\t\t\t\t\tvar iterator = new PathIterator(this, 32, 0.25,\n\t\t\t\t\t\t\t\t\tstrokeMatrix),\n\t\t\t\t\t\t\t\tlength = iterator.length,\n\t\t\t\t\t\t\t\tfrom = -style.getDashOffset(), to,\n\t\t\t\t\t\t\t\ti = 0;\n\t\t\t\t\t\t\tfrom = from % length;\n\t\t\t\t\t\t\twhile (from > 0) {\n\t\t\t\t\t\t\t\tfrom -= getOffset(i--) + getOffset(i--);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\twhile (from < length) {\n\t\t\t\t\t\t\t\tto = from + getOffset(i++);\n\t\t\t\t\t\t\t\tif (from > 0 || to > 0)\n\t\t\t\t\t\t\t\t\titerator.drawPart(ctx,\n\t\t\t\t\t\t\t\t\t\t\tMath.max(from, 0), Math.max(to, 0));\n\t\t\t\t\t\t\t\tfrom = to + getOffset(i++);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tctx.stroke();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\n\t\t\t_drawSelected: function(ctx, matrix) {\n\t\t\t\tctx.beginPath();\n\t\t\t\tdrawSegments(ctx, this, matrix);\n\t\t\t\tctx.stroke();\n\t\t\t\tdrawHandles(ctx, this._segments, matrix, paper.settings.handleSize);\n\t\t\t}\n\t\t};\n\t},\n\tnew function() {\n\t\tfunction getFirstControlPoints(rhs) {\n\t\t\tvar n = rhs.length,\n\t\t\t\tx = [],\n\t\t\t\ttmp = [],\n\t\t\t\tb = 2;\n\t\t\tx[0] = rhs[0] / b;\n\t\t\tfor (var i = 1; i < n; i++) {\n\t\t\t\ttmp[i] = 1 / b;\n\t\t\t\tb = (i < n - 1 ? 4 : 2) - tmp[i];\n\t\t\t\tx[i] = (rhs[i] - x[i - 1]) / b;\n\t\t\t}\n\t\t\tfor (var i = 1; i < n; i++) {\n\t\t\t\tx[n - i - 1] -= tmp[n - i] * x[n - i];\n\t\t\t}\n\t\t\treturn x;\n\t\t}\n\t\n\t\treturn {\n\t\t\tsmooth: function() {\n\t\t\t\tvar segments = this._segments,\n\t\t\t\t\tsize = segments.length,\n\t\t\t\t\tclosed = this._closed,\n\t\t\t\t\tn = size,\n\t\t\t\t\toverlap = 0;\n\t\t\t\tif (size <= 2)\n\t\t\t\t\treturn;\n\t\t\t\tif (closed) {\n\t\t\t\t\toverlap = Math.min(size, 4);\n\t\t\t\t\tn += Math.min(size, overlap) * 2;\n\t\t\t\t}\n\t\t\t\tvar knots = [];\n\t\t\t\tfor (var i = 0; i < size; i++)\n\t\t\t\t\tknots[i + overlap] = segments[i]._point;\n\t\t\t\tif (closed) {\n\t\t\t\t\tfor (var i = 0; i < overlap; i++) {\n\t\t\t\t\t\tknots[i] = segments[i + size - overlap]._point;\n\t\t\t\t\t\tknots[i + size + overlap] = segments[i]._point;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tn--;\n\t\t\t\t}\n\t\t\t\tvar rhs = [];\n\t\n\t\t\t\tfor (var i = 1; i < n - 1; i++)\n\t\t\t\t\trhs[i] = 4 * knots[i]._x + 2 * knots[i + 1]._x;\n\t\t\t\trhs[0] = knots[0]._x + 2 * knots[1]._x;\n\t\t\t\trhs[n - 1] = 3 * knots[n - 1]._x;\n\t\t\t\tvar x = getFirstControlPoints(rhs);\n\t\n\t\t\t\tfor (var i = 1; i < n - 1; i++)\n\t\t\t\t\trhs[i] = 4 * knots[i]._y + 2 * knots[i + 1]._y;\n\t\t\t\trhs[0] = knots[0]._y + 2 * knots[1]._y;\n\t\t\t\trhs[n - 1] = 3 * knots[n - 1]._y;\n\t\t\t\tvar y = getFirstControlPoints(rhs);\n\t\n\t\t\t\tif (closed) {\n\t\t\t\t\tfor (var i = 0, j = size; i < overlap; i++, j++) {\n\t\t\t\t\t\tvar f1 = i / overlap,\n\t\t\t\t\t\t\tf2 = 1 - f1,\n\t\t\t\t\t\t\tie = i + overlap,\n\t\t\t\t\t\t\tje = j + overlap;\n\t\t\t\t\t\tx[j] = x[i] * f1 + x[j] * f2;\n\t\t\t\t\t\ty[j] = y[i] * f1 + y[j] * f2;\n\t\t\t\t\t\tx[je] = x[ie] * f2 + x[je] * f1;\n\t\t\t\t\t\ty[je] = y[ie] * f2 + y[je] * f1;\n\t\t\t\t\t}\n\t\t\t\t\tn--;\n\t\t\t\t}\n\t\t\t\tvar handleIn = null;\n\t\t\t\tfor (var i = overlap; i <= n - overlap; i++) {\n\t\t\t\t\tvar segment = segments[i - overlap];\n\t\t\t\t\tif (handleIn)\n\t\t\t\t\t\tsegment.setHandleIn(handleIn.subtract(segment._point));\n\t\t\t\t\tif (i < n) {\n\t\t\t\t\t\tsegment.setHandleOut(\n\t\t\t\t\t\t\t\tnew Point(x[i], y[i]).subtract(segment._point));\n\t\t\t\t\t\thandleIn = i < n - 1\n\t\t\t\t\t\t\t\t? new Point(\n\t\t\t\t\t\t\t\t\t2 * knots[i + 1]._x - x[i + 1],\n\t\t\t\t\t\t\t\t\t2 * knots[i + 1]._y - y[i + 1])\n\t\t\t\t\t\t\t\t: new Point(\n\t\t\t\t\t\t\t\t\t(knots[n]._x + x[n - 1]) / 2,\n\t\t\t\t\t\t\t\t\t(knots[n]._y + y[n - 1]) / 2);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (closed && handleIn) {\n\t\t\t\t\tvar segment = this._segments[0];\n\t\t\t\t\tsegment.setHandleIn(handleIn.subtract(segment._point));\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t},\n\tnew function() {\n\t\tfunction getCurrentSegment(that) {\n\t\t\tvar segments = that._segments;\n\t\t\tif (segments.length === 0)\n\t\t\t\tthrow new Error('Use a moveTo() command first');\n\t\t\treturn segments[segments.length - 1];\n\t\t}\n\t\n\t\treturn {\n\t\t\tmoveTo: function() {\n\t\t\t\tvar segments = this._segments;\n\t\t\t\tif (segments.length === 1)\n\t\t\t\t\tthis.removeSegment(0);\n\t\t\t\tif (!segments.length)\n\t\t\t\t\tthis._add([ new Segment(Point.read(arguments)) ]);\n\t\t\t},\n\t\n\t\t\tmoveBy: function() {\n\t\t\t\tthrow new Error('moveBy() is unsupported on Path items.');\n\t\t\t},\n\t\n\t\t\tlineTo: function() {\n\t\t\t\tthis._add([ new Segment(Point.read(arguments)) ]);\n\t\t\t},\n\t\n\t\t\tcubicCurveTo: function() {\n\t\t\t\tvar handle1 = Point.read(arguments),\n\t\t\t\t\thandle2 = Point.read(arguments),\n\t\t\t\t\tto = Point.read(arguments),\n\t\t\t\t\tcurrent = getCurrentSegment(this);\n\t\t\t\tcurrent.setHandleOut(handle1.subtract(current._point));\n\t\t\t\tthis._add([ new Segment(to, handle2.subtract(to)) ]);\n\t\t\t},\n\t\n\t\t\tquadraticCurveTo: function() {\n\t\t\t\tvar handle = Point.read(arguments),\n\t\t\t\t\tto = Point.read(arguments),\n\t\t\t\t\tcurrent = getCurrentSegment(this)._point;\n\t\t\t\tthis.cubicCurveTo(\n\t\t\t\t\thandle.add(current.subtract(handle).multiply(1 / 3)),\n\t\t\t\t\thandle.add(to.subtract(handle).multiply(1 / 3)),\n\t\t\t\t\tto\n\t\t\t\t);\n\t\t\t},\n\t\n\t\t\tcurveTo: function() {\n\t\t\t\tvar through = Point.read(arguments),\n\t\t\t\t\tto = Point.read(arguments),\n\t\t\t\t\tt = Base.pick(Base.read(arguments), 0.5),\n\t\t\t\t\tt1 = 1 - t,\n\t\t\t\t\tcurrent = getCurrentSegment(this)._point,\n\t\t\t\t\thandle = through.subtract(current.multiply(t1 * t1))\n\t\t\t\t\t\t.subtract(to.multiply(t * t)).divide(2 * t * t1);\n\t\t\t\tif (handle.isNaN())\n\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t'Cannot put a curve through points with parameter = ' + t);\n\t\t\t\tthis.quadraticCurveTo(handle, to);\n\t\t\t},\n\t\n\t\t\tarcTo: function() {\n\t\t\t\tvar current = getCurrentSegment(this),\n\t\t\t\t\tfrom = current._point,\n\t\t\t\t\tto = Point.read(arguments),\n\t\t\t\t\tthrough,\n\t\t\t\t\tpeek = Base.peek(arguments),\n\t\t\t\t\tclockwise = Base.pick(peek, true),\n\t\t\t\t\tcenter, extent, vector, matrix;\n\t\t\t\tif (typeof clockwise === 'boolean') {\n\t\t\t\t\tvar middle = from.add(to).divide(2),\n\t\t\t\t\tthrough = middle.add(middle.subtract(from).rotate(\n\t\t\t\t\t\t\tclockwise ? -90 : 90));\n\t\t\t\t} else if (Base.remain(arguments) <= 2) {\n\t\t\t\t\tthrough = to;\n\t\t\t\t\tto = Point.read(arguments);\n\t\t\t\t} else {\n\t\t\t\t\tvar radius = Size.read(arguments);\n\t\t\t\t\tif (radius.isZero())\n\t\t\t\t\t\treturn this.lineTo(to);\n\t\t\t\t\tvar rotation = Base.read(arguments),\n\t\t\t\t\t\tclockwise = !!Base.read(arguments),\n\t\t\t\t\t\tlarge = !!Base.read(arguments),\n\t\t\t\t\t\tmiddle = from.add(to).divide(2),\n\t\t\t\t\t\tpt = from.subtract(middle).rotate(-rotation),\n\t\t\t\t\t\tx = pt.x,\n\t\t\t\t\t\ty = pt.y,\n\t\t\t\t\t\tabs = Math.abs,\n\t\t\t\t\t\trx = abs(radius.width),\n\t\t\t\t\t\try = abs(radius.height),\n\t\t\t\t\t\trxSq = rx * rx,\n\t\t\t\t\t\trySq = ry * ry,\n\t\t\t\t\t\txSq =  x * x,\n\t\t\t\t\t\tySq =  y * y;\n\t\t\t\t\tvar factor = Math.sqrt(xSq / rxSq + ySq / rySq);\n\t\t\t\t\tif (factor > 1) {\n\t\t\t\t\t\trx *= factor;\n\t\t\t\t\t\try *= factor;\n\t\t\t\t\t\trxSq = rx * rx;\n\t\t\t\t\t\trySq = ry * ry;\n\t\t\t\t\t}\n\t\t\t\t\tfactor = (rxSq * rySq - rxSq * ySq - rySq * xSq) /\n\t\t\t\t\t\t\t(rxSq * ySq + rySq * xSq);\n\t\t\t\t\tif (abs(factor) < 1e-12)\n\t\t\t\t\t\tfactor = 0;\n\t\t\t\t\tif (factor < 0)\n\t\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t\t\t'Cannot create an arc with the given arguments');\n\t\t\t\t\tcenter = new Point(rx * y / ry, -ry * x / rx)\n\t\t\t\t\t\t\t.multiply((large === clockwise ? -1 : 1)\n\t\t\t\t\t\t\t\t* Math.sqrt(factor))\n\t\t\t\t\t\t\t.rotate(rotation).add(middle);\n\t\t\t\t\tmatrix = new Matrix().translate(center).rotate(rotation)\n\t\t\t\t\t\t\t.scale(rx, ry);\n\t\t\t\t\tvector = matrix._inverseTransform(from);\n\t\t\t\t\textent = vector.getDirectedAngle(matrix._inverseTransform(to));\n\t\t\t\t\tif (!clockwise && extent > 0)\n\t\t\t\t\t\textent -= 360;\n\t\t\t\t\telse if (clockwise && extent < 0)\n\t\t\t\t\t\textent += 360;\n\t\t\t\t}\n\t\t\t\tif (through) {\n\t\t\t\t\tvar l1 = new Line(from.add(through).divide(2),\n\t\t\t\t\t\t\t\tthrough.subtract(from).rotate(90), true),\n\t\t\t\t\t\tl2 = new Line(through.add(to).divide(2),\n\t\t\t\t\t\t\t\tto.subtract(through).rotate(90), true),\n\t\t\t\t\t\tline = new Line(from, to),\n\t\t\t\t\t\tthroughSide = line.getSide(through);\n\t\t\t\t\tcenter = l1.intersect(l2, true);\n\t\t\t\t\tif (!center) {\n\t\t\t\t\t\tif (!throughSide)\n\t\t\t\t\t\t\treturn this.lineTo(to);\n\t\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t\t\t'Cannot create an arc with the given arguments');\n\t\t\t\t\t}\n\t\t\t\t\tvector = from.subtract(center);\n\t\t\t\t\textent = vector.getDirectedAngle(to.subtract(center));\n\t\t\t\t\tvar centerSide = line.getSide(center);\n\t\t\t\t\tif (centerSide === 0) {\n\t\t\t\t\t\textent = throughSide * Math.abs(extent);\n\t\t\t\t\t} else if (throughSide === centerSide) {\n\t\t\t\t\t\textent += extent < 0 ? 360 : -360;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tvar ext = Math.abs(extent),\n\t\t\t\t\tcount = ext >= 360 ? 4 : Math.ceil(ext / 90),\n\t\t\t\t\tinc = extent / count,\n\t\t\t\t\thalf = inc * Math.PI / 360,\n\t\t\t\t\tz = 4 / 3 * Math.sin(half) / (1 + Math.cos(half)),\n\t\t\t\t\tsegments = [];\n\t\t\t\tfor (var i = 0; i <= count; i++) {\n\t\t\t\t\tvar pt = to,\n\t\t\t\t\t\tout = null;\n\t\t\t\t\tif (i < count) {\n\t\t\t\t\t\tout = vector.rotate(90).multiply(z);\n\t\t\t\t\t\tif (matrix) {\n\t\t\t\t\t\t\tpt = matrix._transformPoint(vector);\n\t\t\t\t\t\t\tout = matrix._transformPoint(vector.add(out))\n\t\t\t\t\t\t\t\t\t.subtract(pt);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tpt = center.add(vector);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (i === 0) {\n\t\t\t\t\t\tcurrent.setHandleOut(out);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tvar _in = vector.rotate(-90).multiply(z);\n\t\t\t\t\t\tif (matrix) {\n\t\t\t\t\t\t\t_in = matrix._transformPoint(vector.add(_in))\n\t\t\t\t\t\t\t\t\t.subtract(pt);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsegments.push(new Segment(pt, _in, out));\n\t\t\t\t\t}\n\t\t\t\t\tvector = vector.rotate(inc);\n\t\t\t\t}\n\t\t\t\tthis._add(segments);\n\t\t\t},\n\t\n\t\t\tlineBy: function() {\n\t\t\t\tvar to = Point.read(arguments),\n\t\t\t\t\tcurrent = getCurrentSegment(this)._point;\n\t\t\t\tthis.lineTo(current.add(to));\n\t\t\t},\n\t\n\t\t\tcurveBy: function() {\n\t\t\t\tvar through = Point.read(arguments),\n\t\t\t\t\tto = Point.read(arguments),\n\t\t\t\t\tparameter = Base.read(arguments),\n\t\t\t\t\tcurrent = getCurrentSegment(this)._point;\n\t\t\t\tthis.curveTo(current.add(through), current.add(to), parameter);\n\t\t\t},\n\t\n\t\t\tcubicCurveBy: function() {\n\t\t\t\tvar handle1 = Point.read(arguments),\n\t\t\t\t\thandle2 = Point.read(arguments),\n\t\t\t\t\tto = Point.read(arguments),\n\t\t\t\t\tcurrent = getCurrentSegment(this)._point;\n\t\t\t\tthis.cubicCurveTo(current.add(handle1), current.add(handle2),\n\t\t\t\t\t\tcurrent.add(to));\n\t\t\t},\n\t\n\t\t\tquadraticCurveBy: function() {\n\t\t\t\tvar handle = Point.read(arguments),\n\t\t\t\t\tto = Point.read(arguments),\n\t\t\t\t\tcurrent = getCurrentSegment(this)._point;\n\t\t\t\tthis.quadraticCurveTo(current.add(handle), current.add(to));\n\t\t\t},\n\t\n\t\t\tarcBy: function() {\n\t\t\t\tvar current = getCurrentSegment(this)._point,\n\t\t\t\t\tpoint = current.add(Point.read(arguments)),\n\t\t\t\t\tclockwise = Base.pick(Base.peek(arguments), true);\n\t\t\t\tif (typeof clockwise === 'boolean') {\n\t\t\t\t\tthis.arcTo(point, clockwise);\n\t\t\t\t} else {\n\t\t\t\t\tthis.arcTo(point, current.add(Point.read(arguments)));\n\t\t\t\t}\n\t\t\t},\n\t\n\t\t\tclosePath: function(join) {\n\t\t\t\tthis.setClosed(true);\n\t\t\t\tif (join)\n\t\t\t\t\tthis.join();\n\t\t\t}\n\t\t};\n\t}, {\n\t\n\t\t_getBounds: function(getter, matrix) {\n\t\t\treturn Path[getter](this._segments, this._closed, this.getStyle(),\n\t\t\t\t\tmatrix);\n\t\t},\n\t\n\tstatics: {\n\t\tgetBounds: function(segments, closed, style, matrix, strokePadding) {\n\t\t\tvar first = segments[0];\n\t\t\tif (!first)\n\t\t\t\treturn new Rectangle();\n\t\t\tvar coords = new Array(6),\n\t\t\t\tprevCoords = first._transformCoordinates(matrix, new Array(6), false),\n\t\t\t\tmin = prevCoords.slice(0, 2),\n\t\t\t\tmax = min.slice(),\n\t\t\t\troots = new Array(2);\n\t\n\t\t\tfunction processSegment(segment) {\n\t\t\t\tsegment._transformCoordinates(matrix, coords, false);\n\t\t\t\tfor (var i = 0; i < 2; i++) {\n\t\t\t\t\tCurve._addBounds(\n\t\t\t\t\t\tprevCoords[i],\n\t\t\t\t\t\tprevCoords[i + 4],\n\t\t\t\t\t\tcoords[i + 2],\n\t\t\t\t\t\tcoords[i],\n\t\t\t\t\t\ti, strokePadding ? strokePadding[i] : 0, min, max, roots);\n\t\t\t\t}\n\t\t\t\tvar tmp = prevCoords;\n\t\t\t\tprevCoords = coords;\n\t\t\t\tcoords = tmp;\n\t\t\t}\n\t\n\t\t\tfor (var i = 1, l = segments.length; i < l; i++)\n\t\t\t\tprocessSegment(segments[i]);\n\t\t\tif (closed)\n\t\t\t\tprocessSegment(first);\n\t\t\treturn new Rectangle(min[0], min[1], max[0] - min[0], max[1] - min[1]);\n\t\t},\n\t\n\t\tgetStrokeBounds: function(segments, closed, style, matrix) {\n\t\t\tif (!style.hasStroke())\n\t\t\t\treturn Path.getBounds(segments, closed, style, matrix);\n\t\t\tvar length = segments.length - (closed ? 0 : 1),\n\t\t\t\tradius = style.getStrokeWidth() / 2,\n\t\t\t\tpadding = Path._getPenPadding(radius, matrix),\n\t\t\t\tbounds = Path.getBounds(segments, closed, style, matrix, padding),\n\t\t\t\tjoin = style.getStrokeJoin(),\n\t\t\t\tcap = style.getStrokeCap(),\n\t\t\t\tmiterLimit = radius * style.getMiterLimit();\n\t\t\tvar joinBounds = new Rectangle(new Size(padding).multiply(2));\n\t\n\t\t\tfunction add(point) {\n\t\t\t\tbounds = bounds.include(matrix\n\t\t\t\t\t? matrix._transformPoint(point, point) : point);\n\t\t\t}\n\t\n\t\t\tfunction addRound(segment) {\n\t\t\t\tbounds = bounds.unite(joinBounds.setCenter(matrix\n\t\t\t\t\t? matrix._transformPoint(segment._point) : segment._point));\n\t\t\t}\n\t\n\t\t\tfunction addJoin(segment, join) {\n\t\t\t\tvar handleIn = segment._handleIn,\n\t\t\t\t\thandleOut = segment._handleOut;\n\t\t\t\tif (join === 'round' || !handleIn.isZero() && !handleOut.isZero()\n\t\t\t\t\t\t&& handleIn.isCollinear(handleOut)) {\n\t\t\t\t\taddRound(segment);\n\t\t\t\t} else {\n\t\t\t\t\tPath._addBevelJoin(segment, join, radius, miterLimit, add);\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\tfunction addCap(segment, cap) {\n\t\t\t\tif (cap === 'round') {\n\t\t\t\t\taddRound(segment);\n\t\t\t\t} else {\n\t\t\t\t\tPath._addSquareCap(segment, cap, radius, add);\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\tfor (var i = 1; i < length; i++)\n\t\t\t\taddJoin(segments[i], join);\n\t\t\tif (closed) {\n\t\t\t\taddJoin(segments[0], join);\n\t\t\t} else if (length > 0) {\n\t\t\t\taddCap(segments[0], cap);\n\t\t\t\taddCap(segments[segments.length - 1], cap);\n\t\t\t}\n\t\t\treturn bounds;\n\t\t},\n\t\n\t\t_getPenPadding: function(radius, matrix) {\n\t\t\tif (!matrix)\n\t\t\t\treturn [radius, radius];\n\t\t\tvar mx = matrix.shiftless(),\n\t\t\t\thor = mx.transform(new Point(radius, 0)),\n\t\t\t\tver = mx.transform(new Point(0, radius)),\n\t\t\t\tphi = hor.getAngleInRadians(),\n\t\t\t\ta = hor.getLength(),\n\t\t\t\tb = ver.getLength();\n\t\t\tvar sin = Math.sin(phi),\n\t\t\t\tcos = Math.cos(phi),\n\t\t\t\ttan = Math.tan(phi),\n\t\t\t\ttx = -Math.atan(b * tan / a),\n\t\t\t\tty = Math.atan(b / (tan * a));\n\t\t\treturn [Math.abs(a * Math.cos(tx) * cos - b * Math.sin(tx) * sin),\n\t\t\t\t\tMath.abs(b * Math.sin(ty) * cos + a * Math.cos(ty) * sin)];\n\t\t},\n\t\n\t\t_addBevelJoin: function(segment, join, radius, miterLimit, addPoint, area) {\n\t\t\tvar curve2 = segment.getCurve(),\n\t\t\t\tcurve1 = curve2.getPrevious(),\n\t\t\t\tpoint = curve2.getPointAt(0, true),\n\t\t\t\tnormal1 = curve1.getNormalAt(1, true),\n\t\t\t\tnormal2 = curve2.getNormalAt(0, true),\n\t\t\t\tstep = normal1.getDirectedAngle(normal2) < 0 ? -radius : radius;\n\t\t\tnormal1.setLength(step);\n\t\t\tnormal2.setLength(step);\n\t\t\tif (area) {\n\t\t\t\taddPoint(point);\n\t\t\t\taddPoint(point.add(normal1));\n\t\t\t}\n\t\t\tif (join === 'miter') {\n\t\t\t\tvar corner = new Line(\n\t\t\t\t\t\tpoint.add(normal1),\n\t\t\t\t\t\tnew Point(-normal1.y, normal1.x), true\n\t\t\t\t\t).intersect(new Line(\n\t\t\t\t\t\tpoint.add(normal2),\n\t\t\t\t\t\tnew Point(-normal2.y, normal2.x), true\n\t\t\t\t\t), true);\n\t\t\t\tif (corner && point.getDistance(corner) <= miterLimit) {\n\t\t\t\t\taddPoint(corner);\n\t\t\t\t\tif (!area)\n\t\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!area)\n\t\t\t\taddPoint(point.add(normal1));\n\t\t\taddPoint(point.add(normal2));\n\t\t},\n\t\n\t\t_addSquareCap: function(segment, cap, radius, addPoint, area) {\n\t\t\tvar point = segment._point,\n\t\t\t\tloc = segment.getLocation(),\n\t\t\t\tnormal = loc.getNormal().multiply(radius);\n\t\t\tif (area) {\n\t\t\t\taddPoint(point.subtract(normal));\n\t\t\t\taddPoint(point.add(normal));\n\t\t\t}\n\t\t\tif (cap === 'square')\n\t\t\t\tpoint = point.add(normal.rotate(loc.getParameter() === 0 ? -90 : 90));\n\t\t\taddPoint(point.add(normal));\n\t\t\taddPoint(point.subtract(normal));\n\t\t},\n\t\n\t\tgetHandleBounds: function(segments, closed, style, matrix, strokePadding,\n\t\t\t\tjoinPadding) {\n\t\t\tvar coords = new Array(6),\n\t\t\t\tx1 = Infinity,\n\t\t\t\tx2 = -x1,\n\t\t\t\ty1 = x1,\n\t\t\t\ty2 = x2;\n\t\t\tfor (var i = 0, l = segments.length; i < l; i++) {\n\t\t\t\tvar segment = segments[i];\n\t\t\t\tsegment._transformCoordinates(matrix, coords, false);\n\t\t\t\tfor (var j = 0; j < 6; j += 2) {\n\t\t\t\t\tvar padding = j === 0 ? joinPadding : strokePadding,\n\t\t\t\t\t\tpaddingX = padding ? padding[0] : 0,\n\t\t\t\t\t\tpaddingY = padding ? padding[1] : 0,\n\t\t\t\t\t\tx = coords[j],\n\t\t\t\t\t\ty = coords[j + 1],\n\t\t\t\t\t\txn = x - paddingX,\n\t\t\t\t\t\txx = x + paddingX,\n\t\t\t\t\t\tyn = y - paddingY,\n\t\t\t\t\t\tyx = y + paddingY;\n\t\t\t\t\tif (xn < x1) x1 = xn;\n\t\t\t\t\tif (xx > x2) x2 = xx;\n\t\t\t\t\tif (yn < y1) y1 = yn;\n\t\t\t\t\tif (yx > y2) y2 = yx;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn new Rectangle(x1, y1, x2 - x1, y2 - y1);\n\t\t},\n\t\n\t\tgetRoughBounds: function(segments, closed, style, matrix) {\n\t\t\tvar strokeRadius = style.hasStroke() ? style.getStrokeWidth() / 2 : 0,\n\t\t\t\tjoinRadius = strokeRadius;\n\t\t\tif (strokeRadius > 0) {\n\t\t\t\tif (style.getStrokeJoin() === 'miter')\n\t\t\t\t\tjoinRadius = strokeRadius * style.getMiterLimit();\n\t\t\t\tif (style.getStrokeCap() === 'square')\n\t\t\t\t\tjoinRadius = Math.max(joinRadius, strokeRadius * Math.sqrt(2));\n\t\t\t}\n\t\t\treturn Path.getHandleBounds(segments, closed, style, matrix,\n\t\t\t\t\tPath._getPenPadding(strokeRadius, matrix),\n\t\t\t\t\tPath._getPenPadding(joinRadius, matrix));\n\t\t}\n\t}});\n\t\n\tPath.inject({ statics: new function() {\n\t\n\t\tvar kappa = 0.5522847498307936,\n\t\t\tellipseSegments = [\n\t\t\t\tnew Segment([-1, 0], [0, kappa ], [0, -kappa]),\n\t\t\t\tnew Segment([0, -1], [-kappa, 0], [kappa, 0 ]),\n\t\t\t\tnew Segment([1, 0], [0, -kappa], [0, kappa ]),\n\t\t\t\tnew Segment([0, 1], [kappa, 0 ], [-kappa, 0])\n\t\t\t];\n\t\n\t\tfunction createPath(segments, closed, args) {\n\t\t\tvar props = Base.getNamed(args),\n\t\t\t\tpath = new Path(props && props.insert === false && Item.NO_INSERT);\n\t\t\tpath._add(segments);\n\t\t\tpath._closed = closed;\n\t\t\treturn path.set(props);\n\t\t}\n\t\n\t\tfunction createEllipse(center, radius, args) {\n\t\t\tvar segments = new Array(4);\n\t\t\tfor (var i = 0; i < 4; i++) {\n\t\t\t\tvar segment = ellipseSegments[i];\n\t\t\t\tsegments[i] = new Segment(\n\t\t\t\t\tsegment._point.multiply(radius).add(center),\n\t\t\t\t\tsegment._handleIn.multiply(radius),\n\t\t\t\t\tsegment._handleOut.multiply(radius)\n\t\t\t\t);\n\t\t\t}\n\t\t\treturn createPath(segments, true, args);\n\t\t}\n\t\n\t\treturn {\n\t\t\tLine: function() {\n\t\t\t\treturn createPath([\n\t\t\t\t\tnew Segment(Point.readNamed(arguments, 'from')),\n\t\t\t\t\tnew Segment(Point.readNamed(arguments, 'to'))\n\t\t\t\t], false, arguments);\n\t\t\t},\n\t\n\t\t\tCircle: function() {\n\t\t\t\tvar center = Point.readNamed(arguments, 'center'),\n\t\t\t\t\tradius = Base.readNamed(arguments, 'radius');\n\t\t\t\treturn createEllipse(center, new Size(radius), arguments);\n\t\t\t},\n\t\n\t\t\tRectangle: function() {\n\t\t\t\tvar rect = Rectangle.readNamed(arguments, 'rectangle'),\n\t\t\t\t\tradius = Size.readNamed(arguments, 'radius', 0,\n\t\t\t\t\t\t\t{ readNull: true }),\n\t\t\t\t\tbl = rect.getBottomLeft(true),\n\t\t\t\t\ttl = rect.getTopLeft(true),\n\t\t\t\t\ttr = rect.getTopRight(true),\n\t\t\t\t\tbr = rect.getBottomRight(true),\n\t\t\t\t\tsegments;\n\t\t\t\tif (!radius || radius.isZero()) {\n\t\t\t\t\tsegments = [\n\t\t\t\t\t\tnew Segment(bl),\n\t\t\t\t\t\tnew Segment(tl),\n\t\t\t\t\t\tnew Segment(tr),\n\t\t\t\t\t\tnew Segment(br)\n\t\t\t\t\t];\n\t\t\t\t} else {\n\t\t\t\t\tradius = Size.min(radius, rect.getSize(true).divide(2));\n\t\t\t\t\tvar rx = radius.width,\n\t\t\t\t\t\try = radius.height,\n\t\t\t\t\t\thx = rx * kappa,\n\t\t\t\t\t\thy = ry * kappa;\n\t\t\t\t\tsegments = [\n\t\t\t\t\t\tnew Segment(bl.add(rx, 0), null, [-hx, 0]),\n\t\t\t\t\t\tnew Segment(bl.subtract(0, ry), [0, hy]),\n\t\t\t\t\t\tnew Segment(tl.add(0, ry), null, [0, -hy]),\n\t\t\t\t\t\tnew Segment(tl.add(rx, 0), [-hx, 0], null),\n\t\t\t\t\t\tnew Segment(tr.subtract(rx, 0), null, [hx, 0]),\n\t\t\t\t\t\tnew Segment(tr.add(0, ry), [0, -hy], null),\n\t\t\t\t\t\tnew Segment(br.subtract(0, ry), null, [0, hy]),\n\t\t\t\t\t\tnew Segment(br.subtract(rx, 0), [hx, 0])\n\t\t\t\t\t];\n\t\t\t\t}\n\t\t\t\treturn createPath(segments, true, arguments);\n\t\t\t},\n\t\n\t\t\tRoundRectangle: '#Rectangle',\n\t\n\t\t\tEllipse: function() {\n\t\t\t\tvar ellipse = Shape._readEllipse(arguments);\n\t\t\t\treturn createEllipse(ellipse.center, ellipse.radius, arguments);\n\t\t\t},\n\t\n\t\t\tOval: '#Ellipse',\n\t\n\t\t\tArc: function() {\n\t\t\t\tvar from = Point.readNamed(arguments, 'from'),\n\t\t\t\t\tthrough = Point.readNamed(arguments, 'through'),\n\t\t\t\t\tto = Point.readNamed(arguments, 'to'),\n\t\t\t\t\tprops = Base.getNamed(arguments),\n\t\t\t\t\tpath = new Path(props && props.insert === false\n\t\t\t\t\t\t\t&& Item.NO_INSERT);\n\t\t\t\tpath.moveTo(from);\n\t\t\t\tpath.arcTo(through, to);\n\t\t\t\treturn path.set(props);\n\t\t\t},\n\t\n\t\t\tRegularPolygon: function() {\n\t\t\t\tvar center = Point.readNamed(arguments, 'center'),\n\t\t\t\t\tsides = Base.readNamed(arguments, 'sides'),\n\t\t\t\t\tradius = Base.readNamed(arguments, 'radius'),\n\t\t\t\t\tstep = 360 / sides,\n\t\t\t\t\tthree = !(sides % 3),\n\t\t\t\t\tvector = new Point(0, three ? -radius : radius),\n\t\t\t\t\toffset = three ? -1 : 0.5,\n\t\t\t\t\tsegments = new Array(sides);\n\t\t\t\tfor (var i = 0; i < sides; i++)\n\t\t\t\t\tsegments[i] = new Segment(center.add(\n\t\t\t\t\t\tvector.rotate((i + offset) * step)));\n\t\t\t\treturn createPath(segments, true, arguments);\n\t\t\t},\n\t\n\t\t\tStar: function() {\n\t\t\t\tvar center = Point.readNamed(arguments, 'center'),\n\t\t\t\t\tpoints = Base.readNamed(arguments, 'points') * 2,\n\t\t\t\t\tradius1 = Base.readNamed(arguments, 'radius1'),\n\t\t\t\t\tradius2 = Base.readNamed(arguments, 'radius2'),\n\t\t\t\t\tstep = 360 / points,\n\t\t\t\t\tvector = new Point(0, -1),\n\t\t\t\t\tsegments = new Array(points);\n\t\t\t\tfor (var i = 0; i < points; i++)\n\t\t\t\t\tsegments[i] = new Segment(center.add(vector.rotate(step * i)\n\t\t\t\t\t\t\t.multiply(i % 2 ? radius2 : radius1)));\n\t\t\t\treturn createPath(segments, true, arguments);\n\t\t\t}\n\t\t};\n\t}});\n\t\n\tvar CompoundPath = PathItem.extend({\n\t\t_class: 'CompoundPath',\n\t\t_serializeFields: {\n\t\t\tchildren: []\n\t\t},\n\t\n\t\tinitialize: function CompoundPath(arg) {\n\t\t\tthis._children = [];\n\t\t\tthis._namedChildren = {};\n\t\t\tif (!this._initialize(arg)) {\n\t\t\t\tif (typeof arg === 'string') {\n\t\t\t\t\tthis.setPathData(arg);\n\t\t\t\t} else {\n\t\t\t\t\tthis.addChildren(Array.isArray(arg) ? arg : arguments);\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\n\t\tinsertChildren: function insertChildren(index, items, _preserve) {\n\t\t\tfor (var i = items.length - 1; i >= 0; i--) {\n\t\t\t\tvar item = items[i];\n\t\t\t\tif (item instanceof CompoundPath) {\n\t\t\t\t\titems.splice.apply(items, [i, 1].concat(item.removeChildren()));\n\t\t\t\t\titem.remove();\n\t\t\t\t}\n\t\t\t}\n\t\t\titems = insertChildren.base.call(this, index, items, _preserve, Path);\n\t\t\tfor (var i = 0, l = !_preserve && items && items.length; i < l; i++) {\n\t\t\t\tvar item = items[i];\n\t\t\t\tif (item._clockwise === undefined)\n\t\t\t\t\titem.setClockwise(item._index === 0);\n\t\t\t}\n\t\t\treturn items;\n\t\t},\n\t\n\t\treverse: function() {\n\t\t\tvar children = this._children;\n\t\t\tfor (var i = 0, l = children.length; i < l; i++)\n\t\t\t\tchildren[i].reverse();\n\t\t},\n\t\n\t\tsmooth: function() {\n\t\t\tfor (var i = 0, l = this._children.length; i < l; i++)\n\t\t\t\tthis._children[i].smooth();\n\t\t},\n\t\n\t\treduce: function reduce() {\n\t\t\tvar children = this._children;\n\t\t\tfor (var i = children.length - 1; i >= 0; i--) {\n\t\t\t\tvar path = children[i].reduce();\n\t\t\t\tif (path.isEmpty())\n\t\t\t\t\tchildren.splice(i, 1);\n\t\t\t}\n\t\t\tif (children.length === 0) {\n\t\t\t\tvar path = new Path(Item.NO_INSERT);\n\t\t\t\tpath.insertAbove(this);\n\t\t\t\tpath.setStyle(this._style);\n\t\t\t\tthis.remove();\n\t\t\t\treturn path;\n\t\t\t}\n\t\t\treturn reduce.base.call(this);\n\t\t},\n\t\n\t\tisClockwise: function() {\n\t\t\tvar child = this.getFirstChild();\n\t\t\treturn child && child.isClockwise();\n\t\t},\n\t\n\t\tsetClockwise: function(clockwise) {\n\t\t\tif (this.isClockwise() !== !!clockwise)\n\t\t\t\tthis.reverse();\n\t\t},\n\t\n\t\tgetFirstSegment: function() {\n\t\t\tvar first = this.getFirstChild();\n\t\t\treturn first && first.getFirstSegment();\n\t\t},\n\t\n\t\tgetLastSegment: function() {\n\t\t\tvar last = this.getLastChild();\n\t\t\treturn last && last.getLastSegment();\n\t\t},\n\t\n\t\tgetCurves: function() {\n\t\t\tvar children = this._children,\n\t\t\t\tcurves = [];\n\t\t\tfor (var i = 0, l = children.length; i < l; i++)\n\t\t\t\tcurves.push.apply(curves, children[i].getCurves());\n\t\t\treturn curves;\n\t\t},\n\t\n\t\tgetFirstCurve: function() {\n\t\t\tvar first = this.getFirstChild();\n\t\t\treturn first && first.getFirstCurve();\n\t\t},\n\t\n\t\tgetLastCurve: function() {\n\t\t\tvar last = this.getLastChild();\n\t\t\treturn last && last.getFirstCurve();\n\t\t},\n\t\n\t\tgetArea: function() {\n\t\t\tvar children = this._children,\n\t\t\t\tarea = 0;\n\t\t\tfor (var i = 0, l = children.length; i < l; i++)\n\t\t\t\tarea += children[i].getArea();\n\t\t\treturn area;\n\t\t}\n\t}, {\n\t\tbeans: true,\n\t\n\t\tgetPathData: function(_matrix, _precision) {\n\t\t\tvar children = this._children,\n\t\t\t\tpaths = [];\n\t\t\tfor (var i = 0, l = children.length; i < l; i++) {\n\t\t\t\tvar child = children[i],\n\t\t\t\t\tmx = child._matrix;\n\t\t\t\tpaths.push(child.getPathData(_matrix && !mx.isIdentity()\n\t\t\t\t\t\t? _matrix.chain(mx) : _matrix, _precision));\n\t\t\t}\n\t\t\treturn paths.join(' ');\n\t\t}\n\t}, {\n\t\t_getChildHitTestOptions: function(options) {\n\t\t\treturn options.class === Path || options.type === 'path'\n\t\t\t\t\t? options\n\t\t\t\t\t: new Base(options, { fill: false });\n\t\t},\n\t\n\t\t_draw: function(ctx, param, strokeMatrix) {\n\t\t\tvar children = this._children;\n\t\t\tif (children.length === 0)\n\t\t\t\treturn;\n\t\n\t\t\tif (this._currentPath) {\n\t\t\t\tctx.currentPath = this._currentPath;\n\t\t\t} else {\n\t\t\t\tparam = param.extend({ dontStart: true, dontFinish: true });\n\t\t\t\tctx.beginPath();\n\t\t\t\tfor (var i = 0, l = children.length; i < l; i++)\n\t\t\t\t\tchildren[i].draw(ctx, param, strokeMatrix);\n\t\t\t\tthis._currentPath = ctx.currentPath;\n\t\t\t}\n\t\n\t\t\tif (!param.clip) {\n\t\t\t\tthis._setStyles(ctx);\n\t\t\t\tvar style = this._style;\n\t\t\t\tif (style.hasFill()) {\n\t\t\t\t\tctx.fill(style.getWindingRule());\n\t\t\t\t\tctx.shadowColor = 'rgba(0,0,0,0)';\n\t\t\t\t}\n\t\t\t\tif (style.hasStroke())\n\t\t\t\t\tctx.stroke();\n\t\t\t}\n\t\t},\n\t\n\t\t_drawSelected: function(ctx, matrix, selectedItems) {\n\t\t\tvar children = this._children;\n\t\t\tfor (var i = 0, l = children.length; i < l; i++) {\n\t\t\t\tvar child = children[i],\n\t\t\t\t\tmx = child._matrix;\n\t\t\t\tif (!selectedItems[child._id])\n\t\t\t\t\tchild._drawSelected(ctx, mx.isIdentity() ? matrix\n\t\t\t\t\t\t\t: matrix.chain(mx));\n\t\t\t}\n\t\t}\n\t},\n\tnew function() {\n\t\tfunction getCurrentPath(that, check) {\n\t\t\tvar children = that._children;\n\t\t\tif (check && children.length === 0)\n\t\t\t\tthrow new Error('Use a moveTo() command first');\n\t\t\treturn children[children.length - 1];\n\t\t}\n\t\n\t\tvar fields = {\n\t\t\tmoveTo: function() {\n\t\t\t\tvar current = getCurrentPath(this),\n\t\t\t\t\tpath = current && current.isEmpty() ? current\n\t\t\t\t\t\t\t: new Path(Item.NO_INSERT);\n\t\t\t\tif (path !== current)\n\t\t\t\t\tthis.addChild(path);\n\t\t\t\tpath.moveTo.apply(path, arguments);\n\t\t\t},\n\t\n\t\t\tmoveBy: function() {\n\t\t\t\tvar current = getCurrentPath(this, true),\n\t\t\t\t\tlast = current && current.getLastSegment(),\n\t\t\t\t\tpoint = Point.read(arguments);\n\t\t\t\tthis.moveTo(last ? point.add(last._point) : point);\n\t\t\t},\n\t\n\t\t\tclosePath: function(join) {\n\t\t\t\tgetCurrentPath(this, true).closePath(join);\n\t\t\t}\n\t\t};\n\t\n\t\tBase.each(['lineTo', 'cubicCurveTo', 'quadraticCurveTo', 'curveTo', 'arcTo',\n\t\t\t\t'lineBy', 'cubicCurveBy', 'quadraticCurveBy', 'curveBy', 'arcBy'],\n\t\t\t\tfunction(key) {\n\t\t\t\t\tfields[key] = function() {\n\t\t\t\t\t\tvar path = getCurrentPath(this, true);\n\t\t\t\t\t\tpath[key].apply(path, arguments);\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t);\n\t\n\t\treturn fields;\n\t});\n\t\n\tPathItem.inject(new function() {\n\t\tvar operators = {\n\t\t\tunite: function(w) {\n\t\t\t\treturn w === 1 || w === 0;\n\t\t\t},\n\t\n\t\t\tintersect: function(w) {\n\t\t\t\treturn w === 2;\n\t\t\t},\n\t\n\t\t\tsubtract: function(w) {\n\t\t\t\treturn w === 1;\n\t\t\t},\n\t\n\t\t\texclude: function(w) {\n\t\t\t\treturn w === 1;\n\t\t\t}\n\t\t};\n\t\n\t\tfunction preparePath(path, resolve) {\n\t\t\tvar res = path.clone(false).reduce().transform(null, true, true);\n\t\t\treturn resolve ? res.resolveCrossings().reorient() : res;\n\t\t}\n\t\n\t\tfunction finishBoolean(ctor, paths, path1, path2, reduce) {\n\t\t\tvar result = new ctor(Item.NO_INSERT);\n\t\t\tresult.addChildren(paths, true);\n\t\t\tif (reduce)\n\t\t\t\tresult = result.reduce();\n\t\t\tresult.insertAbove(path2 && path1.isSibling(path2)\n\t\t\t\t\t&& path1.getIndex() < path2.getIndex()\n\t\t\t\t\t\t? path2 : path1);\n\t\t\tresult.setStyle(path1._style);\n\t\t\treturn result;\n\t\t}\n\t\n\t\tfunction computeBoolean(path1, path2, operation) {\n\t\t\tif (!path1._children && !path1._closed)\n\t\t\t\treturn computeOpenBoolean(path1, path2, operation);\n\t\t\tvar _path1 = preparePath(path1, true),\n\t\t\t\t_path2 = path2 && path1 !== path2 && preparePath(path2, true);\n\t\t\tif (_path2 && /^(subtract|exclude)$/.test(operation)\n\t\t\t\t\t^ (_path2.isClockwise() !== _path1.isClockwise()))\n\t\t\t\t_path2.reverse();\n\t\t\tvar intersections = CurveLocation.expand(\n\t\t\t\t_path1.getIntersections(_path2, function(inter) {\n\t\t\t\t\treturn _path2 && inter.isOverlap() || inter.isCrossing();\n\t\t\t\t})\n\t\t\t);\n\t\t\tdivideLocations(intersections);\n\t\n\t\t\tvar segments = [],\n\t\t\t\tmonoCurves = [];\n\t\n\t\t\tfunction collect(paths) {\n\t\t\t\tfor (var i = 0, l = paths.length; i < l; i++) {\n\t\t\t\t\tvar path = paths[i];\n\t\t\t\t\tsegments.push.apply(segments, path._segments);\n\t\t\t\t\tmonoCurves.push.apply(monoCurves, path._getMonoCurves());\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\tcollect(_path1._children || [_path1]);\n\t\t\tif (_path2)\n\t\t\t\tcollect(_path2._children || [_path2]);\n\t\t\tfor (var i = 0, l = intersections.length; i < l; i++) {\n\t\t\t\tpropagateWinding(intersections[i]._segment, _path1, _path2,\n\t\t\t\t\t\tmonoCurves, operation);\n\t\t\t}\n\t\t\tfor (var i = 0, l = segments.length; i < l; i++) {\n\t\t\t\tvar segment = segments[i];\n\t\t\t\tif (segment._winding == null) {\n\t\t\t\t\tpropagateWinding(segment, _path1, _path2, monoCurves,\n\t\t\t\t\t\t\toperation);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn finishBoolean(CompoundPath, tracePaths(segments, operation),\n\t\t\t\t\tpath1, path2, true);\n\t\t}\n\t\n\t\tfunction computeOpenBoolean(path1, path2, operation) {\n\t\t\tif (!path2 || !path2._children && !path2._closed\n\t\t\t\t\t|| !/^(subtract|intersect)$/.test(operation))\n\t\t\t\treturn null;\n\t\t\tvar _path1 = preparePath(path1, false),\n\t\t\t\t_path2 = preparePath(path2, false),\n\t\t\t\tintersections = _path1.getIntersections(_path2, function(inter) {\n\t\t\t\t\treturn inter.isOverlap() || inter.isCrossing();\n\t\t\t\t}),\n\t\t\t\tsub = operation === 'subtract',\n\t\t\t\tpaths = [];\n\t\n\t\t\tfunction addPath(path) {\n\t\t\t\tif (_path2.contains(path.getPointAt(path.getLength() / 2)) ^ sub) {\n\t\t\t\t\tpaths.unshift(path);\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\tfor (var i = intersections.length - 1; i >= 0; i--) {\n\t\t\t\tvar path = intersections[i].split();\n\t\t\t\tif (path) {\n\t\t\t\t\tif (addPath(path))\n\t\t\t\t\t\tpath.getFirstSegment().setHandleIn(0, 0);\n\t\t\t\t\t_path1.getLastSegment().setHandleOut(0, 0);\n\t\t\t\t}\n\t\t\t}\n\t\t\taddPath(_path1);\n\t\t\treturn finishBoolean(Group, paths, path1, path2);\n\t\t}\n\t\n\t\tfunction linkIntersections(from, to) {\n\t\t\tvar prev = from;\n\t\t\twhile (prev) {\n\t\t\t\tif (prev === to)\n\t\t\t\t\treturn;\n\t\t\t\tprev = prev._prev;\n\t\t\t}\n\t\t\twhile (from._next && from._next !== to)\n\t\t\t\tfrom = from._next;\n\t\t\tif (!from._next) {\n\t\t\t\twhile (to._prev)\n\t\t\t\t\tto = to._prev;\n\t\t\t\tfrom._next = to;\n\t\t\t\tto._prev = from;\n\t\t\t}\n\t\t}\n\t\n\t\tfunction divideLocations(locations) {\n\t\t\tvar tMin = 4e-7,\n\t\t\t\ttMax = 1 - tMin,\n\t\t\t\tnoHandles = false,\n\t\t\t\tclearSegments = [],\n\t\t\t\tprevCurve,\n\t\t\t\tprevT;\n\t\n\t\t\tfor (var i = locations.length - 1; i >= 0; i--) {\n\t\t\t\tvar loc = locations[i],\n\t\t\t\t\tcurve = loc._curve,\n\t\t\t\t\tt = loc._parameter,\n\t\t\t\t\torigT = t;\n\t\t\t\tif (curve !== prevCurve) {\n\t\t\t\t\tnoHandles = !curve.hasHandles();\n\t\t\t\t} else if (prevT > 0) {\n\t\t\t\t\tt /= prevT;\n\t\t\t\t}\n\t\t\t\tvar segment;\n\t\t\t\tif (t < tMin) {\n\t\t\t\t\tsegment = curve._segment1;\n\t\t\t\t} else if (t > tMax) {\n\t\t\t\t\tsegment = curve._segment2;\n\t\t\t\t} else {\n\t\t\t\t\tsegment = curve.divide(t, true, true)._segment1;\n\t\t\t\t\tif (noHandles)\n\t\t\t\t\t\tclearSegments.push(segment);\n\t\t\t\t}\n\t\t\t\tloc._setSegment(segment);\n\t\t\t\tvar inter = segment._intersection,\n\t\t\t\t\tdest = loc._intersection;\n\t\t\t\tif (inter) {\n\t\t\t\t\tlinkIntersections(inter, dest);\n\t\t\t\t\tvar other = inter;\n\t\t\t\t\twhile (other) {\n\t\t\t\t\t\tlinkIntersections(other._intersection, inter);\n\t\t\t\t\t\tother = other._next;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tsegment._intersection = dest;\n\t\t\t\t}\n\t\t\t\tprevCurve = curve;\n\t\t\t\tprevT = origT;\n\t\t\t}\n\t\t\tfor (var i = 0, l = clearSegments.length; i < l; i++) {\n\t\t\t\tclearSegments[i].clearHandles();\n\t\t\t}\n\t\t}\n\t\n\t\tfunction getWinding(point, curves, horizontal, testContains) {\n\t\t\tvar epsilon = 2e-7,\n\t\t\t\ttMin = 4e-7,\n\t\t\t\ttMax = 1 - tMin,\n\t\t\t\tpx = point.x,\n\t\t\t\tpy = point.y,\n\t\t\t\twindLeft = 0,\n\t\t\t\twindRight = 0,\n\t\t\t\troots = [],\n\t\t\t\tabs = Math.abs;\n\t\t\tif (horizontal) {\n\t\t\t\tvar yTop = -Infinity,\n\t\t\t\t\tyBottom = Infinity,\n\t\t\t\t\tyBefore = py - epsilon,\n\t\t\t\t\tyAfter = py + epsilon;\n\t\t\t\tfor (var i = 0, l = curves.length; i < l; i++) {\n\t\t\t\t\tvar values = curves[i].values;\n\t\t\t\t\tif (Curve.solveCubic(values, 0, px, roots, 0, 1) > 0) {\n\t\t\t\t\t\tfor (var j = roots.length - 1; j >= 0; j--) {\n\t\t\t\t\t\t\tvar y = Curve.getPoint(values, roots[j]).y;\n\t\t\t\t\t\t\tif (y < yBefore && y > yTop) {\n\t\t\t\t\t\t\t\tyTop = y;\n\t\t\t\t\t\t\t} else if (y > yAfter && y < yBottom) {\n\t\t\t\t\t\t\t\tyBottom = y;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tyTop = (yTop + py) / 2;\n\t\t\t\tyBottom = (yBottom + py) / 2;\n\t\t\t\tif (yTop > -Infinity)\n\t\t\t\t\twindLeft = getWinding(new Point(px, yTop), curves, false,\n\t\t\t\t\t\t\ttestContains);\n\t\t\t\tif (yBottom < Infinity)\n\t\t\t\t\twindRight = getWinding(new Point(px, yBottom), curves, false,\n\t\t\t\t\t\t\ttestContains);\n\t\t\t} else {\n\t\t\t\tvar xBefore = px - epsilon,\n\t\t\t\t\txAfter = px + epsilon;\n\t\t\t\tvar startCounted = false,\n\t\t\t\t\tprevCurve,\n\t\t\t\t\tprevT;\n\t\t\t\tfor (var i = 0, l = curves.length; i < l; i++) {\n\t\t\t\t\tvar curve = curves[i],\n\t\t\t\t\t\tvalues = curve.values,\n\t\t\t\t\t\twinding = curve.winding;\n\t\t\t\t\tif (winding && (winding === 1\n\t\t\t\t\t\t\t&& py >= values[1] && py <= values[7]\n\t\t\t\t\t\t\t|| py >= values[7] && py <= values[1])\n\t\t\t\t\t\t&& Curve.solveCubic(values, 1, py, roots, 0, 1) === 1) {\n\t\t\t\t\t\tvar t = roots[0];\n\t\t\t\t\t\tif (!(\n\t\t\t\t\t\t\tt > tMax && startCounted && curve.next !== curves[i + 1]\n\t\t\t\t\t\t\t|| t < tMin && prevT > tMax\n\t\t\t\t\t\t\t\t&& curve.previous === prevCurve)) {\n\t\t\t\t\t\t\tvar x = Curve.getPoint(values, t).x,\n\t\t\t\t\t\t\t\tslope = Curve.getTangent(values, t).y,\n\t\t\t\t\t\t\t\tcounted = false;\n\t\t\t\t\t\t\tif (Numerical.isZero(slope) && !Curve.isStraight(values)\n\t\t\t\t\t\t\t\t\t|| t < tMin && slope * Curve.getTangent(\n\t\t\t\t\t\t\t\t\t\tcurve.previous.values, 1).y < 0\n\t\t\t\t\t\t\t\t\t|| t > tMax && slope * Curve.getTangent(\n\t\t\t\t\t\t\t\t\t\tcurve.next.values, 0).y < 0) {\n\t\t\t\t\t\t\t\tif (testContains && x >= xBefore && x <= xAfter) {\n\t\t\t\t\t\t\t\t\t++windLeft;\n\t\t\t\t\t\t\t\t\t++windRight;\n\t\t\t\t\t\t\t\t\tcounted = true;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else if (x <= xBefore) {\n\t\t\t\t\t\t\t\twindLeft += winding;\n\t\t\t\t\t\t\t\tcounted = true;\n\t\t\t\t\t\t\t} else if (x >= xAfter) {\n\t\t\t\t\t\t\t\twindRight += winding;\n\t\t\t\t\t\t\t\tcounted = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (curve.previous !== curves[i - 1])\n\t\t\t\t\t\t\t\tstartCounted = t < tMin && counted;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tprevCurve = curve;\n\t\t\t\t\t\tprevT = t;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn Math.max(abs(windLeft), abs(windRight));\n\t\t}\n\t\n\t\tfunction propagateWinding(segment, path1, path2, monoCurves, operation) {\n\t\t\tvar epsilon = 2e-7,\n\t\t\t\tchain = [],\n\t\t\t\tstart = segment,\n\t\t\t\ttotalLength = 0,\n\t\t\t\twindingSum = 0;\n\t\t\tdo {\n\t\t\t\tvar curve = segment.getCurve(),\n\t\t\t\t\tlength = curve.getLength();\n\t\t\t\tchain.push({ segment: segment, curve: curve, length: length });\n\t\t\t\ttotalLength += length;\n\t\t\t\tsegment = segment.getNext();\n\t\t\t} while (segment && !segment._intersection && segment !== start);\n\t\t\tfor (var i = 0; i < 3; i++) {\n\t\t\t\tvar length = totalLength * (i + 1) / 4;\n\t\t\t\tfor (var k = 0, m = chain.length; k < m; k++) {\n\t\t\t\t\tvar node = chain[k],\n\t\t\t\t\t\tcurveLength = node.length;\n\t\t\t\t\tif (length <= curveLength) {\n\t\t\t\t\t\tif (length < epsilon || curveLength - length < epsilon)\n\t\t\t\t\t\t\tlength = curveLength / 2;\n\t\t\t\t\t\tvar curve = node.curve,\n\t\t\t\t\t\t\tpath = curve._path,\n\t\t\t\t\t\t\tparent = path._parent,\n\t\t\t\t\t\t\tpt = curve.getPointAt(length),\n\t\t\t\t\t\t\thor = curve.isHorizontal();\n\t\t\t\t\t\tif (parent instanceof CompoundPath)\n\t\t\t\t\t\t\tpath = parent;\n\t\t\t\t\t\twindingSum += operation === 'subtract' && path2\n\t\t\t\t\t\t\t&& (path === path1 && path2._getWinding(pt, hor)\n\t\t\t\t\t\t\t|| path === path2 && !path1._getWinding(pt, hor))\n\t\t\t\t\t\t\t? 0\n\t\t\t\t\t\t\t: getWinding(pt, monoCurves, hor);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tlength -= curveLength;\n\t\t\t\t}\n\t\t\t}\n\t\t\tvar winding = Math.round(windingSum / 3);\n\t\t\tfor (var j = chain.length - 1; j >= 0; j--)\n\t\t\t\tchain[j].segment._winding = winding;\n\t\t}\n\t\n\t\tfunction tracePaths(segments, operation) {\n\t\t\tvar paths = [],\n\t\t\t\tstart,\n\t\t\t\totherStart,\n\t\t\t\toperator = operators[operation],\n\t\t\t\toverlapWinding = {\n\t\t\t\t\tunite: { 1: 2 },\n\t\t\t\t\tintersect: { 2: 1 }\n\t\t\t\t}[operation];\n\t\n\t\t\tfunction isValid(seg, adjusted) {\n\t\t\t\tif (seg._visited)\n\t\t\t\t\treturn false;\n\t\t\t\tif (!operator)\n\t\t\t\t\treturn true;\n\t\t\t\tvar winding = seg._winding,\n\t\t\t\t\tinter = seg._intersection;\n\t\t\t\tif (inter && adjusted && overlapWinding && inter.isOverlap())\n\t\t\t\t\twinding = overlapWinding[winding] || winding;\n\t\t\t\treturn operator(winding);\n\t\t\t}\n\t\n\t\t\tfunction isStart(seg) {\n\t\t\t\treturn seg === start || seg === otherStart;\n\t\t\t}\n\t\n\t\t\tfunction findBestIntersection(inter, strict) {\n\t\t\t\tif (!inter._next)\n\t\t\t\t\treturn inter;\n\t\t\t\twhile (inter) {\n\t\t\t\t\tvar seg = inter._segment,\n\t\t\t\t\t\tnextSeg = seg.getNext(),\n\t\t\t\t\t\tnextInter = nextSeg._intersection;\n\t\t\t\t\tif (isStart(nextSeg)\n\t\t\t\t\t\t|| !seg._visited && !nextSeg._visited\n\t\t\t\t\t\t&& (!operator\n\t\t\t\t\t\t\t|| (!strict || isValid(seg))\n\t\t\t\t\t\t\t&& (!(strict && nextInter && nextInter.isOverlap())\n\t\t\t\t\t\t\t\t&& isValid(nextSeg)\n\t\t\t\t\t\t\t\t|| !strict && nextInter\n\t\t\t\t\t\t\t\t&& isValid(nextInter._segment))\n\t\t\t\t\t\t))\n\t\t\t\t\t\treturn inter;\n\t\t\t\t\tinter = inter._next;\n\t\t\t\t}\n\t\t\t\treturn null;\n\t\t\t}\n\t\n\t\t\tfunction findStartSegment(inter, next) {\n\t\t\t\twhile (inter) {\n\t\t\t\t\tvar seg = inter._segment;\n\t\t\t\t\tif (isStart(seg))\n\t\t\t\t\t\treturn seg;\n\t\t\t\t\tinter = inter[next ? '_next' : '_prev'];\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\tfor (var i = 0, l = segments.length; i < l; i++) {\n\t\t\t\tvar seg = segments[i],\n\t\t\t\t\tpath = null,\n\t\t\t\t\tfinished = false;\n\t\t\t\tif (!isValid(seg, true))\n\t\t\t\t\tcontinue;\n\t\t\t\tstart = otherStart = null;\n\t\t\t\twhile (!finished) {\n\t\t\t\t\tvar inter = seg._intersection,\n\t\t\t\t\t\thandleIn = path && seg._handleIn;\n\t\t\t\t\tinter = inter && (findBestIntersection(inter, true)\n\t\t\t\t\t\t\t|| findBestIntersection(inter, false)) || inter;\n\t\t\t\t\tvar other = inter && inter._segment;\n\t\t\t\t\tif (other && isValid(other))\n\t\t\t\t\t\tseg = other;\n\t\t\t\t\tif (seg._visited) {\n\t\t\t\t\t\tfinished = isStart(seg);\n\t\t\t\t\t\tif (!finished && inter) {\n\t\t\t\t\t\t\tvar found = findStartSegment(inter, true)\n\t\t\t\t\t\t\t\t|| findStartSegment(inter, false);\n\t\t\t\t\t\t\tif (found) {\n\t\t\t\t\t\t\t\tseg = found;\n\t\t\t\t\t\t\t\tfinished = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (!path) {\n\t\t\t\t\t\tpath = new Path(Item.NO_INSERT);\n\t\t\t\t\t\tstart = seg;\n\t\t\t\t\t\totherStart = other;\n\t\t\t\t\t}\n\t\t\t\t\tpath.add(new Segment(seg._point, handleIn, seg._handleOut));\n\t\t\t\t\tseg._visited = true;\n\t\t\t\t\tseg = seg.getNext();\n\t\t\t\t\tfinished = isStart(seg);\n\t\t\t\t}\n\t\t\t\tif (finished) {\n\t\t\t\t\tpath.firstSegment.setHandleIn(seg._handleIn);\n\t\t\t\t\tpath.setClosed(true);\n\t\t\t\t} else if (path) {\n\t\t\t\t\tconsole.error('Boolean operation resulted in open path',\n\t\t\t\t\t\t\t'segments =', path._segments.length,\n\t\t\t\t\t\t\t'length =', path.getLength());\n\t\t\t\t\tpath = null;\n\t\t\t\t}\n\t\t\t\tif (path && (path._segments.length > 8\n\t\t\t\t\t\t|| !Numerical.isZero(path.getArea()))) {\n\t\t\t\t\tpaths.push(path);\n\t\t\t\t\tpath = null;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn paths;\n\t\t}\n\t\n\t\treturn {\n\t\t\t_getWinding: function(point, horizontal, testContains) {\n\t\t\t\treturn getWinding(point, this._getMonoCurves(),\n\t\t\t\t\t\thorizontal, testContains);\n\t\t\t},\n\t\n\t\t\tunite: function(path) {\n\t\t\t\treturn computeBoolean(this, path, 'unite');\n\t\t\t},\n\t\n\t\t\tintersect: function(path) {\n\t\t\t\treturn computeBoolean(this, path, 'intersect');\n\t\t\t},\n\t\n\t\t\tsubtract: function(path) {\n\t\t\t\treturn computeBoolean(this, path, 'subtract');\n\t\t\t},\n\t\n\t\t\texclude: function(path) {\n\t\t\t\treturn computeBoolean(this, path, 'exclude');\n\t\t\t},\n\t\n\t\t\tdivide: function(path) {\n\t\t\t\treturn finishBoolean(Group,\n\t\t\t\t\t\t[this.subtract(path), this.intersect(path)],\n\t\t\t\t\t\tthis, path, true);\n\t\t\t},\n\t\n\t\t\tresolveCrossings: function() {\n\t\t\t\tvar crossings = this.getCrossings();\n\t\t\t\tif (!crossings.length)\n\t\t\t\t\treturn this;\n\t\t\t\tdivideLocations(CurveLocation.expand(crossings));\n\t\t\t\tvar paths = this._children || [this],\n\t\t\t\t\tsegments = [];\n\t\t\t\tfor (var i = 0, l = paths.length; i < l; i++) {\n\t\t\t\t\tsegments.push.apply(segments, paths[i]._segments);\n\t\t\t\t}\n\t\t\t\treturn finishBoolean(CompoundPath, tracePaths(segments),\n\t\t\t\t\t\tthis, null, false);\n\t\t\t}\n\t\t};\n\t});\n\t\n\tPath.inject({\n\t\t_getMonoCurves: function() {\n\t\t\tvar monoCurves = this._monoCurves,\n\t\t\t\tprevCurve;\n\t\n\t\t\tfunction insertCurve(v) {\n\t\t\t\tvar y0 = v[1],\n\t\t\t\t\ty1 = v[7],\n\t\t\t\t\tcurve = {\n\t\t\t\t\t\tvalues: v,\n\t\t\t\t\t\twinding: y0 === y1\n\t\t\t\t\t\t\t? 0\n\t\t\t\t\t\t\t: y0 > y1\n\t\t\t\t\t\t\t\t? -1\n\t\t\t\t\t\t\t\t: 1,\n\t\t\t\t\t\tprevious: prevCurve,\n\t\t\t\t\t\tnext: null\n\t\t\t\t\t};\n\t\t\t\tif (prevCurve)\n\t\t\t\t\tprevCurve.next = curve;\n\t\t\t\tmonoCurves.push(curve);\n\t\t\t\tprevCurve = curve;\n\t\t\t}\n\t\n\t\t\tfunction handleCurve(v) {\n\t\t\t\tif (Curve.getLength(v) === 0)\n\t\t\t\t\treturn;\n\t\t\t\tvar y0 = v[1],\n\t\t\t\t\ty1 = v[3],\n\t\t\t\t\ty2 = v[5],\n\t\t\t\t\ty3 = v[7];\n\t\t\t\tif (Curve.isStraight(v)) {\n\t\t\t\t\tinsertCurve(v);\n\t\t\t\t} else {\n\t\t\t\t\tvar a = 3 * (y1 - y2) - y0 + y3,\n\t\t\t\t\t\tb = 2 * (y0 + y2) - 4 * y1,\n\t\t\t\t\t\tc = y1 - y0,\n\t\t\t\t\t\ttMin = 4e-7,\n\t\t\t\t\t\ttMax = 1 - tMin,\n\t\t\t\t\t\troots = [],\n\t\t\t\t\t\tn = Numerical.solveQuadratic(a, b, c, roots, tMin, tMax);\n\t\t\t\t\tif (n === 0) {\n\t\t\t\t\t\tinsertCurve(v);\n\t\t\t\t\t} else {\n\t\t\t\t\t\troots.sort();\n\t\t\t\t\t\tvar t = roots[0],\n\t\t\t\t\t\t\tparts = Curve.subdivide(v, t);\n\t\t\t\t\t\tinsertCurve(parts[0]);\n\t\t\t\t\t\tif (n > 1) {\n\t\t\t\t\t\t\tt = (roots[1] - t) / (1 - t);\n\t\t\t\t\t\t\tparts = Curve.subdivide(parts[1], t);\n\t\t\t\t\t\t\tinsertCurve(parts[0]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tinsertCurve(parts[1]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\tif (!monoCurves) {\n\t\t\t\tmonoCurves = this._monoCurves = [];\n\t\t\t\tvar curves = this.getCurves(),\n\t\t\t\t\tsegments = this._segments;\n\t\t\t\tfor (var i = 0, l = curves.length; i < l; i++)\n\t\t\t\t\thandleCurve(curves[i].getValues());\n\t\t\t\tif (!this._closed && segments.length > 1) {\n\t\t\t\t\tvar p1 = segments[segments.length - 1]._point,\n\t\t\t\t\t\tp2 = segments[0]._point,\n\t\t\t\t\t\tp1x = p1._x, p1y = p1._y,\n\t\t\t\t\t\tp2x = p2._x, p2y = p2._y;\n\t\t\t\t\thandleCurve([p1x, p1y, p1x, p1y, p2x, p2y, p2x, p2y]);\n\t\t\t\t}\n\t\t\t\tif (monoCurves.length > 0) {\n\t\t\t\t\tvar first = monoCurves[0],\n\t\t\t\t\t\tlast = monoCurves[monoCurves.length - 1];\n\t\t\t\t\tfirst.previous = last;\n\t\t\t\t\tlast.next = first;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn monoCurves;\n\t\t},\n\t\n\t\tgetInteriorPoint: function() {\n\t\t\tvar bounds = this.getBounds(),\n\t\t\t\tpoint = bounds.getCenter(true);\n\t\t\tif (!this.contains(point)) {\n\t\t\t\tvar curves = this._getMonoCurves(),\n\t\t\t\t\troots = [],\n\t\t\t\t\ty = point.y,\n\t\t\t\t\txIntercepts = [];\n\t\t\t\tfor (var i = 0, l = curves.length; i < l; i++) {\n\t\t\t\t\tvar values = curves[i].values;\n\t\t\t\t\tif ((curves[i].winding === 1\n\t\t\t\t\t\t\t&& y >= values[1] && y <= values[7]\n\t\t\t\t\t\t\t|| y >= values[7] && y <= values[1])\n\t\t\t\t\t\t\t&& Curve.solveCubic(values, 1, y, roots, 0, 1) > 0) {\n\t\t\t\t\t\tfor (var j = roots.length - 1; j >= 0; j--)\n\t\t\t\t\t\t\txIntercepts.push(Curve.getPoint(values, roots[j]).x);\n\t\t\t\t\t}\n\t\t\t\t\tif (xIntercepts.length > 1)\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tpoint.x = (xIntercepts[0] + xIntercepts[1]) / 2;\n\t\t\t}\n\t\t\treturn point;\n\t\t},\n\t\n\t\treorient: function() {\n\t\t\tthis.setClockwise(true);\n\t\t\treturn this;\n\t\t}\n\t});\n\t\n\tCompoundPath.inject({\n\t\t_getMonoCurves: function() {\n\t\t\tvar children = this._children,\n\t\t\t\tmonoCurves = [];\n\t\t\tfor (var i = 0, l = children.length; i < l; i++)\n\t\t\t\tmonoCurves.push.apply(monoCurves, children[i]._getMonoCurves());\n\t\t\treturn monoCurves;\n\t\t},\n\t\n\t\treorient: function() {\n\t\t\tvar children = this.removeChildren().sort(function(a, b) {\n\t\t\t\treturn b.getBounds().getArea() - a.getBounds().getArea();\n\t\t\t});\n\t\t\tif (children.length > 0) {\n\t\t\t\tthis.addChildren(children);\n\t\t\t\tvar clockwise = children[0].isClockwise();\n\t\t\t\tfor (var i = 1, l = children.length; i < l; i++) {\n\t\t\t\t\tvar point = children[i].getInteriorPoint(),\n\t\t\t\t\t\tcounters = 0;\n\t\t\t\t\tfor (var j = i - 1; j >= 0; j--) {\n\t\t\t\t\t\tif (children[j].contains(point))\n\t\t\t\t\t\t\tcounters++;\n\t\t\t\t\t}\n\t\t\t\t\tchildren[i].setClockwise(counters % 2 === 0 && clockwise);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn this;\n\t\t}\n\t});\n\t\n\tvar PathIterator = Base.extend({\n\t\t_class: 'PathIterator',\n\t\n\t\tinitialize: function(path, maxRecursion, tolerance, matrix) {\n\t\t\tvar curves = [],\n\t\t\t\tparts = [],\n\t\t\t\tlength = 0,\n\t\t\t\tminDifference = 1 / (maxRecursion || 32),\n\t\t\t\tsegments = path._segments,\n\t\t\t\tsegment1 = segments[0],\n\t\t\t\tsegment2;\n\t\n\t\t\tfunction addCurve(segment1, segment2) {\n\t\t\t\tvar curve = Curve.getValues(segment1, segment2, matrix);\n\t\t\t\tcurves.push(curve);\n\t\t\t\tcomputeParts(curve, segment1._index, 0, 1);\n\t\t\t}\n\t\n\t\t\tfunction computeParts(curve, index, minT, maxT) {\n\t\t\t\tif ((maxT - minT) > minDifference\n\t\t\t\t\t\t&& !Curve.isFlatEnough(curve, tolerance || 0.25)) {\n\t\t\t\t\tvar split = Curve.subdivide(curve, 0.5),\n\t\t\t\t\t\thalfT = (minT + maxT) / 2;\n\t\t\t\t\tcomputeParts(split[0], index, minT, halfT);\n\t\t\t\t\tcomputeParts(split[1], index, halfT, maxT);\n\t\t\t\t} else {\n\t\t\t\t\tvar x = curve[6] - curve[0],\n\t\t\t\t\t\ty = curve[7] - curve[1],\n\t\t\t\t\t\tdist = Math.sqrt(x * x + y * y);\n\t\t\t\t\tif (dist > 1e-6) {\n\t\t\t\t\t\tlength += dist;\n\t\t\t\t\t\tparts.push({\n\t\t\t\t\t\t\toffset: length,\n\t\t\t\t\t\t\tvalue: maxT,\n\t\t\t\t\t\t\tindex: index\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\tfor (var i = 1, l = segments.length; i < l; i++) {\n\t\t\t\tsegment2 = segments[i];\n\t\t\t\taddCurve(segment1, segment2);\n\t\t\t\tsegment1 = segment2;\n\t\t\t}\n\t\t\tif (path._closed)\n\t\t\t\taddCurve(segment2, segments[0]);\n\t\n\t\t\tthis.curves = curves;\n\t\t\tthis.parts = parts;\n\t\t\tthis.length = length;\n\t\t\tthis.index = 0;\n\t\t},\n\t\n\t\tgetParameterAt: function(offset) {\n\t\t\tvar i, j = this.index;\n\t\t\tfor (;;) {\n\t\t\t\ti = j;\n\t\t\t\tif (j == 0 || this.parts[--j].offset < offset)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfor (var l = this.parts.length; i < l; i++) {\n\t\t\t\tvar part = this.parts[i];\n\t\t\t\tif (part.offset >= offset) {\n\t\t\t\t\tthis.index = i;\n\t\t\t\t\tvar prev = this.parts[i - 1];\n\t\t\t\t\tvar prevVal = prev && prev.index == part.index ? prev.value : 0,\n\t\t\t\t\t\tprevLen = prev ? prev.offset : 0;\n\t\t\t\t\treturn {\n\t\t\t\t\t\tvalue: prevVal + (part.value - prevVal)\n\t\t\t\t\t\t\t* (offset - prevLen) / (part.offset - prevLen),\n\t\t\t\t\t\tindex: part.index\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t}\n\t\t\tvar part = this.parts[this.parts.length - 1];\n\t\t\treturn {\n\t\t\t\tvalue: 1,\n\t\t\t\tindex: part.index\n\t\t\t};\n\t\t},\n\t\n\t\tdrawPart: function(ctx, from, to) {\n\t\t\tfrom = this.getParameterAt(from);\n\t\t\tto = this.getParameterAt(to);\n\t\t\tfor (var i = from.index; i <= to.index; i++) {\n\t\t\t\tvar curve = Curve.getPart(this.curves[i],\n\t\t\t\t\t\ti == from.index ? from.value : 0,\n\t\t\t\t\t\ti == to.index ? to.value : 1);\n\t\t\t\tif (i == from.index)\n\t\t\t\t\tctx.moveTo(curve[0], curve[1]);\n\t\t\t\tctx.bezierCurveTo.apply(ctx, curve.slice(2));\n\t\t\t}\n\t\t}\n\t}, Base.each(Curve.evaluateMethods,\n\t\tfunction(name) {\n\t\t\tthis[name + 'At'] = function(offset, weighted) {\n\t\t\t\tvar param = this.getParameterAt(offset);\n\t\t\t\treturn Curve[name](this.curves[param.index], param.value, weighted);\n\t\t\t};\n\t\t}, {})\n\t);\n\t\n\tvar PathFitter = Base.extend({\n\t\tinitialize: function(path, error) {\n\t\t\tvar points = this.points = [],\n\t\t\t\tsegments = path._segments,\n\t\t\t\tprev;\n\t\t\tfor (var i = 0, l = segments.length; i < l; i++) {\n\t\t\t\tvar point = segments[i].point.clone();\n\t\t\t\tif (!prev || !prev.equals(point)) {\n\t\t\t\t\tpoints.push(point);\n\t\t\t\t\tprev = point;\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\tif (path._closed) {\n\t\t\t\tthis.closed = true;\n\t\t\t\tpoints.unshift(points[points.length - 1]);\n\t\t\t\tpoints.push(points[1]);\n\t\t\t}\n\t\n\t\t\tthis.error = error;\n\t\t},\n\t\n\t\tfit: function() {\n\t\t\tvar points = this.points,\n\t\t\t\tlength = points.length,\n\t\t\t\tsegments = this.segments = length > 0\n\t\t\t\t\t\t? [new Segment(points[0])] : [];\n\t\t\tif (length > 1)\n\t\t\t\tthis.fitCubic(0, length - 1,\n\t\t\t\t\tpoints[1].subtract(points[0]).normalize(),\n\t\t\t\t\tpoints[length - 2].subtract(points[length - 1]).normalize());\n\t\n\t\t\tif (this.closed) {\n\t\t\t\tsegments.shift();\n\t\t\t\tsegments.pop();\n\t\t\t}\n\t\n\t\t\treturn segments;\n\t\t},\n\t\n\t\tfitCubic: function(first, last, tan1, tan2) {\n\t\t\tif (last - first == 1) {\n\t\t\t\tvar pt1 = this.points[first],\n\t\t\t\t\tpt2 = this.points[last],\n\t\t\t\t\tdist = pt1.getDistance(pt2) / 3;\n\t\t\t\tthis.addCurve([pt1, pt1.add(tan1.normalize(dist)),\n\t\t\t\t\t\tpt2.add(tan2.normalize(dist)), pt2]);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvar uPrime = this.chordLengthParameterize(first, last),\n\t\t\t\tmaxError = Math.max(this.error, this.error * this.error),\n\t\t\t\tsplit,\n\t\t\t\tparametersInOrder = true;\n\t\t\tfor (var i = 0; i <= 4; i++) {\n\t\t\t\tvar curve = this.generateBezier(first, last, uPrime, tan1, tan2);\n\t\t\t\tvar max = this.findMaxError(first, last, curve, uPrime);\n\t\t\t\tif (max.error < this.error && parametersInOrder) {\n\t\t\t\t\tthis.addCurve(curve);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tsplit = max.index;\n\t\t\t\tif (max.error >= maxError)\n\t\t\t\t\tbreak;\n\t\t\t\tparametersInOrder = this.reparameterize(first, last, uPrime, curve);\n\t\t\t\tmaxError = max.error;\n\t\t\t}\n\t\t\tvar V1 = this.points[split - 1].subtract(this.points[split]),\n\t\t\t\tV2 = this.points[split].subtract(this.points[split + 1]),\n\t\t\t\ttanCenter = V1.add(V2).divide(2).normalize();\n\t\t\tthis.fitCubic(first, split, tan1, tanCenter);\n\t\t\tthis.fitCubic(split, last, tanCenter.negate(), tan2);\n\t\t},\n\t\n\t\taddCurve: function(curve) {\n\t\t\tvar prev = this.segments[this.segments.length - 1];\n\t\t\tprev.setHandleOut(curve[1].subtract(curve[0]));\n\t\t\tthis.segments.push(\n\t\t\t\t\tnew Segment(curve[3], curve[2].subtract(curve[3])));\n\t\t},\n\t\n\t\tgenerateBezier: function(first, last, uPrime, tan1, tan2) {\n\t\t\tvar epsilon = 1e-12,\n\t\t\t\tpt1 = this.points[first],\n\t\t\t\tpt2 = this.points[last],\n\t\t\t\tC = [[0, 0], [0, 0]],\n\t\t\t\tX = [0, 0];\n\t\n\t\t\tfor (var i = 0, l = last - first + 1; i < l; i++) {\n\t\t\t\tvar u = uPrime[i],\n\t\t\t\t\tt = 1 - u,\n\t\t\t\t\tb = 3 * u * t,\n\t\t\t\t\tb0 = t * t * t,\n\t\t\t\t\tb1 = b * t,\n\t\t\t\t\tb2 = b * u,\n\t\t\t\t\tb3 = u * u * u,\n\t\t\t\t\ta1 = tan1.normalize(b1),\n\t\t\t\t\ta2 = tan2.normalize(b2),\n\t\t\t\t\ttmp = this.points[first + i]\n\t\t\t\t\t\t.subtract(pt1.multiply(b0 + b1))\n\t\t\t\t\t\t.subtract(pt2.multiply(b2 + b3));\n\t\t\t\tC[0][0] += a1.dot(a1);\n\t\t\t\tC[0][1] += a1.dot(a2);\n\t\t\t\tC[1][0] = C[0][1];\n\t\t\t\tC[1][1] += a2.dot(a2);\n\t\t\t\tX[0] += a1.dot(tmp);\n\t\t\t\tX[1] += a2.dot(tmp);\n\t\t\t}\n\t\n\t\t\tvar detC0C1 = C[0][0] * C[1][1] - C[1][0] * C[0][1],\n\t\t\t\talpha1, alpha2;\n\t\t\tif (Math.abs(detC0C1) > epsilon) {\n\t\t\t\tvar detC0X\t= C[0][0] * X[1]\t- C[1][0] * X[0],\n\t\t\t\t\tdetXC1\t= X[0]\t  * C[1][1] - X[1]\t  * C[0][1];\n\t\t\t\talpha1 = detXC1 / detC0C1;\n\t\t\t\talpha2 = detC0X / detC0C1;\n\t\t\t} else {\n\t\t\t\tvar c0 = C[0][0] + C[0][1],\n\t\t\t\t\tc1 = C[1][0] + C[1][1];\n\t\t\t\tif (Math.abs(c0) > epsilon) {\n\t\t\t\t\talpha1 = alpha2 = X[0] / c0;\n\t\t\t\t} else if (Math.abs(c1) > epsilon) {\n\t\t\t\t\talpha1 = alpha2 = X[1] / c1;\n\t\t\t\t} else {\n\t\t\t\t\talpha1 = alpha2 = 0;\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\tvar segLength = pt2.getDistance(pt1),\n\t\t\t\teps = epsilon * segLength,\n\t\t\t\thandle1,\n\t\t\t\thandle2;\n\t\t\tif (alpha1 < eps || alpha2 < eps) {\n\t\t\t\talpha1 = alpha2 = segLength / 3;\n\t\t\t} else {\n\t\t\t\tvar line = pt2.subtract(pt1);\n\t\t\t\thandle1 = tan1.normalize(alpha1);\n\t\t\t\thandle2 = tan2.normalize(alpha2);\n\t\t\t\tif (handle1.dot(line) - handle2.dot(line) > segLength * segLength) {\n\t\t\t\t\talpha1 = alpha2 = segLength / 3;\n\t\t\t\t\thandle1 = handle2 = null;\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\treturn [pt1, pt1.add(handle1 || tan1.normalize(alpha1)),\n\t\t\t\t\tpt2.add(handle2 || tan2.normalize(alpha2)), pt2];\n\t\t},\n\t\n\t\treparameterize: function(first, last, u, curve) {\n\t\t\tfor (var i = first; i <= last; i++) {\n\t\t\t\tu[i - first] = this.findRoot(curve, this.points[i], u[i - first]);\n\t\t\t}\n\t\t\tfor (var i = 1, l = u.length; i < l; i++) {\n\t\t\t\tif (u[i] <= u[i - 1])\n\t\t\t\t\treturn false;\n\t\t\t}\n\t\t\treturn true;\n\t\t},\n\t\n\t\tfindRoot: function(curve, point, u) {\n\t\t\tvar curve1 = [],\n\t\t\t\tcurve2 = [];\n\t\t\tfor (var i = 0; i <= 2; i++) {\n\t\t\t\tcurve1[i] = curve[i + 1].subtract(curve[i]).multiply(3);\n\t\t\t}\n\t\t\tfor (var i = 0; i <= 1; i++) {\n\t\t\t\tcurve2[i] = curve1[i + 1].subtract(curve1[i]).multiply(2);\n\t\t\t}\n\t\t\tvar pt = this.evaluate(3, curve, u),\n\t\t\t\tpt1 = this.evaluate(2, curve1, u),\n\t\t\t\tpt2 = this.evaluate(1, curve2, u),\n\t\t\t\tdiff = pt.subtract(point),\n\t\t\t\tdf = pt1.dot(pt1) + diff.dot(pt2);\n\t\t\tif (Math.abs(df) < 1e-6)\n\t\t\t\treturn u;\n\t\t\treturn u - diff.dot(pt1) / df;\n\t\t},\n\t\n\t\tevaluate: function(degree, curve, t) {\n\t\t\tvar tmp = curve.slice();\n\t\t\tfor (var i = 1; i <= degree; i++) {\n\t\t\t\tfor (var j = 0; j <= degree - i; j++) {\n\t\t\t\t\ttmp[j] = tmp[j].multiply(1 - t).add(tmp[j + 1].multiply(t));\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn tmp[0];\n\t\t},\n\t\n\t\tchordLengthParameterize: function(first, last) {\n\t\t\tvar u = [0];\n\t\t\tfor (var i = first + 1; i <= last; i++) {\n\t\t\t\tu[i - first] = u[i - first - 1]\n\t\t\t\t\t\t+ this.points[i].getDistance(this.points[i - 1]);\n\t\t\t}\n\t\t\tfor (var i = 1, m = last - first; i <= m; i++) {\n\t\t\t\tu[i] /= u[m];\n\t\t\t}\n\t\t\treturn u;\n\t\t},\n\t\n\t\tfindMaxError: function(first, last, curve, u) {\n\t\t\tvar index = Math.floor((last - first + 1) / 2),\n\t\t\t\tmaxDist = 0;\n\t\t\tfor (var i = first + 1; i < last; i++) {\n\t\t\t\tvar P = this.evaluate(3, curve, u[i - first]);\n\t\t\t\tvar v = P.subtract(this.points[i]);\n\t\t\t\tvar dist = v.x * v.x + v.y * v.y;\n\t\t\t\tif (dist >= maxDist) {\n\t\t\t\t\tmaxDist = dist;\n\t\t\t\t\tindex = i;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn {\n\t\t\t\terror: maxDist,\n\t\t\t\tindex: index\n\t\t\t};\n\t\t}\n\t});\n\t\n\tvar TextItem = Item.extend({\n\t\t_class: 'TextItem',\n\t\t_boundsSelected: true,\n\t\t_applyMatrix: false,\n\t\t_canApplyMatrix: false,\n\t\t_serializeFields: {\n\t\t\tcontent: null\n\t\t},\n\t\t_boundsGetter: 'getBounds',\n\t\n\t\tinitialize: function TextItem(arg) {\n\t\t\tthis._content = '';\n\t\t\tthis._lines = [];\n\t\t\tvar hasProps = arg && Base.isPlainObject(arg)\n\t\t\t\t\t&& arg.x === undefined && arg.y === undefined;\n\t\t\tthis._initialize(hasProps && arg, !hasProps && Point.read(arguments));\n\t\t},\n\t\n\t\t_equals: function(item) {\n\t\t\treturn this._content === item._content;\n\t\t},\n\t\n\t\t_clone: function _clone(copy, insert, includeMatrix) {\n\t\t\tcopy.setContent(this._content);\n\t\t\treturn _clone.base.call(this, copy, insert, includeMatrix);\n\t\t},\n\t\n\t\tgetContent: function() {\n\t\t\treturn this._content;\n\t\t},\n\t\n\t\tsetContent: function(content) {\n\t\t\tthis._content = '' + content;\n\t\t\tthis._lines = this._content.split(/\\r\\n|\\n|\\r/mg);\n\t\t\tthis._changed(265);\n\t\t},\n\t\n\t\tisEmpty: function() {\n\t\t\treturn !this._content;\n\t\t},\n\t\n\t\tgetCharacterStyle: '#getStyle',\n\t\tsetCharacterStyle: '#setStyle',\n\t\n\t\tgetParagraphStyle: '#getStyle',\n\t\tsetParagraphStyle: '#setStyle'\n\t});\n\t\n\tvar PointText = TextItem.extend({\n\t\t_class: 'PointText',\n\t\n\t\tinitialize: function PointText() {\n\t\t\tTextItem.apply(this, arguments);\n\t\t},\n\t\n\t\tclone: function(insert) {\n\t\t\treturn this._clone(new PointText(Item.NO_INSERT), insert);\n\t\t},\n\t\n\t\tgetPoint: function() {\n\t\t\tvar point = this._matrix.getTranslation();\n\t\t\treturn new LinkedPoint(point.x, point.y, this, 'setPoint');\n\t\t},\n\t\n\t\tsetPoint: function() {\n\t\t\tvar point = Point.read(arguments);\n\t\t\tthis.translate(point.subtract(this._matrix.getTranslation()));\n\t\t},\n\t\n\t\t_draw: function(ctx) {\n\t\t\tif (!this._content)\n\t\t\t\treturn;\n\t\t\tthis._setStyles(ctx);\n\t\t\tvar style = this._style,\n\t\t\t\tlines = this._lines,\n\t\t\t\tleading = style.getLeading(),\n\t\t\t\tshadowColor = ctx.shadowColor;\n\t\t\tctx.font = style.getFontStyle();\n\t\t\tctx.textAlign = style.getJustification();\n\t\t\tfor (var i = 0, l = lines.length; i < l; i++) {\n\t\t\t\tctx.shadowColor = shadowColor;\n\t\t\t\tvar line = lines[i];\n\t\t\t\tif (style.hasFill()) {\n\t\t\t\t\tctx.fillText(line, 0, 0);\n\t\t\t\t\tctx.shadowColor = 'rgba(0,0,0,0)';\n\t\t\t\t}\n\t\t\t\tif (style.hasStroke())\n\t\t\t\t\tctx.strokeText(line, 0, 0);\n\t\t\t\tctx.translate(0, leading);\n\t\t\t}\n\t\t},\n\t\n\t\t_getBounds: function(getter, matrix) {\n\t\t\tvar style = this._style,\n\t\t\t\tlines = this._lines,\n\t\t\t\tnumLines = lines.length,\n\t\t\t\tjustification = style.getJustification(),\n\t\t\t\tleading = style.getLeading(),\n\t\t\t\twidth = this.getView().getTextWidth(style.getFontStyle(), lines),\n\t\t\t\tx = 0;\n\t\t\tif (justification !== 'left')\n\t\t\t\tx -= width / (justification === 'center' ? 2: 1);\n\t\t\tvar bounds = new Rectangle(x,\n\t\t\t\t\t\tnumLines ? - 0.75 * leading : 0,\n\t\t\t\t\t\twidth, numLines * leading);\n\t\t\treturn matrix ? matrix._transformBounds(bounds, bounds) : bounds;\n\t\t}\n\t});\n\t\n\tvar Color = Base.extend(new function() {\n\t\tvar types = {\n\t\t\tgray: ['gray'],\n\t\t\trgb: ['red', 'green', 'blue'],\n\t\t\thsb: ['hue', 'saturation', 'brightness'],\n\t\t\thsl: ['hue', 'saturation', 'lightness'],\n\t\t\tgradient: ['gradient', 'origin', 'destination', 'highlight']\n\t\t};\n\t\n\t\tvar componentParsers = {},\n\t\t\tcolorCache = {},\n\t\t\tcolorCtx;\n\t\n\t\tfunction fromCSS(string) {\n\t\t\tvar match = string.match(/^#(\\w{1,2})(\\w{1,2})(\\w{1,2})$/),\n\t\t\t\tcomponents;\n\t\t\tif (match) {\n\t\t\t\tcomponents = [0, 0, 0];\n\t\t\t\tfor (var i = 0; i < 3; i++) {\n\t\t\t\t\tvar value = match[i + 1];\n\t\t\t\t\tcomponents[i] = parseInt(value.length == 1\n\t\t\t\t\t\t\t? value + value : value, 16) / 255;\n\t\t\t\t}\n\t\t\t} else if (match = string.match(/^rgba?\\((.*)\\)$/)) {\n\t\t\t\tcomponents = match[1].split(',');\n\t\t\t\tfor (var i = 0, l = components.length; i < l; i++) {\n\t\t\t\t\tvar value = +components[i];\n\t\t\t\t\tcomponents[i] = i < 3 ? value / 255 : value;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tvar cached = colorCache[string];\n\t\t\t\tif (!cached) {\n\t\t\t\t\tif (!colorCtx) {\n\t\t\t\t\t\tcolorCtx = CanvasProvider.getContext(1, 1);\n\t\t\t\t\t\tcolorCtx.globalCompositeOperation = 'copy';\n\t\t\t\t\t}\n\t\t\t\t\tcolorCtx.fillStyle = 'rgba(0,0,0,0)';\n\t\t\t\t\tcolorCtx.fillStyle = string;\n\t\t\t\t\tcolorCtx.fillRect(0, 0, 1, 1);\n\t\t\t\t\tvar data = colorCtx.getImageData(0, 0, 1, 1).data;\n\t\t\t\t\tcached = colorCache[string] = [\n\t\t\t\t\t\tdata[0] / 255,\n\t\t\t\t\t\tdata[1] / 255,\n\t\t\t\t\t\tdata[2] / 255\n\t\t\t\t\t];\n\t\t\t\t}\n\t\t\t\tcomponents = cached.slice();\n\t\t\t}\n\t\t\treturn components;\n\t\t}\n\t\n\t\tvar hsbIndices = [\n\t\t\t[0, 3, 1],\n\t\t\t[2, 0, 1],\n\t\t\t[1, 0, 3],\n\t\t\t[1, 2, 0],\n\t\t\t[3, 1, 0],\n\t\t\t[0, 1, 2]\n\t\t];\n\t\n\t\tvar converters = {\n\t\t\t'rgb-hsb': function(r, g, b) {\n\t\t\t\tvar max = Math.max(r, g, b),\n\t\t\t\t\tmin = Math.min(r, g, b),\n\t\t\t\t\tdelta = max - min,\n\t\t\t\t\th = delta === 0 ? 0\n\t\t\t\t\t\t:\t( max == r ? (g - b) / delta + (g < b ? 6 : 0)\n\t\t\t\t\t\t\t: max == g ? (b - r) / delta + 2\n\t\t\t\t\t\t\t:\t\t\t (r - g) / delta + 4) * 60;\n\t\t\t\treturn [h, max === 0 ? 0 : delta / max, max];\n\t\t\t},\n\t\n\t\t\t'hsb-rgb': function(h, s, b) {\n\t\t\t\th = (((h / 60) % 6) + 6) % 6;\n\t\t\t\tvar i = Math.floor(h),\n\t\t\t\t\tf = h - i,\n\t\t\t\t\ti = hsbIndices[i],\n\t\t\t\t\tv = [\n\t\t\t\t\t\tb,\n\t\t\t\t\t\tb * (1 - s),\n\t\t\t\t\t\tb * (1 - s * f),\n\t\t\t\t\t\tb * (1 - s * (1 - f))\n\t\t\t\t\t];\n\t\t\t\treturn [v[i[0]], v[i[1]], v[i[2]]];\n\t\t\t},\n\t\n\t\t\t'rgb-hsl': function(r, g, b) {\n\t\t\t\tvar max = Math.max(r, g, b),\n\t\t\t\t\tmin = Math.min(r, g, b),\n\t\t\t\t\tdelta = max - min,\n\t\t\t\t\tachromatic = delta === 0,\n\t\t\t\t\th = achromatic ? 0\n\t\t\t\t\t\t:\t( max == r ? (g - b) / delta + (g < b ? 6 : 0)\n\t\t\t\t\t\t\t: max == g ? (b - r) / delta + 2\n\t\t\t\t\t\t\t:\t\t\t (r - g) / delta + 4) * 60,\n\t\t\t\t\tl = (max + min) / 2,\n\t\t\t\t\ts = achromatic ? 0 : l < 0.5\n\t\t\t\t\t\t\t? delta / (max + min)\n\t\t\t\t\t\t\t: delta / (2 - max - min);\n\t\t\t\treturn [h, s, l];\n\t\t\t},\n\t\n\t\t\t'hsl-rgb': function(h, s, l) {\n\t\t\t\th = (((h / 360) % 1) + 1) % 1;\n\t\t\t\tif (s === 0)\n\t\t\t\t\treturn [l, l, l];\n\t\t\t\tvar t3s = [ h + 1 / 3, h, h - 1 / 3 ],\n\t\t\t\t\tt2 = l < 0.5 ? l * (1 + s) : l + s - l * s,\n\t\t\t\t\tt1 = 2 * l - t2,\n\t\t\t\t\tc = [];\n\t\t\t\tfor (var i = 0; i < 3; i++) {\n\t\t\t\t\tvar t3 = t3s[i];\n\t\t\t\t\tif (t3 < 0) t3 += 1;\n\t\t\t\t\tif (t3 > 1) t3 -= 1;\n\t\t\t\t\tc[i] = 6 * t3 < 1\n\t\t\t\t\t\t? t1 + (t2 - t1) * 6 * t3\n\t\t\t\t\t\t: 2 * t3 < 1\n\t\t\t\t\t\t\t? t2\n\t\t\t\t\t\t\t: 3 * t3 < 2\n\t\t\t\t\t\t\t\t? t1 + (t2 - t1) * ((2 / 3) - t3) * 6\n\t\t\t\t\t\t\t\t: t1;\n\t\t\t\t}\n\t\t\t\treturn c;\n\t\t\t},\n\t\n\t\t\t'rgb-gray': function(r, g, b) {\n\t\t\t\treturn [r * 0.2989 + g * 0.587 + b * 0.114];\n\t\t\t},\n\t\n\t\t\t'gray-rgb': function(g) {\n\t\t\t\treturn [g, g, g];\n\t\t\t},\n\t\n\t\t\t'gray-hsb': function(g) {\n\t\t\t\treturn [0, 0, g];\n\t\t\t},\n\t\n\t\t\t'gray-hsl': function(g) {\n\t\t\t\treturn [0, 0, g];\n\t\t\t},\n\t\n\t\t\t'gradient-rgb': function() {\n\t\t\t\treturn [];\n\t\t\t},\n\t\n\t\t\t'rgb-gradient': function() {\n\t\t\t\treturn [];\n\t\t\t}\n\t\n\t\t};\n\t\n\t\treturn Base.each(types, function(properties, type) {\n\t\t\tcomponentParsers[type] = [];\n\t\t\tBase.each(properties, function(name, index) {\n\t\t\t\tvar part = Base.capitalize(name),\n\t\t\t\t\thasOverlap = /^(hue|saturation)$/.test(name),\n\t\t\t\t\tparser = componentParsers[type][index] = name === 'gradient'\n\t\t\t\t\t\t? function(value) {\n\t\t\t\t\t\t\tvar current = this._components[0];\n\t\t\t\t\t\t\tvalue = Gradient.read(Array.isArray(value) ? value\n\t\t\t\t\t\t\t\t\t: arguments, 0, { readNull: true });\n\t\t\t\t\t\t\tif (current !== value) {\n\t\t\t\t\t\t\t\tif (current)\n\t\t\t\t\t\t\t\t\tcurrent._removeOwner(this);\n\t\t\t\t\t\t\t\tif (value)\n\t\t\t\t\t\t\t\t\tvalue._addOwner(this);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn value;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t: type === 'gradient'\n\t\t\t\t\t\t\t? function() {\n\t\t\t\t\t\t\t\treturn Point.read(arguments, 0, {\n\t\t\t\t\t\t\t\t\t\treadNull: name === 'highlight',\n\t\t\t\t\t\t\t\t\t\tclone: true\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t: function(value) {\n\t\t\t\t\t\t\t\treturn value == null || isNaN(value) ? 0 : value;\n\t\t\t\t\t\t\t};\n\t\n\t\t\t\tthis['get' + part] = function() {\n\t\t\t\t\treturn this._type === type\n\t\t\t\t\t\t|| hasOverlap && /^hs[bl]$/.test(this._type)\n\t\t\t\t\t\t\t? this._components[index]\n\t\t\t\t\t\t\t: this._convert(type)[index];\n\t\t\t\t};\n\t\n\t\t\t\tthis['set' + part] = function(value) {\n\t\t\t\t\tif (this._type !== type\n\t\t\t\t\t\t\t&& !(hasOverlap && /^hs[bl]$/.test(this._type))) {\n\t\t\t\t\t\tthis._components = this._convert(type);\n\t\t\t\t\t\tthis._properties = types[type];\n\t\t\t\t\t\tthis._type = type;\n\t\t\t\t\t}\n\t\t\t\t\tthis._components[index] = parser.call(this, value);\n\t\t\t\t\tthis._changed();\n\t\t\t\t};\n\t\t\t}, this);\n\t\t}, {\n\t\t\t_class: 'Color',\n\t\t\t_readIndex: true,\n\t\n\t\t\tinitialize: function Color(arg) {\n\t\t\t\tvar slice = Array.prototype.slice,\n\t\t\t\t\targs = arguments,\n\t\t\t\t\tread = 0,\n\t\t\t\t\ttype,\n\t\t\t\t\tcomponents,\n\t\t\t\t\talpha,\n\t\t\t\t\tvalues;\n\t\t\t\tif (Array.isArray(arg)) {\n\t\t\t\t\targs = arg;\n\t\t\t\t\targ = args[0];\n\t\t\t\t}\n\t\t\t\tvar argType = arg != null && typeof arg;\n\t\t\t\tif (argType === 'string' && arg in types) {\n\t\t\t\t\ttype = arg;\n\t\t\t\t\targ = args[1];\n\t\t\t\t\tif (Array.isArray(arg)) {\n\t\t\t\t\t\tcomponents = arg;\n\t\t\t\t\t\talpha = args[2];\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (this.__read)\n\t\t\t\t\t\t\tread = 1;\n\t\t\t\t\t\targs = slice.call(args, 1);\n\t\t\t\t\t\targType = typeof arg;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!components) {\n\t\t\t\t\tvalues = argType === 'number'\n\t\t\t\t\t\t\t? args\n\t\t\t\t\t\t\t: argType === 'object' && arg.length != null\n\t\t\t\t\t\t\t\t? arg\n\t\t\t\t\t\t\t\t: null;\n\t\t\t\t\tif (values) {\n\t\t\t\t\t\tif (!type)\n\t\t\t\t\t\t\ttype = values.length >= 3\n\t\t\t\t\t\t\t\t\t? 'rgb'\n\t\t\t\t\t\t\t\t\t: 'gray';\n\t\t\t\t\t\tvar length = types[type].length;\n\t\t\t\t\t\talpha = values[length];\n\t\t\t\t\t\tif (this.__read)\n\t\t\t\t\t\t\tread += values === arguments\n\t\t\t\t\t\t\t\t? length + (alpha != null ? 1 : 0)\n\t\t\t\t\t\t\t\t: 1;\n\t\t\t\t\t\tif (values.length > length)\n\t\t\t\t\t\t\tvalues = slice.call(values, 0, length);\n\t\t\t\t\t} else if (argType === 'string') {\n\t\t\t\t\t\ttype = 'rgb';\n\t\t\t\t\t\tcomponents = fromCSS(arg);\n\t\t\t\t\t\tif (components.length === 4) {\n\t\t\t\t\t\t\talpha = components[3];\n\t\t\t\t\t\t\tcomponents.length--;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (argType === 'object') {\n\t\t\t\t\t\tif (arg.constructor === Color) {\n\t\t\t\t\t\t\ttype = arg._type;\n\t\t\t\t\t\t\tcomponents = arg._components.slice();\n\t\t\t\t\t\t\talpha = arg._alpha;\n\t\t\t\t\t\t\tif (type === 'gradient') {\n\t\t\t\t\t\t\t\tfor (var i = 1, l = components.length; i < l; i++) {\n\t\t\t\t\t\t\t\t\tvar point = components[i];\n\t\t\t\t\t\t\t\t\tif (point)\n\t\t\t\t\t\t\t\t\t\tcomponents[i] = point.clone();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else if (arg.constructor === Gradient) {\n\t\t\t\t\t\t\ttype = 'gradient';\n\t\t\t\t\t\t\tvalues = args;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\ttype = 'hue' in arg\n\t\t\t\t\t\t\t\t? 'lightness' in arg\n\t\t\t\t\t\t\t\t\t? 'hsl'\n\t\t\t\t\t\t\t\t\t: 'hsb'\n\t\t\t\t\t\t\t\t: 'gradient' in arg || 'stops' in arg\n\t\t\t\t\t\t\t\t\t\t|| 'radial' in arg\n\t\t\t\t\t\t\t\t\t? 'gradient'\n\t\t\t\t\t\t\t\t\t: 'gray' in arg\n\t\t\t\t\t\t\t\t\t\t? 'gray'\n\t\t\t\t\t\t\t\t\t\t: 'rgb';\n\t\t\t\t\t\t\tvar properties = types[type],\n\t\t\t\t\t\t\t\tparsers = componentParsers[type];\n\t\t\t\t\t\t\tthis._components = components = [];\n\t\t\t\t\t\t\tfor (var i = 0, l = properties.length; i < l; i++) {\n\t\t\t\t\t\t\t\tvar value = arg[properties[i]];\n\t\t\t\t\t\t\t\tif (value == null && i === 0 && type === 'gradient'\n\t\t\t\t\t\t\t\t\t\t&& 'stops' in arg) {\n\t\t\t\t\t\t\t\t\tvalue = {\n\t\t\t\t\t\t\t\t\t\tstops: arg.stops,\n\t\t\t\t\t\t\t\t\t\tradial: arg.radial\n\t\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tvalue = parsers[i].call(this, value);\n\t\t\t\t\t\t\t\tif (value != null)\n\t\t\t\t\t\t\t\t\tcomponents[i] = value;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\talpha = arg.alpha;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (this.__read && type)\n\t\t\t\t\t\tread = 1;\n\t\t\t\t}\n\t\t\t\tthis._type = type || 'rgb';\n\t\t\t\tthis._id = UID.get(Color);\n\t\t\t\tif (!components) {\n\t\t\t\t\tthis._components = components = [];\n\t\t\t\t\tvar parsers = componentParsers[this._type];\n\t\t\t\t\tfor (var i = 0, l = parsers.length; i < l; i++) {\n\t\t\t\t\t\tvar value = parsers[i].call(this, values && values[i]);\n\t\t\t\t\t\tif (value != null)\n\t\t\t\t\t\t\tcomponents[i] = value;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tthis._components = components;\n\t\t\t\tthis._properties = types[this._type];\n\t\t\t\tthis._alpha = alpha;\n\t\t\t\tif (this.__read)\n\t\t\t\t\tthis.__read = read;\n\t\t\t},\n\t\n\t\t\t_serialize: function(options, dictionary) {\n\t\t\t\tvar components = this.getComponents();\n\t\t\t\treturn Base.serialize(\n\t\t\t\t\t\t/^(gray|rgb)$/.test(this._type)\n\t\t\t\t\t\t\t? components\n\t\t\t\t\t\t\t: [this._type].concat(components),\n\t\t\t\t\t\toptions, true, dictionary);\n\t\t\t},\n\t\n\t\t\t_changed: function() {\n\t\t\t\tthis._canvasStyle = null;\n\t\t\t\tif (this._owner)\n\t\t\t\t\tthis._owner._changed(65);\n\t\t\t},\n\t\n\t\t\t_convert: function(type) {\n\t\t\t\tvar converter;\n\t\t\t\treturn this._type === type\n\t\t\t\t\t\t? this._components.slice()\n\t\t\t\t\t\t: (converter = converters[this._type + '-' + type])\n\t\t\t\t\t\t\t? converter.apply(this, this._components)\n\t\t\t\t\t\t\t: converters['rgb-' + type].apply(this,\n\t\t\t\t\t\t\t\tconverters[this._type + '-rgb'].apply(this,\n\t\t\t\t\t\t\t\t\tthis._components));\n\t\t\t},\n\t\n\t\t\tconvert: function(type) {\n\t\t\t\treturn new Color(type, this._convert(type), this._alpha);\n\t\t\t},\n\t\n\t\t\tgetType: function() {\n\t\t\t\treturn this._type;\n\t\t\t},\n\t\n\t\t\tsetType: function(type) {\n\t\t\t\tthis._components = this._convert(type);\n\t\t\t\tthis._properties = types[type];\n\t\t\t\tthis._type = type;\n\t\t\t},\n\t\n\t\t\tgetComponents: function() {\n\t\t\t\tvar components = this._components.slice();\n\t\t\t\tif (this._alpha != null)\n\t\t\t\t\tcomponents.push(this._alpha);\n\t\t\t\treturn components;\n\t\t\t},\n\t\n\t\t\tgetAlpha: function() {\n\t\t\t\treturn this._alpha != null ? this._alpha : 1;\n\t\t\t},\n\t\n\t\t\tsetAlpha: function(alpha) {\n\t\t\t\tthis._alpha = alpha == null ? null : Math.min(Math.max(alpha, 0), 1);\n\t\t\t\tthis._changed();\n\t\t\t},\n\t\n\t\t\thasAlpha: function() {\n\t\t\t\treturn this._alpha != null;\n\t\t\t},\n\t\n\t\t\tequals: function(color) {\n\t\t\t\tvar col = Base.isPlainValue(color, true)\n\t\t\t\t\t\t? Color.read(arguments)\n\t\t\t\t\t\t: color;\n\t\t\t\treturn col === this || col && this._class === col._class\n\t\t\t\t\t\t&& this._type === col._type\n\t\t\t\t\t\t&& this._alpha === col._alpha\n\t\t\t\t\t\t&& Base.equals(this._components, col._components)\n\t\t\t\t\t\t|| false;\n\t\t\t},\n\t\n\t\t\ttoString: function() {\n\t\t\t\tvar properties = this._properties,\n\t\t\t\t\tparts = [],\n\t\t\t\t\tisGradient = this._type === 'gradient',\n\t\t\t\t\tf = Formatter.instance;\n\t\t\t\tfor (var i = 0, l = properties.length; i < l; i++) {\n\t\t\t\t\tvar value = this._components[i];\n\t\t\t\t\tif (value != null)\n\t\t\t\t\t\tparts.push(properties[i] + ': '\n\t\t\t\t\t\t\t\t+ (isGradient ? value : f.number(value)));\n\t\t\t\t}\n\t\t\t\tif (this._alpha != null)\n\t\t\t\t\tparts.push('alpha: ' + f.number(this._alpha));\n\t\t\t\treturn '{ ' + parts.join(', ') + ' }';\n\t\t\t},\n\t\n\t\t\ttoCSS: function(hex) {\n\t\t\t\tvar components = this._convert('rgb'),\n\t\t\t\t\talpha = hex || this._alpha == null ? 1 : this._alpha;\n\t\t\t\tfunction convert(val) {\n\t\t\t\t\treturn Math.round((val < 0 ? 0 : val > 1 ? 1 : val) * 255);\n\t\t\t\t}\n\t\t\t\tcomponents = [\n\t\t\t\t\tconvert(components[0]),\n\t\t\t\t\tconvert(components[1]),\n\t\t\t\t\tconvert(components[2])\n\t\t\t\t];\n\t\t\t\tif (alpha < 1)\n\t\t\t\t\tcomponents.push(alpha < 0 ? 0 : alpha);\n\t\t\t\treturn hex\n\t\t\t\t\t\t? '#' + ((1 << 24) + (components[0] << 16)\n\t\t\t\t\t\t\t+ (components[1] << 8)\n\t\t\t\t\t\t\t+ components[2]).toString(16).slice(1)\n\t\t\t\t\t\t: (components.length == 4 ? 'rgba(' : 'rgb(')\n\t\t\t\t\t\t\t+ components.join(',') + ')';\n\t\t\t},\n\t\n\t\t\ttoCanvasStyle: function(ctx) {\n\t\t\t\tif (this._canvasStyle)\n\t\t\t\t\treturn this._canvasStyle;\n\t\t\t\tif (this._type !== 'gradient')\n\t\t\t\t\treturn this._canvasStyle = this.toCSS();\n\t\t\t\tvar components = this._components,\n\t\t\t\t\tgradient = components[0],\n\t\t\t\t\tstops = gradient._stops,\n\t\t\t\t\torigin = components[1],\n\t\t\t\t\tdestination = components[2],\n\t\t\t\t\tcanvasGradient;\n\t\t\t\tif (gradient._radial) {\n\t\t\t\t\tvar radius = destination.getDistance(origin),\n\t\t\t\t\t\thighlight = components[3];\n\t\t\t\t\tif (highlight) {\n\t\t\t\t\t\tvar vector = highlight.subtract(origin);\n\t\t\t\t\t\tif (vector.getLength() > radius)\n\t\t\t\t\t\t\thighlight = origin.add(vector.normalize(radius - 0.1));\n\t\t\t\t\t}\n\t\t\t\t\tvar start = highlight || origin;\n\t\t\t\t\tcanvasGradient = ctx.createRadialGradient(start.x, start.y,\n\t\t\t\t\t\t\t0, origin.x, origin.y, radius);\n\t\t\t\t} else {\n\t\t\t\t\tcanvasGradient = ctx.createLinearGradient(origin.x, origin.y,\n\t\t\t\t\t\t\tdestination.x, destination.y);\n\t\t\t\t}\n\t\t\t\tfor (var i = 0, l = stops.length; i < l; i++) {\n\t\t\t\t\tvar stop = stops[i];\n\t\t\t\t\tcanvasGradient.addColorStop(stop._rampPoint,\n\t\t\t\t\t\t\tstop._color.toCanvasStyle());\n\t\t\t\t}\n\t\t\t\treturn this._canvasStyle = canvasGradient;\n\t\t\t},\n\t\n\t\t\ttransform: function(matrix) {\n\t\t\t\tif (this._type === 'gradient') {\n\t\t\t\t\tvar components = this._components;\n\t\t\t\t\tfor (var i = 1, l = components.length; i < l; i++) {\n\t\t\t\t\t\tvar point = components[i];\n\t\t\t\t\t\tmatrix._transformPoint(point, point, true);\n\t\t\t\t\t}\n\t\t\t\t\tthis._changed();\n\t\t\t\t}\n\t\t\t},\n\t\n\t\t\tstatics: {\n\t\t\t\t_types: types,\n\t\n\t\t\t\trandom: function() {\n\t\t\t\t\tvar random = Math.random;\n\t\t\t\t\treturn new Color(random(), random(), random());\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t},\n\tnew function() {\n\t\tvar operators = {\n\t\t\tadd: function(a, b) {\n\t\t\t\treturn a + b;\n\t\t\t},\n\t\n\t\t\tsubtract: function(a, b) {\n\t\t\t\treturn a - b;\n\t\t\t},\n\t\n\t\t\tmultiply: function(a, b) {\n\t\t\t\treturn a * b;\n\t\t\t},\n\t\n\t\t\tdivide: function(a, b) {\n\t\t\t\treturn a / b;\n\t\t\t}\n\t\t};\n\t\n\t\treturn Base.each(operators, function(operator, name) {\n\t\t\tthis[name] = function(color) {\n\t\t\t\tcolor = Color.read(arguments);\n\t\t\t\tvar type = this._type,\n\t\t\t\t\tcomponents1 = this._components,\n\t\t\t\t\tcomponents2 = color._convert(type);\n\t\t\t\tfor (var i = 0, l = components1.length; i < l; i++)\n\t\t\t\t\tcomponents2[i] = operator(components1[i], components2[i]);\n\t\t\t\treturn new Color(type, components2,\n\t\t\t\t\t\tthis._alpha != null\n\t\t\t\t\t\t\t\t? operator(this._alpha, color.getAlpha())\n\t\t\t\t\t\t\t\t: null);\n\t\t\t};\n\t\t}, {\n\t\t});\n\t});\n\t\n\tvar Gradient = Base.extend({\n\t\t_class: 'Gradient',\n\t\n\t\tinitialize: function Gradient(stops, radial) {\n\t\t\tthis._id = UID.get();\n\t\t\tif (stops && this._set(stops))\n\t\t\t\tstops = radial = null;\n\t\t\tif (!this._stops)\n\t\t\t\tthis.setStops(stops || ['white', 'black']);\n\t\t\tif (this._radial == null)\n\t\t\t\tthis.setRadial(typeof radial === 'string' && radial === 'radial'\n\t\t\t\t\t\t|| radial || false);\n\t\t},\n\t\n\t\t_serialize: function(options, dictionary) {\n\t\t\treturn dictionary.add(this, function() {\n\t\t\t\treturn Base.serialize([this._stops, this._radial],\n\t\t\t\t\t\toptions, true, dictionary);\n\t\t\t});\n\t\t},\n\t\n\t\t_changed: function() {\n\t\t\tfor (var i = 0, l = this._owners && this._owners.length; i < l; i++)\n\t\t\t\tthis._owners[i]._changed();\n\t\t},\n\t\n\t\t_addOwner: function(color) {\n\t\t\tif (!this._owners)\n\t\t\t\tthis._owners = [];\n\t\t\tthis._owners.push(color);\n\t\t},\n\t\n\t\t_removeOwner: function(color) {\n\t\t\tvar index = this._owners ? this._owners.indexOf(color) : -1;\n\t\t\tif (index != -1) {\n\t\t\t\tthis._owners.splice(index, 1);\n\t\t\t\tif (this._owners.length === 0)\n\t\t\t\t\tthis._owners = undefined;\n\t\t\t}\n\t\t},\n\t\n\t\tclone: function() {\n\t\t\tvar stops = [];\n\t\t\tfor (var i = 0, l = this._stops.length; i < l; i++)\n\t\t\t\tstops[i] = this._stops[i].clone();\n\t\t\treturn new Gradient(stops, this._radial);\n\t\t},\n\t\n\t\tgetStops: function() {\n\t\t\treturn this._stops;\n\t\t},\n\t\n\t\tsetStops: function(stops) {\n\t\t\tif (this.stops) {\n\t\t\t\tfor (var i = 0, l = this._stops.length; i < l; i++)\n\t\t\t\t\tthis._stops[i]._owner = undefined;\n\t\t\t}\n\t\t\tif (stops.length < 2)\n\t\t\t\tthrow new Error(\n\t\t\t\t\t\t'Gradient stop list needs to contain at least two stops.');\n\t\t\tthis._stops = GradientStop.readAll(stops, 0, { clone: true });\n\t\t\tfor (var i = 0, l = this._stops.length; i < l; i++) {\n\t\t\t\tvar stop = this._stops[i];\n\t\t\t\tstop._owner = this;\n\t\t\t\tif (stop._defaultRamp)\n\t\t\t\t\tstop.setRampPoint(i / (l - 1));\n\t\t\t}\n\t\t\tthis._changed();\n\t\t},\n\t\n\t\tgetRadial: function() {\n\t\t\treturn this._radial;\n\t\t},\n\t\n\t\tsetRadial: function(radial) {\n\t\t\tthis._radial = radial;\n\t\t\tthis._changed();\n\t\t},\n\t\n\t\tequals: function(gradient) {\n\t\t\tif (gradient === this)\n\t\t\t\treturn true;\n\t\t\tif (gradient && this._class === gradient._class\n\t\t\t\t\t&& this._stops.length === gradient._stops.length) {\n\t\t\t\tfor (var i = 0, l = this._stops.length; i < l; i++) {\n\t\t\t\t\tif (!this._stops[i].equals(gradient._stops[i]))\n\t\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t});\n\t\n\tvar GradientStop = Base.extend({\n\t\t_class: 'GradientStop',\n\t\n\t\tinitialize: function GradientStop(arg0, arg1) {\n\t\t\tif (arg0) {\n\t\t\t\tvar color, rampPoint;\n\t\t\t\tif (arg1 === undefined && Array.isArray(arg0)) {\n\t\t\t\t\tcolor = arg0[0];\n\t\t\t\t\trampPoint = arg0[1];\n\t\t\t\t} else if (arg0.color) {\n\t\t\t\t\tcolor = arg0.color;\n\t\t\t\t\trampPoint = arg0.rampPoint;\n\t\t\t\t} else {\n\t\t\t\t\tcolor = arg0;\n\t\t\t\t\trampPoint = arg1;\n\t\t\t\t}\n\t\t\t\tthis.setColor(color);\n\t\t\t\tthis.setRampPoint(rampPoint);\n\t\t\t}\n\t\t},\n\t\n\t\tclone: function() {\n\t\t\treturn new GradientStop(this._color.clone(), this._rampPoint);\n\t\t},\n\t\n\t\t_serialize: function(options, dictionary) {\n\t\t\treturn Base.serialize([this._color, this._rampPoint], options, true,\n\t\t\t\t\tdictionary);\n\t\t},\n\t\n\t\t_changed: function() {\n\t\t\tif (this._owner)\n\t\t\t\tthis._owner._changed(65);\n\t\t},\n\t\n\t\tgetRampPoint: function() {\n\t\t\treturn this._rampPoint;\n\t\t},\n\t\n\t\tsetRampPoint: function(rampPoint) {\n\t\t\tthis._defaultRamp = rampPoint == null;\n\t\t\tthis._rampPoint = rampPoint || 0;\n\t\t\tthis._changed();\n\t\t},\n\t\n\t\tgetColor: function() {\n\t\t\treturn this._color;\n\t\t},\n\t\n\t\tsetColor: function(color) {\n\t\t\tthis._color = Color.read(arguments);\n\t\t\tif (this._color === color)\n\t\t\t\tthis._color = color.clone();\n\t\t\tthis._color._owner = this;\n\t\t\tthis._changed();\n\t\t},\n\t\n\t\tequals: function(stop) {\n\t\t\treturn stop === this || stop && this._class === stop._class\n\t\t\t\t\t&& this._color.equals(stop._color)\n\t\t\t\t\t&& this._rampPoint == stop._rampPoint\n\t\t\t\t\t|| false;\n\t\t}\n\t});\n\t\n\tvar Style = Base.extend(new function() {\n\t\tvar defaults = {\n\t\t\tfillColor: undefined,\n\t\t\tstrokeColor: undefined,\n\t\t\tstrokeWidth: 1,\n\t\t\tstrokeCap: 'butt',\n\t\t\tstrokeJoin: 'miter',\n\t\t\tstrokeScaling: true,\n\t\t\tmiterLimit: 10,\n\t\t\tdashOffset: 0,\n\t\t\tdashArray: [],\n\t\t\twindingRule: 'nonzero',\n\t\t\tshadowColor: undefined,\n\t\t\tshadowBlur: 0,\n\t\t\tshadowOffset: new Point(),\n\t\t\tselectedColor: undefined,\n\t\t\tfontFamily: 'sans-serif',\n\t\t\tfontWeight: 'normal',\n\t\t\tfontSize: 12,\n\t\t\tfont: 'sans-serif',\n\t\t\tleading: null,\n\t\t\tjustification: 'left'\n\t\t};\n\t\n\t\tvar flags = {\n\t\t\tstrokeWidth: 97,\n\t\t\tstrokeCap: 97,\n\t\t\tstrokeJoin: 97,\n\t\t\tstrokeScaling: 105,\n\t\t\tmiterLimit: 97,\n\t\t\tfontFamily: 9,\n\t\t\tfontWeight: 9,\n\t\t\tfontSize: 9,\n\t\t\tfont: 9,\n\t\t\tleading: 9,\n\t\t\tjustification: 9\n\t\t};\n\t\n\t\tvar item = { beans: true },\n\t\t\tfields = {\n\t\t\t\t_defaults: defaults,\n\t\t\t\t_textDefaults: new Base(defaults, {\n\t\t\t\t\tfillColor: new Color()\n\t\t\t\t}),\n\t\t\t\tbeans: true\n\t\t\t};\n\t\n\t\tBase.each(defaults, function(value, key) {\n\t\t\tvar isColor = /Color$/.test(key),\n\t\t\t\tisPoint = key === 'shadowOffset',\n\t\t\t\tpart = Base.capitalize(key),\n\t\t\t\tflag = flags[key],\n\t\t\t\tset = 'set' + part,\n\t\t\t\tget = 'get' + part;\n\t\n\t\t\tfields[set] = function(value) {\n\t\t\t\tvar owner = this._owner,\n\t\t\t\t\tchildren = owner && owner._children;\n\t\t\t\tif (children && children.length > 0\n\t\t\t\t\t\t&& !(owner instanceof CompoundPath)) {\n\t\t\t\t\tfor (var i = 0, l = children.length; i < l; i++)\n\t\t\t\t\t\tchildren[i]._style[set](value);\n\t\t\t\t} else {\n\t\t\t\t\tvar old = this._values[key];\n\t\t\t\t\tif (old !== value) {\n\t\t\t\t\t\tif (isColor) {\n\t\t\t\t\t\t\tif (old)\n\t\t\t\t\t\t\t\told._owner = undefined;\n\t\t\t\t\t\t\tif (value && value.constructor === Color) {\n\t\t\t\t\t\t\t\tif (value._owner)\n\t\t\t\t\t\t\t\t\tvalue = value.clone();\n\t\t\t\t\t\t\t\tvalue._owner = owner;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tthis._values[key] = value;\n\t\t\t\t\t\tif (owner)\n\t\t\t\t\t\t\towner._changed(flag || 65);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\t\n\t\t\tfields[get] = function(_dontMerge) {\n\t\t\t\tvar owner = this._owner,\n\t\t\t\t\tchildren = owner && owner._children,\n\t\t\t\t\tvalue;\n\t\t\t\tif (!children || children.length === 0 || _dontMerge\n\t\t\t\t\t\t|| owner instanceof CompoundPath) {\n\t\t\t\t\tvar value = this._values[key];\n\t\t\t\t\tif (value === undefined) {\n\t\t\t\t\t\tvalue = this._defaults[key];\n\t\t\t\t\t\tif (value && value.clone)\n\t\t\t\t\t\t\tvalue = value.clone();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tvar ctor = isColor ? Color : isPoint ? Point : null;\n\t\t\t\t\t\tif (ctor && !(value && value.constructor === ctor)) {\n\t\t\t\t\t\t\tthis._values[key] = value = ctor.read([value], 0,\n\t\t\t\t\t\t\t\t\t{ readNull: true, clone: true });\n\t\t\t\t\t\t\tif (value && isColor)\n\t\t\t\t\t\t\t\tvalue._owner = owner;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn value;\n\t\t\t\t}\n\t\t\t\tfor (var i = 0, l = children.length; i < l; i++) {\n\t\t\t\t\tvar childValue = children[i]._style[get]();\n\t\t\t\t\tif (i === 0) {\n\t\t\t\t\t\tvalue = childValue;\n\t\t\t\t\t} else if (!Base.equals(value, childValue)) {\n\t\t\t\t\t\treturn undefined;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn value;\n\t\t\t};\n\t\n\t\t\titem[get] = function(_dontMerge) {\n\t\t\t\treturn this._style[get](_dontMerge);\n\t\t\t};\n\t\n\t\t\titem[set] = function(value) {\n\t\t\t\tthis._style[set](value);\n\t\t\t};\n\t\t});\n\t\n\t\tItem.inject(item);\n\t\treturn fields;\n\t}, {\n\t\t_class: 'Style',\n\t\n\t\tinitialize: function Style(style, _owner, _project) {\n\t\t\tthis._values = {};\n\t\t\tthis._owner = _owner;\n\t\t\tthis._project = _owner && _owner._project || _project || paper.project;\n\t\t\tif (_owner instanceof TextItem)\n\t\t\t\tthis._defaults = this._textDefaults;\n\t\t\tif (style)\n\t\t\t\tthis.set(style);\n\t\t},\n\t\n\t\tset: function(style) {\n\t\t\tvar isStyle = style instanceof Style,\n\t\t\t\tvalues = isStyle ? style._values : style;\n\t\t\tif (values) {\n\t\t\t\tfor (var key in values) {\n\t\t\t\t\tif (key in this._defaults) {\n\t\t\t\t\t\tvar value = values[key];\n\t\t\t\t\t\tthis[key] = value && isStyle && value.clone\n\t\t\t\t\t\t\t\t? value.clone() : value;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\n\t\tequals: function(style) {\n\t\t\treturn style === this || style && this._class === style._class\n\t\t\t\t\t&& Base.equals(this._values, style._values)\n\t\t\t\t\t|| false;\n\t\t},\n\t\n\t\thasFill: function() {\n\t\t\treturn !!this.getFillColor();\n\t\t},\n\t\n\t\thasStroke: function() {\n\t\t\treturn !!this.getStrokeColor() && this.getStrokeWidth() > 0;\n\t\t},\n\t\n\t\thasShadow: function() {\n\t\t\treturn !!this.getShadowColor() && this.getShadowBlur() > 0;\n\t\t},\n\t\n\t\tgetView: function() {\n\t\t\treturn this._project.getView();\n\t\t},\n\t\n\t\tgetFontStyle: function() {\n\t\t\tvar fontSize = this.getFontSize();\n\t\t\treturn this.getFontWeight()\n\t\t\t\t\t+ ' ' + fontSize + (/[a-z]/i.test(fontSize + '') ? ' ' : 'px ')\n\t\t\t\t\t+ this.getFontFamily();\n\t\t},\n\t\n\t\tgetFont: '#getFontFamily',\n\t\tsetFont: '#setFontFamily',\n\t\n\t\tgetLeading: function getLeading() {\n\t\t\tvar leading = getLeading.base.call(this),\n\t\t\t\tfontSize = this.getFontSize();\n\t\t\tif (/pt|em|%|px/.test(fontSize))\n\t\t\t\tfontSize = this.getView().getPixelSize(fontSize);\n\t\t\treturn leading != null ? leading : fontSize * 1.2;\n\t\t}\n\t\n\t});\n\t\n\tvar DomElement = new function() {\n\t\tfunction handlePrefix(el, name, set, value) {\n\t\t\tvar prefixes = ['', 'webkit', 'moz', 'Moz', 'ms', 'o'],\n\t\t\t\tsuffix = name[0].toUpperCase() + name.substring(1);\n\t\t\tfor (var i = 0; i < 6; i++) {\n\t\t\t\tvar prefix = prefixes[i],\n\t\t\t\t\tkey = prefix ? prefix + suffix : name;\n\t\t\t\tif (key in el) {\n\t\t\t\t\tif (set) {\n\t\t\t\t\t\tel[key] = value;\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn el[key];\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\n\t\treturn {\n\t\t\tgetStyles: function(el) {\n\t\t\t\tvar doc = el && el.nodeType !== 9 ? el.ownerDocument : el,\n\t\t\t\t\tview = doc && doc.defaultView;\n\t\t\t\treturn view && view.getComputedStyle(el, '');\n\t\t\t},\n\t\n\t\t\tgetBounds: function(el, viewport) {\n\t\t\t\tvar doc = el.ownerDocument,\n\t\t\t\t\tbody = doc.body,\n\t\t\t\t\thtml = doc.documentElement,\n\t\t\t\t\trect;\n\t\t\t\ttry {\n\t\t\t\t\trect = el.getBoundingClientRect();\n\t\t\t\t} catch (e) {\n\t\t\t\t\trect = { left: 0, top: 0, width: 0, height: 0 };\n\t\t\t\t}\n\t\t\t\tvar x = rect.left - (html.clientLeft || body.clientLeft || 0),\n\t\t\t\t\ty = rect.top - (html.clientTop || body.clientTop || 0);\n\t\t\t\tif (!viewport) {\n\t\t\t\t\tvar view = doc.defaultView;\n\t\t\t\t\tx += view.pageXOffset || html.scrollLeft || body.scrollLeft;\n\t\t\t\t\ty += view.pageYOffset || html.scrollTop || body.scrollTop;\n\t\t\t\t}\n\t\t\t\treturn new Rectangle(x, y, rect.width, rect.height);\n\t\t\t},\n\t\n\t\t\tgetViewportBounds: function(el) {\n\t\t\t\tvar doc = el.ownerDocument,\n\t\t\t\t\tview = doc.defaultView,\n\t\t\t\t\thtml = doc.documentElement;\n\t\t\t\treturn new Rectangle(0, 0,\n\t\t\t\t\tview.innerWidth || html.clientWidth,\n\t\t\t\t\tview.innerHeight || html.clientHeight\n\t\t\t\t);\n\t\t\t},\n\t\n\t\t\tgetOffset: function(el, viewport) {\n\t\t\t\treturn DomElement.getBounds(el, viewport).getPoint();\n\t\t\t},\n\t\n\t\t\tgetSize: function(el) {\n\t\t\t\treturn DomElement.getBounds(el, true).getSize();\n\t\t\t},\n\t\n\t\t\tisInvisible: function(el) {\n\t\t\t\treturn DomElement.getSize(el).equals(new Size(0, 0));\n\t\t\t},\n\t\n\t\t\tisInView: function(el) {\n\t\t\t\treturn !DomElement.isInvisible(el)\n\t\t\t\t\t\t&& DomElement.getViewportBounds(el).intersects(\n\t\t\t\t\t\t\tDomElement.getBounds(el, true));\n\t\t\t},\n\t\n\t\t\tgetPrefixed: function(el, name) {\n\t\t\t\treturn handlePrefix(el, name);\n\t\t\t},\n\t\n\t\t\tsetPrefixed: function(el, name, value) {\n\t\t\t\tif (typeof name === 'object') {\n\t\t\t\t\tfor (var key in name)\n\t\t\t\t\t\thandlePrefix(el, key, true, name[key]);\n\t\t\t\t} else {\n\t\t\t\t\thandlePrefix(el, name, true, value);\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t};\n\t\n\tvar DomEvent = {\n\t\tadd: function(el, events) {\n\t\t\tfor (var type in events) {\n\t\t\t\tvar func = events[type],\n\t\t\t\t\tparts = type.split(/[\\s,]+/g);\n\t\t\t\tfor (var i = 0, l = parts.length; i < l; i++)\n\t\t\t\t\tel.addEventListener(parts[i], func, false);\n\t\t\t}\n\t\t},\n\t\n\t\tremove: function(el, events) {\n\t\t\tfor (var type in events) {\n\t\t\t\tvar func = events[type],\n\t\t\t\t\tparts = type.split(/[\\s,]+/g);\n\t\t\t\tfor (var i = 0, l = parts.length; i < l; i++)\n\t\t\t\t\tel.removeEventListener(parts[i], func, false);\n\t\t\t}\n\t\t},\n\t\n\t\tgetPoint: function(event) {\n\t\t\tvar pos = event.targetTouches\n\t\t\t\t\t? event.targetTouches.length\n\t\t\t\t\t\t? event.targetTouches[0]\n\t\t\t\t\t\t: event.changedTouches[0]\n\t\t\t\t\t: event;\n\t\t\treturn new Point(\n\t\t\t\tpos.pageX || pos.clientX + document.documentElement.scrollLeft,\n\t\t\t\tpos.pageY || pos.clientY + document.documentElement.scrollTop\n\t\t\t);\n\t\t},\n\t\n\t\tgetTarget: function(event) {\n\t\t\treturn event.target || event.srcElement;\n\t\t},\n\t\n\t\tgetRelatedTarget: function(event) {\n\t\t\treturn event.relatedTarget || event.toElement;\n\t\t},\n\t\n\t\tgetOffset: function(event, target) {\n\t\t\treturn DomEvent.getPoint(event).subtract(DomElement.getOffset(\n\t\t\t\t\ttarget || DomEvent.getTarget(event)));\n\t\t},\n\t\n\t\tstop: function(event) {\n\t\t\tevent.stopPropagation();\n\t\t\tevent.preventDefault();\n\t\t}\n\t};\n\t\n\tDomEvent.requestAnimationFrame = new function() {\n\t\tvar nativeRequest = DomElement.getPrefixed(window, 'requestAnimationFrame'),\n\t\t\trequested = false,\n\t\t\tcallbacks = [],\n\t\t\tfocused = true,\n\t\t\ttimer;\n\t\n\t\tDomEvent.add(window, {\n\t\t\tfocus: function() {\n\t\t\t\tfocused = true;\n\t\t\t},\n\t\t\tblur: function() {\n\t\t\t\tfocused = false;\n\t\t\t}\n\t\t});\n\t\n\t\tfunction handleCallbacks() {\n\t\t\tfor (var i = callbacks.length - 1; i >= 0; i--) {\n\t\t\t\tvar entry = callbacks[i],\n\t\t\t\t\tfunc = entry[0],\n\t\t\t\t\tel = entry[1];\n\t\t\t\tif (!el || (PaperScope.getAttribute(el, 'keepalive') == 'true'\n\t\t\t\t\t\t|| focused) && DomElement.isInView(el)) {\n\t\t\t\t\tcallbacks.splice(i, 1);\n\t\t\t\t\tfunc();\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (nativeRequest) {\n\t\t\t\tif (callbacks.length) {\n\t\t\t\t\tnativeRequest(handleCallbacks);\n\t\t\t\t} else {\n\t\t\t\t\trequested = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\n\t\treturn function(callback, element) {\n\t\t\tcallbacks.push([callback, element]);\n\t\t\tif (nativeRequest) {\n\t\t\t\tif (!requested) {\n\t\t\t\t\tnativeRequest(handleCallbacks);\n\t\t\t\t\trequested = true;\n\t\t\t\t}\n\t\t\t} else if (!timer) {\n\t\t\t\ttimer = setInterval(handleCallbacks, 1000 / 60);\n\t\t\t}\n\t\t};\n\t};\n\t\n\tvar View = Base.extend(Emitter, {\n\t\t_class: 'View',\n\t\n\t\tinitialize: function View(project, element) {\n\t\t\tthis._project = project;\n\t\t\tthis._scope = project._scope;\n\t\t\tthis._element = element;\n\t\t\tvar size;\n\t\t\tif (!this._pixelRatio)\n\t\t\t\tthis._pixelRatio = window.devicePixelRatio || 1;\n\t\t\tthis._id = element.getAttribute('id');\n\t\t\tif (this._id == null)\n\t\t\t\telement.setAttribute('id', this._id = 'view-' + View._id++);\n\t\t\tDomEvent.add(element, this._viewEvents);\n\t\t\tvar none = 'none';\n\t\t\tDomElement.setPrefixed(element.style, {\n\t\t\t\tuserSelect: none,\n\t\t\t\ttouchAction: none,\n\t\t\t\ttouchCallout: none,\n\t\t\t\tcontentZooming: none,\n\t\t\t\tuserDrag: none,\n\t\t\t\ttapHighlightColor: 'rgba(0,0,0,0)'\n\t\t\t});\n\t\n\t\t\tfunction getSize(name) {\n\t\t\t\treturn element[name] || parseInt(element.getAttribute(name), 10);\n\t\t\t};\n\t\n\t\t\tfunction getCanvasSize() {\n\t\t\t\tvar size = DomElement.getSize(element);\n\t\t\t\treturn size.isNaN() || size.isZero()\n\t\t\t\t\t\t? new Size(getSize('width'), getSize('height'))\n\t\t\t\t\t\t: size;\n\t\t\t};\n\t\n\t\t\tif (PaperScope.hasAttribute(element, 'resize')) {\n\t\t\t\tvar that = this;\n\t\t\t\tDomEvent.add(window, this._windowEvents = {\n\t\t\t\t\tresize: function() {\n\t\t\t\t\t\tthat.setViewSize(getCanvasSize());\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t\tthis._setViewSize(size = getCanvasSize());\n\t\t\tif (PaperScope.hasAttribute(element, 'stats')\n\t\t\t\t\t&& typeof Stats !== 'undefined') {\n\t\t\t\tthis._stats = new Stats();\n\t\t\t\tvar stats = this._stats.domElement,\n\t\t\t\t\tstyle = stats.style,\n\t\t\t\t\toffset = DomElement.getOffset(element);\n\t\t\t\tstyle.position = 'absolute';\n\t\t\t\tstyle.left = offset.x + 'px';\n\t\t\t\tstyle.top = offset.y + 'px';\n\t\t\t\tdocument.body.appendChild(stats);\n\t\t\t}\n\t\t\tView._views.push(this);\n\t\t\tView._viewsById[this._id] = this;\n\t\t\tthis._viewSize = size;\n\t\t\t(this._matrix = new Matrix())._owner = this;\n\t\t\tthis._zoom = 1;\n\t\t\tif (!View._focused)\n\t\t\t\tView._focused = this;\n\t\t\tthis._frameItems = {};\n\t\t\tthis._frameItemCount = 0;\n\t\t},\n\t\n\t\tremove: function() {\n\t\t\tif (!this._project)\n\t\t\t\treturn false;\n\t\t\tif (View._focused === this)\n\t\t\t\tView._focused = null;\n\t\t\tView._views.splice(View._views.indexOf(this), 1);\n\t\t\tdelete View._viewsById[this._id];\n\t\t\tif (this._project._view === this)\n\t\t\t\tthis._project._view = null;\n\t\t\tDomEvent.remove(this._element, this._viewEvents);\n\t\t\tDomEvent.remove(window, this._windowEvents);\n\t\t\tthis._element = this._project = null;\n\t\t\tthis.off('frame');\n\t\t\tthis._animate = false;\n\t\t\tthis._frameItems = {};\n\t\t\treturn true;\n\t\t},\n\t\n\t\t_events: Base.each(['onResize', 'onMouseDown', 'onMouseUp', 'onMouseMove'],\n\t\t\tfunction(name) {\n\t\t\t\tthis[name] = {\n\t\t\t\t\tinstall: function(type) {\n\t\t\t\t\t\tthis._installEvent(type);\n\t\t\t\t\t},\n\t\n\t\t\t\t\tuninstall: function(type) {\n\t\t\t\t\t\tthis._uninstallEvent(type);\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t}, {\n\t\t\t\tonFrame: {\n\t\t\t\t\tinstall: function() {\n\t\t\t\t\t\tthis.play();\n\t\t\t\t\t},\n\t\n\t\t\t\t\tuninstall: function() {\n\t\t\t\t\t\tthis.pause();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t),\n\t\n\t\t_animate: false,\n\t\t_time: 0,\n\t\t_count: 0,\n\t\n\t\t_requestFrame: function() {\n\t\t\tvar that = this;\n\t\t\tDomEvent.requestAnimationFrame(function() {\n\t\t\t\tthat._requested = false;\n\t\t\t\tif (!that._animate)\n\t\t\t\t\treturn;\n\t\t\t\tthat._requestFrame();\n\t\t\t\tthat._handleFrame();\n\t\t\t}, this._element);\n\t\t\tthis._requested = true;\n\t\t},\n\t\n\t\t_handleFrame: function() {\n\t\t\tpaper = this._scope;\n\t\t\tvar now = Date.now() / 1000,\n\t\t\t\tdelta = this._before ? now - this._before : 0;\n\t\t\tthis._before = now;\n\t\t\tthis._handlingFrame = true;\n\t\t\tthis.emit('frame', new Base({\n\t\t\t\tdelta: delta,\n\t\t\t\ttime: this._time += delta,\n\t\t\t\tcount: this._count++\n\t\t\t}));\n\t\t\tif (this._stats)\n\t\t\t\tthis._stats.update();\n\t\t\tthis._handlingFrame = false;\n\t\t\tthis.update();\n\t\t},\n\t\n\t\t_animateItem: function(item, animate) {\n\t\t\tvar items = this._frameItems;\n\t\t\tif (animate) {\n\t\t\t\titems[item._id] = {\n\t\t\t\t\titem: item,\n\t\t\t\t\ttime: 0,\n\t\t\t\t\tcount: 0\n\t\t\t\t};\n\t\t\t\tif (++this._frameItemCount === 1)\n\t\t\t\t\tthis.on('frame', this._handleFrameItems);\n\t\t\t} else {\n\t\t\t\tdelete items[item._id];\n\t\t\t\tif (--this._frameItemCount === 0) {\n\t\t\t\t\tthis.off('frame', this._handleFrameItems);\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\n\t\t_handleFrameItems: function(event) {\n\t\t\tfor (var i in this._frameItems) {\n\t\t\t\tvar entry = this._frameItems[i];\n\t\t\t\tentry.item.emit('frame', new Base(event, {\n\t\t\t\t\ttime: entry.time += event.delta,\n\t\t\t\t\tcount: entry.count++\n\t\t\t\t}));\n\t\t\t}\n\t\t},\n\t\n\t\t_update: function() {\n\t\t\tthis._project._needsUpdate = true;\n\t\t\tif (this._handlingFrame)\n\t\t\t\treturn;\n\t\t\tif (this._animate) {\n\t\t\t\tthis._handleFrame();\n\t\t\t} else {\n\t\t\t\tthis.update();\n\t\t\t}\n\t\t},\n\t\n\t\t_changed: function(flags) {\n\t\t\tif (flags & 1)\n\t\t\t\tthis._project._needsUpdate = true;\n\t\t},\n\t\n\t\t_transform: function(matrix) {\n\t\t\tthis._matrix.concatenate(matrix);\n\t\t\tthis._bounds = null;\n\t\t\tthis._update();\n\t\t},\n\t\n\t\tgetElement: function() {\n\t\t\treturn this._element;\n\t\t},\n\t\n\t\tgetPixelRatio: function() {\n\t\t\treturn this._pixelRatio;\n\t\t},\n\t\n\t\tgetResolution: function() {\n\t\t\treturn this._pixelRatio * 72;\n\t\t},\n\t\n\t\tgetViewSize: function() {\n\t\t\tvar size = this._viewSize;\n\t\t\treturn new LinkedSize(size.width, size.height, this, 'setViewSize');\n\t\t},\n\t\n\t\tsetViewSize: function() {\n\t\t\tvar size = Size.read(arguments),\n\t\t\t\tdelta = size.subtract(this._viewSize);\n\t\t\tif (delta.isZero())\n\t\t\t\treturn;\n\t\t\tthis._viewSize.set(size.width, size.height);\n\t\t\tthis._setViewSize(size);\n\t\t\tthis._bounds = null;\n\t\t\tthis.emit('resize', {\n\t\t\t\tsize: size,\n\t\t\t\tdelta: delta\n\t\t\t});\n\t\t\tthis._update();\n\t\t},\n\t\n\t\t_setViewSize: function(size) {\n\t\t\tvar element = this._element;\n\t\t\telement.width = size.width;\n\t\t\telement.height = size.height;\n\t\t},\n\t\n\t\tgetBounds: function() {\n\t\t\tif (!this._bounds)\n\t\t\t\tthis._bounds = this._matrix.inverted()._transformBounds(\n\t\t\t\t\t\tnew Rectangle(new Point(), this._viewSize));\n\t\t\treturn this._bounds;\n\t\t},\n\t\n\t\tgetSize: function() {\n\t\t\treturn this.getBounds().getSize();\n\t\t},\n\t\n\t\tgetCenter: function() {\n\t\t\treturn this.getBounds().getCenter();\n\t\t},\n\t\n\t\tsetCenter: function() {\n\t\t\tvar center = Point.read(arguments);\n\t\t\tthis.scrollBy(center.subtract(this.getCenter()));\n\t\t},\n\t\n\t\tgetZoom: function() {\n\t\t\treturn this._zoom;\n\t\t},\n\t\n\t\tsetZoom: function(zoom) {\n\t\t\tthis._transform(new Matrix().scale(zoom / this._zoom,\n\t\t\t\tthis.getCenter()));\n\t\t\tthis._zoom = zoom;\n\t\t},\n\t\n\t\tisVisible: function() {\n\t\t\treturn DomElement.isInView(this._element);\n\t\t},\n\t\n\t\tscrollBy: function() {\n\t\t\tthis._transform(new Matrix().translate(Point.read(arguments).negate()));\n\t\t},\n\t\n\t\tplay: function() {\n\t\t\tthis._animate = true;\n\t\t\tif (!this._requested)\n\t\t\t\tthis._requestFrame();\n\t\t},\n\t\n\t\tpause: function() {\n\t\t\tthis._animate = false;\n\t\t},\n\t\n\t\tdraw: function() {\n\t\t\tthis.update();\n\t\t},\n\t\n\t\tprojectToView: function() {\n\t\t\treturn this._matrix._transformPoint(Point.read(arguments));\n\t\t},\n\t\n\t\tviewToProject: function() {\n\t\t\treturn this._matrix._inverseTransform(Point.read(arguments));\n\t\t}\n\t\n\t}, {\n\t\tstatics: {\n\t\t\t_views: [],\n\t\t\t_viewsById: {},\n\t\t\t_id: 0,\n\t\n\t\t\tcreate: function(project, element) {\n\t\t\t\tif (typeof element === 'string')\n\t\t\t\t\telement = document.getElementById(element);\n\t\t\t\treturn new CanvasView(project, element);\n\t\t\t}\n\t\t}\n\t},\n\tnew function() {\n\t\tvar tool,\n\t\t\tprevFocus,\n\t\t\ttempFocus,\n\t\t\tdragging = false;\n\t\n\t\tfunction getView(event) {\n\t\t\tvar target = DomEvent.getTarget(event);\n\t\t\treturn target.getAttribute && View._viewsById[target.getAttribute('id')];\n\t\t}\n\t\n\t\tfunction viewToProject(view, event) {\n\t\t\treturn view.viewToProject(DomEvent.getOffset(event, view._element));\n\t\t}\n\t\n\t\tfunction updateFocus() {\n\t\t\tif (!View._focused || !View._focused.isVisible()) {\n\t\t\t\tfor (var i = 0, l = View._views.length; i < l; i++) {\n\t\t\t\t\tvar view = View._views[i];\n\t\t\t\t\tif (view && view.isVisible()) {\n\t\t\t\t\t\tView._focused = tempFocus = view;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\n\t\tfunction handleMouseMove(view, point, event) {\n\t\t\tview._handleEvent('mousemove', point, event);\n\t\t\tvar tool = view._scope.tool;\n\t\t\tif (tool) {\n\t\t\t\ttool._handleEvent(dragging && tool.responds('mousedrag')\n\t\t\t\t\t\t? 'mousedrag' : 'mousemove', point, event);\n\t\t\t}\n\t\t\tview.update();\n\t\t\treturn tool;\n\t\t}\n\t\n\t\tvar navigator = window.navigator,\n\t\t\tmousedown, mousemove, mouseup;\n\t\tif (navigator.pointerEnabled || navigator.msPointerEnabled) {\n\t\t\tmousedown = 'pointerdown MSPointerDown';\n\t\t\tmousemove = 'pointermove MSPointerMove';\n\t\t\tmouseup = 'pointerup pointercancel MSPointerUp MSPointerCancel';\n\t\t} else {\n\t\t\tmousedown = 'touchstart';\n\t\t\tmousemove = 'touchmove';\n\t\t\tmouseup = 'touchend touchcancel';\n\t\t\tif (!('ontouchstart' in window && navigator.userAgent.match(\n\t\t\t\t\t/mobile|tablet|ip(ad|hone|od)|android|silk/i))) {\n\t\t\t\tmousedown += ' mousedown';\n\t\t\t\tmousemove += ' mousemove';\n\t\t\t\tmouseup += ' mouseup';\n\t\t\t}\n\t\t}\n\t\n\t\tvar viewEvents = {\n\t\t\t'selectstart dragstart': function(event) {\n\t\t\t\tif (dragging)\n\t\t\t\t\tevent.preventDefault();\n\t\t\t}\n\t\t};\n\t\n\t\tvar docEvents = {\n\t\t\tmouseout: function(event) {\n\t\t\t\tvar view = View._focused,\n\t\t\t\t\ttarget = DomEvent.getRelatedTarget(event);\n\t\t\t\tif (view && (!target || target.nodeName === 'HTML'))\n\t\t\t\t\thandleMouseMove(view, viewToProject(view, event), event);\n\t\t\t},\n\t\n\t\t\tscroll: updateFocus\n\t\t};\n\t\n\t\tviewEvents[mousedown] = function(event) {\n\t\t\tvar view = View._focused = getView(event),\n\t\t\t\tpoint = viewToProject(view, event);\n\t\t\tdragging = true;\n\t\t\tview._handleEvent('mousedown', point, event);\n\t\t\tif (tool = view._scope.tool)\n\t\t\t\ttool._handleEvent('mousedown', point, event);\n\t\t\tview.update();\n\t\t};\n\t\n\t\tdocEvents[mousemove] = function(event) {\n\t\t\tvar view = View._focused;\n\t\t\tif (!dragging) {\n\t\t\t\tvar target = getView(event);\n\t\t\t\tif (target) {\n\t\t\t\t\tif (view !== target)\n\t\t\t\t\t\thandleMouseMove(view, viewToProject(view, event), event);\n\t\t\t\t\tprevFocus = view;\n\t\t\t\t\tview = View._focused = tempFocus = target;\n\t\t\t\t} else if (tempFocus && tempFocus === view) {\n\t\t\t\t\tview = View._focused = prevFocus;\n\t\t\t\t\tupdateFocus();\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (view) {\n\t\t\t\tvar point = viewToProject(view, event);\n\t\t\t\tif (dragging || view.getBounds().contains(point))\n\t\t\t\t\ttool = handleMouseMove(view, point, event);\n\t\t\t}\n\t\t};\n\t\n\t\tdocEvents[mouseup] = function(event) {\n\t\t\tvar view = View._focused;\n\t\t\tif (!view || !dragging)\n\t\t\t\treturn;\n\t\t\tvar point = viewToProject(view, event);\n\t\t\tdragging = false;\n\t\t\tview._handleEvent('mouseup', point, event);\n\t\t\tif (tool)\n\t\t\t\ttool._handleEvent('mouseup', point, event);\n\t\t\tview.update();\n\t\t};\n\t\n\t\tDomEvent.add(document, docEvents);\n\t\n\t\tDomEvent.add(window, {\n\t\t\tload: updateFocus\n\t\t});\n\t\n\t\tvar mouseFlags = {\n\t\t\tmousedown: {\n\t\t\t\tmousedown: 1,\n\t\t\t\tmousedrag: 1,\n\t\t\t\tclick: 1,\n\t\t\t\tdoubleclick: 1\n\t\t\t},\n\t\t\tmouseup: {\n\t\t\t\tmouseup: 1,\n\t\t\t\tmousedrag: 1,\n\t\t\t\tclick: 1,\n\t\t\t\tdoubleclick: 1\n\t\t\t},\n\t\t\tmousemove: {\n\t\t\t\tmousedrag: 1,\n\t\t\t\tmousemove: 1,\n\t\t\t\tmouseenter: 1,\n\t\t\t\tmouseleave: 1\n\t\t\t}\n\t\t};\n\t\n\t\treturn {\n\t\t\t_viewEvents: viewEvents,\n\t\n\t\t\t_handleEvent: function() {},\n\t\n\t\t\t_installEvent: function(type) {\n\t\t\t\tvar counters = this._eventCounters;\n\t\t\t\tif (counters) {\n\t\t\t\t\tfor (var key in mouseFlags) {\n\t\t\t\t\t\tcounters[key] = (counters[key] || 0)\n\t\t\t\t\t\t\t\t+ (mouseFlags[key][type] || 0);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\n\t\t\t_uninstallEvent: function(type) {\n\t\t\t\tvar counters = this._eventCounters;\n\t\t\t\tif (counters) {\n\t\t\t\t\tfor (var key in mouseFlags)\n\t\t\t\t\t\tcounters[key] -= mouseFlags[key][type] || 0;\n\t\t\t\t}\n\t\t\t},\n\t\n\t\t\tstatics: {\n\t\t\t\tupdateFocus: updateFocus\n\t\t\t}\n\t\t};\n\t});\n\t\n\tvar CanvasView = View.extend({\n\t\t_class: 'CanvasView',\n\t\n\t\tinitialize: function CanvasView(project, canvas) {\n\t\t\tif (!(canvas instanceof HTMLCanvasElement)) {\n\t\t\t\tvar size = Size.read(arguments, 1);\n\t\t\t\tif (size.isZero())\n\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t\t'Cannot create CanvasView with the provided argument: '\n\t\t\t\t\t\t\t+ [].slice.call(arguments, 1));\n\t\t\t\tcanvas = CanvasProvider.getCanvas(size);\n\t\t\t}\n\t\t\tthis._context = canvas.getContext('2d');\n\t\t\tthis._eventCounters = {};\n\t\t\tthis._pixelRatio = 1;\n\t\t\tif (!/^off|false$/.test(PaperScope.getAttribute(canvas, 'hidpi'))) {\n\t\t\t\tvar deviceRatio = window.devicePixelRatio || 1,\n\t\t\t\t\tbackingStoreRatio = DomElement.getPrefixed(this._context,\n\t\t\t\t\t\t\t'backingStorePixelRatio') || 1;\n\t\t\t\tthis._pixelRatio = deviceRatio / backingStoreRatio;\n\t\t\t}\n\t\t\tView.call(this, project, canvas);\n\t\t},\n\t\n\t\t_setViewSize: function(size) {\n\t\t\tvar element = this._element,\n\t\t\t\tpixelRatio = this._pixelRatio,\n\t\t\t\twidth = size.width,\n\t\t\t\theight = size.height;\n\t\t\telement.width = width * pixelRatio;\n\t\t\telement.height = height * pixelRatio;\n\t\t\tif (pixelRatio !== 1) {\n\t\t\t\tif (!PaperScope.hasAttribute(element, 'resize')) {\n\t\t\t\t\tvar style = element.style;\n\t\t\t\t\tstyle.width = width + 'px';\n\t\t\t\t\tstyle.height = height + 'px';\n\t\t\t\t}\n\t\t\t\tthis._context.scale(pixelRatio, pixelRatio);\n\t\t\t}\n\t\t},\n\t\n\t\tgetPixelSize: function(size) {\n\t\t\tvar browser = paper.browser,\n\t\t\t\tpixels;\n\t\t\tif (browser && browser.firefox) {\n\t\t\t\tvar parent = this._element.parentNode,\n\t\t\t\t\ttemp = document.createElement('div');\n\t\t\t\ttemp.style.fontSize = size;\n\t\t\t\tparent.appendChild(temp);\n\t\t\t\tpixels = parseFloat(DomElement.getStyles(temp).fontSize);\n\t\t\t\tparent.removeChild(temp);\n\t\t\t} else {\n\t\t\t\tvar ctx = this._context,\n\t\t\t\t\tprevFont = ctx.font;\n\t\t\t\tctx.font = size + ' serif';\n\t\t\t\tpixels = parseFloat(ctx.font);\n\t\t\t\tctx.font = prevFont;\n\t\t\t}\n\t\t\treturn pixels;\n\t\t},\n\t\n\t\tgetTextWidth: function(font, lines) {\n\t\t\tvar ctx = this._context,\n\t\t\t\tprevFont = ctx.font,\n\t\t\t\twidth = 0;\n\t\t\tctx.font = font;\n\t\t\tfor (var i = 0, l = lines.length; i < l; i++)\n\t\t\t\twidth = Math.max(width, ctx.measureText(lines[i]).width);\n\t\t\tctx.font = prevFont;\n\t\t\treturn width;\n\t\t},\n\t\n\t\tupdate: function(force) {\n\t\t\tvar project = this._project;\n\t\t\tif (!project || !force && !project._needsUpdate)\n\t\t\t\treturn false;\n\t\t\tvar ctx = this._context,\n\t\t\t\tsize = this._viewSize;\n\t\t\tctx.clearRect(0, 0, size.width + 1, size.height + 1);\n\t\t\tproject.draw(ctx, this._matrix, this._pixelRatio);\n\t\t\tproject._needsUpdate = false;\n\t\t\treturn true;\n\t\t}\n\t},\n\tnew function() {\n\t\tvar downPoint,\n\t\t\tlastPoint,\n\t\t\toverPoint,\n\t\t\tdownItem,\n\t\t\tlastItem,\n\t\t\toverItem,\n\t\t\tdragItem,\n\t\t\tdblClick,\n\t\t\tclickTime;\n\t\n\t\tfunction callEvent(view, type, event, point, target, lastPoint) {\n\t\t\tvar item = target,\n\t\t\t\tmouseEvent;\n\t\n\t\t\tfunction call(obj) {\n\t\t\t\tif (obj.responds(type)) {\n\t\t\t\t\tif (!mouseEvent) {\n\t\t\t\t\t\tmouseEvent = new MouseEvent(type, event, point, target,\n\t\t\t\t\t\t\t\tlastPoint ? point.subtract(lastPoint) : null);\n\t\t\t\t\t}\n\t\t\t\t\tif (obj.emit(type, mouseEvent) && mouseEvent.isStopped) {\n\t\t\t\t\t\tevent.preventDefault();\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\twhile (item) {\n\t\t\t\tif (call(item))\n\t\t\t\t\treturn true;\n\t\t\t\titem = item.getParent();\n\t\t\t}\n\t\t\tif (call(view))\n\t\t\t\treturn true;\n\t\t\treturn false;\n\t\t}\n\t\n\t\treturn {\n\t\t\t_handleEvent: function(type, point, event) {\n\t\t\t\tif (!this._eventCounters[type])\n\t\t\t\t\treturn;\n\t\t\t\tvar project = this._project,\n\t\t\t\t\thit = project.hitTest(point, {\n\t\t\t\t\t\ttolerance: 0,\n\t\t\t\t\t\tfill: true,\n\t\t\t\t\t\tstroke: true\n\t\t\t\t\t}),\n\t\t\t\t\titem = hit && hit.item,\n\t\t\t\t\tstopped = false;\n\t\t\t\tswitch (type) {\n\t\t\t\tcase 'mousedown':\n\t\t\t\t\tstopped = callEvent(this, type, event, point, item);\n\t\t\t\t\tdblClick = lastItem == item && (Date.now() - clickTime < 300);\n\t\t\t\t\tdownItem = lastItem = item;\n\t\t\t\t\tdownPoint = lastPoint = overPoint = point;\n\t\t\t\t\tdragItem = !stopped && item;\n\t\t\t\t\twhile (dragItem && !dragItem.responds('mousedrag'))\n\t\t\t\t\t\tdragItem = dragItem._parent;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'mouseup':\n\t\t\t\t\tstopped = callEvent(this, type, event, point, item, downPoint);\n\t\t\t\t\tif (dragItem) {\n\t\t\t\t\t\tif (lastPoint && !lastPoint.equals(point))\n\t\t\t\t\t\t\tcallEvent(this, 'mousedrag', event, point, dragItem,\n\t\t\t\t\t\t\t\t\tlastPoint);\n\t\t\t\t\t\tif (item !== dragItem) {\n\t\t\t\t\t\t\toverPoint = point;\n\t\t\t\t\t\t\tcallEvent(this, 'mousemove', event, point, item,\n\t\t\t\t\t\t\t\t\toverPoint);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (!stopped && item && item === downItem) {\n\t\t\t\t\t\tclickTime = Date.now();\n\t\t\t\t\t\tcallEvent(this, dblClick && downItem.responds('doubleclick')\n\t\t\t\t\t\t\t\t? 'doubleclick' : 'click', event, downPoint, item);\n\t\t\t\t\t\tdblClick = false;\n\t\t\t\t\t}\n\t\t\t\t\tdownItem = dragItem = null;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'mousemove':\n\t\t\t\t\tif (dragItem)\n\t\t\t\t\t\tstopped = callEvent(this, 'mousedrag', event, point,\n\t\t\t\t\t\t\t\tdragItem, lastPoint);\n\t\t\t\t\tif (!stopped) {\n\t\t\t\t\t\tif (item !== overItem)\n\t\t\t\t\t\t\toverPoint = point;\n\t\t\t\t\t\tstopped = callEvent(this, type, event, point, item,\n\t\t\t\t\t\t\t\toverPoint);\n\t\t\t\t\t}\n\t\t\t\t\tlastPoint = overPoint = point;\n\t\t\t\t\tif (item !== overItem) {\n\t\t\t\t\t\tcallEvent(this, 'mouseleave', event, point, overItem);\n\t\t\t\t\t\toverItem = item;\n\t\t\t\t\t\tcallEvent(this, 'mouseenter', event, point, item);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\treturn stopped;\n\t\t\t}\n\t\t};\n\t});\n\t\n\tvar Event = Base.extend({\n\t\t_class: 'Event',\n\t\n\t\tinitialize: function Event(event) {\n\t\t\tthis.event = event;\n\t\t},\n\t\n\t\tisPrevented: false,\n\t\tisStopped: false,\n\t\n\t\tpreventDefault: function() {\n\t\t\tthis.isPrevented = true;\n\t\t\tthis.event.preventDefault();\n\t\t},\n\t\n\t\tstopPropagation: function() {\n\t\t\tthis.isStopped = true;\n\t\t\tthis.event.stopPropagation();\n\t\t},\n\t\n\t\tstop: function() {\n\t\t\tthis.stopPropagation();\n\t\t\tthis.preventDefault();\n\t\t},\n\t\n\t\tgetModifiers: function() {\n\t\t\treturn Key.modifiers;\n\t\t}\n\t});\n\t\n\tvar KeyEvent = Event.extend({\n\t\t_class: 'KeyEvent',\n\t\n\t\tinitialize: function KeyEvent(down, key, character, event) {\n\t\t\tEvent.call(this, event);\n\t\t\tthis.type = down ? 'keydown' : 'keyup';\n\t\t\tthis.key = key;\n\t\t\tthis.character = character;\n\t\t},\n\t\n\t\ttoString: function() {\n\t\t\treturn \"{ type: '\" + this.type\n\t\t\t\t\t+ \"', key: '\" + this.key\n\t\t\t\t\t+ \"', character: '\" + this.character\n\t\t\t\t\t+ \"', modifiers: \" + this.getModifiers()\n\t\t\t\t\t+ \" }\";\n\t\t}\n\t});\n\t\n\tvar Key = new function() {\n\t\n\t\tvar specialKeys = {\n\t\t\t8: 'backspace',\n\t\t\t9: 'tab',\n\t\t\t13: 'enter',\n\t\t\t16: 'shift',\n\t\t\t17: 'control',\n\t\t\t18: 'option',\n\t\t\t19: 'pause',\n\t\t\t20: 'caps-lock',\n\t\t\t27: 'escape',\n\t\t\t32: 'space',\n\t\t\t35: 'end',\n\t\t\t36: 'home',\n\t\t\t37: 'left',\n\t\t\t38: 'up',\n\t\t\t39: 'right',\n\t\t\t40: 'down',\n\t\t\t46: 'delete',\n\t\t\t91: 'command',\n\t\t\t93: 'command',\n\t\t\t224: 'command'\n\t\t},\n\t\n\t\tspecialChars = {\n\t\t\t9: true,\n\t\t\t13: true,\n\t\t\t32: true\n\t\t},\n\t\n\t\tmodifiers = new Base({\n\t\t\tshift: false,\n\t\t\tcontrol: false,\n\t\t\toption: false,\n\t\t\tcommand: false,\n\t\t\tcapsLock: false,\n\t\t\tspace: false\n\t\t}),\n\t\n\t\tcharCodeMap = {},\n\t\tkeyMap = {},\n\t\tcommandFixMap,\n\t\tdownCode;\n\t\n\t\tfunction handleKey(down, keyCode, charCode, event) {\n\t\t\tvar character = charCode ? String.fromCharCode(charCode) : '',\n\t\t\t\tspecialKey = specialKeys[keyCode],\n\t\t\t\tkey = specialKey || character.toLowerCase(),\n\t\t\t\ttype = down ? 'keydown' : 'keyup',\n\t\t\t\tview = View._focused,\n\t\t\t\tscope = view && view.isVisible() && view._scope,\n\t\t\t\ttool = scope && scope.tool,\n\t\t\t\tname;\n\t\t\tkeyMap[key] = down;\n\t\t\tif (down) {\n\t\t\t\tcharCodeMap[keyCode] = charCode;\n\t\t\t} else {\n\t\t\t\tdelete charCodeMap[keyCode];\n\t\t\t}\n\t\t\tif (specialKey && (name = Base.camelize(specialKey)) in modifiers) {\n\t\t\t\tmodifiers[name] = down;\n\t\t\t\tvar browser = paper.browser;\n\t\t\t\tif (name === 'command' && browser && browser.mac) {\n\t\t\t\t\tif (down) {\n\t\t\t\t\t\tcommandFixMap = {};\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfor (var code in commandFixMap) {\n\t\t\t\t\t\t\tif (code in charCodeMap)\n\t\t\t\t\t\t\t\thandleKey(false, code, commandFixMap[code], event);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcommandFixMap = null;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (down && commandFixMap) {\n\t\t\t\tcommandFixMap[keyCode] = charCode;\n\t\t\t}\n\t\t\tif (tool && tool.responds(type)) {\n\t\t\t\tpaper = scope;\n\t\t\t\ttool.emit(type, new KeyEvent(down, key, character, event));\n\t\t\t\tif (view)\n\t\t\t\t\tview.update();\n\t\t\t}\n\t\t}\n\t\n\t\tDomEvent.add(document, {\n\t\t\tkeydown: function(event) {\n\t\t\t\tvar code = event.which || event.keyCode;\n\t\t\t\tif (code in specialKeys || modifiers.command) {\n\t\t\t\t\thandleKey(true, code,\n\t\t\t\t\t\t\tcode in specialChars || modifiers.command ? code : 0,\n\t\t\t\t\t\t\tevent);\n\t\t\t\t} else {\n\t\t\t\t\tdownCode = code;\n\t\t\t\t}\n\t\t\t},\n\t\n\t\t\tkeypress: function(event) {\n\t\t\t\tif (downCode != null) {\n\t\t\t\t\thandleKey(true, downCode, event.which || event.keyCode, event);\n\t\t\t\t\tdownCode = null;\n\t\t\t\t}\n\t\t\t},\n\t\n\t\t\tkeyup: function(event) {\n\t\t\t\tvar code = event.which || event.keyCode;\n\t\t\t\tif (code in charCodeMap)\n\t\t\t\t\thandleKey(false, code, charCodeMap[code], event);\n\t\t\t}\n\t\t});\n\t\n\t\tDomEvent.add(window, {\n\t\t\tblur: function(event) {\n\t\t\t\tfor (var code in charCodeMap)\n\t\t\t\t\thandleKey(false, code, charCodeMap[code], event);\n\t\t\t}\n\t\t});\n\t\n\t\treturn {\n\t\t\tmodifiers: modifiers,\n\t\n\t\t\tisDown: function(key) {\n\t\t\t\treturn !!keyMap[key];\n\t\t\t}\n\t\t};\n\t};\n\t\n\tvar MouseEvent = Event.extend({\n\t\t_class: 'MouseEvent',\n\t\n\t\tinitialize: function MouseEvent(type, event, point, target, delta) {\n\t\t\tEvent.call(this, event);\n\t\t\tthis.type = type;\n\t\t\tthis.point = point;\n\t\t\tthis.target = target;\n\t\t\tthis.delta = delta;\n\t\t},\n\t\n\t\ttoString: function() {\n\t\t\treturn \"{ type: '\" + this.type\n\t\t\t\t\t+ \"', point: \" + this.point\n\t\t\t\t\t+ ', target: ' + this.target\n\t\t\t\t\t+ (this.delta ? ', delta: ' + this.delta : '')\n\t\t\t\t\t+ ', modifiers: ' + this.getModifiers()\n\t\t\t\t\t+ ' }';\n\t\t}\n\t});\n\t\n\tvar ToolEvent = Event.extend({\n\t\t_class: 'ToolEvent',\n\t\t_item: null,\n\t\n\t\tinitialize: function ToolEvent(tool, type, event) {\n\t\t\tthis.tool = tool;\n\t\t\tthis.type = type;\n\t\t\tthis.event = event;\n\t\t},\n\t\n\t\t_choosePoint: function(point, toolPoint) {\n\t\t\treturn point ? point : toolPoint ? toolPoint.clone() : null;\n\t\t},\n\t\n\t\tgetPoint: function() {\n\t\t\treturn this._choosePoint(this._point, this.tool._point);\n\t\t},\n\t\n\t\tsetPoint: function(point) {\n\t\t\tthis._point = point;\n\t\t},\n\t\n\t\tgetLastPoint: function() {\n\t\t\treturn this._choosePoint(this._lastPoint, this.tool._lastPoint);\n\t\t},\n\t\n\t\tsetLastPoint: function(lastPoint) {\n\t\t\tthis._lastPoint = lastPoint;\n\t\t},\n\t\n\t\tgetDownPoint: function() {\n\t\t\treturn this._choosePoint(this._downPoint, this.tool._downPoint);\n\t\t},\n\t\n\t\tsetDownPoint: function(downPoint) {\n\t\t\tthis._downPoint = downPoint;\n\t\t},\n\t\n\t\tgetMiddlePoint: function() {\n\t\t\tif (!this._middlePoint && this.tool._lastPoint) {\n\t\t\t\treturn this.tool._point.add(this.tool._lastPoint).divide(2);\n\t\t\t}\n\t\t\treturn this._middlePoint;\n\t\t},\n\t\n\t\tsetMiddlePoint: function(middlePoint) {\n\t\t\tthis._middlePoint = middlePoint;\n\t\t},\n\t\n\t\tgetDelta: function() {\n\t\t\treturn !this._delta && this.tool._lastPoint\n\t\t\t\t\t? this.tool._point.subtract(this.tool._lastPoint)\n\t\t\t\t\t: this._delta;\n\t\t},\n\t\n\t\tsetDelta: function(delta) {\n\t\t\tthis._delta = delta;\n\t\t},\n\t\n\t\tgetCount: function() {\n\t\t\treturn /^mouse(down|up)$/.test(this.type)\n\t\t\t\t\t? this.tool._downCount\n\t\t\t\t\t: this.tool._count;\n\t\t},\n\t\n\t\tsetCount: function(count) {\n\t\t\tthis.tool[/^mouse(down|up)$/.test(this.type) ? 'downCount' : 'count']\n\t\t\t\t= count;\n\t\t},\n\t\n\t\tgetItem: function() {\n\t\t\tif (!this._item) {\n\t\t\t\tvar result = this.tool._scope.project.hitTest(this.getPoint());\n\t\t\t\tif (result) {\n\t\t\t\t\tvar item = result.item,\n\t\t\t\t\t\tparent = item._parent;\n\t\t\t\t\twhile (/^(Group|CompoundPath)$/.test(parent._class)) {\n\t\t\t\t\t\titem = parent;\n\t\t\t\t\t\tparent = parent._parent;\n\t\t\t\t\t}\n\t\t\t\t\tthis._item = item;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn this._item;\n\t\t},\n\t\n\t\tsetItem: function(item) {\n\t\t\tthis._item = item;\n\t\t},\n\t\n\t\ttoString: function() {\n\t\t\treturn '{ type: ' + this.type\n\t\t\t\t\t+ ', point: ' + this.getPoint()\n\t\t\t\t\t+ ', count: ' + this.getCount()\n\t\t\t\t\t+ ', modifiers: ' + this.getModifiers()\n\t\t\t\t\t+ ' }';\n\t\t}\n\t});\n\t\n\tvar Tool = PaperScopeItem.extend({\n\t\t_class: 'Tool',\n\t\t_list: 'tools',\n\t\t_reference: 'tool',\n\t\t_events: [ 'onActivate', 'onDeactivate', 'onEditOptions',\n\t\t\t\t'onMouseDown', 'onMouseUp', 'onMouseDrag', 'onMouseMove',\n\t\t\t\t'onKeyDown', 'onKeyUp' ],\n\t\n\t\tinitialize: function Tool(props) {\n\t\t\tPaperScopeItem.call(this);\n\t\t\tthis._firstMove = true;\n\t\t\tthis._count = 0;\n\t\t\tthis._downCount = 0;\n\t\t\tthis._set(props);\n\t\t},\n\t\n\t\tgetMinDistance: function() {\n\t\t\treturn this._minDistance;\n\t\t},\n\t\n\t\tsetMinDistance: function(minDistance) {\n\t\t\tthis._minDistance = minDistance;\n\t\t\tif (minDistance != null && this._maxDistance != null\n\t\t\t\t\t&& minDistance > this._maxDistance) {\n\t\t\t\tthis._maxDistance = minDistance;\n\t\t\t}\n\t\t},\n\t\n\t\tgetMaxDistance: function() {\n\t\t\treturn this._maxDistance;\n\t\t},\n\t\n\t\tsetMaxDistance: function(maxDistance) {\n\t\t\tthis._maxDistance = maxDistance;\n\t\t\tif (this._minDistance != null && maxDistance != null\n\t\t\t\t\t&& maxDistance < this._minDistance) {\n\t\t\t\tthis._minDistance = maxDistance;\n\t\t\t}\n\t\t},\n\t\n\t\tgetFixedDistance: function() {\n\t\t\treturn this._minDistance == this._maxDistance\n\t\t\t\t? this._minDistance : null;\n\t\t},\n\t\n\t\tsetFixedDistance: function(distance) {\n\t\t\tthis._minDistance = this._maxDistance = distance;\n\t\t},\n\t\n\t\t_updateEvent: function(type, point, minDistance, maxDistance, start,\n\t\t\t\tneedsChange, matchMaxDistance) {\n\t\t\tif (!start) {\n\t\t\t\tif (minDistance != null || maxDistance != null) {\n\t\t\t\t\tvar minDist = minDistance != null ? minDistance : 0,\n\t\t\t\t\t\tvector = point.subtract(this._point),\n\t\t\t\t\t\tdistance = vector.getLength();\n\t\t\t\t\tif (distance < minDist)\n\t\t\t\t\t\treturn false;\n\t\t\t\t\tif (maxDistance != null && maxDistance != 0) {\n\t\t\t\t\t\tif (distance > maxDistance) {\n\t\t\t\t\t\t\tpoint = this._point.add(vector.normalize(maxDistance));\n\t\t\t\t\t\t} else if (matchMaxDistance) {\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (needsChange && point.equals(this._point))\n\t\t\t\t\treturn false;\n\t\t\t}\n\t\t\tthis._lastPoint = start && type == 'mousemove' ? point : this._point;\n\t\t\tthis._point = point;\n\t\t\tswitch (type) {\n\t\t\tcase 'mousedown':\n\t\t\t\tthis._lastPoint = this._downPoint;\n\t\t\t\tthis._downPoint = this._point;\n\t\t\t\tthis._downCount++;\n\t\t\t\tbreak;\n\t\t\tcase 'mouseup':\n\t\t\t\tthis._lastPoint = this._downPoint;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tthis._count = start ? 0 : this._count + 1;\n\t\t\treturn true;\n\t\t},\n\t\n\t\t_fireEvent: function(type, event) {\n\t\t\tvar sets = paper.project._removeSets;\n\t\t\tif (sets) {\n\t\t\t\tif (type === 'mouseup')\n\t\t\t\t\tsets.mousedrag = null;\n\t\t\t\tvar set = sets[type];\n\t\t\t\tif (set) {\n\t\t\t\t\tfor (var id in set) {\n\t\t\t\t\t\tvar item = set[id];\n\t\t\t\t\t\tfor (var key in sets) {\n\t\t\t\t\t\t\tvar other = sets[key];\n\t\t\t\t\t\t\tif (other && other != set)\n\t\t\t\t\t\t\t\tdelete other[item._id];\n\t\t\t\t\t\t}\n\t\t\t\t\t\titem.remove();\n\t\t\t\t\t}\n\t\t\t\t\tsets[type] = null;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn this.responds(type)\n\t\t\t\t\t&& this.emit(type, new ToolEvent(this, type, event));\n\t\t},\n\t\n\t\t_handleEvent: function(type, point, event) {\n\t\t\tpaper = this._scope;\n\t\t\tvar called = false;\n\t\t\tswitch (type) {\n\t\t\tcase 'mousedown':\n\t\t\t\tthis._updateEvent(type, point, null, null, true, false, false);\n\t\t\t\tcalled = this._fireEvent(type, event);\n\t\t\t\tbreak;\n\t\t\tcase 'mousedrag':\n\t\t\t\tvar needsChange = false,\n\t\t\t\t\tmatchMaxDistance = false;\n\t\t\t\twhile (this._updateEvent(type, point, this.minDistance,\n\t\t\t\t\t\tthis.maxDistance, false, needsChange, matchMaxDistance)) {\n\t\t\t\t\tcalled = this._fireEvent(type, event) || called;\n\t\t\t\t\tneedsChange = true;\n\t\t\t\t\tmatchMaxDistance = true;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'mouseup':\n\t\t\t\tif (!point.equals(this._point)\n\t\t\t\t\t\t&& this._updateEvent('mousedrag', point, this.minDistance,\n\t\t\t\t\t\t\t\tthis.maxDistance, false, false, false)) {\n\t\t\t\t\tcalled = this._fireEvent('mousedrag', event);\n\t\t\t\t}\n\t\t\t\tthis._updateEvent(type, point, null, this.maxDistance, false,\n\t\t\t\t\t\tfalse, false);\n\t\t\t\tcalled = this._fireEvent(type, event) || called;\n\t\t\t\tthis._updateEvent(type, point, null, null, true, false, false);\n\t\t\t\tthis._firstMove = true;\n\t\t\t\tbreak;\n\t\t\tcase 'mousemove':\n\t\t\t\twhile (this._updateEvent(type, point, this.minDistance,\n\t\t\t\t\t\tthis.maxDistance, this._firstMove, true, false)) {\n\t\t\t\t\tcalled = this._fireEvent(type, event) || called;\n\t\t\t\t\tthis._firstMove = false;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (called)\n\t\t\t\tevent.preventDefault();\n\t\t\treturn called;\n\t\t}\n\t\n\t});\n\t\n\tvar Http = {\n\t\trequest: function(method, url, callback, async) {\n\t\t\tasync = (async === undefined) ? true : async;\n\t\t\tvar xhr = new (window.ActiveXObject || XMLHttpRequest)(\n\t\t\t\t\t\t'Microsoft.XMLHTTP');\n\t\t\txhr.open(method.toUpperCase(), url, async);\n\t\t\tif ('overrideMimeType' in xhr)\n\t\t\t\txhr.overrideMimeType('text/plain');\n\t\t\txhr.onreadystatechange = function() {\n\t\t\t\tif (xhr.readyState === 4) {\n\t\t\t\t\tvar status = xhr.status;\n\t\t\t\t\tif (status === 0 || status === 200) {\n\t\t\t\t\t\tcallback.call(xhr, xhr.responseText);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthrow new Error('Could not load ' + url + ' (Error '\n\t\t\t\t\t\t\t\t+ status + ')');\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\t\t\treturn xhr.send(null);\n\t\t}\n\t};\n\t\n\tvar CanvasProvider = {\n\t\tcanvases: [],\n\t\n\t\tgetCanvas: function(width, height) {\n\t\t\tvar canvas,\n\t\t\t\tclear = true;\n\t\t\tif (typeof width === 'object') {\n\t\t\t\theight = width.height;\n\t\t\t\twidth = width.width;\n\t\t\t}\n\t\t\tif (this.canvases.length) {\n\t\t\t\tcanvas = this.canvases.pop();\n\t\t\t} else {\n\t\t\t\tcanvas = document.createElement('canvas');\n\t\t\t}\n\t\t\tvar ctx = canvas.getContext('2d');\n\t\t\tif (canvas.width === width && canvas.height === height) {\n\t\t\t\tif (clear)\n\t\t\t\t\tctx.clearRect(0, 0, width + 1, height + 1);\n\t\t\t} else {\n\t\t\t\tcanvas.width = width;\n\t\t\t\tcanvas.height = height;\n\t\t\t}\n\t\t\tctx.save();\n\t\t\treturn canvas;\n\t\t},\n\t\n\t\tgetContext: function(width, height) {\n\t\t\treturn this.getCanvas(width, height).getContext('2d');\n\t\t},\n\t\n\t\trelease: function(obj) {\n\t\t\tvar canvas = obj.canvas ? obj.canvas : obj;\n\t\t\tcanvas.getContext('2d').restore();\n\t\t\tthis.canvases.push(canvas);\n\t\t}\n\t};\n\t\n\tvar BlendMode = new function() {\n\t\tvar min = Math.min,\n\t\t\tmax = Math.max,\n\t\t\tabs = Math.abs,\n\t\t\tsr, sg, sb, sa,\n\t\t\tbr, bg, bb, ba,\n\t\t\tdr, dg, db;\n\t\n\t\tfunction getLum(r, g, b) {\n\t\t\treturn 0.2989 * r + 0.587 * g + 0.114 * b;\n\t\t}\n\t\n\t\tfunction setLum(r, g, b, l) {\n\t\t\tvar d = l - getLum(r, g, b);\n\t\t\tdr = r + d;\n\t\t\tdg = g + d;\n\t\t\tdb = b + d;\n\t\t\tvar l = getLum(dr, dg, db),\n\t\t\t\tmn = min(dr, dg, db),\n\t\t\t\tmx = max(dr, dg, db);\n\t\t\tif (mn < 0) {\n\t\t\t\tvar lmn = l - mn;\n\t\t\t\tdr = l + (dr - l) * l / lmn;\n\t\t\t\tdg = l + (dg - l) * l / lmn;\n\t\t\t\tdb = l + (db - l) * l / lmn;\n\t\t\t}\n\t\t\tif (mx > 255) {\n\t\t\t\tvar ln = 255 - l,\n\t\t\t\t\tmxl = mx - l;\n\t\t\t\tdr = l + (dr - l) * ln / mxl;\n\t\t\t\tdg = l + (dg - l) * ln / mxl;\n\t\t\t\tdb = l + (db - l) * ln / mxl;\n\t\t\t}\n\t\t}\n\t\n\t\tfunction getSat(r, g, b) {\n\t\t\treturn max(r, g, b) - min(r, g, b);\n\t\t}\n\t\n\t\tfunction setSat(r, g, b, s) {\n\t\t\tvar col = [r, g, b],\n\t\t\t\tmx = max(r, g, b),\n\t\t\t\tmn = min(r, g, b),\n\t\t\t\tmd;\n\t\t\tmn = mn === r ? 0 : mn === g ? 1 : 2;\n\t\t\tmx = mx === r ? 0 : mx === g ? 1 : 2;\n\t\t\tmd = min(mn, mx) === 0 ? max(mn, mx) === 1 ? 2 : 1 : 0;\n\t\t\tif (col[mx] > col[mn]) {\n\t\t\t\tcol[md] = (col[md] - col[mn]) * s / (col[mx] - col[mn]);\n\t\t\t\tcol[mx] = s;\n\t\t\t} else {\n\t\t\t\tcol[md] = col[mx] = 0;\n\t\t\t}\n\t\t\tcol[mn] = 0;\n\t\t\tdr = col[0];\n\t\t\tdg = col[1];\n\t\t\tdb = col[2];\n\t\t}\n\t\n\t\tvar modes = {\n\t\t\tmultiply: function() {\n\t\t\t\tdr = br * sr / 255;\n\t\t\t\tdg = bg * sg / 255;\n\t\t\t\tdb = bb * sb / 255;\n\t\t\t},\n\t\n\t\t\tscreen: function() {\n\t\t\t\tdr = br + sr - (br * sr / 255);\n\t\t\t\tdg = bg + sg - (bg * sg / 255);\n\t\t\t\tdb = bb + sb - (bb * sb / 255);\n\t\t\t},\n\t\n\t\t\toverlay: function() {\n\t\t\t\tdr = br < 128 ? 2 * br * sr / 255 : 255 - 2 * (255 - br) * (255 - sr) / 255;\n\t\t\t\tdg = bg < 128 ? 2 * bg * sg / 255 : 255 - 2 * (255 - bg) * (255 - sg) / 255;\n\t\t\t\tdb = bb < 128 ? 2 * bb * sb / 255 : 255 - 2 * (255 - bb) * (255 - sb) / 255;\n\t\t\t},\n\t\n\t\t\t'soft-light': function() {\n\t\t\t\tvar t = sr * br / 255;\n\t\t\t\tdr = t + br * (255 - (255 - br) * (255 - sr) / 255 - t) / 255;\n\t\t\t\tt = sg * bg / 255;\n\t\t\t\tdg = t + bg * (255 - (255 - bg) * (255 - sg) / 255 - t) / 255;\n\t\t\t\tt = sb * bb / 255;\n\t\t\t\tdb = t + bb * (255 - (255 - bb) * (255 - sb) / 255 - t) / 255;\n\t\t\t},\n\t\n\t\t\t'hard-light': function() {\n\t\t\t\tdr = sr < 128 ? 2 * sr * br / 255 : 255 - 2 * (255 - sr) * (255 - br) / 255;\n\t\t\t\tdg = sg < 128 ? 2 * sg * bg / 255 : 255 - 2 * (255 - sg) * (255 - bg) / 255;\n\t\t\t\tdb = sb < 128 ? 2 * sb * bb / 255 : 255 - 2 * (255 - sb) * (255 - bb) / 255;\n\t\t\t},\n\t\n\t\t\t'color-dodge': function() {\n\t\t\t\tdr = br === 0 ? 0 : sr === 255 ? 255 : min(255, 255 * br / (255 - sr));\n\t\t\t\tdg = bg === 0 ? 0 : sg === 255 ? 255 : min(255, 255 * bg / (255 - sg));\n\t\t\t\tdb = bb === 0 ? 0 : sb === 255 ? 255 : min(255, 255 * bb / (255 - sb));\n\t\t\t},\n\t\n\t\t\t'color-burn': function() {\n\t\t\t\tdr = br === 255 ? 255 : sr === 0 ? 0 : max(0, 255 - (255 - br) * 255 / sr);\n\t\t\t\tdg = bg === 255 ? 255 : sg === 0 ? 0 : max(0, 255 - (255 - bg) * 255 / sg);\n\t\t\t\tdb = bb === 255 ? 255 : sb === 0 ? 0 : max(0, 255 - (255 - bb) * 255 / sb);\n\t\t\t},\n\t\n\t\t\tdarken: function() {\n\t\t\t\tdr = br < sr ? br : sr;\n\t\t\t\tdg = bg < sg ? bg : sg;\n\t\t\t\tdb = bb < sb ? bb : sb;\n\t\t\t},\n\t\n\t\t\tlighten: function() {\n\t\t\t\tdr = br > sr ? br : sr;\n\t\t\t\tdg = bg > sg ? bg : sg;\n\t\t\t\tdb = bb > sb ? bb : sb;\n\t\t\t},\n\t\n\t\t\tdifference: function() {\n\t\t\t\tdr = br - sr;\n\t\t\t\tif (dr < 0)\n\t\t\t\t\tdr = -dr;\n\t\t\t\tdg = bg - sg;\n\t\t\t\tif (dg < 0)\n\t\t\t\t\tdg = -dg;\n\t\t\t\tdb = bb - sb;\n\t\t\t\tif (db < 0)\n\t\t\t\t\tdb = -db;\n\t\t\t},\n\t\n\t\t\texclusion: function() {\n\t\t\t\tdr = br + sr * (255 - br - br) / 255;\n\t\t\t\tdg = bg + sg * (255 - bg - bg) / 255;\n\t\t\t\tdb = bb + sb * (255 - bb - bb) / 255;\n\t\t\t},\n\t\n\t\t\thue: function() {\n\t\t\t\tsetSat(sr, sg, sb, getSat(br, bg, bb));\n\t\t\t\tsetLum(dr, dg, db, getLum(br, bg, bb));\n\t\t\t},\n\t\n\t\t\tsaturation: function() {\n\t\t\t\tsetSat(br, bg, bb, getSat(sr, sg, sb));\n\t\t\t\tsetLum(dr, dg, db, getLum(br, bg, bb));\n\t\t\t},\n\t\n\t\t\tluminosity: function() {\n\t\t\t\tsetLum(br, bg, bb, getLum(sr, sg, sb));\n\t\t\t},\n\t\n\t\t\tcolor: function() {\n\t\t\t\tsetLum(sr, sg, sb, getLum(br, bg, bb));\n\t\t\t},\n\t\n\t\t\tadd: function() {\n\t\t\t\tdr = min(br + sr, 255);\n\t\t\t\tdg = min(bg + sg, 255);\n\t\t\t\tdb = min(bb + sb, 255);\n\t\t\t},\n\t\n\t\t\tsubtract: function() {\n\t\t\t\tdr = max(br - sr, 0);\n\t\t\t\tdg = max(bg - sg, 0);\n\t\t\t\tdb = max(bb - sb, 0);\n\t\t\t},\n\t\n\t\t\taverage: function() {\n\t\t\t\tdr = (br + sr) / 2;\n\t\t\t\tdg = (bg + sg) / 2;\n\t\t\t\tdb = (bb + sb) / 2;\n\t\t\t},\n\t\n\t\t\tnegation: function() {\n\t\t\t\tdr = 255 - abs(255 - sr - br);\n\t\t\t\tdg = 255 - abs(255 - sg - bg);\n\t\t\t\tdb = 255 - abs(255 - sb - bb);\n\t\t\t}\n\t\t};\n\t\n\t\tvar nativeModes = this.nativeModes = Base.each([\n\t\t\t'source-over', 'source-in', 'source-out', 'source-atop',\n\t\t\t'destination-over', 'destination-in', 'destination-out',\n\t\t\t'destination-atop', 'lighter', 'darker', 'copy', 'xor'\n\t\t], function(mode) {\n\t\t\tthis[mode] = true;\n\t\t}, {});\n\t\n\t\tvar ctx = CanvasProvider.getContext(1, 1);\n\t\tBase.each(modes, function(func, mode) {\n\t\t\tvar darken = mode === 'darken',\n\t\t\t\tok = false;\n\t\t\tctx.save();\n\t\t\ttry {\n\t\t\t\tctx.fillStyle = darken ? '#300' : '#a00';\n\t\t\t\tctx.fillRect(0, 0, 1, 1);\n\t\t\t\tctx.globalCompositeOperation = mode;\n\t\t\t\tif (ctx.globalCompositeOperation === mode) {\n\t\t\t\t\tctx.fillStyle = darken ? '#a00' : '#300';\n\t\t\t\t\tctx.fillRect(0, 0, 1, 1);\n\t\t\t\t\tok = ctx.getImageData(0, 0, 1, 1).data[0] !== darken ? 170 : 51;\n\t\t\t\t}\n\t\t\t} catch (e) {}\n\t\t\tctx.restore();\n\t\t\tnativeModes[mode] = ok;\n\t\t});\n\t\tCanvasProvider.release(ctx);\n\t\n\t\tthis.process = function(mode, srcContext, dstContext, alpha, offset) {\n\t\t\tvar srcCanvas = srcContext.canvas,\n\t\t\t\tnormal = mode === 'normal';\n\t\t\tif (normal || nativeModes[mode]) {\n\t\t\t\tdstContext.save();\n\t\t\t\tdstContext.setTransform(1, 0, 0, 1, 0, 0);\n\t\t\t\tdstContext.globalAlpha = alpha;\n\t\t\t\tif (!normal)\n\t\t\t\t\tdstContext.globalCompositeOperation = mode;\n\t\t\t\tdstContext.drawImage(srcCanvas, offset.x, offset.y);\n\t\t\t\tdstContext.restore();\n\t\t\t} else {\n\t\t\t\tvar process = modes[mode];\n\t\t\t\tif (!process)\n\t\t\t\t\treturn;\n\t\t\t\tvar dstData = dstContext.getImageData(offset.x, offset.y,\n\t\t\t\t\t\tsrcCanvas.width, srcCanvas.height),\n\t\t\t\t\tdst = dstData.data,\n\t\t\t\t\tsrc = srcContext.getImageData(0, 0,\n\t\t\t\t\t\tsrcCanvas.width, srcCanvas.height).data;\n\t\t\t\tfor (var i = 0, l = dst.length; i < l; i += 4) {\n\t\t\t\t\tsr = src[i];\n\t\t\t\t\tbr = dst[i];\n\t\t\t\t\tsg = src[i + 1];\n\t\t\t\t\tbg = dst[i + 1];\n\t\t\t\t\tsb = src[i + 2];\n\t\t\t\t\tbb = dst[i + 2];\n\t\t\t\t\tsa = src[i + 3];\n\t\t\t\t\tba = dst[i + 3];\n\t\t\t\t\tprocess();\n\t\t\t\t\tvar a1 = sa * alpha / 255,\n\t\t\t\t\t\ta2 = 1 - a1;\n\t\t\t\t\tdst[i] = a1 * dr + a2 * br;\n\t\t\t\t\tdst[i + 1] = a1 * dg + a2 * bg;\n\t\t\t\t\tdst[i + 2] = a1 * db + a2 * bb;\n\t\t\t\t\tdst[i + 3] = sa * alpha + a2 * ba;\n\t\t\t\t}\n\t\t\t\tdstContext.putImageData(dstData, offset.x, offset.y);\n\t\t\t}\n\t\t};\n\t};\n\t\n\tvar SVGStyles = Base.each({\n\t\tfillColor: ['fill', 'color'],\n\t\tstrokeColor: ['stroke', 'color'],\n\t\tstrokeWidth: ['stroke-width', 'number'],\n\t\tstrokeCap: ['stroke-linecap', 'string'],\n\t\tstrokeJoin: ['stroke-linejoin', 'string'],\n\t\tstrokeScaling: ['vector-effect', 'lookup', {\n\t\t\ttrue: 'none',\n\t\t\tfalse: 'non-scaling-stroke'\n\t\t}, function(item, value) {\n\t\t\treturn !value\n\t\t\t\t\t&& (item instanceof PathItem\n\t\t\t\t\t\t|| item instanceof Shape\n\t\t\t\t\t\t|| item instanceof TextItem);\n\t\t}],\n\t\tmiterLimit: ['stroke-miterlimit', 'number'],\n\t\tdashArray: ['stroke-dasharray', 'array'],\n\t\tdashOffset: ['stroke-dashoffset', 'number'],\n\t\tfontFamily: ['font-family', 'string'],\n\t\tfontWeight: ['font-weight', 'string'],\n\t\tfontSize: ['font-size', 'number'],\n\t\tjustification: ['text-anchor', 'lookup', {\n\t\t\tleft: 'start',\n\t\t\tcenter: 'middle',\n\t\t\tright: 'end'\n\t\t}],\n\t\topacity: ['opacity', 'number'],\n\t\tblendMode: ['mix-blend-mode', 'string']\n\t}, function(entry, key) {\n\t\tvar part = Base.capitalize(key),\n\t\t\tlookup = entry[2];\n\t\tthis[key] = {\n\t\t\ttype: entry[1],\n\t\t\tproperty: key,\n\t\t\tattribute: entry[0],\n\t\t\ttoSVG: lookup,\n\t\t\tfromSVG: lookup && Base.each(lookup, function(value, name) {\n\t\t\t\tthis[value] = name;\n\t\t\t}, {}),\n\t\t\texportFilter: entry[3],\n\t\t\tget: 'get' + part,\n\t\t\tset: 'set' + part\n\t\t};\n\t}, {});\n\t\n\tvar SVGNamespaces = {\n\t\thref: 'http://www.w3.org/1999/xlink',\n\t\txlink: 'http://www.w3.org/2000/xmlns'\n\t};\n\t\n\tnew function() {\n\t\tvar formatter;\n\t\n\t\tfunction setAttributes(node, attrs) {\n\t\t\tfor (var key in attrs) {\n\t\t\t\tvar val = attrs[key],\n\t\t\t\t\tnamespace = SVGNamespaces[key];\n\t\t\t\tif (typeof val === 'number')\n\t\t\t\t\tval = formatter.number(val);\n\t\t\t\tif (namespace) {\n\t\t\t\t\tnode.setAttributeNS(namespace, key, val);\n\t\t\t\t} else {\n\t\t\t\t\tnode.setAttribute(key, val);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn node;\n\t\t}\n\t\n\t\tfunction createElement(tag, attrs) {\n\t\t\treturn setAttributes(\n\t\t\t\tdocument.createElementNS('http://www.w3.org/2000/svg', tag), attrs);\n\t\t}\n\t\n\t\tfunction getTransform(matrix, coordinates, center) {\n\t\t\tvar attrs = new Base(),\n\t\t\t\ttrans = matrix.getTranslation();\n\t\t\tif (coordinates) {\n\t\t\t\tmatrix = matrix.shiftless();\n\t\t\t\tvar point = matrix._inverseTransform(trans);\n\t\t\t\tattrs[center ? 'cx' : 'x'] = point.x;\n\t\t\t\tattrs[center ? 'cy' : 'y'] = point.y;\n\t\t\t\ttrans = null;\n\t\t\t}\n\t\t\tif (!matrix.isIdentity()) {\n\t\t\t\tvar decomposed = matrix.decompose();\n\t\t\t\tif (decomposed && !decomposed.shearing) {\n\t\t\t\t\tvar parts = [],\n\t\t\t\t\t\tangle = decomposed.rotation,\n\t\t\t\t\t\tscale = decomposed.scaling;\n\t\t\t\t\tif (trans && !trans.isZero())\n\t\t\t\t\t\tparts.push('translate(' + formatter.point(trans) + ')');\n\t\t\t\t\tif (!Numerical.isZero(scale.x - 1)\n\t\t\t\t\t\t\t|| !Numerical.isZero(scale.y - 1))\n\t\t\t\t\t\tparts.push('scale(' + formatter.point(scale) +')');\n\t\t\t\t\tif (angle)\n\t\t\t\t\t\tparts.push('rotate(' + formatter.number(angle) + ')');\n\t\t\t\t\tattrs.transform = parts.join(' ');\n\t\t\t\t} else {\n\t\t\t\t\tattrs.transform = 'matrix(' + matrix.getValues().join(',') + ')';\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn attrs;\n\t\t}\n\t\n\t\tfunction exportGroup(item, options) {\n\t\t\tvar attrs = getTransform(item._matrix),\n\t\t\t\tchildren = item._children;\n\t\t\tvar node = createElement('g', attrs);\n\t\t\tfor (var i = 0, l = children.length; i < l; i++) {\n\t\t\t\tvar child = children[i];\n\t\t\t\tvar childNode = exportSVG(child, options);\n\t\t\t\tif (childNode) {\n\t\t\t\t\tif (child.isClipMask()) {\n\t\t\t\t\t\tvar clip = createElement('clipPath');\n\t\t\t\t\t\tclip.appendChild(childNode);\n\t\t\t\t\t\tsetDefinition(child, clip, 'clip');\n\t\t\t\t\t\tsetAttributes(node, {\n\t\t\t\t\t\t\t'clip-path': 'url(#' + clip.id + ')'\n\t\t\t\t\t\t});\n\t\t\t\t\t} else {\n\t\t\t\t\t\tnode.appendChild(childNode);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn node;\n\t\t}\n\t\n\t\tfunction exportRaster(item, options) {\n\t\t\tvar attrs = getTransform(item._matrix, true),\n\t\t\t\tsize = item.getSize(),\n\t\t\t\timage = item.getImage();\n\t\t\tattrs.x -= size.width / 2;\n\t\t\tattrs.y -= size.height / 2;\n\t\t\tattrs.width = size.width;\n\t\t\tattrs.height = size.height;\n\t\t\tattrs.href = options.embedImages === false && image && image.src\n\t\t\t\t\t|| item.toDataURL();\n\t\t\treturn createElement('image', attrs);\n\t\t}\n\t\n\t\tfunction exportPath(item, options) {\n\t\t\tvar matchShapes = options.matchShapes;\n\t\t\tif (matchShapes) {\n\t\t\t\tvar shape = item.toShape(false);\n\t\t\t\tif (shape)\n\t\t\t\t\treturn exportShape(shape, options);\n\t\t\t}\n\t\t\tvar segments = item._segments,\n\t\t\t\ttype,\n\t\t\t\tattrs = getTransform(item._matrix);\n\t\t\tif (segments.length === 0)\n\t\t\t\treturn null;\n\t\t\tif (matchShapes && !item.hasHandles()) {\n\t\t\t\tif (segments.length >= 3) {\n\t\t\t\t\ttype = item._closed ? 'polygon' : 'polyline';\n\t\t\t\t\tvar parts = [];\n\t\t\t\t\tfor(var i = 0, l = segments.length; i < l; i++)\n\t\t\t\t\t\tparts.push(formatter.point(segments[i]._point));\n\t\t\t\t\tattrs.points = parts.join(' ');\n\t\t\t\t} else {\n\t\t\t\t\ttype = 'line';\n\t\t\t\t\tvar first = segments[0]._point,\n\t\t\t\t\t\tlast = segments[segments.length - 1]._point;\n\t\t\t\t\tattrs.set({\n\t\t\t\t\t\tx1: first.x,\n\t\t\t\t\t\ty1: first.y,\n\t\t\t\t\t\tx2: last.x,\n\t\t\t\t\t\ty2: last.y\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\ttype = 'path';\n\t\t\t\tattrs.d = item.getPathData(null, options.precision);\n\t\t\t}\n\t\t\treturn createElement(type, attrs);\n\t\t}\n\t\n\t\tfunction exportShape(item) {\n\t\t\tvar type = item._type,\n\t\t\t\tradius = item._radius,\n\t\t\t\tattrs = getTransform(item._matrix, true, type !== 'rectangle');\n\t\t\tif (type === 'rectangle') {\n\t\t\t\ttype = 'rect';\n\t\t\t\tvar size = item._size,\n\t\t\t\t\twidth = size.width,\n\t\t\t\t\theight = size.height;\n\t\t\t\tattrs.x -= width / 2;\n\t\t\t\tattrs.y -= height / 2;\n\t\t\t\tattrs.width = width;\n\t\t\t\tattrs.height = height;\n\t\t\t\tif (radius.isZero())\n\t\t\t\t\tradius = null;\n\t\t\t}\n\t\t\tif (radius) {\n\t\t\t\tif (type === 'circle') {\n\t\t\t\t\tattrs.r = radius;\n\t\t\t\t} else {\n\t\t\t\t\tattrs.rx = radius.width;\n\t\t\t\t\tattrs.ry = radius.height;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn createElement(type, attrs);\n\t\t}\n\t\n\t\tfunction exportCompoundPath(item, options) {\n\t\t\tvar attrs = getTransform(item._matrix);\n\t\t\tvar data = item.getPathData(null, options.precision);\n\t\t\tif (data)\n\t\t\t\tattrs.d = data;\n\t\t\treturn createElement('path', attrs);\n\t\t}\n\t\n\t\tfunction exportPlacedSymbol(item, options) {\n\t\t\tvar attrs = getTransform(item._matrix, true),\n\t\t\t\tsymbol = item.getSymbol(),\n\t\t\t\tsymbolNode = getDefinition(symbol, 'symbol'),\n\t\t\t\tdefinition = symbol.getDefinition(),\n\t\t\t\tbounds = definition.getBounds();\n\t\t\tif (!symbolNode) {\n\t\t\t\tsymbolNode = createElement('symbol', {\n\t\t\t\t\tviewBox: formatter.rectangle(bounds)\n\t\t\t\t});\n\t\t\t\tsymbolNode.appendChild(exportSVG(definition, options));\n\t\t\t\tsetDefinition(symbol, symbolNode, 'symbol');\n\t\t\t}\n\t\t\tattrs.href = '#' + symbolNode.id;\n\t\t\tattrs.x += bounds.x;\n\t\t\tattrs.y += bounds.y;\n\t\t\tattrs.width = formatter.number(bounds.width);\n\t\t\tattrs.height = formatter.number(bounds.height);\n\t\t\tattrs.overflow = 'visible';\n\t\t\treturn createElement('use', attrs);\n\t\t}\n\t\n\t\tfunction exportGradient(color) {\n\t\t\tvar gradientNode = getDefinition(color, 'color');\n\t\t\tif (!gradientNode) {\n\t\t\t\tvar gradient = color.getGradient(),\n\t\t\t\t\tradial = gradient._radial,\n\t\t\t\t\torigin = color.getOrigin().transform(),\n\t\t\t\t\tdestination = color.getDestination().transform(),\n\t\t\t\t\tattrs;\n\t\t\t\tif (radial) {\n\t\t\t\t\tattrs = {\n\t\t\t\t\t\tcx: origin.x,\n\t\t\t\t\t\tcy: origin.y,\n\t\t\t\t\t\tr: origin.getDistance(destination)\n\t\t\t\t\t};\n\t\t\t\t\tvar highlight = color.getHighlight();\n\t\t\t\t\tif (highlight) {\n\t\t\t\t\t\thighlight = highlight.transform();\n\t\t\t\t\t\tattrs.fx = highlight.x;\n\t\t\t\t\t\tattrs.fy = highlight.y;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tattrs = {\n\t\t\t\t\t\tx1: origin.x,\n\t\t\t\t\t\ty1: origin.y,\n\t\t\t\t\t\tx2: destination.x,\n\t\t\t\t\t\ty2: destination.y\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t\tattrs.gradientUnits = 'userSpaceOnUse';\n\t\t\t\tgradientNode = createElement(\n\t\t\t\t\t\t(radial ? 'radial' : 'linear') + 'Gradient', attrs);\n\t\t\t\tvar stops = gradient._stops;\n\t\t\t\tfor (var i = 0, l = stops.length; i < l; i++) {\n\t\t\t\t\tvar stop = stops[i],\n\t\t\t\t\t\tstopColor = stop._color,\n\t\t\t\t\t\talpha = stopColor.getAlpha();\n\t\t\t\t\tattrs = {\n\t\t\t\t\t\toffset: stop._rampPoint,\n\t\t\t\t\t\t'stop-color': stopColor.toCSS(true)\n\t\t\t\t\t};\n\t\t\t\t\tif (alpha < 1)\n\t\t\t\t\t\tattrs['stop-opacity'] = alpha;\n\t\t\t\t\tgradientNode.appendChild(createElement('stop', attrs));\n\t\t\t\t}\n\t\t\t\tsetDefinition(color, gradientNode, 'color');\n\t\t\t}\n\t\t\treturn 'url(#' + gradientNode.id + ')';\n\t\t}\n\t\n\t\tfunction exportText(item) {\n\t\t\tvar node = createElement('text', getTransform(item._matrix, true));\n\t\t\tnode.textContent = item._content;\n\t\t\treturn node;\n\t\t}\n\t\n\t\tvar exporters = {\n\t\t\tGroup: exportGroup,\n\t\t\tLayer: exportGroup,\n\t\t\tRaster: exportRaster,\n\t\t\tPath: exportPath,\n\t\t\tShape: exportShape,\n\t\t\tCompoundPath: exportCompoundPath,\n\t\t\tPlacedSymbol: exportPlacedSymbol,\n\t\t\tPointText: exportText\n\t\t};\n\t\n\t\tfunction applyStyle(item, node, isRoot) {\n\t\t\tvar attrs = {},\n\t\t\t\tparent = !isRoot && item.getParent();\n\t\n\t\t\tif (item._name != null)\n\t\t\t\tattrs.id = item._name;\n\t\n\t\t\tBase.each(SVGStyles, function(entry) {\n\t\t\t\tvar get = entry.get,\n\t\t\t\t\ttype = entry.type,\n\t\t\t\t\tvalue = item[get]();\n\t\t\t\tif (entry.exportFilter\n\t\t\t\t\t\t? entry.exportFilter(item, value)\n\t\t\t\t\t\t: !parent || !Base.equals(parent[get](), value)) {\n\t\t\t\t\tif (type === 'color' && value != null) {\n\t\t\t\t\t\tvar alpha = value.getAlpha();\n\t\t\t\t\t\tif (alpha < 1)\n\t\t\t\t\t\t\tattrs[entry.attribute + '-opacity'] = alpha;\n\t\t\t\t\t}\n\t\t\t\t\tattrs[entry.attribute] = value == null\n\t\t\t\t\t\t? 'none'\n\t\t\t\t\t\t: type === 'number'\n\t\t\t\t\t\t\t? formatter.number(value)\n\t\t\t\t\t\t\t: type === 'color'\n\t\t\t\t\t\t\t\t? value.gradient\n\t\t\t\t\t\t\t\t\t? exportGradient(value, item)\n\t\t\t\t\t\t\t\t\t: value.toCSS(true)\n\t\t\t\t\t\t\t\t: type === 'array'\n\t\t\t\t\t\t\t\t\t? value.join(',')\n\t\t\t\t\t\t\t\t\t: type === 'lookup'\n\t\t\t\t\t\t\t\t\t\t? entry.toSVG[value]\n\t\t\t\t\t\t\t\t\t\t: value;\n\t\t\t\t}\n\t\t\t});\n\t\n\t\t\tif (attrs.opacity === 1)\n\t\t\t\tdelete attrs.opacity;\n\t\n\t\t\tif (!item._visible)\n\t\t\t\tattrs.visibility = 'hidden';\n\t\n\t\t\treturn setAttributes(node, attrs);\n\t\t}\n\t\n\t\tvar definitions;\n\t\tfunction getDefinition(item, type) {\n\t\t\tif (!definitions)\n\t\t\t\tdefinitions = { ids: {}, svgs: {} };\n\t\t\treturn item && definitions.svgs[type + '-' + item._id];\n\t\t}\n\t\n\t\tfunction setDefinition(item, node, type) {\n\t\t\tif (!definitions)\n\t\t\t\tgetDefinition();\n\t\t\tvar id = definitions.ids[type] = (definitions.ids[type] || 0) + 1;\n\t\t\tnode.id = type + '-' + id;\n\t\t\tdefinitions.svgs[type + '-' + item._id] = node;\n\t\t}\n\t\n\t\tfunction exportDefinitions(node, options) {\n\t\t\tvar svg = node,\n\t\t\t\tdefs = null;\n\t\t\tif (definitions) {\n\t\t\t\tsvg = node.nodeName.toLowerCase() === 'svg' && node;\n\t\t\t\tfor (var i in definitions.svgs) {\n\t\t\t\t\tif (!defs) {\n\t\t\t\t\t\tif (!svg) {\n\t\t\t\t\t\t\tsvg = createElement('svg');\n\t\t\t\t\t\t\tsvg.appendChild(node);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdefs = svg.insertBefore(createElement('defs'),\n\t\t\t\t\t\t\t\tsvg.firstChild);\n\t\t\t\t\t}\n\t\t\t\t\tdefs.appendChild(definitions.svgs[i]);\n\t\t\t\t}\n\t\t\t\tdefinitions = null;\n\t\t\t}\n\t\t\treturn options.asString\n\t\t\t\t\t? new XMLSerializer().serializeToString(svg)\n\t\t\t\t\t: svg;\n\t\t}\n\t\n\t\tfunction exportSVG(item, options, isRoot) {\n\t\t\tvar exporter = exporters[item._class],\n\t\t\t\tnode = exporter && exporter(item, options);\n\t\t\tif (node) {\n\t\t\t\tvar onExport = options.onExport;\n\t\t\t\tif (onExport)\n\t\t\t\t\tnode = onExport(item, node, options) || node;\n\t\t\t\tvar data = JSON.stringify(item._data);\n\t\t\t\tif (data && data !== '{}' && data !== 'null')\n\t\t\t\t\tnode.setAttribute('data-paper-data', data);\n\t\t\t}\n\t\t\treturn node && applyStyle(item, node, isRoot);\n\t\t}\n\t\n\t\tfunction setOptions(options) {\n\t\t\tif (!options)\n\t\t\t\toptions = {};\n\t\t\tformatter = new Formatter(options.precision);\n\t\t\treturn options;\n\t\t}\n\t\n\t\tItem.inject({\n\t\t\texportSVG: function(options) {\n\t\t\t\toptions = setOptions(options);\n\t\t\t\treturn exportDefinitions(exportSVG(this, options, true), options);\n\t\t\t}\n\t\t});\n\t\n\t\tProject.inject({\n\t\t\texportSVG: function(options) {\n\t\t\t\toptions = setOptions(options);\n\t\t\t\tvar layers = this.layers,\n\t\t\t\t\tview = this.getView(),\n\t\t\t\t\tsize = view.getViewSize(),\n\t\t\t\t\tnode = createElement('svg', {\n\t\t\t\t\t\tx: 0,\n\t\t\t\t\t\ty: 0,\n\t\t\t\t\t\twidth: size.width,\n\t\t\t\t\t\theight: size.height,\n\t\t\t\t\t\tversion: '1.1',\n\t\t\t\t\t\txmlns: 'http://www.w3.org/2000/svg',\n\t\t\t\t\t\t'xmlns:xlink': 'http://www.w3.org/1999/xlink'\n\t\t\t\t\t}),\n\t\t\t\t\tparent = node,\n\t\t\t\t\tmatrix = view._matrix;\n\t\t\t\tif (!matrix.isIdentity())\n\t\t\t\t\tparent = node.appendChild(\n\t\t\t\t\t\t\tcreateElement('g', getTransform(matrix)));\n\t\t\t\tfor (var i = 0, l = layers.length; i < l; i++)\n\t\t\t\t\tparent.appendChild(exportSVG(layers[i], options, true));\n\t\t\t\treturn exportDefinitions(node, options);\n\t\t\t}\n\t\t});\n\t};\n\t\n\tnew function() {\n\t\n\t\tfunction getValue(node, name, isString, allowNull) {\n\t\t\tvar namespace = SVGNamespaces[name],\n\t\t\t\tvalue = namespace\n\t\t\t\t\t? node.getAttributeNS(namespace, name)\n\t\t\t\t\t: node.getAttribute(name);\n\t\t\tif (value === 'null')\n\t\t\t\tvalue = null;\n\t\t\treturn value == null\n\t\t\t\t\t? allowNull\n\t\t\t\t\t\t? null\n\t\t\t\t\t\t: isString\n\t\t\t\t\t\t\t? ''\n\t\t\t\t\t\t\t: 0\n\t\t\t\t\t: isString\n\t\t\t\t\t\t? value\n\t\t\t\t\t\t: parseFloat(value);\n\t\t}\n\t\n\t\tfunction getPoint(node, x, y, allowNull) {\n\t\t\tx = getValue(node, x, false, allowNull);\n\t\t\ty = getValue(node, y, false, allowNull);\n\t\t\treturn allowNull && (x == null || y == null) ? null\n\t\t\t\t\t: new Point(x, y);\n\t\t}\n\t\n\t\tfunction getSize(node, w, h, allowNull) {\n\t\t\tw = getValue(node, w, false, allowNull);\n\t\t\th = getValue(node, h, false, allowNull);\n\t\t\treturn allowNull && (w == null || h == null) ? null\n\t\t\t\t\t: new Size(w, h);\n\t\t}\n\t\n\t\tfunction convertValue(value, type, lookup) {\n\t\t\treturn value === 'none'\n\t\t\t\t\t? null\n\t\t\t\t\t: type === 'number'\n\t\t\t\t\t\t? parseFloat(value)\n\t\t\t\t\t\t: type === 'array'\n\t\t\t\t\t\t\t? value ? value.split(/[\\s,]+/g).map(parseFloat) : []\n\t\t\t\t\t\t\t: type === 'color'\n\t\t\t\t\t\t\t\t? getDefinition(value) || value\n\t\t\t\t\t\t\t\t: type === 'lookup'\n\t\t\t\t\t\t\t\t\t? lookup[value]\n\t\t\t\t\t\t\t\t\t: value;\n\t\t}\n\t\n\t\tfunction importGroup(node, type, options, isRoot) {\n\t\t\tvar nodes = node.childNodes,\n\t\t\t\tisClip = type === 'clippath',\n\t\t\t\titem = new Group(),\n\t\t\t\tproject = item._project,\n\t\t\t\tcurrentStyle = project._currentStyle,\n\t\t\t\tchildren = [];\n\t\t\tif (!isClip) {\n\t\t\t\titem = applyAttributes(item, node, isRoot);\n\t\t\t\tproject._currentStyle = item._style.clone();\n\t\t\t}\n\t\t\tif (isRoot) {\n\t\t\t\tvar defs = node.querySelectorAll('defs');\n\t\t\t\tfor (var i = 0, l = defs.length; i < l; i++) {\n\t\t\t\t\timportSVG(defs[i], options, false);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (var i = 0, l = nodes.length; i < l; i++) {\n\t\t\t\tvar childNode = nodes[i],\n\t\t\t\t\tchild;\n\t\t\t\tif (childNode.nodeType === 1\n\t\t\t\t\t\t&& childNode.nodeName.toLowerCase() !== 'defs'\n\t\t\t\t\t\t&& (child = importSVG(childNode, options, false))\n\t\t\t\t\t\t&& !(child instanceof Symbol))\n\t\t\t\t\tchildren.push(child);\n\t\t\t}\n\t\t\titem.addChildren(children);\n\t\t\tif (isClip)\n\t\t\t\titem = applyAttributes(item.reduce(), node, isRoot);\n\t\t\tproject._currentStyle = currentStyle;\n\t\t\tif (isClip || type === 'defs') {\n\t\t\t\titem.remove();\n\t\t\t\titem = null;\n\t\t\t}\n\t\t\treturn item;\n\t\t}\n\t\n\t\tfunction importPoly(node, type) {\n\t\t\tvar coords = node.getAttribute('points').match(\n\t\t\t\t\t\t/[+-]?(?:\\d*\\.\\d+|\\d+\\.?)(?:[eE][+-]?\\d+)?/g),\n\t\t\t\tpoints = [];\n\t\t\tfor (var i = 0, l = coords.length; i < l; i += 2)\n\t\t\t\tpoints.push(new Point(\n\t\t\t\t\t\tparseFloat(coords[i]),\n\t\t\t\t\t\tparseFloat(coords[i + 1])));\n\t\t\tvar path = new Path(points);\n\t\t\tif (type === 'polygon')\n\t\t\t\tpath.closePath();\n\t\t\treturn path;\n\t\t}\n\t\n\t\tfunction importPath(node) {\n\t\t\tvar data = node.getAttribute('d'),\n\t\t\t\tparam = { pathData: data };\n\t\t\treturn (data.match(/m/gi) || []).length > 1 || /z\\S+/i.test(data)\n\t\t\t\t\t? new CompoundPath(param)\n\t\t\t\t\t: new Path(param);\n\t\t}\n\t\n\t\tfunction importGradient(node, type) {\n\t\t\tvar id = (getValue(node, 'href', true) || '').substring(1),\n\t\t\t\tisRadial = type === 'radialgradient',\n\t\t\t\tgradient;\n\t\t\tif (id) {\n\t\t\t\tgradient = definitions[id].getGradient();\n\t\t\t} else {\n\t\t\t\tvar nodes = node.childNodes,\n\t\t\t\t\tstops = [];\n\t\t\t\tfor (var i = 0, l = nodes.length; i < l; i++) {\n\t\t\t\t\tvar child = nodes[i];\n\t\t\t\t\tif (child.nodeType === 1)\n\t\t\t\t\t\tstops.push(applyAttributes(new GradientStop(), child));\n\t\t\t\t}\n\t\t\t\tgradient = new Gradient(stops, isRadial);\n\t\t\t}\n\t\t\tvar origin, destination, highlight;\n\t\t\tif (isRadial) {\n\t\t\t\torigin = getPoint(node, 'cx', 'cy');\n\t\t\t\tdestination = origin.add(getValue(node, 'r'), 0);\n\t\t\t\thighlight = getPoint(node, 'fx', 'fy', true);\n\t\t\t} else {\n\t\t\t\torigin = getPoint(node, 'x1', 'y1');\n\t\t\t\tdestination = getPoint(node, 'x2', 'y2');\n\t\t\t}\n\t\t\tapplyAttributes(\n\t\t\t\tnew Color(gradient, origin, destination, highlight), node);\n\t\t\treturn null;\n\t\t}\n\t\n\t\tvar importers = {\n\t\t\t'#document': function (node, type, options, isRoot) {\n\t\t\t\tvar nodes = node.childNodes;\n\t\t\t\tfor (var i = 0, l = nodes.length; i < l; i++) {\n\t\t\t\t\tvar child = nodes[i];\n\t\t\t\t\tif (child.nodeType === 1) {\n\t\t\t\t\t\tvar next = child.nextSibling;\n\t\t\t\t\t\tdocument.body.appendChild(child);\n\t\t\t\t\t\tvar item = importSVG(child, options, isRoot);\n\t\t\t\t\t\tif (next) {\n\t\t\t\t\t\t\tnode.insertBefore(child, next);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tnode.appendChild(child);\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn item;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\t\tg: importGroup,\n\t\t\tsvg: importGroup,\n\t\t\tclippath: importGroup,\n\t\t\tpolygon: importPoly,\n\t\t\tpolyline: importPoly,\n\t\t\tpath: importPath,\n\t\t\tlineargradient: importGradient,\n\t\t\tradialgradient: importGradient,\n\t\n\t\t\timage: function (node) {\n\t\t\t\tvar raster = new Raster(getValue(node, 'href', true));\n\t\t\t\traster.on('load', function() {\n\t\t\t\t\tvar size = getSize(node, 'width', 'height');\n\t\t\t\t\tthis.setSize(size);\n\t\t\t\t\tvar center = this._matrix._transformPoint(\n\t\t\t\t\t\t\tgetPoint(node, 'x', 'y').add(size.divide(2)));\n\t\t\t\t\tthis.translate(center);\n\t\t\t\t});\n\t\t\t\treturn raster;\n\t\t\t},\n\t\n\t\t\tsymbol: function(node, type, options, isRoot) {\n\t\t\t\treturn new Symbol(importGroup(node, type, options, isRoot), true);\n\t\t\t},\n\t\n\t\t\tdefs: importGroup,\n\t\n\t\t\tuse: function(node) {\n\t\t\t\tvar id = (getValue(node, 'href', true) || '').substring(1),\n\t\t\t\t\tdefinition = definitions[id],\n\t\t\t\t\tpoint = getPoint(node, 'x', 'y');\n\t\t\t\treturn definition\n\t\t\t\t\t\t? definition instanceof Symbol\n\t\t\t\t\t\t\t? definition.place(point)\n\t\t\t\t\t\t\t: definition.clone().translate(point)\n\t\t\t\t\t\t: null;\n\t\t\t},\n\t\n\t\t\tcircle: function(node) {\n\t\t\t\treturn new Shape.Circle(getPoint(node, 'cx', 'cy'),\n\t\t\t\t\t\tgetValue(node, 'r'));\n\t\t\t},\n\t\n\t\t\tellipse: function(node) {\n\t\t\t\treturn new Shape.Ellipse({\n\t\t\t\t\tcenter: getPoint(node, 'cx', 'cy'),\n\t\t\t\t\tradius: getSize(node, 'rx', 'ry')\n\t\t\t\t});\n\t\t\t},\n\t\n\t\t\trect: function(node) {\n\t\t\t\tvar point = getPoint(node, 'x', 'y'),\n\t\t\t\t\tsize = getSize(node, 'width', 'height'),\n\t\t\t\t\tradius = getSize(node, 'rx', 'ry');\n\t\t\t\treturn new Shape.Rectangle(new Rectangle(point, size), radius);\n\t\t\t},\n\t\n\t\t\tline: function(node) {\n\t\t\t\treturn new Path.Line(getPoint(node, 'x1', 'y1'),\n\t\t\t\t\t\tgetPoint(node, 'x2', 'y2'));\n\t\t\t},\n\t\n\t\t\ttext: function(node) {\n\t\t\t\tvar text = new PointText(getPoint(node, 'x', 'y')\n\t\t\t\t\t\t.add(getPoint(node, 'dx', 'dy')));\n\t\t\t\ttext.setContent(node.textContent.trim() || '');\n\t\t\t\treturn text;\n\t\t\t}\n\t\t};\n\t\n\t\tfunction applyTransform(item, value, name, node) {\n\t\t\tvar transforms = (node.getAttribute(name) || '').split(/\\)\\s*/g),\n\t\t\t\tmatrix = new Matrix();\n\t\t\tfor (var i = 0, l = transforms.length; i < l; i++) {\n\t\t\t\tvar transform = transforms[i];\n\t\t\t\tif (!transform)\n\t\t\t\t\tbreak;\n\t\t\t\tvar parts = transform.split(/\\(\\s*/),\n\t\t\t\t\tcommand = parts[0],\n\t\t\t\t\tv = parts[1].split(/[\\s,]+/g);\n\t\t\t\tfor (var j = 0, m = v.length; j < m; j++)\n\t\t\t\t\tv[j] = parseFloat(v[j]);\n\t\t\t\tswitch (command) {\n\t\t\t\tcase 'matrix':\n\t\t\t\t\tmatrix.concatenate(\n\t\t\t\t\t\t\tnew Matrix(v[0], v[1], v[2], v[3], v[4], v[5]));\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'rotate':\n\t\t\t\t\tmatrix.rotate(v[0], v[1], v[2]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'translate':\n\t\t\t\t\tmatrix.translate(v[0], v[1]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'scale':\n\t\t\t\t\tmatrix.scale(v);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'skewX':\n\t\t\t\t\tmatrix.skew(v[0], 0);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'skewY':\n\t\t\t\t\tmatrix.skew(0, v[0]);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\titem.transform(matrix);\n\t\t}\n\t\n\t\tfunction applyOpacity(item, value, name) {\n\t\t\tvar color = item[name === 'fill-opacity' ? 'getFillColor'\n\t\t\t\t\t: 'getStrokeColor']();\n\t\t\tif (color)\n\t\t\t\tcolor.setAlpha(parseFloat(value));\n\t\t}\n\t\n\t\tvar attributes = Base.set(Base.each(SVGStyles, function(entry) {\n\t\t\tthis[entry.attribute] = function(item, value) {\n\t\t\t\titem[entry.set](convertValue(value, entry.type, entry.fromSVG));\n\t\t\t\tif (entry.type === 'color' && item instanceof Shape) {\n\t\t\t\t\tvar color = item[entry.get]();\n\t\t\t\t\tif (color)\n\t\t\t\t\t\tcolor.transform(new Matrix().translate(\n\t\t\t\t\t\t\t\titem.getPosition(true).negate()));\n\t\t\t\t}\n\t\t\t};\n\t\t}, {}), {\n\t\t\tid: function(item, value) {\n\t\t\t\tdefinitions[value] = item;\n\t\t\t\tif (item.setName)\n\t\t\t\t\titem.setName(value);\n\t\t\t},\n\t\n\t\t\t'clip-path': function(item, value) {\n\t\t\t\tvar clip = getDefinition(value);\n\t\t\t\tif (clip) {\n\t\t\t\t\tclip = clip.clone();\n\t\t\t\t\tclip.setClipMask(true);\n\t\t\t\t\tif (item instanceof Group) {\n\t\t\t\t\t\titem.insertChild(0, clip);\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn new Group(clip, item);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\n\t\t\tgradientTransform: applyTransform,\n\t\t\ttransform: applyTransform,\n\t\n\t\t\t'fill-opacity': applyOpacity,\n\t\t\t'stroke-opacity': applyOpacity,\n\t\n\t\t\tvisibility: function(item, value) {\n\t\t\t\titem.setVisible(value === 'visible');\n\t\t\t},\n\t\n\t\t\tdisplay: function(item, value) {\n\t\t\t\titem.setVisible(value !== null);\n\t\t\t},\n\t\n\t\t\t'stop-color': function(item, value) {\n\t\t\t\tif (item.setColor)\n\t\t\t\t\titem.setColor(value);\n\t\t\t},\n\t\n\t\t\t'stop-opacity': function(item, value) {\n\t\t\t\tif (item._color)\n\t\t\t\t\titem._color.setAlpha(parseFloat(value));\n\t\t\t},\n\t\n\t\t\toffset: function(item, value) {\n\t\t\t\tvar percentage = value.match(/(.*)%$/);\n\t\t\t\titem.setRampPoint(percentage\n\t\t\t\t\t\t? percentage[1] / 100\n\t\t\t\t\t\t: parseFloat(value));\n\t\t\t},\n\t\n\t\t\tviewBox: function(item, value, name, node, styles) {\n\t\t\t\tvar rect = new Rectangle(convertValue(value, 'array')),\n\t\t\t\t\tsize = getSize(node, 'width', 'height', true);\n\t\t\t\tif (item instanceof Group) {\n\t\t\t\t\tvar scale = size ? rect.getSize().divide(size) : 1,\n\t\t\t\t\t\tmatrix = new Matrix().translate(rect.getPoint()).scale(scale);\n\t\t\t\t\titem.transform(matrix.inverted());\n\t\t\t\t} else if (item instanceof Symbol) {\n\t\t\t\t\tif (size)\n\t\t\t\t\t\trect.setSize(size);\n\t\t\t\t\tvar clip = getAttribute(node, 'overflow', styles) != 'visible',\n\t\t\t\t\t\tgroup = item._definition;\n\t\t\t\t\tif (clip && !rect.contains(group.getBounds())) {\n\t\t\t\t\t\tclip = new Shape.Rectangle(rect).transform(group._matrix);\n\t\t\t\t\t\tclip.setClipMask(true);\n\t\t\t\t\t\tgroup.addChild(clip);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\n\t\tfunction getAttribute(node, name, styles) {\n\t\t\tvar attr = node.attributes[name],\n\t\t\t\tvalue = attr && attr.value;\n\t\t\tif (!value) {\n\t\t\t\tvar style = Base.camelize(name);\n\t\t\t\tvalue = node.style[style];\n\t\t\t\tif (!value && styles.node[style] !== styles.parent[style])\n\t\t\t\t\tvalue = styles.node[style];\n\t\t\t}\n\t\t\treturn !value\n\t\t\t\t\t? undefined\n\t\t\t\t\t: value === 'none'\n\t\t\t\t\t\t? null\n\t\t\t\t\t\t: value;\n\t\t}\n\t\n\t\tfunction applyAttributes(item, node, isRoot) {\n\t\t\tvar styles = {\n\t\t\t\tnode: DomElement.getStyles(node) || {},\n\t\t\t\tparent: !isRoot && DomElement.getStyles(node.parentNode) || {}\n\t\t\t};\n\t\t\tBase.each(attributes, function(apply, name) {\n\t\t\t\tvar value = getAttribute(node, name, styles);\n\t\t\t\tif (value !== undefined)\n\t\t\t\t\titem = Base.pick(apply(item, value, name, node, styles), item);\n\t\t\t});\n\t\t\treturn item;\n\t\t}\n\t\n\t\tvar definitions = {};\n\t\tfunction getDefinition(value) {\n\t\t\tvar match = value && value.match(/\\((?:#|)([^)']+)/);\n\t\t\treturn match && definitions[match[1]];\n\t\t}\n\t\n\t\tfunction importSVG(source, options, isRoot) {\n\t\t\tif (!source)\n\t\t\t\treturn null;\n\t\t\tif (!options) {\n\t\t\t\toptions = {};\n\t\t\t} else if (typeof options === 'function') {\n\t\t\t\toptions = { onLoad: options };\n\t\t\t}\n\t\n\t\t\tvar node = source,\n\t\t\t\tscope = paper;\n\t\n\t\t\tfunction onLoadCallback(svg) {\n\t\t\t\tpaper = scope;\n\t\t\t\tvar item = importSVG(svg, options, isRoot),\n\t\t\t\t\tonLoad = options.onLoad,\n\t\t\t\t\tview = scope.project && scope.getView();\n\t\t\t\tif (onLoad)\n\t\t\t\t\tonLoad.call(this, item);\n\t\t\t\tview.update();\n\t\t\t}\n\t\n\t\t\tif (isRoot) {\n\t\t\t\tif (typeof source === 'string' && !/^.*</.test(source)) {\n\t\t\t\t\tnode = document.getElementById(source);\n\t\t\t\t\tif (node) {\n\t\t\t\t\t\tsource = null;\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn Http.request('get', source, onLoadCallback);\n\t\t\t\t\t}\n\t\t\t\t} else if (typeof File !== 'undefined' && source instanceof File) {\n\t\t\t\t\tvar reader = new FileReader();\n\t\t\t\t\treader.onload = function() {\n\t\t\t\t\t\tonLoadCallback(reader.result);\n\t\t\t\t\t};\n\t\t\t\t\treturn reader.readAsText(source);\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\tif (typeof source === 'string')\n\t\t\t\tnode = new DOMParser().parseFromString(source, 'image/svg+xml');\n\t\t\tif (!node.nodeName)\n\t\t\t\tthrow new Error('Unsupported SVG source: ' + source);\n\t\t\tvar type = node.nodeName.toLowerCase(),\n\t\t\t\timporter = importers[type],\n\t\t\t\titem,\n\t\t\t\tdata = node.getAttribute && node.getAttribute('data-paper-data'),\n\t\t\t\tsettings = scope.settings,\n\t\t\t\tapplyMatrix = settings.applyMatrix;\n\t\t\tsettings.applyMatrix = false;\n\t\t\titem = importer && importer(node, type, options, isRoot) || null;\n\t\t\tsettings.applyMatrix = applyMatrix;\n\t\t\tif (item) {\n\t\t\t\tif (type !== '#document' && !(item instanceof Group))\n\t\t\t\t\titem = applyAttributes(item, node, isRoot);\n\t\t\t\tvar onImport = options.onImport;\n\t\t\t\tif (onImport)\n\t\t\t\t\titem = onImport(node, item, options) || item;\n\t\t\t\tif (options.expandShapes && item instanceof Shape) {\n\t\t\t\t\titem.remove();\n\t\t\t\t\titem = item.toPath();\n\t\t\t\t}\n\t\t\t\tif (data)\n\t\t\t\t\titem._data = JSON.parse(data);\n\t\t\t}\n\t\t\tif (isRoot) {\n\t\t\t\tdefinitions = {};\n\t\t\t\tif (item && Base.pick(options.applyMatrix, applyMatrix))\n\t\t\t\t\titem.matrix.apply(true, true);\n\t\t\t}\n\t\t\treturn item;\n\t\t}\n\t\n\t\tItem.inject({\n\t\t\timportSVG: function(node, options) {\n\t\t\t\treturn this.addChild(importSVG(node, options, true));\n\t\t\t}\n\t\t});\n\t\n\t\tProject.inject({\n\t\t\timportSVG: function(node, options) {\n\t\t\t\tthis.activate();\n\t\t\t\treturn importSVG(node, options, true);\n\t\t\t}\n\t\t});\n\t};\n\t\n\tBase.exports.PaperScript = (function() {\n\t\tvar exports, define,\n\t\t\tscope = this;\n\t!function(e,r){return\"object\"==typeof exports&&\"object\"==typeof module?r(exports):\"function\"==typeof define&&define.amd?define([\"exports\"],r):(r(e.acorn||(e.acorn={})),void 0)}(this,function(e){\"use strict\";function r(e){fr=e||{};for(var r in mr)Object.prototype.hasOwnProperty.call(fr,r)||(fr[r]=mr[r]);hr=fr.sourceFile||null}function t(e,r){var t=vr(dr,e);r+=\" (\"+t.line+\":\"+t.column+\")\";var n=new SyntaxError(r);throw n.pos=e,n.loc=t,n.raisedAt=br,n}function n(e){function r(e){if(1==e.length)return t+=\"return str === \"+JSON.stringify(e[0])+\";\";t+=\"switch(str){\";for(var r=0;r<e.length;++r)t+=\"case \"+JSON.stringify(e[r])+\":\";t+=\"return true}return false;\"}e=e.split(\" \");var t=\"\",n=[];e:for(var a=0;a<e.length;++a){for(var o=0;o<n.length;++o)if(n[o][0].length==e[a].length){n[o].push(e[a]);continue e}n.push([e[a]])}if(n.length>3){n.sort(function(e,r){return r.length-e.length}),t+=\"switch(str.length){\";for(var a=0;a<n.length;++a){var i=n[a];t+=\"case \"+i[0].length+\":\",r(i)}t+=\"}\"}else r(e);return new Function(\"str\",t)}function a(){this.line=Ar,this.column=br-Sr}function o(){Ar=1,br=Sr=0,Er=!0,u()}function i(e,r){gr=br,fr.locations&&(kr=new a),wr=e,u(),Cr=r,Er=e.beforeExpr}function s(){var e=fr.onComment&&fr.locations&&new a,r=br,n=dr.indexOf(\"*/\",br+=2);if(-1===n&&t(br-2,\"Unterminated comment\"),br=n+2,fr.locations){Kt.lastIndex=r;for(var o;(o=Kt.exec(dr))&&o.index<br;)++Ar,Sr=o.index+o[0].length}fr.onComment&&fr.onComment(!0,dr.slice(r+2,n),r,br,e,fr.locations&&new a)}function c(){for(var e=br,r=fr.onComment&&fr.locations&&new a,t=dr.charCodeAt(br+=2);pr>br&&10!==t&&13!==t&&8232!==t&&8233!==t;)++br,t=dr.charCodeAt(br);fr.onComment&&fr.onComment(!1,dr.slice(e+2,br),e,br,r,fr.locations&&new a)}function u(){for(;pr>br;){var e=dr.charCodeAt(br);if(32===e)++br;else if(13===e){++br;var r=dr.charCodeAt(br);10===r&&++br,fr.locations&&(++Ar,Sr=br)}else if(10===e||8232===e||8233===e)++br,fr.locations&&(++Ar,Sr=br);else if(e>8&&14>e)++br;else if(47===e){var r=dr.charCodeAt(br+1);if(42===r)s();else{if(47!==r)break;c()}}else if(160===e)++br;else{if(!(e>=5760&&Jt.test(String.fromCharCode(e))))break;++br}}}function l(){var e=dr.charCodeAt(br+1);return e>=48&&57>=e?E(!0):(++br,i(xt))}function f(){var e=dr.charCodeAt(br+1);return Er?(++br,k()):61===e?x(Et,2):x(wt,1)}function d(){var e=dr.charCodeAt(br+1);return 61===e?x(Et,2):x(Dt,1)}function p(e){var r=dr.charCodeAt(br+1);return r===e?x(124===e?Lt:Ut,2):61===r?x(Et,2):x(124===e?Rt:Tt,1)}function h(){var e=dr.charCodeAt(br+1);return 61===e?x(Et,2):x(Vt,1)}function m(e){var r=dr.charCodeAt(br+1);return r===e?45==r&&62==dr.charCodeAt(br+2)&&Gt.test(dr.slice(Lr,br))?(br+=3,c(),u(),g()):x(St,2):61===r?x(Et,2):x(At,1)}function v(e){var r=dr.charCodeAt(br+1),t=1;return r===e?(t=62===e&&62===dr.charCodeAt(br+2)?3:2,61===dr.charCodeAt(br+t)?x(Et,t+1):x(jt,t)):33==r&&60==e&&45==dr.charCodeAt(br+2)&&45==dr.charCodeAt(br+3)?(br+=4,c(),u(),g()):(61===r&&(t=61===dr.charCodeAt(br+2)?3:2),x(Ot,t))}function b(e){var r=dr.charCodeAt(br+1);return 61===r?x(qt,61===dr.charCodeAt(br+2)?3:2):x(61===e?Ct:It,1)}function y(e){switch(e){case 46:return l();case 40:return++br,i(mt);case 41:return++br,i(vt);case 59:return++br,i(yt);case 44:return++br,i(bt);case 91:return++br,i(ft);case 93:return++br,i(dt);case 123:return++br,i(pt);case 125:return++br,i(ht);case 58:return++br,i(gt);case 63:return++br,i(kt);case 48:var r=dr.charCodeAt(br+1);if(120===r||88===r)return C();case 49:case 50:case 51:case 52:case 53:case 54:case 55:case 56:case 57:return E(!1);case 34:case 39:return A(e);case 47:return f(e);case 37:case 42:return d();case 124:case 38:return p(e);case 94:return h();case 43:case 45:return m(e);case 60:case 62:return v(e);case 61:case 33:return b(e);case 126:return x(It,1)}return!1}function g(e){if(e?br=yr+1:yr=br,fr.locations&&(xr=new a),e)return k();if(br>=pr)return i(Br);var r=dr.charCodeAt(br);if(Qt(r)||92===r)return L();var n=y(r);if(n===!1){var o=String.fromCharCode(r);if(\"\\\\\"===o||$t.test(o))return L();t(br,\"Unexpected character '\"+o+\"'\")}return n}function x(e,r){var t=dr.slice(br,br+r);br+=r,i(e,t)}function k(){for(var e,r,n=\"\",a=br;;){br>=pr&&t(a,\"Unterminated regular expression\");var o=dr.charAt(br);if(Gt.test(o)&&t(a,\"Unterminated regular expression\"),e)e=!1;else{if(\"[\"===o)r=!0;else if(\"]\"===o&&r)r=!1;else if(\"/\"===o&&!r)break;e=\"\\\\\"===o}++br}var n=dr.slice(a,br);++br;var s=I();return s&&!/^[gmsiy]*$/.test(s)&&t(a,\"Invalid regexp flag\"),i(jr,new RegExp(n,s))}function w(e,r){for(var t=br,n=0,a=0,o=null==r?1/0:r;o>a;++a){var i,s=dr.charCodeAt(br);if(i=s>=97?s-97+10:s>=65?s-65+10:s>=48&&57>=s?s-48:1/0,i>=e)break;++br,n=n*e+i}return br===t||null!=r&&br-t!==r?null:n}function C(){br+=2;var e=w(16);return null==e&&t(yr+2,\"Expected hexadecimal number\"),Qt(dr.charCodeAt(br))&&t(br,\"Identifier directly after number\"),i(Or,e)}function E(e){var r=br,n=!1,a=48===dr.charCodeAt(br);e||null!==w(10)||t(r,\"Invalid number\"),46===dr.charCodeAt(br)&&(++br,w(10),n=!0);var o=dr.charCodeAt(br);(69===o||101===o)&&(o=dr.charCodeAt(++br),(43===o||45===o)&&++br,null===w(10)&&t(r,\"Invalid number\"),n=!0),Qt(dr.charCodeAt(br))&&t(br,\"Identifier directly after number\");var s,c=dr.slice(r,br);return n?s=parseFloat(c):a&&1!==c.length?/[89]/.test(c)||Tr?t(r,\"Invalid number\"):s=parseInt(c,8):s=parseInt(c,10),i(Or,s)}function A(e){br++;for(var r=\"\";;){br>=pr&&t(yr,\"Unterminated string constant\");var n=dr.charCodeAt(br);if(n===e)return++br,i(Dr,r);if(92===n){n=dr.charCodeAt(++br);var a=/^[0-7]+/.exec(dr.slice(br,br+3));for(a&&(a=a[0]);a&&parseInt(a,8)>255;)a=a.slice(0,a.length-1);if(\"0\"===a&&(a=null),++br,a)Tr&&t(br-2,\"Octal literal in strict mode\"),r+=String.fromCharCode(parseInt(a,8)),br+=a.length-1;else switch(n){case 110:r+=\"\\n\";break;case 114:r+=\"\\r\";break;case 120:r+=String.fromCharCode(S(2));break;case 117:r+=String.fromCharCode(S(4));break;case 85:r+=String.fromCharCode(S(8));break;case 116:r+=\"\t\";break;case 98:r+=\"\\b\";break;case 118:r+=\"\u000b\";break;case 102:r+=\"\\f\";break;case 48:r+=\"\\0\";break;case 13:10===dr.charCodeAt(br)&&++br;case 10:fr.locations&&(Sr=br,++Ar);break;default:r+=String.fromCharCode(n)}}else(13===n||10===n||8232===n||8233===n)&&t(yr,\"Unterminated string constant\"),r+=String.fromCharCode(n),++br}}function S(e){var r=w(16,e);return null===r&&t(yr,\"Bad character escape sequence\"),r}function I(){Bt=!1;for(var e,r=!0,n=br;;){var a=dr.charCodeAt(br);if(Yt(a))Bt&&(e+=dr.charAt(br)),++br;else{if(92!==a)break;Bt||(e=dr.slice(n,br)),Bt=!0,117!=dr.charCodeAt(++br)&&t(br,\"Expecting Unicode escape sequence \\\\uXXXX\"),++br;var o=S(4),i=String.fromCharCode(o);i||t(br-1,\"Invalid Unicode escape\"),(r?Qt(o):Yt(o))||t(br-4,\"Invalid Unicode escape\"),e+=i}r=!1}return Bt?e:dr.slice(n,br)}function L(){var e=I(),r=Fr;return Bt||(Wt(e)?r=lt[e]:(fr.forbidReserved&&(3===fr.ecmaVersion?Mt:zt)(e)||Tr&&Xt(e))&&t(yr,\"The keyword '\"+e+\"' is reserved\")),i(r,e)}function U(){Ir=yr,Lr=gr,Ur=kr,g()}function R(e){if(Tr=e,br=Lr,fr.locations)for(;Sr>br;)Sr=dr.lastIndexOf(\"\\n\",Sr-2)+1,--Ar;u(),g()}function V(){this.type=null,this.start=yr,this.end=null}function T(){this.start=xr,this.end=null,null!==hr&&(this.source=hr)}function q(){var e=new V;return fr.locations&&(e.loc=new T),fr.ranges&&(e.range=[yr,0]),e}function O(e){var r=new V;return r.start=e.start,fr.locations&&(r.loc=new T,r.loc.start=e.loc.start),fr.ranges&&(r.range=[e.range[0],0]),r}function j(e,r){return e.type=r,e.end=Lr,fr.locations&&(e.loc.end=Ur),fr.ranges&&(e.range[1]=Lr),e}function D(e){return fr.ecmaVersion>=5&&\"ExpressionStatement\"===e.type&&\"Literal\"===e.expression.type&&\"use strict\"===e.expression.value}function F(e){return wr===e?(U(),!0):void 0}function B(){return!fr.strictSemicolons&&(wr===Br||wr===ht||Gt.test(dr.slice(Lr,yr)))}function M(){F(yt)||B()||X()}function z(e){wr===e?U():X()}function X(){t(yr,\"Unexpected token\")}function N(e){\"Identifier\"!==e.type&&\"MemberExpression\"!==e.type&&t(e.start,\"Assigning to rvalue\"),Tr&&\"Identifier\"===e.type&&Nt(e.name)&&t(e.start,\"Assigning to \"+e.name+\" in strict mode\")}function W(e){Ir=Lr=br,fr.locations&&(Ur=new a),Rr=Tr=null,Vr=[],g();var r=e||q(),t=!0;for(e||(r.body=[]);wr!==Br;){var n=J();r.body.push(n),t&&D(n)&&R(!0),t=!1}return j(r,\"Program\")}function J(){(wr===wt||wr===Et&&\"/=\"==Cr)&&g(!0);var e=wr,r=q();switch(e){case Mr:case Nr:U();var n=e===Mr;F(yt)||B()?r.label=null:wr!==Fr?X():(r.label=lr(),M());for(var a=0;a<Vr.length;++a){var o=Vr[a];if(null==r.label||o.name===r.label.name){if(null!=o.kind&&(n||\"loop\"===o.kind))break;if(r.label&&n)break}}return a===Vr.length&&t(r.start,\"Unsyntactic \"+e.keyword),j(r,n?\"BreakStatement\":\"ContinueStatement\");case Wr:return U(),M(),j(r,\"DebuggerStatement\");case Pr:return U(),Vr.push(Zt),r.body=J(),Vr.pop(),z(tt),r.test=P(),M(),j(r,\"DoWhileStatement\");case _r:if(U(),Vr.push(Zt),z(mt),wr===yt)return $(r,null);if(wr===rt){var i=q();return U(),G(i,!0),j(i,\"VariableDeclaration\"),1===i.declarations.length&&F(ut)?_(r,i):$(r,i)}var i=K(!1,!0);return F(ut)?(N(i),_(r,i)):$(r,i);case Gr:return U(),cr(r,!0);case Kr:return U(),r.test=P(),r.consequent=J(),r.alternate=F(Hr)?J():null,j(r,\"IfStatement\");case Qr:return Rr||t(yr,\"'return' outside of function\"),U(),F(yt)||B()?r.argument=null:(r.argument=K(),M()),j(r,\"ReturnStatement\");case Yr:U(),r.discriminant=P(),r.cases=[],z(pt),Vr.push(en);for(var s,c;wr!=ht;)if(wr===zr||wr===Jr){var u=wr===zr;s&&j(s,\"SwitchCase\"),r.cases.push(s=q()),s.consequent=[],U(),u?s.test=K():(c&&t(Ir,\"Multiple default clauses\"),c=!0,s.test=null),z(gt)}else s||X(),s.consequent.push(J());return s&&j(s,\"SwitchCase\"),U(),Vr.pop(),j(r,\"SwitchStatement\");case Zr:return U(),Gt.test(dr.slice(Lr,yr))&&t(Lr,\"Illegal newline after throw\"),r.argument=K(),M(),j(r,\"ThrowStatement\");case et:if(U(),r.block=H(),r.handler=null,wr===Xr){var l=q();U(),z(mt),l.param=lr(),Tr&&Nt(l.param.name)&&t(l.param.start,\"Binding \"+l.param.name+\" in strict mode\"),z(vt),l.guard=null,l.body=H(),r.handler=j(l,\"CatchClause\")}return r.guardedHandlers=qr,r.finalizer=F($r)?H():null,r.handler||r.finalizer||t(r.start,\"Missing catch or finally clause\"),j(r,\"TryStatement\");case rt:return U(),G(r),M(),j(r,\"VariableDeclaration\");case tt:return U(),r.test=P(),Vr.push(Zt),r.body=J(),Vr.pop(),j(r,\"WhileStatement\");case nt:return Tr&&t(yr,\"'with' in strict mode\"),U(),r.object=P(),r.body=J(),j(r,\"WithStatement\");case pt:return H();case yt:return U(),j(r,\"EmptyStatement\");default:var f=Cr,d=K();if(e===Fr&&\"Identifier\"===d.type&&F(gt)){for(var a=0;a<Vr.length;++a)Vr[a].name===f&&t(d.start,\"Label '\"+f+\"' is already declared\");var p=wr.isLoop?\"loop\":wr===Yr?\"switch\":null;return Vr.push({name:f,kind:p}),r.body=J(),Vr.pop(),r.label=d,j(r,\"LabeledStatement\")}return r.expression=d,M(),j(r,\"ExpressionStatement\")}}function P(){z(mt);var e=K();return z(vt),e}function H(e){var r,t=q(),n=!0,a=!1;for(t.body=[],z(pt);!F(ht);){var o=J();t.body.push(o),n&&e&&D(o)&&(r=a,R(a=!0)),n=!1}return a&&!r&&R(!1),j(t,\"BlockStatement\")}function $(e,r){return e.init=r,z(yt),e.test=wr===yt?null:K(),z(yt),e.update=wr===vt?null:K(),z(vt),e.body=J(),Vr.pop(),j(e,\"ForStatement\")}function _(e,r){return e.left=r,e.right=K(),z(vt),e.body=J(),Vr.pop(),j(e,\"ForInStatement\")}function G(e,r){for(e.declarations=[],e.kind=\"var\";;){var n=q();if(n.id=lr(),Tr&&Nt(n.id.name)&&t(n.id.start,\"Binding \"+n.id.name+\" in strict mode\"),n.init=F(Ct)?K(!0,r):null,e.declarations.push(j(n,\"VariableDeclarator\")),!F(bt))break}return e}function K(e,r){var t=Q(r);if(!e&&wr===bt){var n=O(t);for(n.expressions=[t];F(bt);)n.expressions.push(Q(r));return j(n,\"SequenceExpression\")}return t}function Q(e){var r=Y(e);if(wr.isAssign){var t=O(r);return t.operator=Cr,t.left=r,U(),t.right=Q(e),N(r),j(t,\"AssignmentExpression\")}return r}function Y(e){var r=Z(e);if(F(kt)){var t=O(r);return t.test=r,t.consequent=K(!0),z(gt),t.alternate=K(!0,e),j(t,\"ConditionalExpression\")}return r}function Z(e){return er(rr(),-1,e)}function er(e,r,t){var n=wr.binop;if(null!=n&&(!t||wr!==ut)&&n>r){var a=O(e);a.left=e,a.operator=Cr,U(),a.right=er(rr(),n,t);var o=j(a,/&&|\\|\\|/.test(a.operator)?\"LogicalExpression\":\"BinaryExpression\");return er(o,r,t)}return e}function rr(){if(wr.prefix){var e=q(),r=wr.isUpdate;return e.operator=Cr,e.prefix=!0,Er=!0,U(),e.argument=rr(),r?N(e.argument):Tr&&\"delete\"===e.operator&&\"Identifier\"===e.argument.type&&t(e.start,\"Deleting local variable in strict mode\"),j(e,r?\"UpdateExpression\":\"UnaryExpression\")}for(var n=tr();wr.postfix&&!B();){var e=O(n);e.operator=Cr,e.prefix=!1,e.argument=n,N(n),U(),n=j(e,\"UpdateExpression\")}return n}function tr(){return nr(ar())}function nr(e,r){if(F(xt)){var t=O(e);return t.object=e,t.property=lr(!0),t.computed=!1,nr(j(t,\"MemberExpression\"),r)}if(F(ft)){var t=O(e);return t.object=e,t.property=K(),t.computed=!0,z(dt),nr(j(t,\"MemberExpression\"),r)}if(!r&&F(mt)){var t=O(e);return t.callee=e,t.arguments=ur(vt,!1),nr(j(t,\"CallExpression\"),r)}return e}function ar(){switch(wr){case ot:var e=q();return U(),j(e,\"ThisExpression\");case Fr:return lr();case Or:case Dr:case jr:var e=q();return e.value=Cr,e.raw=dr.slice(yr,gr),U(),j(e,\"Literal\");case it:case st:case ct:var e=q();return e.value=wr.atomValue,e.raw=wr.keyword,U(),j(e,\"Literal\");case mt:var r=xr,t=yr;U();var n=K();return n.start=t,n.end=gr,fr.locations&&(n.loc.start=r,n.loc.end=kr),fr.ranges&&(n.range=[t,gr]),z(vt),n;case ft:var e=q();return U(),e.elements=ur(dt,!0,!0),j(e,\"ArrayExpression\");case pt:return ir();case Gr:var e=q();return U(),cr(e,!1);case at:return or();default:X()}}function or(){var e=q();return U(),e.callee=nr(ar(),!0),e.arguments=F(mt)?ur(vt,!1):qr,j(e,\"NewExpression\")}function ir(){var e=q(),r=!0,n=!1;for(e.properties=[],U();!F(ht);){if(r)r=!1;else if(z(bt),fr.allowTrailingCommas&&F(ht))break;var a,o={key:sr()},i=!1;if(F(gt)?(o.value=K(!0),a=o.kind=\"init\"):fr.ecmaVersion>=5&&\"Identifier\"===o.key.type&&(\"get\"===o.key.name||\"set\"===o.key.name)?(i=n=!0,a=o.kind=o.key.name,o.key=sr(),wr!==mt&&X(),o.value=cr(q(),!1)):X(),\"Identifier\"===o.key.type&&(Tr||n))for(var s=0;s<e.properties.length;++s){var c=e.properties[s];if(c.key.name===o.key.name){var u=a==c.kind||i&&\"init\"===c.kind||\"init\"===a&&(\"get\"===c.kind||\"set\"===c.kind);u&&!Tr&&\"init\"===a&&\"init\"===c.kind&&(u=!1),u&&t(o.key.start,\"Redefinition of property\")}}e.properties.push(o)}return j(e,\"ObjectExpression\")}function sr(){return wr===Or||wr===Dr?ar():lr(!0)}function cr(e,r){wr===Fr?e.id=lr():r?X():e.id=null,e.params=[];var n=!0;for(z(mt);!F(vt);)n?n=!1:z(bt),e.params.push(lr());var a=Rr,o=Vr;if(Rr=!0,Vr=[],e.body=H(!0),Rr=a,Vr=o,Tr||e.body.body.length&&D(e.body.body[0]))for(var i=e.id?-1:0;i<e.params.length;++i){var s=0>i?e.id:e.params[i];if((Xt(s.name)||Nt(s.name))&&t(s.start,\"Defining '\"+s.name+\"' in strict mode\"),i>=0)for(var c=0;i>c;++c)s.name===e.params[c].name&&t(s.start,\"Argument name clash in strict mode\")}return j(e,r?\"FunctionDeclaration\":\"FunctionExpression\")}function ur(e,r,t){for(var n=[],a=!0;!F(e);){if(a)a=!1;else if(z(bt),r&&fr.allowTrailingCommas&&F(e))break;t&&wr===bt?n.push(null):n.push(K(!0))}return n}function lr(e){var r=q();return r.name=wr===Fr?Cr:e&&!fr.forbidReserved&&wr.keyword||X(),Er=!1,U(),j(r,\"Identifier\")}e.version=\"0.4.0\";var fr,dr,pr,hr;e.parse=function(e,t){return dr=String(e),pr=dr.length,r(t),o(),W(fr.program)};var mr=e.defaultOptions={ecmaVersion:5,strictSemicolons:!1,allowTrailingCommas:!0,forbidReserved:!1,locations:!1,onComment:null,ranges:!1,program:null,sourceFile:null},vr=e.getLineInfo=function(e,r){for(var t=1,n=0;;){Kt.lastIndex=n;var a=Kt.exec(e);if(!(a&&a.index<r))break;++t,n=a.index+a[0].length}return{line:t,column:r-n}};e.tokenize=function(e,t){function n(e){return g(e),a.start=yr,a.end=gr,a.startLoc=xr,a.endLoc=kr,a.type=wr,a.value=Cr,a}dr=String(e),pr=dr.length,r(t),o();var a={};return n.jumpTo=function(e,r){if(br=e,fr.locations){Ar=1,Sr=Kt.lastIndex=0;for(var t;(t=Kt.exec(dr))&&t.index<e;)++Ar,Sr=t.index+t[0].length}Er=r,u()},n};var br,yr,gr,xr,kr,wr,Cr,Er,Ar,Sr,Ir,Lr,Ur,Rr,Vr,Tr,qr=[],Or={type:\"num\"},jr={type:\"regexp\"},Dr={type:\"string\"},Fr={type:\"name\"},Br={type:\"eof\"},Mr={keyword:\"break\"},zr={keyword:\"case\",beforeExpr:!0},Xr={keyword:\"catch\"},Nr={keyword:\"continue\"},Wr={keyword:\"debugger\"},Jr={keyword:\"default\"},Pr={keyword:\"do\",isLoop:!0},Hr={keyword:\"else\",beforeExpr:!0},$r={keyword:\"finally\"},_r={keyword:\"for\",isLoop:!0},Gr={keyword:\"function\"},Kr={keyword:\"if\"},Qr={keyword:\"return\",beforeExpr:!0},Yr={keyword:\"switch\"},Zr={keyword:\"throw\",beforeExpr:!0},et={keyword:\"try\"},rt={keyword:\"var\"},tt={keyword:\"while\",isLoop:!0},nt={keyword:\"with\"},at={keyword:\"new\",beforeExpr:!0},ot={keyword:\"this\"},it={keyword:\"null\",atomValue:null},st={keyword:\"true\",atomValue:!0},ct={keyword:\"false\",atomValue:!1},ut={keyword:\"in\",binop:7,beforeExpr:!0},lt={\"break\":Mr,\"case\":zr,\"catch\":Xr,\"continue\":Nr,\"debugger\":Wr,\"default\":Jr,\"do\":Pr,\"else\":Hr,\"finally\":$r,\"for\":_r,\"function\":Gr,\"if\":Kr,\"return\":Qr,\"switch\":Yr,\"throw\":Zr,\"try\":et,\"var\":rt,\"while\":tt,\"with\":nt,\"null\":it,\"true\":st,\"false\":ct,\"new\":at,\"in\":ut,\"instanceof\":{keyword:\"instanceof\",binop:7,beforeExpr:!0},\"this\":ot,\"typeof\":{keyword:\"typeof\",prefix:!0,beforeExpr:!0},\"void\":{keyword:\"void\",prefix:!0,beforeExpr:!0},\"delete\":{keyword:\"delete\",prefix:!0,beforeExpr:!0}},ft={type:\"[\",beforeExpr:!0},dt={type:\"]\"},pt={type:\"{\",beforeExpr:!0},ht={type:\"}\"},mt={type:\"(\",beforeExpr:!0},vt={type:\")\"},bt={type:\",\",beforeExpr:!0},yt={type:\";\",beforeExpr:!0},gt={type:\":\",beforeExpr:!0},xt={type:\".\"},kt={type:\"?\",beforeExpr:!0},wt={binop:10,beforeExpr:!0},Ct={isAssign:!0,beforeExpr:!0},Et={isAssign:!0,beforeExpr:!0},At={binop:9,prefix:!0,beforeExpr:!0},St={postfix:!0,prefix:!0,isUpdate:!0},It={prefix:!0,beforeExpr:!0},Lt={binop:1,beforeExpr:!0},Ut={binop:2,beforeExpr:!0},Rt={binop:3,beforeExpr:!0},Vt={binop:4,beforeExpr:!0},Tt={binop:5,beforeExpr:!0},qt={binop:6,beforeExpr:!0},Ot={binop:7,beforeExpr:!0},jt={binop:8,beforeExpr:!0},Dt={binop:10,beforeExpr:!0};e.tokTypes={bracketL:ft,bracketR:dt,braceL:pt,braceR:ht,parenL:mt,parenR:vt,comma:bt,semi:yt,colon:gt,dot:xt,question:kt,slash:wt,eq:Ct,name:Fr,eof:Br,num:Or,regexp:jr,string:Dr};for(var Ft in lt)e.tokTypes[\"_\"+Ft]=lt[Ft];var Bt,Mt=n(\"abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile\"),zt=n(\"class enum extends super const export import\"),Xt=n(\"implements interface let package private protected public static yield\"),Nt=n(\"eval arguments\"),Wt=n(\"break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this\"),Jt=/[\\u1680\\u180e\\u2000-\\u200a\\u202f\\u205f\\u3000\\ufeff]/,Pt=\"\\xaa\\xb5\\xba\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u02c1\\u02c6-\\u02d1\\u02e0-\\u02e4\\u02ec\\u02ee\\u0370-\\u0374\\u0376\\u0377\\u037a-\\u037d\\u0386\\u0388-\\u038a\\u038c\\u038e-\\u03a1\\u03a3-\\u03f5\\u03f7-\\u0481\\u048a-\\u0527\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u05d0-\\u05ea\\u05f0-\\u05f2\\u0620-\\u064a\\u066e\\u066f\\u0671-\\u06d3\\u06d5\\u06e5\\u06e6\\u06ee\\u06ef\\u06fa-\\u06fc\\u06ff\\u0710\\u0712-\\u072f\\u074d-\\u07a5\\u07b1\\u07ca-\\u07ea\\u07f4\\u07f5\\u07fa\\u0800-\\u0815\\u081a\\u0824\\u0828\\u0840-\\u0858\\u08a0\\u08a2-\\u08ac\\u0904-\\u0939\\u093d\\u0950\\u0958-\\u0961\\u0971-\\u0977\\u0979-\\u097f\\u0985-\\u098c\\u098f\\u0990\\u0993-\\u09a8\\u09aa-\\u09b0\\u09b2\\u09b6-\\u09b9\\u09bd\\u09ce\\u09dc\\u09dd\\u09df-\\u09e1\\u09f0\\u09f1\\u0a05-\\u0a0a\\u0a0f\\u0a10\\u0a13-\\u0a28\\u0a2a-\\u0a30\\u0a32\\u0a33\\u0a35\\u0a36\\u0a38\\u0a39\\u0a59-\\u0a5c\\u0a5e\\u0a72-\\u0a74\\u0a85-\\u0a8d\\u0a8f-\\u0a91\\u0a93-\\u0aa8\\u0aaa-\\u0ab0\\u0ab2\\u0ab3\\u0ab5-\\u0ab9\\u0abd\\u0ad0\\u0ae0\\u0ae1\\u0b05-\\u0b0c\\u0b0f\\u0b10\\u0b13-\\u0b28\\u0b2a-\\u0b30\\u0b32\\u0b33\\u0b35-\\u0b39\\u0b3d\\u0b5c\\u0b5d\\u0b5f-\\u0b61\\u0b71\\u0b83\\u0b85-\\u0b8a\\u0b8e-\\u0b90\\u0b92-\\u0b95\\u0b99\\u0b9a\\u0b9c\\u0b9e\\u0b9f\\u0ba3\\u0ba4\\u0ba8-\\u0baa\\u0bae-\\u0bb9\\u0bd0\\u0c05-\\u0c0c\\u0c0e-\\u0c10\\u0c12-\\u0c28\\u0c2a-\\u0c33\\u0c35-\\u0c39\\u0c3d\\u0c58\\u0c59\\u0c60\\u0c61\\u0c85-\\u0c8c\\u0c8e-\\u0c90\\u0c92-\\u0ca8\\u0caa-\\u0cb3\\u0cb5-\\u0cb9\\u0cbd\\u0cde\\u0ce0\\u0ce1\\u0cf1\\u0cf2\\u0d05-\\u0d0c\\u0d0e-\\u0d10\\u0d12-\\u0d3a\\u0d3d\\u0d4e\\u0d60\\u0d61\\u0d7a-\\u0d7f\\u0d85-\\u0d96\\u0d9a-\\u0db1\\u0db3-\\u0dbb\\u0dbd\\u0dc0-\\u0dc6\\u0e01-\\u0e30\\u0e32\\u0e33\\u0e40-\\u0e46\\u0e81\\u0e82\\u0e84\\u0e87\\u0e88\\u0e8a\\u0e8d\\u0e94-\\u0e97\\u0e99-\\u0e9f\\u0ea1-\\u0ea3\\u0ea5\\u0ea7\\u0eaa\\u0eab\\u0ead-\\u0eb0\\u0eb2\\u0eb3\\u0ebd\\u0ec0-\\u0ec4\\u0ec6\\u0edc-\\u0edf\\u0f00\\u0f40-\\u0f47\\u0f49-\\u0f6c\\u0f88-\\u0f8c\\u1000-\\u102a\\u103f\\u1050-\\u1055\\u105a-\\u105d\\u1061\\u1065\\u1066\\u106e-\\u1070\\u1075-\\u1081\\u108e\\u10a0-\\u10c5\\u10c7\\u10cd\\u10d0-\\u10fa\\u10fc-\\u1248\\u124a-\\u124d\\u1250-\\u1256\\u1258\\u125a-\\u125d\\u1260-\\u1288\\u128a-\\u128d\\u1290-\\u12b0\\u12b2-\\u12b5\\u12b8-\\u12be\\u12c0\\u12c2-\\u12c5\\u12c8-\\u12d6\\u12d8-\\u1310\\u1312-\\u1315\\u1318-\\u135a\\u1380-\\u138f\\u13a0-\\u13f4\\u1401-\\u166c\\u166f-\\u167f\\u1681-\\u169a\\u16a0-\\u16ea\\u16ee-\\u16f0\\u1700-\\u170c\\u170e-\\u1711\\u1720-\\u1731\\u1740-\\u1751\\u1760-\\u176c\\u176e-\\u1770\\u1780-\\u17b3\\u17d7\\u17dc\\u1820-\\u1877\\u1880-\\u18a8\\u18aa\\u18b0-\\u18f5\\u1900-\\u191c\\u1950-\\u196d\\u1970-\\u1974\\u1980-\\u19ab\\u19c1-\\u19c7\\u1a00-\\u1a16\\u1a20-\\u1a54\\u1aa7\\u1b05-\\u1b33\\u1b45-\\u1b4b\\u1b83-\\u1ba0\\u1bae\\u1baf\\u1bba-\\u1be5\\u1c00-\\u1c23\\u1c4d-\\u1c4f\\u1c5a-\\u1c7d\\u1ce9-\\u1cec\\u1cee-\\u1cf1\\u1cf5\\u1cf6\\u1d00-\\u1dbf\\u1e00-\\u1f15\\u1f18-\\u1f1d\\u1f20-\\u1f45\\u1f48-\\u1f4d\\u1f50-\\u1f57\\u1f59\\u1f5b\\u1f5d\\u1f5f-\\u1f7d\\u1f80-\\u1fb4\\u1fb6-\\u1fbc\\u1fbe\\u1fc2-\\u1fc4\\u1fc6-\\u1fcc\\u1fd0-\\u1fd3\\u1fd6-\\u1fdb\\u1fe0-\\u1fec\\u1ff2-\\u1ff4\\u1ff6-\\u1ffc\\u2071\\u207f\\u2090-\\u209c\\u2102\\u2107\\u210a-\\u2113\\u2115\\u2119-\\u211d\\u2124\\u2126\\u2128\\u212a-\\u212d\\u212f-\\u2139\\u213c-\\u213f\\u2145-\\u2149\\u214e\\u2160-\\u2188\\u2c00-\\u2c2e\\u2c30-\\u2c5e\\u2c60-\\u2ce4\\u2ceb-\\u2cee\\u2cf2\\u2cf3\\u2d00-\\u2d25\\u2d27\\u2d2d\\u2d30-\\u2d67\\u2d6f\\u2d80-\\u2d96\\u2da0-\\u2da6\\u2da8-\\u2dae\\u2db0-\\u2db6\\u2db8-\\u2dbe\\u2dc0-\\u2dc6\\u2dc8-\\u2dce\\u2dd0-\\u2dd6\\u2dd8-\\u2dde\\u2e2f\\u3005-\\u3007\\u3021-\\u3029\\u3031-\\u3035\\u3038-\\u303c\\u3041-\\u3096\\u309d-\\u309f\\u30a1-\\u30fa\\u30fc-\\u30ff\\u3105-\\u312d\\u3131-\\u318e\\u31a0-\\u31ba\\u31f0-\\u31ff\\u3400-\\u4db5\\u4e00-\\u9fcc\\ua000-\\ua48c\\ua4d0-\\ua4fd\\ua500-\\ua60c\\ua610-\\ua61f\\ua62a\\ua62b\\ua640-\\ua66e\\ua67f-\\ua697\\ua6a0-\\ua6ef\\ua717-\\ua71f\\ua722-\\ua788\\ua78b-\\ua78e\\ua790-\\ua793\\ua7a0-\\ua7aa\\ua7f8-\\ua801\\ua803-\\ua805\\ua807-\\ua80a\\ua80c-\\ua822\\ua840-\\ua873\\ua882-\\ua8b3\\ua8f2-\\ua8f7\\ua8fb\\ua90a-\\ua925\\ua930-\\ua946\\ua960-\\ua97c\\ua984-\\ua9b2\\ua9cf\\uaa00-\\uaa28\\uaa40-\\uaa42\\uaa44-\\uaa4b\\uaa60-\\uaa76\\uaa7a\\uaa80-\\uaaaf\\uaab1\\uaab5\\uaab6\\uaab9-\\uaabd\\uaac0\\uaac2\\uaadb-\\uaadd\\uaae0-\\uaaea\\uaaf2-\\uaaf4\\uab01-\\uab06\\uab09-\\uab0e\\uab11-\\uab16\\uab20-\\uab26\\uab28-\\uab2e\\uabc0-\\uabe2\\uac00-\\ud7a3\\ud7b0-\\ud7c6\\ud7cb-\\ud7fb\\uf900-\\ufa6d\\ufa70-\\ufad9\\ufb00-\\ufb06\\ufb13-\\ufb17\\ufb1d\\ufb1f-\\ufb28\\ufb2a-\\ufb36\\ufb38-\\ufb3c\\ufb3e\\ufb40\\ufb41\\ufb43\\ufb44\\ufb46-\\ufbb1\\ufbd3-\\ufd3d\\ufd50-\\ufd8f\\ufd92-\\ufdc7\\ufdf0-\\ufdfb\\ufe70-\\ufe74\\ufe76-\\ufefc\\uff21-\\uff3a\\uff41-\\uff5a\\uff66-\\uffbe\\uffc2-\\uffc7\\uffca-\\uffcf\\uffd2-\\uffd7\\uffda-\\uffdc\",Ht=\"\\u0300-\\u036f\\u0483-\\u0487\\u0591-\\u05bd\\u05bf\\u05c1\\u05c2\\u05c4\\u05c5\\u05c7\\u0610-\\u061a\\u0620-\\u0649\\u0672-\\u06d3\\u06e7-\\u06e8\\u06fb-\\u06fc\\u0730-\\u074a\\u0800-\\u0814\\u081b-\\u0823\\u0825-\\u0827\\u0829-\\u082d\\u0840-\\u0857\\u08e4-\\u08fe\\u0900-\\u0903\\u093a-\\u093c\\u093e-\\u094f\\u0951-\\u0957\\u0962-\\u0963\\u0966-\\u096f\\u0981-\\u0983\\u09bc\\u09be-\\u09c4\\u09c7\\u09c8\\u09d7\\u09df-\\u09e0\\u0a01-\\u0a03\\u0a3c\\u0a3e-\\u0a42\\u0a47\\u0a48\\u0a4b-\\u0a4d\\u0a51\\u0a66-\\u0a71\\u0a75\\u0a81-\\u0a83\\u0abc\\u0abe-\\u0ac5\\u0ac7-\\u0ac9\\u0acb-\\u0acd\\u0ae2-\\u0ae3\\u0ae6-\\u0aef\\u0b01-\\u0b03\\u0b3c\\u0b3e-\\u0b44\\u0b47\\u0b48\\u0b4b-\\u0b4d\\u0b56\\u0b57\\u0b5f-\\u0b60\\u0b66-\\u0b6f\\u0b82\\u0bbe-\\u0bc2\\u0bc6-\\u0bc8\\u0bca-\\u0bcd\\u0bd7\\u0be6-\\u0bef\\u0c01-\\u0c03\\u0c46-\\u0c48\\u0c4a-\\u0c4d\\u0c55\\u0c56\\u0c62-\\u0c63\\u0c66-\\u0c6f\\u0c82\\u0c83\\u0cbc\\u0cbe-\\u0cc4\\u0cc6-\\u0cc8\\u0cca-\\u0ccd\\u0cd5\\u0cd6\\u0ce2-\\u0ce3\\u0ce6-\\u0cef\\u0d02\\u0d03\\u0d46-\\u0d48\\u0d57\\u0d62-\\u0d63\\u0d66-\\u0d6f\\u0d82\\u0d83\\u0dca\\u0dcf-\\u0dd4\\u0dd6\\u0dd8-\\u0ddf\\u0df2\\u0df3\\u0e34-\\u0e3a\\u0e40-\\u0e45\\u0e50-\\u0e59\\u0eb4-\\u0eb9\\u0ec8-\\u0ecd\\u0ed0-\\u0ed9\\u0f18\\u0f19\\u0f20-\\u0f29\\u0f35\\u0f37\\u0f39\\u0f41-\\u0f47\\u0f71-\\u0f84\\u0f86-\\u0f87\\u0f8d-\\u0f97\\u0f99-\\u0fbc\\u0fc6\\u1000-\\u1029\\u1040-\\u1049\\u1067-\\u106d\\u1071-\\u1074\\u1082-\\u108d\\u108f-\\u109d\\u135d-\\u135f\\u170e-\\u1710\\u1720-\\u1730\\u1740-\\u1750\\u1772\\u1773\\u1780-\\u17b2\\u17dd\\u17e0-\\u17e9\\u180b-\\u180d\\u1810-\\u1819\\u1920-\\u192b\\u1930-\\u193b\\u1951-\\u196d\\u19b0-\\u19c0\\u19c8-\\u19c9\\u19d0-\\u19d9\\u1a00-\\u1a15\\u1a20-\\u1a53\\u1a60-\\u1a7c\\u1a7f-\\u1a89\\u1a90-\\u1a99\\u1b46-\\u1b4b\\u1b50-\\u1b59\\u1b6b-\\u1b73\\u1bb0-\\u1bb9\\u1be6-\\u1bf3\\u1c00-\\u1c22\\u1c40-\\u1c49\\u1c5b-\\u1c7d\\u1cd0-\\u1cd2\\u1d00-\\u1dbe\\u1e01-\\u1f15\\u200c\\u200d\\u203f\\u2040\\u2054\\u20d0-\\u20dc\\u20e1\\u20e5-\\u20f0\\u2d81-\\u2d96\\u2de0-\\u2dff\\u3021-\\u3028\\u3099\\u309a\\ua640-\\ua66d\\ua674-\\ua67d\\ua69f\\ua6f0-\\ua6f1\\ua7f8-\\ua800\\ua806\\ua80b\\ua823-\\ua827\\ua880-\\ua881\\ua8b4-\\ua8c4\\ua8d0-\\ua8d9\\ua8f3-\\ua8f7\\ua900-\\ua909\\ua926-\\ua92d\\ua930-\\ua945\\ua980-\\ua983\\ua9b3-\\ua9c0\\uaa00-\\uaa27\\uaa40-\\uaa41\\uaa4c-\\uaa4d\\uaa50-\\uaa59\\uaa7b\\uaae0-\\uaae9\\uaaf2-\\uaaf3\\uabc0-\\uabe1\\uabec\\uabed\\uabf0-\\uabf9\\ufb20-\\ufb28\\ufe00-\\ufe0f\\ufe20-\\ufe26\\ufe33\\ufe34\\ufe4d-\\ufe4f\\uff10-\\uff19\\uff3f\",$t=new RegExp(\"[\"+Pt+\"]\"),_t=new RegExp(\"[\"+Pt+Ht+\"]\"),Gt=/[\\n\\r\\u2028\\u2029]/,Kt=/\\r\\n|[\\n\\r\\u2028\\u2029]/g,Qt=e.isIdentifierStart=function(e){return 65>e?36===e:91>e?!0:97>e?95===e:123>e?!0:e>=170&&$t.test(String.fromCharCode(e))},Yt=e.isIdentifierChar=function(e){return 48>e?36===e:58>e?!0:65>e?!1:91>e?!0:97>e?95===e:123>e?!0:e>=170&&_t.test(String.fromCharCode(e))},Zt={kind:\"loop\"},en={kind:\"switch\"}});\n\t\n\t\tvar binaryOperators = {\n\t\t\t'+': '__add',\n\t\t\t'-': '__subtract',\n\t\t\t'*': '__multiply',\n\t\t\t'/': '__divide',\n\t\t\t'%': '__modulo',\n\t\t\t'==': 'equals',\n\t\t\t'!=': 'equals'\n\t\t};\n\t\n\t\tvar unaryOperators = {\n\t\t\t'-': '__negate',\n\t\t\t'+': null\n\t\t};\n\t\n\t\tvar fields = Base.each(\n\t\t\t['add', 'subtract', 'multiply', 'divide', 'modulo', 'negate'],\n\t\t\tfunction(name) {\n\t\t\t\tthis['__' + name] = '#' + name;\n\t\t\t},\n\t\t\t{}\n\t\t);\n\t\tPoint.inject(fields);\n\t\tSize.inject(fields);\n\t\tColor.inject(fields);\n\t\n\t\tfunction __$__(left, operator, right) {\n\t\t\tvar handler = binaryOperators[operator];\n\t\t\tif (left && left[handler]) {\n\t\t\t\tvar res = left[handler](right);\n\t\t\t\treturn operator === '!=' ? !res : res;\n\t\t\t}\n\t\t\tswitch (operator) {\n\t\t\tcase '+': return left + right;\n\t\t\tcase '-': return left - right;\n\t\t\tcase '*': return left * right;\n\t\t\tcase '/': return left / right;\n\t\t\tcase '%': return left % right;\n\t\t\tcase '==': return left == right;\n\t\t\tcase '!=': return left != right;\n\t\t\t}\n\t\t}\n\t\n\t\tfunction $__(operator, value) {\n\t\t\tvar handler = unaryOperators[operator];\n\t\t\tif (handler && value && value[handler])\n\t\t\t\treturn value[handler]();\n\t\t\tswitch (operator) {\n\t\t\tcase '+': return +value;\n\t\t\tcase '-': return -value;\n\t\t\t}\n\t\t}\n\t\n\t\tfunction parse(code, options) {\n\t\t\treturn scope.acorn.parse(code, options);\n\t\t}\n\t\n\t\tfunction compile(code, url, options) {\n\t\t\tif (!code)\n\t\t\t\treturn '';\n\t\t\toptions = options || {};\n\t\t\turl = url || '';\n\t\n\t\t\tvar insertions = [];\n\t\n\t\t\tfunction getOffset(offset) {\n\t\t\t\tfor (var i = 0, l = insertions.length; i < l; i++) {\n\t\t\t\t\tvar insertion = insertions[i];\n\t\t\t\t\tif (insertion[0] >= offset)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\toffset += insertion[1];\n\t\t\t\t}\n\t\t\t\treturn offset;\n\t\t\t}\n\t\n\t\t\tfunction getCode(node) {\n\t\t\t\treturn code.substring(getOffset(node.range[0]),\n\t\t\t\t\t\tgetOffset(node.range[1]));\n\t\t\t}\n\t\n\t\t\tfunction getBetween(left, right) {\n\t\t\t\treturn code.substring(getOffset(left.range[1]),\n\t\t\t\t\t\tgetOffset(right.range[0]));\n\t\t\t}\n\t\n\t\t\tfunction replaceCode(node, str) {\n\t\t\t\tvar start = getOffset(node.range[0]),\n\t\t\t\t\tend = getOffset(node.range[1]),\n\t\t\t\t\tinsert = 0;\n\t\t\t\tfor (var i = insertions.length - 1; i >= 0; i--) {\n\t\t\t\t\tif (start > insertions[i][0]) {\n\t\t\t\t\t\tinsert = i + 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tinsertions.splice(insert, 0, [start, str.length - end + start]);\n\t\t\t\tcode = code.substring(0, start) + str + code.substring(end);\n\t\t\t}\n\t\n\t\t\tfunction walkAST(node, parent) {\n\t\t\t\tif (!node)\n\t\t\t\t\treturn;\n\t\t\t\tfor (var key in node) {\n\t\t\t\t\tif (key === 'range' || key === 'loc')\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tvar value = node[key];\n\t\t\t\t\tif (Array.isArray(value)) {\n\t\t\t\t\t\tfor (var i = 0, l = value.length; i < l; i++)\n\t\t\t\t\t\t\twalkAST(value[i], node);\n\t\t\t\t\t} else if (value && typeof value === 'object') {\n\t\t\t\t\t\twalkAST(value, node);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tswitch (node.type) {\n\t\t\t\tcase 'UnaryExpression':\n\t\t\t\t\tif (node.operator in unaryOperators\n\t\t\t\t\t\t\t&& node.argument.type !== 'Literal') {\n\t\t\t\t\t\tvar arg = getCode(node.argument);\n\t\t\t\t\t\treplaceCode(node, '$__(\"' + node.operator + '\", '\n\t\t\t\t\t\t\t\t+ arg + ')');\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'BinaryExpression':\n\t\t\t\t\tif (node.operator in binaryOperators\n\t\t\t\t\t\t\t&& node.left.type !== 'Literal') {\n\t\t\t\t\t\tvar left = getCode(node.left),\n\t\t\t\t\t\t\tright = getCode(node.right),\n\t\t\t\t\t\t\tbetween = getBetween(node.left, node.right),\n\t\t\t\t\t\t\toperator = node.operator;\n\t\t\t\t\t\treplaceCode(node, '__$__(' + left + ','\n\t\t\t\t\t\t\t\t+ between.replace(new RegExp('\\\\' + operator),\n\t\t\t\t\t\t\t\t\t'\"' + operator + '\"')\n\t\t\t\t\t\t\t\t+ ', ' + right + ')');\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'UpdateExpression':\n\t\t\t\tcase 'AssignmentExpression':\n\t\t\t\t\tvar parentType = parent && parent.type;\n\t\t\t\t\tif (!(\n\t\t\t\t\t\t\tparentType === 'ForStatement'\n\t\t\t\t\t\t\t|| parentType === 'BinaryExpression'\n\t\t\t\t\t\t\t\t&& /^[=!<>]/.test(parent.operator)\n\t\t\t\t\t\t\t|| parentType === 'MemberExpression' && parent.computed\n\t\t\t\t\t)) {\n\t\t\t\t\t\tif (node.type === 'UpdateExpression') {\n\t\t\t\t\t\t\tvar arg = getCode(node.argument),\n\t\t\t\t\t\t\t\texp = '__$__(' + arg + ', \"' + node.operator[0]\n\t\t\t\t\t\t\t\t\t\t+ '\", 1)',\n\t\t\t\t\t\t\t\tstr = arg + ' = ' + exp;\n\t\t\t\t\t\t\tif (!node.prefix\n\t\t\t\t\t\t\t\t\t&& (parentType === 'AssignmentExpression'\n\t\t\t\t\t\t\t\t\t\t|| parentType === 'VariableDeclarator')) {\n\t\t\t\t\t\t\t\tif (getCode(parent.left || parent.id) === arg)\n\t\t\t\t\t\t\t\t\tstr = exp;\n\t\t\t\t\t\t\t\tstr = arg + '; ' + str;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treplaceCode(node, str);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif (/^.=$/.test(node.operator)\n\t\t\t\t\t\t\t\t\t&& node.left.type !== 'Literal') {\n\t\t\t\t\t\t\t\tvar left = getCode(node.left),\n\t\t\t\t\t\t\t\t\tright = getCode(node.right);\n\t\t\t\t\t\t\t\treplaceCode(node, left + ' = __$__(' + left + ', \"'\n\t\t\t\t\t\t\t\t\t\t+ node.operator[0] + '\", ' + right + ')');\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tvar sourceMap = null,\n\t\t\t\tbrowser = paper.browser,\n\t\t\t\tversion = browser.versionNumber,\n\t\t\t\tlineBreaks = /\\r\\n|\\n|\\r/mg;\n\t\t\tif (browser.chrome && version >= 30\n\t\t\t\t\t|| browser.webkit && version >= 537.76\n\t\t\t\t\t|| browser.firefox && version >= 23) {\n\t\t\t\tvar offset = 0;\n\t\t\t\tif (window.location.href.indexOf(url) === 0) {\n\t\t\t\t\tvar html = document.getElementsByTagName('html')[0].innerHTML;\n\t\t\t\t\toffset = html.substr(0, html.indexOf(code) + 1).match(\n\t\t\t\t\t\t\tlineBreaks).length + 1;\n\t\t\t\t}\n\t\t\t\tvar mappings = ['AAAA'];\n\t\t\t\tmappings.length = (code.match(lineBreaks) || []).length + 1 + offset;\n\t\t\t\tsourceMap = {\n\t\t\t\t\tversion: 3,\n\t\t\t\t\tfile: url,\n\t\t\t\t\tnames:[],\n\t\t\t\t\tmappings: mappings.join(';AACA'),\n\t\t\t\t\tsourceRoot: '',\n\t\t\t\t\tsources: [url]\n\t\t\t\t};\n\t\t\t\tvar source = options.source || !url && code;\n\t\t\t\tif (source)\n\t\t\t\t\tsourceMap.sourcesContent = [source];\n\t\t\t}\n\t\t\twalkAST(parse(code, { ranges: true }));\n\t\t\tif (sourceMap) {\n\t\t\t\tcode = new Array(offset + 1).join('\\n') + code\n\t\t\t\t\t\t+ \"\\n//# sourceMappingURL=data:application/json;base64,\"\n\t\t\t\t\t\t+ (btoa(unescape(encodeURIComponent(\n\t\t\t\t\t\t\tJSON.stringify(sourceMap)))))\n\t\t\t\t\t\t+ \"\\n//# sourceURL=\" + (url || 'paperscript');\n\t\t\t}\n\t\t\treturn code;\n\t\t}\n\t\n\t\tfunction execute(code, scope, url, options) {\n\t\t\tpaper = scope;\n\t\t\tvar view = scope.getView(),\n\t\t\t\ttool = /\\s+on(?:Key|Mouse)(?:Up|Down|Move|Drag)\\b/.test(code)\n\t\t\t\t\t\t? new Tool()\n\t\t\t\t\t\t: null,\n\t\t\t\ttoolHandlers = tool ? tool._events : [],\n\t\t\t\thandlers = ['onFrame', 'onResize'].concat(toolHandlers),\n\t\t\t\tparams = [],\n\t\t\t\targs = [],\n\t\t\t\tfunc;\n\t\t\tcode = compile(code, url, options);\n\t\t\tfunction expose(scope, hidden) {\n\t\t\t\tfor (var key in scope) {\n\t\t\t\t\tif ((hidden || !/^_/.test(key)) && new RegExp('([\\\\b\\\\s\\\\W]|^)'\n\t\t\t\t\t\t\t+ key.replace(/\\$/g, '\\\\$') + '\\\\b').test(code)) {\n\t\t\t\t\t\tparams.push(key);\n\t\t\t\t\t\targs.push(scope[key]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\texpose({ __$__: __$__, $__: $__, paper: scope, view: view, tool: tool },\n\t\t\t\t\ttrue);\n\t\t\texpose(scope);\n\t\t\thandlers = Base.each(handlers, function(key) {\n\t\t\t\tif (new RegExp('\\\\s+' + key + '\\\\b').test(code)) {\n\t\t\t\t\tparams.push(key);\n\t\t\t\t\tthis.push(key + ': ' + key);\n\t\t\t\t}\n\t\t\t}, []).join(', ');\n\t\t\tif (handlers)\n\t\t\t\tcode += '\\nreturn { ' + handlers + ' };';\n\t\t\tvar browser = paper.browser;\n\t\t\tif (browser.chrome || browser.firefox) {\n\t\t\t\tvar script = document.createElement('script'),\n\t\t\t\t\thead = document.head || document.getElementsByTagName('head')[0];\n\t\t\t\tif (browser.firefox)\n\t\t\t\t\tcode = '\\n' + code;\n\t\t\t\tscript.appendChild(document.createTextNode(\n\t\t\t\t\t'paper._execute = function(' + params + ') {' + code + '\\n}'\n\t\t\t\t));\n\t\t\t\thead.appendChild(script);\n\t\t\t\tfunc = paper._execute;\n\t\t\t\tdelete paper._execute;\n\t\t\t\thead.removeChild(script);\n\t\t\t} else {\n\t\t\t\tfunc = Function(params, code);\n\t\t\t}\n\t\t\tvar res = func.apply(scope, args) || {};\n\t\t\tBase.each(toolHandlers, function(key) {\n\t\t\t\tvar value = res[key];\n\t\t\t\tif (value)\n\t\t\t\t\ttool[key] = value;\n\t\t\t});\n\t\t\tif (view) {\n\t\t\t\tif (res.onResize)\n\t\t\t\t\tview.setOnResize(res.onResize);\n\t\t\t\tview.emit('resize', {\n\t\t\t\t\tsize: view.size,\n\t\t\t\t\tdelta: new Point()\n\t\t\t\t});\n\t\t\t\tif (res.onFrame)\n\t\t\t\t\tview.setOnFrame(res.onFrame);\n\t\t\t\tview.update();\n\t\t\t}\n\t\t}\n\t\n\t\tfunction loadScript(script) {\n\t\t\tif (/^text\\/(?:x-|)paperscript$/.test(script.type)\n\t\t\t\t\t&& PaperScope.getAttribute(script, 'ignore') !== 'true') {\n\t\t\t\tvar canvasId = PaperScope.getAttribute(script, 'canvas'),\n\t\t\t\t\tcanvas = document.getElementById(canvasId),\n\t\t\t\t\tsrc = script.src || script.getAttribute('data-src'),\n\t\t\t\t\tasync = PaperScope.hasAttribute(script, 'async'),\n\t\t\t\t\tscopeAttribute = 'data-paper-scope';\n\t\t\t\tif (!canvas)\n\t\t\t\t\tthrow new Error('Unable to find canvas with id \"'\n\t\t\t\t\t\t\t+ canvasId + '\"');\n\t\t\t\tvar scope = PaperScope.get(canvas.getAttribute(scopeAttribute))\n\t\t\t\t\t\t\t|| new PaperScope().setup(canvas);\n\t\t\t\tcanvas.setAttribute(scopeAttribute, scope._id);\n\t\t\t\tif (src) {\n\t\t\t\t\tHttp.request('get', src, function(code) {\n\t\t\t\t\t\texecute(code, scope, src);\n\t\t\t\t\t}, async);\n\t\t\t\t} else {\n\t\t\t\t\texecute(script.innerHTML, scope, script.baseURI);\n\t\t\t\t}\n\t\t\t\tscript.setAttribute('data-paper-ignore', 'true');\n\t\t\t\treturn scope;\n\t\t\t}\n\t\t}\n\t\n\t\tfunction loadAll() {\n\t\t\tBase.each(document.getElementsByTagName('script'), loadScript);\n\t\t}\n\t\n\t\tfunction load(script) {\n\t\t\treturn script ? loadScript(script) : loadAll();\n\t\t}\n\t\n\t\tif (document.readyState === 'complete') {\n\t\t\tsetTimeout(loadAll);\n\t\t} else {\n\t\t\tDomEvent.add(window, { load: loadAll });\n\t\t}\n\t\n\t\treturn {\n\t\t\tcompile: compile,\n\t\t\texecute: execute,\n\t\t\tload: load,\n\t\t\tparse: parse\n\t\t};\n\t\n\t}).call(this);\n\t\n\tpaper = new (PaperScope.inject(Base.exports, {\n\t\tenumerable: true,\n\t\tBase: Base,\n\t\tNumerical: Numerical,\n\t\tKey: Key\n\t}))();\n\t\n\tif (true) {\n\t\t!(__WEBPACK_AMD_DEFINE_FACTORY__ = (paper), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t} else if (typeof module === 'object' && module) {\n\t\tmodule.exports = paper;\n\t}\n\t\n\treturn paper;\n\t};\n\n\n/***/ },\n/* 2 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t\tvalue: true\n\t});\n\t\n\tvar _classCallCheck2 = __webpack_require__(3);\n\t\n\tvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\t\n\tvar _createClass2 = __webpack_require__(4);\n\t\n\tvar _createClass3 = _interopRequireDefault(_createClass2);\n\t\n\tvar _ramda = __webpack_require__(8);\n\t\n\tvar _ramda2 = _interopRequireDefault(_ramda);\n\t\n\tvar _dialogue = __webpack_require__(9);\n\t\n\tvar _dialogue2 = _interopRequireDefault(_dialogue);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tvar story = [{\n\t\t\"scene\": \"intro\",\n\t\t\"src\": \"vid/Intro.mp4\",\n\t\t\"next\": \"conflict\"\n\t}, {\n\t\t\"scene\": \"conflict\",\n\t\t\"src\": \"vid/Background.mp4\",\n\t\t\"dialogue\": \"intro_dialog\"\n\t}, {\n\t\t\"scene\": \"mech_force\",\n\t\t\"src\": \"vid/Meteor.mp4\",\n\t\t\"next\": \"mech_force_dialog\"\n\t}, {\n\t\t\"scene\": \"mech_force_dialog\",\n\t\t\"src\": \"vid/Background.mp4\",\n\t\t\"dialogue\": \"asteroid_dialog\"\n\t}, {\n\t\t\"scene\": \"compete_kind\",\n\t\t\"src\": \"vid/Background.mp4\",\n\t\t\"dialogue\": \"compete_kind_dialog\"\n\t}, {\n\t\t\"scene\": \"compete_hard\",\n\t\t\"src\": \"vid/Background.mp4\",\n\t\t\"dialogue\": \"compete_hard_dialog\"\n\t}, {\n\t\t\"scene\": \"electrical_density\",\n\t\t\"src\": \"vid/Cars.mp4\",\n\t\t\"next\": \"ed_dialog\"\n\t\n\t}, {\n\t\t\"scene\": \"conductivity\",\n\t\t\"src\": \"vid/Phone.mp4\",\n\t\t\"next\": \"c_dialog\"\n\t}, {\n\t\t\"scene\": \"ed_dialog\",\n\t\t\"src\": \"vid/Background.mp4\",\n\t\t\"dialogue\": \"ed_c_dialog\"\n\t}, {\n\t\t\"scene\": \"c_dialog\",\n\t\t\"src\": \"vid/Background.mp4\",\n\t\t\"dialogue\": \"c_c_dialog\"\n\t}, {\n\t\t\"scene\": \"electrical_density_2\",\n\t\t\"src\": \"vid/Cars.mp4\",\n\t\t\"next\": \"end1\"\n\t\n\t}, {\n\t\t\"scene\": \"conductivity_2\",\n\t\t\"src\": \"vid/Phone.mp4\",\n\t\t\"next\": \"end1\"\n\t}, {\n\t\t\"scene\": \"electrical_density_good\",\n\t\t\"src\": \"vid/Cars.mp4\",\n\t\t\"next\": \"end2\"\n\t\n\t}, {\n\t\t\"scene\": \"conductivity_good\",\n\t\t\"src\": \"vid/Phone.mp4\",\n\t\t\"next\": \"good_mid\"\n\t}, {\n\t\t\"scene\": \"good_mid\",\n\t\t\"src\": \"vid/Background.mp4\",\n\t\t\"dialogue\": \"good_dialog\"\n\t}, {\n\t\t\"src\": \"vid/Background.mp4\",\n\t\t\"scene\": \"end1\",\n\t\t\"dialogue\": \"ending_dialog_1\"\n\t}, {\n\t\t\"src\": \"vid/Background.mp4\",\n\t\t\"dialogue\": \"ending_dialog_2\",\n\t\t\"scene\": \"end2\"\n\t}, {\n\t\t\"src\": \"vid/Background.mp4\",\n\t\t\"scene\": \"end_true\",\n\t\t\"next\": \"test\"\n\t}, {\n\t\t\"src\": \"vid/Background.mp4\",\n\t\t\"scene\": \"test\"\n\t}];\n\t\n\twindow.s = story;\n\t\n\tvar cache = [];\n\t\n\tfunction createVideo(element) {\n\t\tvar item = _ramda2.default.find(_ramda2.default.propEq(\"src\", element.src))(cache);\n\t\tif (item != null) {\n\t\t\telement.video = item.video;\n\t\t} else {\n\t\t\tvar vid = document.createElement(\"video\");\n\t\t\tif (element.src == \"vid/Background.mp4\") {\n\t\t\t\tvid.loop = true;\n\t\t\t}\n\t\t\tvid.src = element.src;\n\t\t\tcache.push({ src: element.src, video: vid });\n\t\t\telement.video = vid;\n\t\t}\n\t}\n\t\n\tvar Story = function () {\n\t\tfunction Story() {\n\t\t\t(0, _classCallCheck3.default)(this, Story);\n\t\n\t\t\tthis.story = story;\n\t\t\tthis.showDialogue = false;\n\t\t\tthis.dialogue = new _dialogue2.default();\n\t\t\tthis.current = this.story[0];\n\t\t\tthis.story.forEach(createVideo);\n\t\t\tconsole.log(cache);\n\t\t}\n\t\n\t\t(0, _createClass3.default)(Story, [{\n\t\t\tkey: \"defaultVideo\",\n\t\t\tvalue: function defaultVideo() {\n\t\t\t\treturn _ramda2.default.find(_ramda2.default.propEq(\"src\", \"vid/Background.mp4\"))(cache);\n\t\t\t}\n\t\t}, {\n\t\t\tkey: \"scene\",\n\t\t\tvalue: function scene(name) {\n\t\t\t\treturn _ramda2.default.find(_ramda2.default.propEq(\"scene\", name))(this.story);\n\t\t\t}\n\t\t}, {\n\t\t\tkey: \"exists\",\n\t\t\tvalue: function exists(scene) {\n\t\t\t\treturn this.scene(scene) != null;\n\t\t\t}\n\t\t}, {\n\t\t\tkey: \"choices\",\n\t\t\tvalue: function choices() {\n\t\t\t\tif (this.current.dialogue != null) {\n\t\t\t\t\tif (this.dialogue.hasChoices()) {\n\t\t\t\t\t\treturn this.dialogue.choices();\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn this.dialogue.say();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (this.current.choice != null) {\n\t\t\t\t\treturn this.current.choice.map(function (o) {\n\t\t\t\t\t\treturn o.show;\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\treturn [];\n\t\t\t\t}\n\t\t\t}\n\t\t}, {\n\t\t\tkey: \"hasChoices\",\n\t\t\tvalue: function hasChoices() {\n\t\t\t\treturn this.current.choice != null || this.dialogue.hasChoices();\n\t\t\t}\n\t\t}, {\n\t\t\tkey: \"setHasDialogue\",\n\t\t\tvalue: function setHasDialogue(bool /* bool */) {\n\t\t\t\tthis.showDialogue = bool;\n\t\t\t}\n\t\t}, {\n\t\t\tkey: \"hasDialogue\",\n\t\t\tvalue: function hasDialogue() {\n\t\t\t\treturn this.showDialogue;\n\t\t\t}\n\t\t}, {\n\t\t\tkey: \"neededVideos\",\n\t\t\tvalue: function neededVideos() {\n\t\t\t\tvar _this = this;\n\t\n\t\t\t\tif (this.current.choice) {\n\t\t\t\t\treturn this.current.choice.map(function (e) {\n\t\t\t\t\t\treturn _this.scene(e.scene);\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\treturn [this.scene(this.current.next)];\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\t//events for the scene\n\t\n\t\t}, {\n\t\t\tkey: \"onBefore\",\n\t\t\tvalue: function onBefore(scene, fn) {\n\t\t\t\tif (this.exists(scene)) {\n\t\t\t\t\tthis.scene(scene).onBefore = fn;\n\t\t\t\t}\n\t\t\t}\n\t\t}, {\n\t\t\tkey: \"offBefore\",\n\t\t\tvalue: function offBefore(scene) {\n\t\t\t\tif (this.exists(scene)) {\n\t\t\t\t\tdelete this.scene(scene).onBefore;\n\t\t\t\t}\n\t\t\t}\n\t\t}, {\n\t\t\tkey: \"onAfter\",\n\t\t\tvalue: function onAfter(scene, fn) {\n\t\t\t\tif (this.exists(scene)) {\n\t\t\t\t\tthis.scene(scene).onAfter = fn;\n\t\t\t\t}\n\t\t\t}\n\t\t}, {\n\t\t\tkey: \"offAfetr\",\n\t\t\tvalue: function offAfetr(scene) {\n\t\t\t\tif (this.exists(scene)) {\n\t\t\t\t\tdelete this.scene(scene).onAfter;\n\t\t\t\t}\n\t\t\t}\n\t\t}, {\n\t\t\tkey: \"switchTo\",\n\t\t\tvalue: function switchTo(scene) {\n\t\t\t\tif (scene != null) {\n\t\t\t\t\tif (this.current.onAfter != null) {\n\t\t\t\t\t\t// calls onAfter just before switching the video\n\t\t\t\t\t\tthis.current.onAfter();\n\t\t\t\t\t}\n\t\n\t\t\t\t\tthis.current = this.scene(scene); // switch the video with the next one\n\t\n\t\t\t\t\tif (this.current.dialogue != null) {\n\t\t\t\t\t\tthis.dialogue.select(this.current.dialogue);\n\t\t\t\t\t\tthis.showDialogue = true;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis.showDialogue = false;\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif (this.current.onBefore != null) {\n\t\t\t\t\t\t// call onBefore for the the next video\n\t\t\t\t\t\tthis.current.onBefore();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}, {\n\t\t\tkey: \"next\",\n\t\t\tvalue: function next(choice) {\n\t\t\t\tif (this.current.dialogue != null) {\n\t\t\t\t\tvar scene = this.dialogue.next(choice);\n\t\t\t\t\tthis.switchTo(scene);\n\t\t\t\t} else {\n\t\t\t\t\tthis.switchTo(this.current.next);\n\t\t\t\t}\n\t\t\t}\n\t\t}]);\n\t\treturn Story;\n\t}();\n\n\texports.default = Story;\n\n/***/ },\n/* 3 */,\n/* 4 */,\n/* 5 */,\n/* 6 */,\n/* 7 */,\n/* 8 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t//  Ramda v0.19.1\n\t//  https://github.com/ramda/ramda\n\t//  (c) 2013-2016 Scott Sauyet, Michael Hurley, and David Chambers\n\t//  Ramda may be freely distributed under the MIT license.\n\t\n\t;(function() {\n\t\n\t  'use strict';\n\t\n\t  /**\n\t     * A special placeholder value used to specify \"gaps\" within curried functions,\n\t     * allowing partial application of any combination of arguments, regardless of\n\t     * their positions.\n\t     *\n\t     * If `g` is a curried ternary function and `_` is `R.__`, the following are\n\t     * equivalent:\n\t     *\n\t     *   - `g(1, 2, 3)`\n\t     *   - `g(_, 2, 3)(1)`\n\t     *   - `g(_, _, 3)(1)(2)`\n\t     *   - `g(_, _, 3)(1, 2)`\n\t     *   - `g(_, 2, _)(1, 3)`\n\t     *   - `g(_, 2)(1)(3)`\n\t     *   - `g(_, 2)(1, 3)`\n\t     *   - `g(_, 2)(_, 3)(1)`\n\t     *\n\t     * @constant\n\t     * @memberOf R\n\t     * @since v0.6.0\n\t     * @category Function\n\t     * @example\n\t     *\n\t     *      var greet = R.replace('{name}', R.__, 'Hello, {name}!');\n\t     *      greet('Alice'); //=> 'Hello, Alice!'\n\t     */\n\t    var __ = { '@@functional/placeholder': true };\n\t\n\t    /* eslint-disable no-unused-vars */\n\t    var _arity = function _arity(n, fn) {\n\t        /* eslint-disable no-unused-vars */\n\t        switch (n) {\n\t        case 0:\n\t            return function () {\n\t                return fn.apply(this, arguments);\n\t            };\n\t        case 1:\n\t            return function (a0) {\n\t                return fn.apply(this, arguments);\n\t            };\n\t        case 2:\n\t            return function (a0, a1) {\n\t                return fn.apply(this, arguments);\n\t            };\n\t        case 3:\n\t            return function (a0, a1, a2) {\n\t                return fn.apply(this, arguments);\n\t            };\n\t        case 4:\n\t            return function (a0, a1, a2, a3) {\n\t                return fn.apply(this, arguments);\n\t            };\n\t        case 5:\n\t            return function (a0, a1, a2, a3, a4) {\n\t                return fn.apply(this, arguments);\n\t            };\n\t        case 6:\n\t            return function (a0, a1, a2, a3, a4, a5) {\n\t                return fn.apply(this, arguments);\n\t            };\n\t        case 7:\n\t            return function (a0, a1, a2, a3, a4, a5, a6) {\n\t                return fn.apply(this, arguments);\n\t            };\n\t        case 8:\n\t            return function (a0, a1, a2, a3, a4, a5, a6, a7) {\n\t                return fn.apply(this, arguments);\n\t            };\n\t        case 9:\n\t            return function (a0, a1, a2, a3, a4, a5, a6, a7, a8) {\n\t                return fn.apply(this, arguments);\n\t            };\n\t        case 10:\n\t            return function (a0, a1, a2, a3, a4, a5, a6, a7, a8, a9) {\n\t                return fn.apply(this, arguments);\n\t            };\n\t        default:\n\t            throw new Error('First argument to _arity must be a non-negative integer no greater than ten');\n\t        }\n\t    };\n\t\n\t    var _arrayFromIterator = function _arrayFromIterator(iter) {\n\t        var list = [];\n\t        var next;\n\t        while (!(next = iter.next()).done) {\n\t            list.push(next.value);\n\t        }\n\t        return list;\n\t    };\n\t\n\t    var _cloneRegExp = function _cloneRegExp(pattern) {\n\t        return new RegExp(pattern.source, (pattern.global ? 'g' : '') + (pattern.ignoreCase ? 'i' : '') + (pattern.multiline ? 'm' : '') + (pattern.sticky ? 'y' : '') + (pattern.unicode ? 'u' : ''));\n\t    };\n\t\n\t    var _complement = function _complement(f) {\n\t        return function () {\n\t            return !f.apply(this, arguments);\n\t        };\n\t    };\n\t\n\t    /**\n\t     * Private `concat` function to merge two array-like objects.\n\t     *\n\t     * @private\n\t     * @param {Array|Arguments} [set1=[]] An array-like object.\n\t     * @param {Array|Arguments} [set2=[]] An array-like object.\n\t     * @return {Array} A new, merged array.\n\t     * @example\n\t     *\n\t     *      _concat([4, 5, 6], [1, 2, 3]); //=> [4, 5, 6, 1, 2, 3]\n\t     */\n\t    var _concat = function _concat(set1, set2) {\n\t        set1 = set1 || [];\n\t        set2 = set2 || [];\n\t        var idx;\n\t        var len1 = set1.length;\n\t        var len2 = set2.length;\n\t        var result = [];\n\t        idx = 0;\n\t        while (idx < len1) {\n\t            result[result.length] = set1[idx];\n\t            idx += 1;\n\t        }\n\t        idx = 0;\n\t        while (idx < len2) {\n\t            result[result.length] = set2[idx];\n\t            idx += 1;\n\t        }\n\t        return result;\n\t    };\n\t\n\t    var _containsWith = function _containsWith(pred, x, list) {\n\t        var idx = 0;\n\t        var len = list.length;\n\t        while (idx < len) {\n\t            if (pred(x, list[idx])) {\n\t                return true;\n\t            }\n\t            idx += 1;\n\t        }\n\t        return false;\n\t    };\n\t\n\t    var _filter = function _filter(fn, list) {\n\t        var idx = 0;\n\t        var len = list.length;\n\t        var result = [];\n\t        while (idx < len) {\n\t            if (fn(list[idx])) {\n\t                result[result.length] = list[idx];\n\t            }\n\t            idx += 1;\n\t        }\n\t        return result;\n\t    };\n\t\n\t    var _forceReduced = function _forceReduced(x) {\n\t        return {\n\t            '@@transducer/value': x,\n\t            '@@transducer/reduced': true\n\t        };\n\t    };\n\t\n\t    var _has = function _has(prop, obj) {\n\t        return Object.prototype.hasOwnProperty.call(obj, prop);\n\t    };\n\t\n\t    var _identity = function _identity(x) {\n\t        return x;\n\t    };\n\t\n\t    var _isArguments = function () {\n\t        var toString = Object.prototype.toString;\n\t        return toString.call(arguments) === '[object Arguments]' ? function _isArguments(x) {\n\t            return toString.call(x) === '[object Arguments]';\n\t        } : function _isArguments(x) {\n\t            return _has('callee', x);\n\t        };\n\t    }();\n\t\n\t    /**\n\t     * Tests whether or not an object is an array.\n\t     *\n\t     * @private\n\t     * @param {*} val The object to test.\n\t     * @return {Boolean} `true` if `val` is an array, `false` otherwise.\n\t     * @example\n\t     *\n\t     *      _isArray([]); //=> true\n\t     *      _isArray(null); //=> false\n\t     *      _isArray({}); //=> false\n\t     */\n\t    var _isArray = Array.isArray || function _isArray(val) {\n\t        return val != null && val.length >= 0 && Object.prototype.toString.call(val) === '[object Array]';\n\t    };\n\t\n\t    /**\n\t     * Determine if the passed argument is an integer.\n\t     *\n\t     * @private\n\t     * @param {*} n\n\t     * @category Type\n\t     * @return {Boolean}\n\t     */\n\t    var _isInteger = Number.isInteger || function _isInteger(n) {\n\t        return n << 0 === n;\n\t    };\n\t\n\t    var _isNumber = function _isNumber(x) {\n\t        return Object.prototype.toString.call(x) === '[object Number]';\n\t    };\n\t\n\t    var _isObject = function _isObject(x) {\n\t        return Object.prototype.toString.call(x) === '[object Object]';\n\t    };\n\t\n\t    var _isPlaceholder = function _isPlaceholder(a) {\n\t        return a != null && typeof a === 'object' && a['@@functional/placeholder'] === true;\n\t    };\n\t\n\t    var _isRegExp = function _isRegExp(x) {\n\t        return Object.prototype.toString.call(x) === '[object RegExp]';\n\t    };\n\t\n\t    var _isString = function _isString(x) {\n\t        return Object.prototype.toString.call(x) === '[object String]';\n\t    };\n\t\n\t    var _isTransformer = function _isTransformer(obj) {\n\t        return typeof obj['@@transducer/step'] === 'function';\n\t    };\n\t\n\t    var _map = function _map(fn, functor) {\n\t        var idx = 0;\n\t        var len = functor.length;\n\t        var result = Array(len);\n\t        while (idx < len) {\n\t            result[idx] = fn(functor[idx]);\n\t            idx += 1;\n\t        }\n\t        return result;\n\t    };\n\t\n\t    var _of = function _of(x) {\n\t        return [x];\n\t    };\n\t\n\t    var _pipe = function _pipe(f, g) {\n\t        return function () {\n\t            return g.call(this, f.apply(this, arguments));\n\t        };\n\t    };\n\t\n\t    var _pipeP = function _pipeP(f, g) {\n\t        return function () {\n\t            var ctx = this;\n\t            return f.apply(ctx, arguments).then(function (x) {\n\t                return g.call(ctx, x);\n\t            });\n\t        };\n\t    };\n\t\n\t    // \\b matches word boundary; [\\b] matches backspace\n\t    var _quote = function _quote(s) {\n\t        var escaped = s.replace(/\\\\/g, '\\\\\\\\').replace(/[\\b]/g, '\\\\b')    // \\b matches word boundary; [\\b] matches backspace\n\t    .replace(/\\f/g, '\\\\f').replace(/\\n/g, '\\\\n').replace(/\\r/g, '\\\\r').replace(/\\t/g, '\\\\t').replace(/\\v/g, '\\\\v').replace(/\\0/g, '\\\\0');\n\t        return '\"' + escaped.replace(/\"/g, '\\\\\"') + '\"';\n\t    };\n\t\n\t    var _reduced = function _reduced(x) {\n\t        return x && x['@@transducer/reduced'] ? x : {\n\t            '@@transducer/value': x,\n\t            '@@transducer/reduced': true\n\t        };\n\t    };\n\t\n\t    /**\n\t     * An optimized, private array `slice` implementation.\n\t     *\n\t     * @private\n\t     * @param {Arguments|Array} args The array or arguments object to consider.\n\t     * @param {Number} [from=0] The array index to slice from, inclusive.\n\t     * @param {Number} [to=args.length] The array index to slice to, exclusive.\n\t     * @return {Array} A new, sliced array.\n\t     * @example\n\t     *\n\t     *      _slice([1, 2, 3, 4, 5], 1, 3); //=> [2, 3]\n\t     *\n\t     *      var firstThreeArgs = function(a, b, c, d) {\n\t     *        return _slice(arguments, 0, 3);\n\t     *      };\n\t     *      firstThreeArgs(1, 2, 3, 4); //=> [1, 2, 3]\n\t     */\n\t    var _slice = function _slice(args, from, to) {\n\t        switch (arguments.length) {\n\t        case 1:\n\t            return _slice(args, 0, args.length);\n\t        case 2:\n\t            return _slice(args, from, args.length);\n\t        default:\n\t            var list = [];\n\t            var idx = 0;\n\t            var len = Math.max(0, Math.min(args.length, to) - from);\n\t            while (idx < len) {\n\t                list[idx] = args[from + idx];\n\t                idx += 1;\n\t            }\n\t            return list;\n\t        }\n\t    };\n\t\n\t    /**\n\t     * Polyfill from <https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/toISOString>.\n\t     */\n\t    var _toISOString = function () {\n\t        var pad = function pad(n) {\n\t            return (n < 10 ? '0' : '') + n;\n\t        };\n\t        return typeof Date.prototype.toISOString === 'function' ? function _toISOString(d) {\n\t            return d.toISOString();\n\t        } : function _toISOString(d) {\n\t            return d.getUTCFullYear() + '-' + pad(d.getUTCMonth() + 1) + '-' + pad(d.getUTCDate()) + 'T' + pad(d.getUTCHours()) + ':' + pad(d.getUTCMinutes()) + ':' + pad(d.getUTCSeconds()) + '.' + (d.getUTCMilliseconds() / 1000).toFixed(3).slice(2, 5) + 'Z';\n\t        };\n\t    }();\n\t\n\t    var _xfBase = {\n\t        init: function () {\n\t            return this.xf['@@transducer/init']();\n\t        },\n\t        result: function (result) {\n\t            return this.xf['@@transducer/result'](result);\n\t        }\n\t    };\n\t\n\t    var _xwrap = function () {\n\t        function XWrap(fn) {\n\t            this.f = fn;\n\t        }\n\t        XWrap.prototype['@@transducer/init'] = function () {\n\t            throw new Error('init not implemented on XWrap');\n\t        };\n\t        XWrap.prototype['@@transducer/result'] = function (acc) {\n\t            return acc;\n\t        };\n\t        XWrap.prototype['@@transducer/step'] = function (acc, x) {\n\t            return this.f(acc, x);\n\t        };\n\t        return function _xwrap(fn) {\n\t            return new XWrap(fn);\n\t        };\n\t    }();\n\t\n\t    var _aperture = function _aperture(n, list) {\n\t        var idx = 0;\n\t        var limit = list.length - (n - 1);\n\t        var acc = new Array(limit >= 0 ? limit : 0);\n\t        while (idx < limit) {\n\t            acc[idx] = _slice(list, idx, idx + n);\n\t            idx += 1;\n\t        }\n\t        return acc;\n\t    };\n\t\n\t    /**\n\t     * Similar to hasMethod, this checks whether a function has a [methodname]\n\t     * function. If it isn't an array it will execute that function otherwise it\n\t     * will default to the ramda implementation.\n\t     *\n\t     * @private\n\t     * @param {Function} fn ramda implemtation\n\t     * @param {String} methodname property to check for a custom implementation\n\t     * @return {Object} Whatever the return value of the method is.\n\t     */\n\t    var _checkForMethod = function _checkForMethod(methodname, fn) {\n\t        return function () {\n\t            var length = arguments.length;\n\t            if (length === 0) {\n\t                return fn();\n\t            }\n\t            var obj = arguments[length - 1];\n\t            return _isArray(obj) || typeof obj[methodname] !== 'function' ? fn.apply(this, arguments) : obj[methodname].apply(obj, _slice(arguments, 0, length - 1));\n\t        };\n\t    };\n\t\n\t    /**\n\t     * Optimized internal one-arity curry function.\n\t     *\n\t     * @private\n\t     * @category Function\n\t     * @param {Function} fn The function to curry.\n\t     * @return {Function} The curried function.\n\t     */\n\t    var _curry1 = function _curry1(fn) {\n\t        return function f1(a) {\n\t            if (arguments.length === 0 || _isPlaceholder(a)) {\n\t                return f1;\n\t            } else {\n\t                return fn.apply(this, arguments);\n\t            }\n\t        };\n\t    };\n\t\n\t    /**\n\t     * Optimized internal two-arity curry function.\n\t     *\n\t     * @private\n\t     * @category Function\n\t     * @param {Function} fn The function to curry.\n\t     * @return {Function} The curried function.\n\t     */\n\t    var _curry2 = function _curry2(fn) {\n\t        return function f2(a, b) {\n\t            switch (arguments.length) {\n\t            case 0:\n\t                return f2;\n\t            case 1:\n\t                return _isPlaceholder(a) ? f2 : _curry1(function (_b) {\n\t                    return fn(a, _b);\n\t                });\n\t            default:\n\t                return _isPlaceholder(a) && _isPlaceholder(b) ? f2 : _isPlaceholder(a) ? _curry1(function (_a) {\n\t                    return fn(_a, b);\n\t                }) : _isPlaceholder(b) ? _curry1(function (_b) {\n\t                    return fn(a, _b);\n\t                }) : fn(a, b);\n\t            }\n\t        };\n\t    };\n\t\n\t    /**\n\t     * Optimized internal three-arity curry function.\n\t     *\n\t     * @private\n\t     * @category Function\n\t     * @param {Function} fn The function to curry.\n\t     * @return {Function} The curried function.\n\t     */\n\t    var _curry3 = function _curry3(fn) {\n\t        return function f3(a, b, c) {\n\t            switch (arguments.length) {\n\t            case 0:\n\t                return f3;\n\t            case 1:\n\t                return _isPlaceholder(a) ? f3 : _curry2(function (_b, _c) {\n\t                    return fn(a, _b, _c);\n\t                });\n\t            case 2:\n\t                return _isPlaceholder(a) && _isPlaceholder(b) ? f3 : _isPlaceholder(a) ? _curry2(function (_a, _c) {\n\t                    return fn(_a, b, _c);\n\t                }) : _isPlaceholder(b) ? _curry2(function (_b, _c) {\n\t                    return fn(a, _b, _c);\n\t                }) : _curry1(function (_c) {\n\t                    return fn(a, b, _c);\n\t                });\n\t            default:\n\t                return _isPlaceholder(a) && _isPlaceholder(b) && _isPlaceholder(c) ? f3 : _isPlaceholder(a) && _isPlaceholder(b) ? _curry2(function (_a, _b) {\n\t                    return fn(_a, _b, c);\n\t                }) : _isPlaceholder(a) && _isPlaceholder(c) ? _curry2(function (_a, _c) {\n\t                    return fn(_a, b, _c);\n\t                }) : _isPlaceholder(b) && _isPlaceholder(c) ? _curry2(function (_b, _c) {\n\t                    return fn(a, _b, _c);\n\t                }) : _isPlaceholder(a) ? _curry1(function (_a) {\n\t                    return fn(_a, b, c);\n\t                }) : _isPlaceholder(b) ? _curry1(function (_b) {\n\t                    return fn(a, _b, c);\n\t                }) : _isPlaceholder(c) ? _curry1(function (_c) {\n\t                    return fn(a, b, _c);\n\t                }) : fn(a, b, c);\n\t            }\n\t        };\n\t    };\n\t\n\t    /**\n\t     * Internal curryN function.\n\t     *\n\t     * @private\n\t     * @category Function\n\t     * @param {Number} length The arity of the curried function.\n\t     * @param {Array} received An array of arguments received thus far.\n\t     * @param {Function} fn The function to curry.\n\t     * @return {Function} The curried function.\n\t     */\n\t    var _curryN = function _curryN(length, received, fn) {\n\t        return function () {\n\t            var combined = [];\n\t            var argsIdx = 0;\n\t            var left = length;\n\t            var combinedIdx = 0;\n\t            while (combinedIdx < received.length || argsIdx < arguments.length) {\n\t                var result;\n\t                if (combinedIdx < received.length && (!_isPlaceholder(received[combinedIdx]) || argsIdx >= arguments.length)) {\n\t                    result = received[combinedIdx];\n\t                } else {\n\t                    result = arguments[argsIdx];\n\t                    argsIdx += 1;\n\t                }\n\t                combined[combinedIdx] = result;\n\t                if (!_isPlaceholder(result)) {\n\t                    left -= 1;\n\t                }\n\t                combinedIdx += 1;\n\t            }\n\t            return left <= 0 ? fn.apply(this, combined) : _arity(left, _curryN(length, combined, fn));\n\t        };\n\t    };\n\t\n\t    /**\n\t     * Returns a function that dispatches with different strategies based on the\n\t     * object in list position (last argument). If it is an array, executes [fn].\n\t     * Otherwise, if it has a function with [methodname], it will execute that\n\t     * function (functor case). Otherwise, if it is a transformer, uses transducer\n\t     * [xf] to return a new transformer (transducer case). Otherwise, it will\n\t     * default to executing [fn].\n\t     *\n\t     * @private\n\t     * @param {String} methodname property to check for a custom implementation\n\t     * @param {Function} xf transducer to initialize if object is transformer\n\t     * @param {Function} fn default ramda implementation\n\t     * @return {Function} A function that dispatches on object in list position\n\t     */\n\t    var _dispatchable = function _dispatchable(methodname, xf, fn) {\n\t        return function () {\n\t            var length = arguments.length;\n\t            if (length === 0) {\n\t                return fn();\n\t            }\n\t            var obj = arguments[length - 1];\n\t            if (!_isArray(obj)) {\n\t                var args = _slice(arguments, 0, length - 1);\n\t                if (typeof obj[methodname] === 'function') {\n\t                    return obj[methodname].apply(obj, args);\n\t                }\n\t                if (_isTransformer(obj)) {\n\t                    var transducer = xf.apply(null, args);\n\t                    return transducer(obj);\n\t                }\n\t            }\n\t            return fn.apply(this, arguments);\n\t        };\n\t    };\n\t\n\t    var _dropLastWhile = function dropLastWhile(pred, list) {\n\t        var idx = list.length - 1;\n\t        while (idx >= 0 && pred(list[idx])) {\n\t            idx -= 1;\n\t        }\n\t        return _slice(list, 0, idx + 1);\n\t    };\n\t\n\t    var _xall = function () {\n\t        function XAll(f, xf) {\n\t            this.xf = xf;\n\t            this.f = f;\n\t            this.all = true;\n\t        }\n\t        XAll.prototype['@@transducer/init'] = _xfBase.init;\n\t        XAll.prototype['@@transducer/result'] = function (result) {\n\t            if (this.all) {\n\t                result = this.xf['@@transducer/step'](result, true);\n\t            }\n\t            return this.xf['@@transducer/result'](result);\n\t        };\n\t        XAll.prototype['@@transducer/step'] = function (result, input) {\n\t            if (!this.f(input)) {\n\t                this.all = false;\n\t                result = _reduced(this.xf['@@transducer/step'](result, false));\n\t            }\n\t            return result;\n\t        };\n\t        return _curry2(function _xall(f, xf) {\n\t            return new XAll(f, xf);\n\t        });\n\t    }();\n\t\n\t    var _xany = function () {\n\t        function XAny(f, xf) {\n\t            this.xf = xf;\n\t            this.f = f;\n\t            this.any = false;\n\t        }\n\t        XAny.prototype['@@transducer/init'] = _xfBase.init;\n\t        XAny.prototype['@@transducer/result'] = function (result) {\n\t            if (!this.any) {\n\t                result = this.xf['@@transducer/step'](result, false);\n\t            }\n\t            return this.xf['@@transducer/result'](result);\n\t        };\n\t        XAny.prototype['@@transducer/step'] = function (result, input) {\n\t            if (this.f(input)) {\n\t                this.any = true;\n\t                result = _reduced(this.xf['@@transducer/step'](result, true));\n\t            }\n\t            return result;\n\t        };\n\t        return _curry2(function _xany(f, xf) {\n\t            return new XAny(f, xf);\n\t        });\n\t    }();\n\t\n\t    var _xaperture = function () {\n\t        function XAperture(n, xf) {\n\t            this.xf = xf;\n\t            this.pos = 0;\n\t            this.full = false;\n\t            this.acc = new Array(n);\n\t        }\n\t        XAperture.prototype['@@transducer/init'] = _xfBase.init;\n\t        XAperture.prototype['@@transducer/result'] = function (result) {\n\t            this.acc = null;\n\t            return this.xf['@@transducer/result'](result);\n\t        };\n\t        XAperture.prototype['@@transducer/step'] = function (result, input) {\n\t            this.store(input);\n\t            return this.full ? this.xf['@@transducer/step'](result, this.getCopy()) : result;\n\t        };\n\t        XAperture.prototype.store = function (input) {\n\t            this.acc[this.pos] = input;\n\t            this.pos += 1;\n\t            if (this.pos === this.acc.length) {\n\t                this.pos = 0;\n\t                this.full = true;\n\t            }\n\t        };\n\t        XAperture.prototype.getCopy = function () {\n\t            return _concat(_slice(this.acc, this.pos), _slice(this.acc, 0, this.pos));\n\t        };\n\t        return _curry2(function _xaperture(n, xf) {\n\t            return new XAperture(n, xf);\n\t        });\n\t    }();\n\t\n\t    var _xdrop = function () {\n\t        function XDrop(n, xf) {\n\t            this.xf = xf;\n\t            this.n = n;\n\t        }\n\t        XDrop.prototype['@@transducer/init'] = _xfBase.init;\n\t        XDrop.prototype['@@transducer/result'] = _xfBase.result;\n\t        XDrop.prototype['@@transducer/step'] = function (result, input) {\n\t            if (this.n > 0) {\n\t                this.n -= 1;\n\t                return result;\n\t            }\n\t            return this.xf['@@transducer/step'](result, input);\n\t        };\n\t        return _curry2(function _xdrop(n, xf) {\n\t            return new XDrop(n, xf);\n\t        });\n\t    }();\n\t\n\t    var _xdropLast = function () {\n\t        function XDropLast(n, xf) {\n\t            this.xf = xf;\n\t            this.pos = 0;\n\t            this.full = false;\n\t            this.acc = new Array(n);\n\t        }\n\t        XDropLast.prototype['@@transducer/init'] = _xfBase.init;\n\t        XDropLast.prototype['@@transducer/result'] = function (result) {\n\t            this.acc = null;\n\t            return this.xf['@@transducer/result'](result);\n\t        };\n\t        XDropLast.prototype['@@transducer/step'] = function (result, input) {\n\t            if (this.full) {\n\t                result = this.xf['@@transducer/step'](result, this.acc[this.pos]);\n\t            }\n\t            this.store(input);\n\t            return result;\n\t        };\n\t        XDropLast.prototype.store = function (input) {\n\t            this.acc[this.pos] = input;\n\t            this.pos += 1;\n\t            if (this.pos === this.acc.length) {\n\t                this.pos = 0;\n\t                this.full = true;\n\t            }\n\t        };\n\t        return _curry2(function _xdropLast(n, xf) {\n\t            return new XDropLast(n, xf);\n\t        });\n\t    }();\n\t\n\t    var _xdropRepeatsWith = function () {\n\t        function XDropRepeatsWith(pred, xf) {\n\t            this.xf = xf;\n\t            this.pred = pred;\n\t            this.lastValue = undefined;\n\t            this.seenFirstValue = false;\n\t        }\n\t        XDropRepeatsWith.prototype['@@transducer/init'] = function () {\n\t            return this.xf['@@transducer/init']();\n\t        };\n\t        XDropRepeatsWith.prototype['@@transducer/result'] = function (result) {\n\t            return this.xf['@@transducer/result'](result);\n\t        };\n\t        XDropRepeatsWith.prototype['@@transducer/step'] = function (result, input) {\n\t            var sameAsLast = false;\n\t            if (!this.seenFirstValue) {\n\t                this.seenFirstValue = true;\n\t            } else if (this.pred(this.lastValue, input)) {\n\t                sameAsLast = true;\n\t            }\n\t            this.lastValue = input;\n\t            return sameAsLast ? result : this.xf['@@transducer/step'](result, input);\n\t        };\n\t        return _curry2(function _xdropRepeatsWith(pred, xf) {\n\t            return new XDropRepeatsWith(pred, xf);\n\t        });\n\t    }();\n\t\n\t    var _xdropWhile = function () {\n\t        function XDropWhile(f, xf) {\n\t            this.xf = xf;\n\t            this.f = f;\n\t        }\n\t        XDropWhile.prototype['@@transducer/init'] = _xfBase.init;\n\t        XDropWhile.prototype['@@transducer/result'] = _xfBase.result;\n\t        XDropWhile.prototype['@@transducer/step'] = function (result, input) {\n\t            if (this.f) {\n\t                if (this.f(input)) {\n\t                    return result;\n\t                }\n\t                this.f = null;\n\t            }\n\t            return this.xf['@@transducer/step'](result, input);\n\t        };\n\t        return _curry2(function _xdropWhile(f, xf) {\n\t            return new XDropWhile(f, xf);\n\t        });\n\t    }();\n\t\n\t    var _xfilter = function () {\n\t        function XFilter(f, xf) {\n\t            this.xf = xf;\n\t            this.f = f;\n\t        }\n\t        XFilter.prototype['@@transducer/init'] = _xfBase.init;\n\t        XFilter.prototype['@@transducer/result'] = _xfBase.result;\n\t        XFilter.prototype['@@transducer/step'] = function (result, input) {\n\t            return this.f(input) ? this.xf['@@transducer/step'](result, input) : result;\n\t        };\n\t        return _curry2(function _xfilter(f, xf) {\n\t            return new XFilter(f, xf);\n\t        });\n\t    }();\n\t\n\t    var _xfind = function () {\n\t        function XFind(f, xf) {\n\t            this.xf = xf;\n\t            this.f = f;\n\t            this.found = false;\n\t        }\n\t        XFind.prototype['@@transducer/init'] = _xfBase.init;\n\t        XFind.prototype['@@transducer/result'] = function (result) {\n\t            if (!this.found) {\n\t                result = this.xf['@@transducer/step'](result, void 0);\n\t            }\n\t            return this.xf['@@transducer/result'](result);\n\t        };\n\t        XFind.prototype['@@transducer/step'] = function (result, input) {\n\t            if (this.f(input)) {\n\t                this.found = true;\n\t                result = _reduced(this.xf['@@transducer/step'](result, input));\n\t            }\n\t            return result;\n\t        };\n\t        return _curry2(function _xfind(f, xf) {\n\t            return new XFind(f, xf);\n\t        });\n\t    }();\n\t\n\t    var _xfindIndex = function () {\n\t        function XFindIndex(f, xf) {\n\t            this.xf = xf;\n\t            this.f = f;\n\t            this.idx = -1;\n\t            this.found = false;\n\t        }\n\t        XFindIndex.prototype['@@transducer/init'] = _xfBase.init;\n\t        XFindIndex.prototype['@@transducer/result'] = function (result) {\n\t            if (!this.found) {\n\t                result = this.xf['@@transducer/step'](result, -1);\n\t            }\n\t            return this.xf['@@transducer/result'](result);\n\t        };\n\t        XFindIndex.prototype['@@transducer/step'] = function (result, input) {\n\t            this.idx += 1;\n\t            if (this.f(input)) {\n\t                this.found = true;\n\t                result = _reduced(this.xf['@@transducer/step'](result, this.idx));\n\t            }\n\t            return result;\n\t        };\n\t        return _curry2(function _xfindIndex(f, xf) {\n\t            return new XFindIndex(f, xf);\n\t        });\n\t    }();\n\t\n\t    var _xfindLast = function () {\n\t        function XFindLast(f, xf) {\n\t            this.xf = xf;\n\t            this.f = f;\n\t        }\n\t        XFindLast.prototype['@@transducer/init'] = _xfBase.init;\n\t        XFindLast.prototype['@@transducer/result'] = function (result) {\n\t            return this.xf['@@transducer/result'](this.xf['@@transducer/step'](result, this.last));\n\t        };\n\t        XFindLast.prototype['@@transducer/step'] = function (result, input) {\n\t            if (this.f(input)) {\n\t                this.last = input;\n\t            }\n\t            return result;\n\t        };\n\t        return _curry2(function _xfindLast(f, xf) {\n\t            return new XFindLast(f, xf);\n\t        });\n\t    }();\n\t\n\t    var _xfindLastIndex = function () {\n\t        function XFindLastIndex(f, xf) {\n\t            this.xf = xf;\n\t            this.f = f;\n\t            this.idx = -1;\n\t            this.lastIdx = -1;\n\t        }\n\t        XFindLastIndex.prototype['@@transducer/init'] = _xfBase.init;\n\t        XFindLastIndex.prototype['@@transducer/result'] = function (result) {\n\t            return this.xf['@@transducer/result'](this.xf['@@transducer/step'](result, this.lastIdx));\n\t        };\n\t        XFindLastIndex.prototype['@@transducer/step'] = function (result, input) {\n\t            this.idx += 1;\n\t            if (this.f(input)) {\n\t                this.lastIdx = this.idx;\n\t            }\n\t            return result;\n\t        };\n\t        return _curry2(function _xfindLastIndex(f, xf) {\n\t            return new XFindLastIndex(f, xf);\n\t        });\n\t    }();\n\t\n\t    var _xmap = function () {\n\t        function XMap(f, xf) {\n\t            this.xf = xf;\n\t            this.f = f;\n\t        }\n\t        XMap.prototype['@@transducer/init'] = _xfBase.init;\n\t        XMap.prototype['@@transducer/result'] = _xfBase.result;\n\t        XMap.prototype['@@transducer/step'] = function (result, input) {\n\t            return this.xf['@@transducer/step'](result, this.f(input));\n\t        };\n\t        return _curry2(function _xmap(f, xf) {\n\t            return new XMap(f, xf);\n\t        });\n\t    }();\n\t\n\t    var _xtake = function () {\n\t        function XTake(n, xf) {\n\t            this.xf = xf;\n\t            this.n = n;\n\t        }\n\t        XTake.prototype['@@transducer/init'] = _xfBase.init;\n\t        XTake.prototype['@@transducer/result'] = _xfBase.result;\n\t        XTake.prototype['@@transducer/step'] = function (result, input) {\n\t            if (this.n === 0) {\n\t                return _reduced(result);\n\t            } else {\n\t                this.n -= 1;\n\t                return this.xf['@@transducer/step'](result, input);\n\t            }\n\t        };\n\t        return _curry2(function _xtake(n, xf) {\n\t            return new XTake(n, xf);\n\t        });\n\t    }();\n\t\n\t    var _xtakeWhile = function () {\n\t        function XTakeWhile(f, xf) {\n\t            this.xf = xf;\n\t            this.f = f;\n\t        }\n\t        XTakeWhile.prototype['@@transducer/init'] = _xfBase.init;\n\t        XTakeWhile.prototype['@@transducer/result'] = _xfBase.result;\n\t        XTakeWhile.prototype['@@transducer/step'] = function (result, input) {\n\t            return this.f(input) ? this.xf['@@transducer/step'](result, input) : _reduced(result);\n\t        };\n\t        return _curry2(function _xtakeWhile(f, xf) {\n\t            return new XTakeWhile(f, xf);\n\t        });\n\t    }();\n\t\n\t    /**\n\t     * Adds two numbers. Equivalent to `a + b` but curried.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @since v0.1.0\n\t     * @category Math\n\t     * @sig Number -> Number -> Number\n\t     * @param {Number} a\n\t     * @param {Number} b\n\t     * @return {Number}\n\t     * @see R.subtract\n\t     * @example\n\t     *\n\t     *      R.add(2, 3);       //=>  5\n\t     *      R.add(7)(10);      //=> 17\n\t     */\n\t    var add = _curry2(function add(a, b) {\n\t        return a + b;\n\t    });\n\t\n\t    /**\n\t     * Applies a function to the value at the given index of an array, returning a\n\t     * new copy of the array with the element at the given index replaced with the\n\t     * result of the function application.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @since v0.14.0\n\t     * @category List\n\t     * @sig (a -> a) -> Number -> [a] -> [a]\n\t     * @param {Function} fn The function to apply.\n\t     * @param {Number} idx The index.\n\t     * @param {Array|Arguments} list An array-like object whose value\n\t     *        at the supplied index will be replaced.\n\t     * @return {Array} A copy of the supplied array-like object with\n\t     *         the element at index `idx` replaced with the value\n\t     *         returned by applying `fn` to the existing element.\n\t     * @see R.update\n\t     * @example\n\t     *\n\t     *      R.adjust(R.add(10), 1, [0, 1, 2]);     //=> [0, 11, 2]\n\t     *      R.adjust(R.add(10))(1)([0, 1, 2]);     //=> [0, 11, 2]\n\t     */\n\t    var adjust = _curry3(function adjust(fn, idx, list) {\n\t        if (idx >= list.length || idx < -list.length) {\n\t            return list;\n\t        }\n\t        var start = idx < 0 ? list.length : 0;\n\t        var _idx = start + idx;\n\t        var _list = _concat(list);\n\t        _list[_idx] = fn(list[_idx]);\n\t        return _list;\n\t    });\n\t\n\t    /**\n\t     * Returns `true` if all elements of the list match the predicate, `false` if\n\t     * there are any that don't.\n\t     *\n\t     * Dispatches to the `all` method of the second argument, if present.\n\t     *\n\t     * Acts as a transducer if a transformer is given in list position.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @since v0.1.0\n\t     * @category List\n\t     * @sig (a -> Boolean) -> [a] -> Boolean\n\t     * @param {Function} fn The predicate function.\n\t     * @param {Array} list The array to consider.\n\t     * @return {Boolean} `true` if the predicate is satisfied by every element, `false`\n\t     *         otherwise.\n\t     * @see R.any, R.none, R.transduce\n\t     * @example\n\t     *\n\t     *      var lessThan2 = R.flip(R.lt)(2);\n\t     *      var lessThan3 = R.flip(R.lt)(3);\n\t     *      R.all(lessThan2)([1, 2]); //=> false\n\t     *      R.all(lessThan3)([1, 2]); //=> true\n\t     */\n\t    var all = _curry2(_dispatchable('all', _xall, function all(fn, list) {\n\t        var idx = 0;\n\t        while (idx < list.length) {\n\t            if (!fn(list[idx])) {\n\t                return false;\n\t            }\n\t            idx += 1;\n\t        }\n\t        return true;\n\t    }));\n\t\n\t    /**\n\t     * Returns a function that always returns the given value. Note that for\n\t     * non-primitives the value returned is a reference to the original value.\n\t     *\n\t     * This function is known as `const`, `constant`, or `K` (for K combinator) in\n\t     * other languages and libraries.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @since v0.1.0\n\t     * @category Function\n\t     * @sig a -> (* -> a)\n\t     * @param {*} val The value to wrap in a function\n\t     * @return {Function} A Function :: * -> val.\n\t     * @example\n\t     *\n\t     *      var t = R.always('Tee');\n\t     *      t(); //=> 'Tee'\n\t     */\n\t    var always = _curry1(function always(val) {\n\t        return function () {\n\t            return val;\n\t        };\n\t    });\n\t\n\t    /**\n\t     * Returns `true` if both arguments are `true`; `false` otherwise.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @since v0.1.0\n\t     * @category Logic\n\t     * @sig * -> * -> *\n\t     * @param {Boolean} a A boolean value\n\t     * @param {Boolean} b A boolean value\n\t     * @return {Boolean} `true` if both arguments are `true`, `false` otherwise\n\t     * @see R.both\n\t     * @example\n\t     *\n\t     *      R.and(true, true); //=> true\n\t     *      R.and(true, false); //=> false\n\t     *      R.and(false, true); //=> false\n\t     *      R.and(false, false); //=> false\n\t     */\n\t    var and = _curry2(function and(a, b) {\n\t        return a && b;\n\t    });\n\t\n\t    /**\n\t     * Returns `true` if at least one of elements of the list match the predicate,\n\t     * `false` otherwise.\n\t     *\n\t     * Dispatches to the `any` method of the second argument, if present.\n\t     *\n\t     * Acts as a transducer if a transformer is given in list position.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @since v0.1.0\n\t     * @category List\n\t     * @sig (a -> Boolean) -> [a] -> Boolean\n\t     * @param {Function} fn The predicate function.\n\t     * @param {Array} list The array to consider.\n\t     * @return {Boolean} `true` if the predicate is satisfied by at least one element, `false`\n\t     *         otherwise.\n\t     * @see R.all, R.none, R.transduce\n\t     * @example\n\t     *\n\t     *      var lessThan0 = R.flip(R.lt)(0);\n\t     *      var lessThan2 = R.flip(R.lt)(2);\n\t     *      R.any(lessThan0)([1, 2]); //=> false\n\t     *      R.any(lessThan2)([1, 2]); //=> true\n\t     */\n\t    var any = _curry2(_dispatchable('any', _xany, function any(fn, list) {\n\t        var idx = 0;\n\t        while (idx < list.length) {\n\t            if (fn(list[idx])) {\n\t                return true;\n\t            }\n\t            idx += 1;\n\t        }\n\t        return false;\n\t    }));\n\t\n\t    /**\n\t     * Returns a new list, composed of n-tuples of consecutive elements If `n` is\n\t     * greater than the length of the list, an empty list is returned.\n\t     *\n\t     * Dispatches to the `aperture` method of the second argument, if present.\n\t     *\n\t     * Acts as a transducer if a transformer is given in list position.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @since v0.12.0\n\t     * @category List\n\t     * @sig Number -> [a] -> [[a]]\n\t     * @param {Number} n The size of the tuples to create\n\t     * @param {Array} list The list to split into `n`-tuples\n\t     * @return {Array} The new list.\n\t     * @see R.transduce\n\t     * @example\n\t     *\n\t     *      R.aperture(2, [1, 2, 3, 4, 5]); //=> [[1, 2], [2, 3], [3, 4], [4, 5]]\n\t     *      R.aperture(3, [1, 2, 3, 4, 5]); //=> [[1, 2, 3], [2, 3, 4], [3, 4, 5]]\n\t     *      R.aperture(7, [1, 2, 3, 4, 5]); //=> []\n\t     */\n\t    var aperture = _curry2(_dispatchable('aperture', _xaperture, _aperture));\n\t\n\t    /**\n\t     * Returns a new list containing the contents of the given list, followed by\n\t     * the given element.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @since v0.1.0\n\t     * @category List\n\t     * @sig a -> [a] -> [a]\n\t     * @param {*} el The element to add to the end of the new list.\n\t     * @param {Array} list The list whose contents will be added to the beginning of the output\n\t     *        list.\n\t     * @return {Array} A new list containing the contents of the old list followed by `el`.\n\t     * @see R.prepend\n\t     * @example\n\t     *\n\t     *      R.append('tests', ['write', 'more']); //=> ['write', 'more', 'tests']\n\t     *      R.append('tests', []); //=> ['tests']\n\t     *      R.append(['tests'], ['write', 'more']); //=> ['write', 'more', ['tests']]\n\t     */\n\t    var append = _curry2(function append(el, list) {\n\t        return _concat(list, [el]);\n\t    });\n\t\n\t    /**\n\t     * Applies function `fn` to the argument list `args`. This is useful for\n\t     * creating a fixed-arity function from a variadic function. `fn` should be a\n\t     * bound function if context is significant.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @since v0.7.0\n\t     * @category Function\n\t     * @sig (*... -> a) -> [*] -> a\n\t     * @param {Function} fn\n\t     * @param {Array} args\n\t     * @return {*}\n\t     * @see R.call, R.unapply\n\t     * @example\n\t     *\n\t     *      var nums = [1, 2, 3, -99, 42, 6, 7];\n\t     *      R.apply(Math.max, nums); //=> 42\n\t     */\n\t    var apply = _curry2(function apply(fn, args) {\n\t        return fn.apply(this, args);\n\t    });\n\t\n\t    /**\n\t     * Makes a shallow clone of an object, setting or overriding the specified\n\t     * property with the given value. Note that this copies and flattens prototype\n\t     * properties onto the new object as well. All non-primitive properties are\n\t     * copied by reference.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @since v0.8.0\n\t     * @category Object\n\t     * @sig String -> a -> {k: v} -> {k: v}\n\t     * @param {String} prop the property name to set\n\t     * @param {*} val the new value\n\t     * @param {Object} obj the object to clone\n\t     * @return {Object} a new object similar to the original except for the specified property.\n\t     * @see R.dissoc\n\t     * @example\n\t     *\n\t     *      R.assoc('c', 3, {a: 1, b: 2}); //=> {a: 1, b: 2, c: 3}\n\t     */\n\t    var assoc = _curry3(function assoc(prop, val, obj) {\n\t        var result = {};\n\t        for (var p in obj) {\n\t            result[p] = obj[p];\n\t        }\n\t        result[prop] = val;\n\t        return result;\n\t    });\n\t\n\t    /**\n\t     * Makes a shallow clone of an object, setting or overriding the nodes required\n\t     * to create the given path, and placing the specific value at the tail end of\n\t     * that path. Note that this copies and flattens prototype properties onto the\n\t     * new object as well. All non-primitive properties are copied by reference.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @since v0.8.0\n\t     * @category Object\n\t     * @sig [String] -> a -> {k: v} -> {k: v}\n\t     * @param {Array} path the path to set\n\t     * @param {*} val the new value\n\t     * @param {Object} obj the object to clone\n\t     * @return {Object} a new object similar to the original except along the specified path.\n\t     * @see R.dissocPath\n\t     * @example\n\t     *\n\t     *      R.assocPath(['a', 'b', 'c'], 42, {a: {b: {c: 0}}}); //=> {a: {b: {c: 42}}}\n\t     */\n\t    var assocPath = _curry3(function assocPath(path, val, obj) {\n\t        switch (path.length) {\n\t        case 0:\n\t            return val;\n\t        case 1:\n\t            return assoc(path[0], val, obj);\n\t        default:\n\t            return assoc(path[0], assocPath(_slice(path, 1), val, Object(obj[path[0]])), obj);\n\t        }\n\t    });\n\t\n\t    /**\n\t     * Creates a function that is bound to a context.\n\t     * Note: `R.bind` does not provide the additional argument-binding capabilities of\n\t     * [Function.prototype.bind](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/bind).\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @since v0.6.0\n\t     * @category Function\n\t     * @category Object\n\t     * @sig (* -> *) -> {*} -> (* -> *)\n\t     * @param {Function} fn The function to bind to context\n\t     * @param {Object} thisObj The context to bind `fn` to\n\t     * @return {Function} A function that will execute in the context of `thisObj`.\n\t     * @see R.partial\n\t     */\n\t    var bind = _curry2(function bind(fn, thisObj) {\n\t        return _arity(fn.length, function () {\n\t            return fn.apply(thisObj, arguments);\n\t        });\n\t    });\n\t\n\t    /**\n\t     * A function wrapping calls to the two functions in an `&&` operation,\n\t     * returning the result of the first function if it is false-y and the result\n\t     * of the second function otherwise. Note that this is short-circuited,\n\t     * meaning that the second function will not be invoked if the first returns a\n\t     * false-y value.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @since v0.12.0\n\t     * @category Logic\n\t     * @sig (*... -> Boolean) -> (*... -> Boolean) -> (*... -> Boolean)\n\t     * @param {Function} f a predicate\n\t     * @param {Function} g another predicate\n\t     * @return {Function} a function that applies its arguments to `f` and `g` and `&&`s their outputs together.\n\t     * @see R.and\n\t     * @example\n\t     *\n\t     *      var gt10 = x => x > 10;\n\t     *      var even = x => x % 2 === 0;\n\t     *      var f = R.both(gt10, even);\n\t     *      f(100); //=> true\n\t     *      f(101); //=> false\n\t     */\n\t    var both = _curry2(function both(f, g) {\n\t        return function _both() {\n\t            return f.apply(this, arguments) && g.apply(this, arguments);\n\t        };\n\t    });\n\t\n\t    /**\n\t     * Makes a comparator function out of a function that reports whether the first\n\t     * element is less than the second.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @since v0.1.0\n\t     * @category Function\n\t     * @sig (a, b -> Boolean) -> (a, b -> Number)\n\t     * @param {Function} pred A predicate function of arity two.\n\t     * @return {Function} A Function :: a -> b -> Int that returns `-1` if a < b, `1` if b < a, otherwise `0`.\n\t     * @example\n\t     *\n\t     *      var cmp = R.comparator((a, b) => a.age < b.age);\n\t     *      var people = [\n\t     *        // ...\n\t     *      ];\n\t     *      R.sort(cmp, people);\n\t     */\n\t    var comparator = _curry1(function comparator(pred) {\n\t        return function (a, b) {\n\t            return pred(a, b) ? -1 : pred(b, a) ? 1 : 0;\n\t        };\n\t    });\n\t\n\t    /**\n\t     * Returns a function, `fn`, which encapsulates if/else-if/else logic.\n\t     * `R.cond` takes a list of [predicate, transform] pairs. All of the arguments\n\t     * to `fn` are applied to each of the predicates in turn until one returns a\n\t     * \"truthy\" value, at which point `fn` returns the result of applying its\n\t     * arguments to the corresponding transformer. If none of the predicates\n\t     * matches, `fn` returns undefined.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @since v0.6.0\n\t     * @category Logic\n\t     * @sig [[(*... -> Boolean),(*... -> *)]] -> (*... -> *)\n\t     * @param {Array} pairs\n\t     * @return {Function}\n\t     * @example\n\t     *\n\t     *      var fn = R.cond([\n\t     *        [R.equals(0),   R.always('water freezes at 0°C')],\n\t     *        [R.equals(100), R.always('water boils at 100°C')],\n\t     *        [R.T,           temp => 'nothing special happens at ' + temp + '°C']\n\t     *      ]);\n\t     *      fn(0); //=> 'water freezes at 0°C'\n\t     *      fn(50); //=> 'nothing special happens at 50°C'\n\t     *      fn(100); //=> 'water boils at 100°C'\n\t     */\n\t    var cond = _curry1(function cond(pairs) {\n\t        return function () {\n\t            var idx = 0;\n\t            while (idx < pairs.length) {\n\t                if (pairs[idx][0].apply(this, arguments)) {\n\t                    return pairs[idx][1].apply(this, arguments);\n\t                }\n\t                idx += 1;\n\t            }\n\t        };\n\t    });\n\t\n\t    /**\n\t     * Counts the elements of a list according to how many match each value of a\n\t     * key generated by the supplied function. Returns an object mapping the keys\n\t     * produced by `fn` to the number of occurrences in the list. Note that all\n\t     * keys are coerced to strings because of how JavaScript objects work.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @since v0.1.0\n\t     * @category Relation\n\t     * @sig (a -> String) -> [a] -> {*}\n\t     * @param {Function} fn The function used to map values to keys.\n\t     * @param {Array} list The list to count elements from.\n\t     * @return {Object} An object mapping keys to number of occurrences in the list.\n\t     * @example\n\t     *\n\t     *      var numbers = [1.0, 1.1, 1.2, 2.0, 3.0, 2.2];\n\t     *      var letters = R.split('', 'abcABCaaaBBc');\n\t     *      R.countBy(Math.floor)(numbers);    //=> {'1': 3, '2': 2, '3': 1}\n\t     *      R.countBy(R.toLower)(letters);   //=> {'a': 5, 'b': 4, 'c': 3}\n\t     */\n\t    var countBy = _curry2(function countBy(fn, list) {\n\t        var counts = {};\n\t        var len = list.length;\n\t        var idx = 0;\n\t        while (idx < len) {\n\t            var key = fn(list[idx]);\n\t            counts[key] = (_has(key, counts) ? counts[key] : 0) + 1;\n\t            idx += 1;\n\t        }\n\t        return counts;\n\t    });\n\t\n\t    /**\n\t     * Returns a curried equivalent of the provided function, with the specified\n\t     * arity. The curried function has two unusual capabilities. First, its\n\t     * arguments needn't be provided one at a time. If `g` is `R.curryN(3, f)`, the\n\t     * following are equivalent:\n\t     *\n\t     *   - `g(1)(2)(3)`\n\t     *   - `g(1)(2, 3)`\n\t     *   - `g(1, 2)(3)`\n\t     *   - `g(1, 2, 3)`\n\t     *\n\t     * Secondly, the special placeholder value `R.__` may be used to specify\n\t     * \"gaps\", allowing partial application of any combination of arguments,\n\t     * regardless of their positions. If `g` is as above and `_` is `R.__`, the\n\t     * following are equivalent:\n\t     *\n\t     *   - `g(1, 2, 3)`\n\t     *   - `g(_, 2, 3)(1)`\n\t     *   - `g(_, _, 3)(1)(2)`\n\t     *   - `g(_, _, 3)(1, 2)`\n\t     *   - `g(_, 2)(1)(3)`\n\t     *   - `g(_, 2)(1, 3)`\n\t     *   - `g(_, 2)(_, 3)(1)`\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @since v0.5.0\n\t     * @category Function\n\t     * @sig Number -> (* -> a) -> (* -> a)\n\t     * @param {Number} length The arity for the returned function.\n\t     * @param {Function} fn The function to curry.\n\t     * @return {Function} A new, curried function.\n\t     * @see R.curry\n\t     * @example\n\t     *\n\t     *      var sumArgs = (...args) => R.sum(args);\n\t     *\n\t     *      var curriedAddFourNumbers = R.curryN(4, sumArgs);\n\t     *      var f = curriedAddFourNumbers(1, 2);\n\t     *      var g = f(3);\n\t     *      g(4); //=> 10\n\t     */\n\t    var curryN = _curry2(function curryN(length, fn) {\n\t        if (length === 1) {\n\t            return _curry1(fn);\n\t        }\n\t        return _arity(length, _curryN(length, [], fn));\n\t    });\n\t\n\t    /**\n\t     * Decrements its argument.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @since v0.9.0\n\t     * @category Math\n\t     * @sig Number -> Number\n\t     * @param {Number} n\n\t     * @return {Number}\n\t     * @see R.inc\n\t     * @example\n\t     *\n\t     *      R.dec(42); //=> 41\n\t     */\n\t    var dec = add(-1);\n\t\n\t    /**\n\t     * Returns the second argument if it is not `null`, `undefined` or `NaN`\n\t     * otherwise the first argument is returned.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @since v0.10.0\n\t     * @category Logic\n\t     * @sig a -> b -> a | b\n\t     * @param {a} val The default value.\n\t     * @param {b} val The value to return if it is not null or undefined\n\t     * @return {*} The the second value or the default value\n\t     * @example\n\t     *\n\t     *      var defaultTo42 = R.defaultTo(42);\n\t     *\n\t     *      defaultTo42(null);  //=> 42\n\t     *      defaultTo42(undefined);  //=> 42\n\t     *      defaultTo42('Ramda');  //=> 'Ramda'\n\t     *      defaultTo42(parseInt('string')); //=> 42\n\t     */\n\t    var defaultTo = _curry2(function defaultTo(d, v) {\n\t        return v == null || v !== v ? d : v;\n\t    });\n\t\n\t    /**\n\t     * Finds the set (i.e. no duplicates) of all elements in the first list not\n\t     * contained in the second list. Duplication is determined according to the\n\t     * value returned by applying the supplied predicate to two list elements.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @since v0.1.0\n\t     * @category Relation\n\t     * @sig (a -> a -> Boolean) -> [*] -> [*] -> [*]\n\t     * @param {Function} pred A predicate used to test whether two items are equal.\n\t     * @param {Array} list1 The first list.\n\t     * @param {Array} list2 The second list.\n\t     * @return {Array} The elements in `list1` that are not in `list2`.\n\t     * @see R.difference\n\t     * @example\n\t     *\n\t     *      function cmp(x, y) => x.a === y.a;\n\t     *      var l1 = [{a: 1}, {a: 2}, {a: 3}];\n\t     *      var l2 = [{a: 3}, {a: 4}];\n\t     *      R.differenceWith(cmp, l1, l2); //=> [{a: 1}, {a: 2}]\n\t     */\n\t    var differenceWith = _curry3(function differenceWith(pred, first, second) {\n\t        var out = [];\n\t        var idx = 0;\n\t        var firstLen = first.length;\n\t        while (idx < firstLen) {\n\t            if (!_containsWith(pred, first[idx], second) && !_containsWith(pred, first[idx], out)) {\n\t                out.push(first[idx]);\n\t            }\n\t            idx += 1;\n\t        }\n\t        return out;\n\t    });\n\t\n\t    /**\n\t     * Returns a new object that does not contain a `prop` property.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @since v0.10.0\n\t     * @category Object\n\t     * @sig String -> {k: v} -> {k: v}\n\t     * @param {String} prop the name of the property to dissociate\n\t     * @param {Object} obj the object to clone\n\t     * @return {Object} a new object similar to the original but without the specified property\n\t     * @see R.assoc\n\t     * @example\n\t     *\n\t     *      R.dissoc('b', {a: 1, b: 2, c: 3}); //=> {a: 1, c: 3}\n\t     */\n\t    var dissoc = _curry2(function dissoc(prop, obj) {\n\t        var result = {};\n\t        for (var p in obj) {\n\t            if (p !== prop) {\n\t                result[p] = obj[p];\n\t            }\n\t        }\n\t        return result;\n\t    });\n\t\n\t    /**\n\t     * Makes a shallow clone of an object, omitting the property at the given path.\n\t     * Note that this copies and flattens prototype properties onto the new object\n\t     * as well. All non-primitive properties are copied by reference.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @since v0.11.0\n\t     * @category Object\n\t     * @sig [String] -> {k: v} -> {k: v}\n\t     * @param {Array} path the path to set\n\t     * @param {Object} obj the object to clone\n\t     * @return {Object} a new object without the property at path\n\t     * @see R.assocPath\n\t     * @example\n\t     *\n\t     *      R.dissocPath(['a', 'b', 'c'], {a: {b: {c: 42}}}); //=> {a: {b: {}}}\n\t     */\n\t    var dissocPath = _curry2(function dissocPath(path, obj) {\n\t        switch (path.length) {\n\t        case 0:\n\t            return obj;\n\t        case 1:\n\t            return dissoc(path[0], obj);\n\t        default:\n\t            var head = path[0];\n\t            var tail = _slice(path, 1);\n\t            return obj[head] == null ? obj : assoc(head, dissocPath(tail, obj[head]), obj);\n\t        }\n\t    });\n\t\n\t    /**\n\t     * Divides two numbers. Equivalent to `a / b`.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @since v0.1.0\n\t     * @category Math\n\t     * @sig Number -> Number -> Number\n\t     * @param {Number} a The first value.\n\t     * @param {Number} b The second value.\n\t     * @return {Number} The result of `a / b`.\n\t     * @see R.multiply\n\t     * @example\n\t     *\n\t     *      R.divide(71, 100); //=> 0.71\n\t     *\n\t     *      var half = R.divide(R.__, 2);\n\t     *      half(42); //=> 21\n\t     *\n\t     *      var reciprocal = R.divide(1);\n\t     *      reciprocal(4);   //=> 0.25\n\t     */\n\t    var divide = _curry2(function divide(a, b) {\n\t        return a / b;\n\t    });\n\t\n\t    /**\n\t     * Returns a new list containing the last `n` elements of a given list, passing\n\t     * each value to the supplied predicate function, skipping elements while the\n\t     * predicate function returns `true`. The predicate function is passed one\n\t     * argument: *(value)*.\n\t     *\n\t     * Dispatches to the `dropWhile` method of the second argument, if present.\n\t     *\n\t     * Acts as a transducer if a transformer is given in list position.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @since v0.9.0\n\t     * @category List\n\t     * @sig (a -> Boolean) -> [a] -> [a]\n\t     * @param {Function} fn The function called per iteration.\n\t     * @param {Array} list The collection to iterate over.\n\t     * @return {Array} A new array.\n\t     * @see R.takeWhile, R.transduce, R.addIndex\n\t     * @example\n\t     *\n\t     *      var lteTwo = x => x <= 2;\n\t     *\n\t     *      R.dropWhile(lteTwo, [1, 2, 3, 4, 3, 2, 1]); //=> [3, 4, 3, 2, 1]\n\t     */\n\t    var dropWhile = _curry2(_dispatchable('dropWhile', _xdropWhile, function dropWhile(pred, list) {\n\t        var idx = 0;\n\t        var len = list.length;\n\t        while (idx < len && pred(list[idx])) {\n\t            idx += 1;\n\t        }\n\t        return _slice(list, idx);\n\t    }));\n\t\n\t    /**\n\t     * A function wrapping calls to the two functions in an `||` operation,\n\t     * returning the result of the first function if it is truth-y and the result\n\t     * of the second function otherwise. Note that this is short-circuited,\n\t     * meaning that the second function will not be invoked if the first returns a\n\t     * truth-y value.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @since v0.12.0\n\t     * @category Logic\n\t     * @sig (*... -> Boolean) -> (*... -> Boolean) -> (*... -> Boolean)\n\t     * @param {Function} f a predicate\n\t     * @param {Function} g another predicate\n\t     * @return {Function} a function that applies its arguments to `f` and `g` and `||`s their outputs together.\n\t     * @see R.or\n\t     * @example\n\t     *\n\t     *      var gt10 = x => x > 10;\n\t     *      var even = x => x % 2 === 0;\n\t     *      var f = R.either(gt10, even);\n\t     *      f(101); //=> true\n\t     *      f(8); //=> true\n\t     */\n\t    var either = _curry2(function either(f, g) {\n\t        return function _either() {\n\t            return f.apply(this, arguments) || g.apply(this, arguments);\n\t        };\n\t    });\n\t\n\t    /**\n\t     * Returns the empty value of its argument's type. Ramda defines the empty\n\t     * value of Array (`[]`), Object (`{}`), String (`''`), and Arguments. Other\n\t     * types are supported if they define `<Type>.empty` and/or\n\t     * `<Type>.prototype.empty`.\n\t     *\n\t     * Dispatches to the `empty` method of the first argument, if present.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @since v0.3.0\n\t     * @category Function\n\t     * @sig a -> a\n\t     * @param {*} x\n\t     * @return {*}\n\t     * @example\n\t     *\n\t     *      R.empty(Just(42));      //=> Nothing()\n\t     *      R.empty([1, 2, 3]);     //=> []\n\t     *      R.empty('unicorns');    //=> ''\n\t     *      R.empty({x: 1, y: 2});  //=> {}\n\t     */\n\t    // else\n\t    var empty = _curry1(function empty(x) {\n\t        return x != null && typeof x.empty === 'function' ? x.empty() : x != null && x.constructor != null && typeof x.constructor.empty === 'function' ? x.constructor.empty() : _isArray(x) ? [] : _isString(x) ? '' : _isObject(x) ? {} : _isArguments(x) ? function () {\n\t            return arguments;\n\t        }() : // else\n\t        void 0;\n\t    });\n\t\n\t    /**\n\t     * Creates a new object by recursively evolving a shallow copy of `object`,\n\t     * according to the `transformation` functions. All non-primitive properties\n\t     * are copied by reference.\n\t     *\n\t     * A `transformation` function will not be invoked if its corresponding key\n\t     * does not exist in the evolved object.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @since v0.9.0\n\t     * @category Object\n\t     * @sig {k: (v -> v)} -> {k: v} -> {k: v}\n\t     * @param {Object} transformations The object specifying transformation functions to apply\n\t     *        to the object.\n\t     * @param {Object} object The object to be transformed.\n\t     * @return {Object} The transformed object.\n\t     * @example\n\t     *\n\t     *      var tomato  = {firstName: '  Tomato ', data: {elapsed: 100, remaining: 1400}, id:123};\n\t     *      var transformations = {\n\t     *        firstName: R.trim,\n\t     *        lastName: R.trim, // Will not get invoked.\n\t     *        data: {elapsed: R.add(1), remaining: R.add(-1)}\n\t     *      };\n\t     *      R.evolve(transformations, tomato); //=> {firstName: 'Tomato', data: {elapsed: 101, remaining: 1399}, id:123}\n\t     */\n\t    var evolve = _curry2(function evolve(transformations, object) {\n\t        var result = {};\n\t        var transformation, key, type;\n\t        for (key in object) {\n\t            transformation = transformations[key];\n\t            type = typeof transformation;\n\t            result[key] = type === 'function' ? transformation(object[key]) : type === 'object' ? evolve(transformations[key], object[key]) : object[key];\n\t        }\n\t        return result;\n\t    });\n\t\n\t    /**\n\t     * Returns the first element of the list which matches the predicate, or\n\t     * `undefined` if no element matches.\n\t     *\n\t     * Dispatches to the `find` method of the second argument, if present.\n\t     *\n\t     * Acts as a transducer if a transformer is given in list position.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @since v0.1.0\n\t     * @category List\n\t     * @sig (a -> Boolean) -> [a] -> a | undefined\n\t     * @param {Function} fn The predicate function used to determine if the element is the\n\t     *        desired one.\n\t     * @param {Array} list The array to consider.\n\t     * @return {Object} The element found, or `undefined`.\n\t     * @see R.transduce\n\t     * @example\n\t     *\n\t     *      var xs = [{a: 1}, {a: 2}, {a: 3}];\n\t     *      R.find(R.propEq('a', 2))(xs); //=> {a: 2}\n\t     *      R.find(R.propEq('a', 4))(xs); //=> undefined\n\t     */\n\t    var find = _curry2(_dispatchable('find', _xfind, function find(fn, list) {\n\t        var idx = 0;\n\t        var len = list.length;\n\t        while (idx < len) {\n\t            if (fn(list[idx])) {\n\t                return list[idx];\n\t            }\n\t            idx += 1;\n\t        }\n\t    }));\n\t\n\t    /**\n\t     * Returns the index of the first element of the list which matches the\n\t     * predicate, or `-1` if no element matches.\n\t     *\n\t     * Dispatches to the `findIndex` method of the second argument, if present.\n\t     *\n\t     * Acts as a transducer if a transformer is given in list position.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @since v0.1.1\n\t     * @category List\n\t     * @sig (a -> Boolean) -> [a] -> Number\n\t     * @param {Function} fn The predicate function used to determine if the element is the\n\t     * desired one.\n\t     * @param {Array} list The array to consider.\n\t     * @return {Number} The index of the element found, or `-1`.\n\t     * @see R.transduce\n\t     * @example\n\t     *\n\t     *      var xs = [{a: 1}, {a: 2}, {a: 3}];\n\t     *      R.findIndex(R.propEq('a', 2))(xs); //=> 1\n\t     *      R.findIndex(R.propEq('a', 4))(xs); //=> -1\n\t     */\n\t    var findIndex = _curry2(_dispatchable('findIndex', _xfindIndex, function findIndex(fn, list) {\n\t        var idx = 0;\n\t        var len = list.length;\n\t        while (idx < len) {\n\t            if (fn(list[idx])) {\n\t                return idx;\n\t            }\n\t            idx += 1;\n\t        }\n\t        return -1;\n\t    }));\n\t\n\t    /**\n\t     * Returns the last element of the list which matches the predicate, or\n\t     * `undefined` if no element matches.\n\t     *\n\t     * Dispatches to the `findLast` method of the second argument, if present.\n\t     *\n\t     * Acts as a transducer if a transformer is given in list position.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @since v0.1.1\n\t     * @category List\n\t     * @sig (a -> Boolean) -> [a] -> a | undefined\n\t     * @param {Function} fn The predicate function used to determine if the element is the\n\t     * desired one.\n\t     * @param {Array} list The array to consider.\n\t     * @return {Object} The element found, or `undefined`.\n\t     * @see R.transduce\n\t     * @example\n\t     *\n\t     *      var xs = [{a: 1, b: 0}, {a:1, b: 1}];\n\t     *      R.findLast(R.propEq('a', 1))(xs); //=> {a: 1, b: 1}\n\t     *      R.findLast(R.propEq('a', 4))(xs); //=> undefined\n\t     */\n\t    var findLast = _curry2(_dispatchable('findLast', _xfindLast, function findLast(fn, list) {\n\t        var idx = list.length - 1;\n\t        while (idx >= 0) {\n\t            if (fn(list[idx])) {\n\t                return list[idx];\n\t            }\n\t            idx -= 1;\n\t        }\n\t    }));\n\t\n\t    /**\n\t     * Returns the index of the last element of the list which matches the\n\t     * predicate, or `-1` if no element matches.\n\t     *\n\t     * Dispatches to the `findLastIndex` method of the second argument, if present.\n\t     *\n\t     * Acts as a transducer if a transformer is given in list position.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @since v0.1.1\n\t     * @category List\n\t     * @sig (a -> Boolean) -> [a] -> Number\n\t     * @param {Function} fn The predicate function used to determine if the element is the\n\t     * desired one.\n\t     * @param {Array} list The array to consider.\n\t     * @return {Number} The index of the element found, or `-1`.\n\t     * @see R.transduce\n\t     * @example\n\t     *\n\t     *      var xs = [{a: 1, b: 0}, {a:1, b: 1}];\n\t     *      R.findLastIndex(R.propEq('a', 1))(xs); //=> 1\n\t     *      R.findLastIndex(R.propEq('a', 4))(xs); //=> -1\n\t     */\n\t    var findLastIndex = _curry2(_dispatchable('findLastIndex', _xfindLastIndex, function findLastIndex(fn, list) {\n\t        var idx = list.length - 1;\n\t        while (idx >= 0) {\n\t            if (fn(list[idx])) {\n\t                return idx;\n\t            }\n\t            idx -= 1;\n\t        }\n\t        return -1;\n\t    }));\n\t\n\t    /**\n\t     * Iterate over an input `list`, calling a provided function `fn` for each\n\t     * element in the list.\n\t     *\n\t     * `fn` receives one argument: *(value)*.\n\t     *\n\t     * Note: `R.forEach` does not skip deleted or unassigned indices (sparse\n\t     * arrays), unlike the native `Array.prototype.forEach` method. For more\n\t     * details on this behavior, see:\n\t     * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach#Description\n\t     *\n\t     * Also note that, unlike `Array.prototype.forEach`, Ramda's `forEach` returns\n\t     * the original array. In some libraries this function is named `each`.\n\t     *\n\t     * Dispatches to the `forEach` method of the second argument, if present.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @since v0.1.1\n\t     * @category List\n\t     * @sig (a -> *) -> [a] -> [a]\n\t     * @param {Function} fn The function to invoke. Receives one argument, `value`.\n\t     * @param {Array} list The list to iterate over.\n\t     * @return {Array} The original list.\n\t     * @see R.addIndex\n\t     * @example\n\t     *\n\t     *      var printXPlusFive = x => console.log(x + 5);\n\t     *      R.forEach(printXPlusFive, [1, 2, 3]); //=> [1, 2, 3]\n\t     *      //-> 6\n\t     *      //-> 7\n\t     *      //-> 8\n\t     */\n\t    var forEach = _curry2(_checkForMethod('forEach', function forEach(fn, list) {\n\t        var len = list.length;\n\t        var idx = 0;\n\t        while (idx < len) {\n\t            fn(list[idx]);\n\t            idx += 1;\n\t        }\n\t        return list;\n\t    }));\n\t\n\t    /**\n\t     * Creates a new object out of a list key-value pairs.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @since v0.3.0\n\t     * @category List\n\t     * @sig [[k,v]] -> {k: v}\n\t     * @param {Array} pairs An array of two-element arrays that will be the keys and values of the output object.\n\t     * @return {Object} The object made by pairing up `keys` and `values`.\n\t     * @see R.toPairs, R.pair\n\t     * @example\n\t     *\n\t     *      R.fromPairs([['a', 1], ['b', 2],  ['c', 3]]); //=> {a: 1, b: 2, c: 3}\n\t     */\n\t    var fromPairs = _curry1(function fromPairs(pairs) {\n\t        var idx = 0;\n\t        var len = pairs.length;\n\t        var out = {};\n\t        while (idx < len) {\n\t            if (_isArray(pairs[idx]) && pairs[idx].length) {\n\t                out[pairs[idx][0]] = pairs[idx][1];\n\t            }\n\t            idx += 1;\n\t        }\n\t        return out;\n\t    });\n\t\n\t    /**\n\t     * Returns `true` if the first argument is greater than the second; `false`\n\t     * otherwise.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @since v0.1.0\n\t     * @category Relation\n\t     * @sig Ord a => a -> a -> Boolean\n\t     * @param {*} a\n\t     * @param {*} b\n\t     * @return {Boolean}\n\t     * @see R.lt\n\t     * @example\n\t     *\n\t     *      R.gt(2, 1); //=> true\n\t     *      R.gt(2, 2); //=> false\n\t     *      R.gt(2, 3); //=> false\n\t     *      R.gt('a', 'z'); //=> false\n\t     *      R.gt('z', 'a'); //=> true\n\t     */\n\t    var gt = _curry2(function gt(a, b) {\n\t        return a > b;\n\t    });\n\t\n\t    /**\n\t     * Returns `true` if the first argument is greater than or equal to the second;\n\t     * `false` otherwise.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @since v0.1.0\n\t     * @category Relation\n\t     * @sig Ord a => a -> a -> Boolean\n\t     * @param {Number} a\n\t     * @param {Number} b\n\t     * @return {Boolean}\n\t     * @see R.lte\n\t     * @example\n\t     *\n\t     *      R.gte(2, 1); //=> true\n\t     *      R.gte(2, 2); //=> true\n\t     *      R.gte(2, 3); //=> false\n\t     *      R.gte('a', 'z'); //=> false\n\t     *      R.gte('z', 'a'); //=> true\n\t     */\n\t    var gte = _curry2(function gte(a, b) {\n\t        return a >= b;\n\t    });\n\t\n\t    /**\n\t     * Returns whether or not an object has an own property with the specified name\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @since v0.7.0\n\t     * @category Object\n\t     * @sig s -> {s: x} -> Boolean\n\t     * @param {String} prop The name of the property to check for.\n\t     * @param {Object} obj The object to query.\n\t     * @return {Boolean} Whether the property exists.\n\t     * @example\n\t     *\n\t     *      var hasName = R.has('name');\n\t     *      hasName({name: 'alice'});   //=> true\n\t     *      hasName({name: 'bob'});     //=> true\n\t     *      hasName({});                //=> false\n\t     *\n\t     *      var point = {x: 0, y: 0};\n\t     *      var pointHas = R.has(R.__, point);\n\t     *      pointHas('x');  //=> true\n\t     *      pointHas('y');  //=> true\n\t     *      pointHas('z');  //=> false\n\t     */\n\t    var has = _curry2(_has);\n\t\n\t    /**\n\t     * Returns whether or not an object or its prototype chain has a property with\n\t     * the specified name\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @since v0.7.0\n\t     * @category Object\n\t     * @sig s -> {s: x} -> Boolean\n\t     * @param {String} prop The name of the property to check for.\n\t     * @param {Object} obj The object to query.\n\t     * @return {Boolean} Whether the property exists.\n\t     * @example\n\t     *\n\t     *      function Rectangle(width, height) {\n\t     *        this.width = width;\n\t     *        this.height = height;\n\t     *      }\n\t     *      Rectangle.prototype.area = function() {\n\t     *        return this.width * this.height;\n\t     *      };\n\t     *\n\t     *      var square = new Rectangle(2, 2);\n\t     *      R.hasIn('width', square);  //=> true\n\t     *      R.hasIn('area', square);  //=> true\n\t     */\n\t    var hasIn = _curry2(function hasIn(prop, obj) {\n\t        return prop in obj;\n\t    });\n\t\n\t    /**\n\t     * Returns true if its arguments are identical, false otherwise. Values are\n\t     * identical if they reference the same memory. `NaN` is identical to `NaN`;\n\t     * `0` and `-0` are not identical.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @since v0.15.0\n\t     * @category Relation\n\t     * @sig a -> a -> Boolean\n\t     * @param {*} a\n\t     * @param {*} b\n\t     * @return {Boolean}\n\t     * @example\n\t     *\n\t     *      var o = {};\n\t     *      R.identical(o, o); //=> true\n\t     *      R.identical(1, 1); //=> true\n\t     *      R.identical(1, '1'); //=> false\n\t     *      R.identical([], []); //=> false\n\t     *      R.identical(0, -0); //=> false\n\t     *      R.identical(NaN, NaN); //=> true\n\t     */\n\t    // SameValue algorithm\n\t    // Steps 1-5, 7-10\n\t    // Steps 6.b-6.e: +0 != -0\n\t    // Step 6.a: NaN == NaN\n\t    var identical = _curry2(function identical(a, b) {\n\t        // SameValue algorithm\n\t        if (a === b) {\n\t            // Steps 1-5, 7-10\n\t            // Steps 6.b-6.e: +0 != -0\n\t            return a !== 0 || 1 / a === 1 / b;\n\t        } else {\n\t            // Step 6.a: NaN == NaN\n\t            return a !== a && b !== b;\n\t        }\n\t    });\n\t\n\t    /**\n\t     * A function that does nothing but return the parameter supplied to it. Good\n\t     * as a default or placeholder function.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @since v0.1.0\n\t     * @category Function\n\t     * @sig a -> a\n\t     * @param {*} x The value to return.\n\t     * @return {*} The input value, `x`.\n\t     * @example\n\t     *\n\t     *      R.identity(1); //=> 1\n\t     *\n\t     *      var obj = {};\n\t     *      R.identity(obj) === obj; //=> true\n\t     */\n\t    var identity = _curry1(_identity);\n\t\n\t    /**\n\t     * Creates a function that will process either the `onTrue` or the `onFalse`\n\t     * function depending upon the result of the `condition` predicate.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @since v0.8.0\n\t     * @category Logic\n\t     * @sig (*... -> Boolean) -> (*... -> *) -> (*... -> *) -> (*... -> *)\n\t     * @param {Function} condition A predicate function\n\t     * @param {Function} onTrue A function to invoke when the `condition` evaluates to a truthy value.\n\t     * @param {Function} onFalse A function to invoke when the `condition` evaluates to a falsy value.\n\t     * @return {Function} A new unary function that will process either the `onTrue` or the `onFalse`\n\t     *                    function depending upon the result of the `condition` predicate.\n\t     * @see R.unless, R.when\n\t     * @example\n\t     *\n\t     *      var incCount = R.ifElse(\n\t     *        R.has('count'),\n\t     *        R.over(R.lensProp('count'), R.inc),\n\t     *        R.assoc('count', 1)\n\t     *      );\n\t     *      incCount({});           //=> { count: 1 }\n\t     *      incCount({ count: 1 }); //=> { count: 2 }\n\t     */\n\t    var ifElse = _curry3(function ifElse(condition, onTrue, onFalse) {\n\t        return curryN(Math.max(condition.length, onTrue.length, onFalse.length), function _ifElse() {\n\t            return condition.apply(this, arguments) ? onTrue.apply(this, arguments) : onFalse.apply(this, arguments);\n\t        });\n\t    });\n\t\n\t    /**\n\t     * Increments its argument.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @since v0.9.0\n\t     * @category Math\n\t     * @sig Number -> Number\n\t     * @param {Number} n\n\t     * @return {Number}\n\t     * @see R.dec\n\t     * @example\n\t     *\n\t     *      R.inc(42); //=> 43\n\t     */\n\t    var inc = add(1);\n\t\n\t    /**\n\t     * Inserts the supplied element into the list, at index `index`. _Note that\n\t     * this is not destructive_: it returns a copy of the list with the changes.\n\t     * <small>No lists have been harmed in the application of this function.</small>\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @since v0.2.2\n\t     * @category List\n\t     * @sig Number -> a -> [a] -> [a]\n\t     * @param {Number} index The position to insert the element\n\t     * @param {*} elt The element to insert into the Array\n\t     * @param {Array} list The list to insert into\n\t     * @return {Array} A new Array with `elt` inserted at `index`.\n\t     * @example\n\t     *\n\t     *      R.insert(2, 'x', [1,2,3,4]); //=> [1,2,'x',3,4]\n\t     */\n\t    var insert = _curry3(function insert(idx, elt, list) {\n\t        idx = idx < list.length && idx >= 0 ? idx : list.length;\n\t        var result = _slice(list);\n\t        result.splice(idx, 0, elt);\n\t        return result;\n\t    });\n\t\n\t    /**\n\t     * Inserts the sub-list into the list, at index `index`. _Note that this is not\n\t     * destructive_: it returns a copy of the list with the changes.\n\t     * <small>No lists have been harmed in the application of this function.</small>\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @since v0.9.0\n\t     * @category List\n\t     * @sig Number -> [a] -> [a] -> [a]\n\t     * @param {Number} index The position to insert the sub-list\n\t     * @param {Array} elts The sub-list to insert into the Array\n\t     * @param {Array} list The list to insert the sub-list into\n\t     * @return {Array} A new Array with `elts` inserted starting at `index`.\n\t     * @example\n\t     *\n\t     *      R.insertAll(2, ['x','y','z'], [1,2,3,4]); //=> [1,2,'x','y','z',3,4]\n\t     */\n\t    var insertAll = _curry3(function insertAll(idx, elts, list) {\n\t        idx = idx < list.length && idx >= 0 ? idx : list.length;\n\t        return _concat(_concat(_slice(list, 0, idx), elts), _slice(list, idx));\n\t    });\n\t\n\t    /**\n\t     * Creates a new list with the separator interposed between elements.\n\t     *\n\t     * Dispatches to the `intersperse` method of the second argument, if present.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @since v0.14.0\n\t     * @category List\n\t     * @sig a -> [a] -> [a]\n\t     * @param {*} separator The element to add to the list.\n\t     * @param {Array} list The list to be interposed.\n\t     * @return {Array} The new list.\n\t     * @example\n\t     *\n\t     *      R.intersperse('n', ['ba', 'a', 'a']); //=> ['ba', 'n', 'a', 'n', 'a']\n\t     */\n\t    var intersperse = _curry2(_checkForMethod('intersperse', function intersperse(separator, list) {\n\t        var out = [];\n\t        var idx = 0;\n\t        var length = list.length;\n\t        while (idx < length) {\n\t            if (idx === length - 1) {\n\t                out.push(list[idx]);\n\t            } else {\n\t                out.push(list[idx], separator);\n\t            }\n\t            idx += 1;\n\t        }\n\t        return out;\n\t    }));\n\t\n\t    /**\n\t     * See if an object (`val`) is an instance of the supplied constructor. This\n\t     * function will check up the inheritance chain, if any.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @since v0.3.0\n\t     * @category Type\n\t     * @sig (* -> {*}) -> a -> Boolean\n\t     * @param {Object} ctor A constructor\n\t     * @param {*} val The value to test\n\t     * @return {Boolean}\n\t     * @example\n\t     *\n\t     *      R.is(Object, {}); //=> true\n\t     *      R.is(Number, 1); //=> true\n\t     *      R.is(Object, 1); //=> false\n\t     *      R.is(String, 's'); //=> true\n\t     *      R.is(String, new String('')); //=> true\n\t     *      R.is(Object, new String('')); //=> true\n\t     *      R.is(Object, 's'); //=> false\n\t     *      R.is(Number, {}); //=> false\n\t     */\n\t    var is = _curry2(function is(Ctor, val) {\n\t        return val != null && val.constructor === Ctor || val instanceof Ctor;\n\t    });\n\t\n\t    /**\n\t     * Tests whether or not an object is similar to an array.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @since v0.5.0\n\t     * @category Type\n\t     * @category List\n\t     * @sig * -> Boolean\n\t     * @param {*} x The object to test.\n\t     * @return {Boolean} `true` if `x` has a numeric length property and extreme indices defined; `false` otherwise.\n\t     * @example\n\t     *\n\t     *      R.isArrayLike([]); //=> true\n\t     *      R.isArrayLike(true); //=> false\n\t     *      R.isArrayLike({}); //=> false\n\t     *      R.isArrayLike({length: 10}); //=> false\n\t     *      R.isArrayLike({0: 'zero', 9: 'nine', length: 10}); //=> true\n\t     */\n\t    var isArrayLike = _curry1(function isArrayLike(x) {\n\t        if (_isArray(x)) {\n\t            return true;\n\t        }\n\t        if (!x) {\n\t            return false;\n\t        }\n\t        if (typeof x !== 'object') {\n\t            return false;\n\t        }\n\t        if (x instanceof String) {\n\t            return false;\n\t        }\n\t        if (x.nodeType === 1) {\n\t            return !!x.length;\n\t        }\n\t        if (x.length === 0) {\n\t            return true;\n\t        }\n\t        if (x.length > 0) {\n\t            return x.hasOwnProperty(0) && x.hasOwnProperty(x.length - 1);\n\t        }\n\t        return false;\n\t    });\n\t\n\t    /**\n\t     * Checks if the input value is `null` or `undefined`.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @since v0.9.0\n\t     * @category Type\n\t     * @sig * -> Boolean\n\t     * @param {*} x The value to test.\n\t     * @return {Boolean} `true` if `x` is `undefined` or `null`, otherwise `false`.\n\t     * @example\n\t     *\n\t     *      R.isNil(null); //=> true\n\t     *      R.isNil(undefined); //=> true\n\t     *      R.isNil(0); //=> false\n\t     *      R.isNil([]); //=> false\n\t     */\n\t    var isNil = _curry1(function isNil(x) {\n\t        return x == null;\n\t    });\n\t\n\t    /**\n\t     * Returns a list containing the names of all the enumerable own properties of\n\t     * the supplied object.\n\t     * Note that the order of the output array is not guaranteed to be consistent\n\t     * across different JS platforms.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @since v0.1.0\n\t     * @category Object\n\t     * @sig {k: v} -> [k]\n\t     * @param {Object} obj The object to extract properties from\n\t     * @return {Array} An array of the object's own properties.\n\t     * @example\n\t     *\n\t     *      R.keys({a: 1, b: 2, c: 3}); //=> ['a', 'b', 'c']\n\t     */\n\t    // cover IE < 9 keys issues\n\t    // Safari bug\n\t    var keys = function () {\n\t        // cover IE < 9 keys issues\n\t        var hasEnumBug = !{ toString: null }.propertyIsEnumerable('toString');\n\t        var nonEnumerableProps = [\n\t            'constructor',\n\t            'valueOf',\n\t            'isPrototypeOf',\n\t            'toString',\n\t            'propertyIsEnumerable',\n\t            'hasOwnProperty',\n\t            'toLocaleString'\n\t        ];\n\t        // Safari bug\n\t        var hasArgsEnumBug = function () {\n\t            'use strict';\n\t            return arguments.propertyIsEnumerable('length');\n\t        }();\n\t        var contains = function contains(list, item) {\n\t            var idx = 0;\n\t            while (idx < list.length) {\n\t                if (list[idx] === item) {\n\t                    return true;\n\t                }\n\t                idx += 1;\n\t            }\n\t            return false;\n\t        };\n\t        return typeof Object.keys === 'function' && !hasArgsEnumBug ? _curry1(function keys(obj) {\n\t            return Object(obj) !== obj ? [] : Object.keys(obj);\n\t        }) : _curry1(function keys(obj) {\n\t            if (Object(obj) !== obj) {\n\t                return [];\n\t            }\n\t            var prop, nIdx;\n\t            var ks = [];\n\t            var checkArgsLength = hasArgsEnumBug && _isArguments(obj);\n\t            for (prop in obj) {\n\t                if (_has(prop, obj) && (!checkArgsLength || prop !== 'length')) {\n\t                    ks[ks.length] = prop;\n\t                }\n\t            }\n\t            if (hasEnumBug) {\n\t                nIdx = nonEnumerableProps.length - 1;\n\t                while (nIdx >= 0) {\n\t                    prop = nonEnumerableProps[nIdx];\n\t                    if (_has(prop, obj) && !contains(ks, prop)) {\n\t                        ks[ks.length] = prop;\n\t                    }\n\t                    nIdx -= 1;\n\t                }\n\t            }\n\t            return ks;\n\t        });\n\t    }();\n\t\n\t    /**\n\t     * Returns a list containing the names of all the properties of the supplied\n\t     * object, including prototype properties.\n\t     * Note that the order of the output array is not guaranteed to be consistent\n\t     * across different JS platforms.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @since v0.2.0\n\t     * @category Object\n\t     * @sig {k: v} -> [k]\n\t     * @param {Object} obj The object to extract properties from\n\t     * @return {Array} An array of the object's own and prototype properties.\n\t     * @example\n\t     *\n\t     *      var F = function() { this.x = 'X'; };\n\t     *      F.prototype.y = 'Y';\n\t     *      var f = new F();\n\t     *      R.keysIn(f); //=> ['x', 'y']\n\t     */\n\t    var keysIn = _curry1(function keysIn(obj) {\n\t        var prop;\n\t        var ks = [];\n\t        for (prop in obj) {\n\t            ks[ks.length] = prop;\n\t        }\n\t        return ks;\n\t    });\n\t\n\t    /**\n\t     * Returns the number of elements in the array by returning `list.length`.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @since v0.3.0\n\t     * @category List\n\t     * @sig [a] -> Number\n\t     * @param {Array} list The array to inspect.\n\t     * @return {Number} The length of the array.\n\t     * @example\n\t     *\n\t     *      R.length([]); //=> 0\n\t     *      R.length([1, 2, 3]); //=> 3\n\t     */\n\t    var length = _curry1(function length(list) {\n\t        return list != null && is(Number, list.length) ? list.length : NaN;\n\t    });\n\t\n\t    /**\n\t     * Returns `true` if the first argument is less than the second; `false`\n\t     * otherwise.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @since v0.1.0\n\t     * @category Relation\n\t     * @sig Ord a => a -> a -> Boolean\n\t     * @param {*} a\n\t     * @param {*} b\n\t     * @return {Boolean}\n\t     * @see R.gt\n\t     * @example\n\t     *\n\t     *      R.lt(2, 1); //=> false\n\t     *      R.lt(2, 2); //=> false\n\t     *      R.lt(2, 3); //=> true\n\t     *      R.lt('a', 'z'); //=> true\n\t     *      R.lt('z', 'a'); //=> false\n\t     */\n\t    var lt = _curry2(function lt(a, b) {\n\t        return a < b;\n\t    });\n\t\n\t    /**\n\t     * Returns `true` if the first argument is less than or equal to the second;\n\t     * `false` otherwise.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @since v0.1.0\n\t     * @category Relation\n\t     * @sig Ord a => a -> a -> Boolean\n\t     * @param {Number} a\n\t     * @param {Number} b\n\t     * @return {Boolean}\n\t     * @see R.gte\n\t     * @example\n\t     *\n\t     *      R.lte(2, 1); //=> false\n\t     *      R.lte(2, 2); //=> true\n\t     *      R.lte(2, 3); //=> true\n\t     *      R.lte('a', 'z'); //=> true\n\t     *      R.lte('z', 'a'); //=> false\n\t     */\n\t    var lte = _curry2(function lte(a, b) {\n\t        return a <= b;\n\t    });\n\t\n\t    /**\n\t     * The mapAccum function behaves like a combination of map and reduce; it\n\t     * applies a function to each element of a list, passing an accumulating\n\t     * parameter from left to right, and returning a final value of this\n\t     * accumulator together with the new list.\n\t     *\n\t     * The iterator function receives two arguments, *acc* and *value*, and should\n\t     * return a tuple *[acc, value]*.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @since v0.10.0\n\t     * @category List\n\t     * @sig (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])\n\t     * @param {Function} fn The function to be called on every element of the input `list`.\n\t     * @param {*} acc The accumulator value.\n\t     * @param {Array} list The list to iterate over.\n\t     * @return {*} The final, accumulated value.\n\t     * @see R.addIndex\n\t     * @example\n\t     *\n\t     *      var digits = ['1', '2', '3', '4'];\n\t     *      var append = (a, b) => [a + b, a + b];\n\t     *\n\t     *      R.mapAccum(append, 0, digits); //=> ['01234', ['01', '012', '0123', '01234']]\n\t     */\n\t    var mapAccum = _curry3(function mapAccum(fn, acc, list) {\n\t        var idx = 0;\n\t        var len = list.length;\n\t        var result = [];\n\t        var tuple = [acc];\n\t        while (idx < len) {\n\t            tuple = fn(tuple[0], list[idx]);\n\t            result[idx] = tuple[1];\n\t            idx += 1;\n\t        }\n\t        return [\n\t            tuple[0],\n\t            result\n\t        ];\n\t    });\n\t\n\t    /**\n\t     * The mapAccumRight function behaves like a combination of map and reduce; it\n\t     * applies a function to each element of a list, passing an accumulating\n\t     * parameter from right to left, and returning a final value of this\n\t     * accumulator together with the new list.\n\t     *\n\t     * Similar to `mapAccum`, except moves through the input list from the right to\n\t     * the left.\n\t     *\n\t     * The iterator function receives two arguments, *acc* and *value*, and should\n\t     * return a tuple *[acc, value]*.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @since v0.10.0\n\t     * @category List\n\t     * @sig (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])\n\t     * @param {Function} fn The function to be called on every element of the input `list`.\n\t     * @param {*} acc The accumulator value.\n\t     * @param {Array} list The list to iterate over.\n\t     * @return {*} The final, accumulated value.\n\t     * @see R.addIndex\n\t     * @example\n\t     *\n\t     *      var digits = ['1', '2', '3', '4'];\n\t     *      var append = (a, b) => [a + b, a + b];\n\t     *\n\t     *      R.mapAccumRight(append, 0, digits); //=> ['04321', ['04321', '0432', '043', '04']]\n\t     */\n\t    var mapAccumRight = _curry3(function mapAccumRight(fn, acc, list) {\n\t        var idx = list.length - 1;\n\t        var result = [];\n\t        var tuple = [acc];\n\t        while (idx >= 0) {\n\t            tuple = fn(tuple[0], list[idx]);\n\t            result[idx] = tuple[1];\n\t            idx -= 1;\n\t        }\n\t        return [\n\t            tuple[0],\n\t            result\n\t        ];\n\t    });\n\t\n\t    /**\n\t     * Tests a regular expression against a String. Note that this function will\n\t     * return an empty array when there are no matches. This differs from\n\t     * [`String.prototype.match`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/match)\n\t     * which returns `null` when there are no matches.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @since v0.1.0\n\t     * @category String\n\t     * @sig RegExp -> String -> [String | Undefined]\n\t     * @param {RegExp} rx A regular expression.\n\t     * @param {String} str The string to match against\n\t     * @return {Array} The list of matches or empty array.\n\t     * @see R.test\n\t     * @example\n\t     *\n\t     *      R.match(/([a-z]a)/g, 'bananas'); //=> ['ba', 'na', 'na']\n\t     *      R.match(/a/, 'b'); //=> []\n\t     *      R.match(/a/, null); //=> TypeError: null does not have a method named \"match\"\n\t     */\n\t    var match = _curry2(function match(rx, str) {\n\t        return str.match(rx) || [];\n\t    });\n\t\n\t    /**\n\t     * mathMod behaves like the modulo operator should mathematically, unlike the\n\t     * `%` operator (and by extension, R.modulo). So while \"-17 % 5\" is -2,\n\t     * mathMod(-17, 5) is 3. mathMod requires Integer arguments, and returns NaN\n\t     * when the modulus is zero or negative.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @since v0.3.0\n\t     * @category Math\n\t     * @sig Number -> Number -> Number\n\t     * @param {Number} m The dividend.\n\t     * @param {Number} p the modulus.\n\t     * @return {Number} The result of `b mod a`.\n\t     * @example\n\t     *\n\t     *      R.mathMod(-17, 5);  //=> 3\n\t     *      R.mathMod(17, 5);   //=> 2\n\t     *      R.mathMod(17, -5);  //=> NaN\n\t     *      R.mathMod(17, 0);   //=> NaN\n\t     *      R.mathMod(17.2, 5); //=> NaN\n\t     *      R.mathMod(17, 5.3); //=> NaN\n\t     *\n\t     *      var clock = R.mathMod(R.__, 12);\n\t     *      clock(15); //=> 3\n\t     *      clock(24); //=> 0\n\t     *\n\t     *      var seventeenMod = R.mathMod(17);\n\t     *      seventeenMod(3);  //=> 2\n\t     *      seventeenMod(4);  //=> 1\n\t     *      seventeenMod(10); //=> 7\n\t     */\n\t    var mathMod = _curry2(function mathMod(m, p) {\n\t        if (!_isInteger(m)) {\n\t            return NaN;\n\t        }\n\t        if (!_isInteger(p) || p < 1) {\n\t            return NaN;\n\t        }\n\t        return (m % p + p) % p;\n\t    });\n\t\n\t    /**\n\t     * Returns the larger of its two arguments.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @since v0.1.0\n\t     * @category Relation\n\t     * @sig Ord a => a -> a -> a\n\t     * @param {*} a\n\t     * @param {*} b\n\t     * @return {*}\n\t     * @see R.maxBy, R.min\n\t     * @example\n\t     *\n\t     *      R.max(789, 123); //=> 789\n\t     *      R.max('a', 'b'); //=> 'b'\n\t     */\n\t    var max = _curry2(function max(a, b) {\n\t        return b > a ? b : a;\n\t    });\n\t\n\t    /**\n\t     * Takes a function and two values, and returns whichever value produces the\n\t     * larger result when passed to the provided function.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @since v0.8.0\n\t     * @category Relation\n\t     * @sig Ord b => (a -> b) -> a -> a -> a\n\t     * @param {Function} f\n\t     * @param {*} a\n\t     * @param {*} b\n\t     * @return {*}\n\t     * @see R.max, R.minBy\n\t     * @example\n\t     *\n\t     *      //  square :: Number -> Number\n\t     *      var square = n => n * n;\n\t     *\n\t     *      R.maxBy(square, -3, 2); //=> -3\n\t     *\n\t     *      R.reduce(R.maxBy(square), 0, [3, -5, 4, 1, -2]); //=> -5\n\t     *      R.reduce(R.maxBy(square), 0, []); //=> 0\n\t     */\n\t    var maxBy = _curry3(function maxBy(f, a, b) {\n\t        return f(b) > f(a) ? b : a;\n\t    });\n\t\n\t    /**\n\t     * Creates a new object with the own properties of the two provided objects. If\n\t     * a key exists in both objects, the provided function is applied to the key\n\t     * and the values associated with the key in each object, with the result being\n\t     * used as the value associated with the key in the returned object. The key\n\t     * will be excluded from the returned object if the resulting value is\n\t     * `undefined`.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @since 0.19.1\n\t     * @since 0.19.0\n\t     * @category Object\n\t     * @sig (String -> a -> a -> a) -> {a} -> {a} -> {a}\n\t     * @param {Function} fn\n\t     * @param {Object} l\n\t     * @param {Object} r\n\t     * @return {Object}\n\t     * @see R.merge, R.mergeWith\n\t     * @example\n\t     *\n\t     *      let concatValues = (k, l, r) => k == 'values' ? R.concat(l, r) : r\n\t     *      R.mergeWithKey(concatValues,\n\t     *                     { a: true, thing: 'foo', values: [10, 20] },\n\t     *                     { b: true, thing: 'bar', values: [15, 35] });\n\t     *      //=> { a: true, b: true, thing: 'bar', values: [10, 20, 15, 35] }\n\t     */\n\t    var mergeWithKey = _curry3(function mergeWithKey(fn, l, r) {\n\t        var result = {};\n\t        var k;\n\t        for (k in l) {\n\t            if (_has(k, l)) {\n\t                result[k] = _has(k, r) ? fn(k, l[k], r[k]) : l[k];\n\t            }\n\t        }\n\t        for (k in r) {\n\t            if (_has(k, r) && !_has(k, result)) {\n\t                result[k] = r[k];\n\t            }\n\t        }\n\t        return result;\n\t    });\n\t\n\t    /**\n\t     * Returns the smaller of its two arguments.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @since v0.1.0\n\t     * @category Relation\n\t     * @sig Ord a => a -> a -> a\n\t     * @param {*} a\n\t     * @param {*} b\n\t     * @return {*}\n\t     * @see R.minBy, R.max\n\t     * @example\n\t     *\n\t     *      R.min(789, 123); //=> 123\n\t     *      R.min('a', 'b'); //=> 'a'\n\t     */\n\t    var min = _curry2(function min(a, b) {\n\t        return b < a ? b : a;\n\t    });\n\t\n\t    /**\n\t     * Takes a function and two values, and returns whichever value produces the\n\t     * smaller result when passed to the provided function.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @since v0.8.0\n\t     * @category Relation\n\t     * @sig Ord b => (a -> b) -> a -> a -> a\n\t     * @param {Function} f\n\t     * @param {*} a\n\t     * @param {*} b\n\t     * @return {*}\n\t     * @see R.min, R.maxBy\n\t     * @example\n\t     *\n\t     *      //  square :: Number -> Number\n\t     *      var square = n => n * n;\n\t     *\n\t     *      R.minBy(square, -3, 2); //=> 2\n\t     *\n\t     *      R.reduce(R.minBy(square), Infinity, [3, -5, 4, 1, -2]); //=> 1\n\t     *      R.reduce(R.minBy(square), Infinity, []); //=> Infinity\n\t     */\n\t    var minBy = _curry3(function minBy(f, a, b) {\n\t        return f(b) < f(a) ? b : a;\n\t    });\n\t\n\t    /**\n\t     * Divides the second parameter by the first and returns the remainder. Note\n\t     * that this function preserves the JavaScript-style behavior for modulo. For\n\t     * mathematical modulo see `mathMod`.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @since v0.1.1\n\t     * @category Math\n\t     * @sig Number -> Number -> Number\n\t     * @param {Number} a The value to the divide.\n\t     * @param {Number} b The pseudo-modulus\n\t     * @return {Number} The result of `b % a`.\n\t     * @see R.mathMod\n\t     * @example\n\t     *\n\t     *      R.modulo(17, 3); //=> 2\n\t     *      // JS behavior:\n\t     *      R.modulo(-17, 3); //=> -2\n\t     *      R.modulo(17, -3); //=> 2\n\t     *\n\t     *      var isOdd = R.modulo(R.__, 2);\n\t     *      isOdd(42); //=> 0\n\t     *      isOdd(21); //=> 1\n\t     */\n\t    var modulo = _curry2(function modulo(a, b) {\n\t        return a % b;\n\t    });\n\t\n\t    /**\n\t     * Multiplies two numbers. Equivalent to `a * b` but curried.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @since v0.1.0\n\t     * @category Math\n\t     * @sig Number -> Number -> Number\n\t     * @param {Number} a The first value.\n\t     * @param {Number} b The second value.\n\t     * @return {Number} The result of `a * b`.\n\t     * @see R.divide\n\t     * @example\n\t     *\n\t     *      var double = R.multiply(2);\n\t     *      var triple = R.multiply(3);\n\t     *      double(3);       //=>  6\n\t     *      triple(4);       //=> 12\n\t     *      R.multiply(2, 5);  //=> 10\n\t     */\n\t    var multiply = _curry2(function multiply(a, b) {\n\t        return a * b;\n\t    });\n\t\n\t    /**\n\t     * Wraps a function of any arity (including nullary) in a function that accepts\n\t     * exactly `n` parameters. Any extraneous parameters will not be passed to the\n\t     * supplied function.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @since v0.1.0\n\t     * @category Function\n\t     * @sig Number -> (* -> a) -> (* -> a)\n\t     * @param {Number} n The desired arity of the new function.\n\t     * @param {Function} fn The function to wrap.\n\t     * @return {Function} A new function wrapping `fn`. The new function is guaranteed to be of\n\t     *         arity `n`.\n\t     * @example\n\t     *\n\t     *      var takesTwoArgs = (a, b) => [a, b];\n\t     *\n\t     *      takesTwoArgs.length; //=> 2\n\t     *      takesTwoArgs(1, 2); //=> [1, 2]\n\t     *\n\t     *      var takesOneArg = R.nAry(1, takesTwoArgs);\n\t     *      takesOneArg.length; //=> 1\n\t     *      // Only `n` arguments are passed to the wrapped function\n\t     *      takesOneArg(1, 2); //=> [1, undefined]\n\t     */\n\t    var nAry = _curry2(function nAry(n, fn) {\n\t        switch (n) {\n\t        case 0:\n\t            return function () {\n\t                return fn.call(this);\n\t            };\n\t        case 1:\n\t            return function (a0) {\n\t                return fn.call(this, a0);\n\t            };\n\t        case 2:\n\t            return function (a0, a1) {\n\t                return fn.call(this, a0, a1);\n\t            };\n\t        case 3:\n\t            return function (a0, a1, a2) {\n\t                return fn.call(this, a0, a1, a2);\n\t            };\n\t        case 4:\n\t            return function (a0, a1, a2, a3) {\n\t                return fn.call(this, a0, a1, a2, a3);\n\t            };\n\t        case 5:\n\t            return function (a0, a1, a2, a3, a4) {\n\t                return fn.call(this, a0, a1, a2, a3, a4);\n\t            };\n\t        case 6:\n\t            return function (a0, a1, a2, a3, a4, a5) {\n\t                return fn.call(this, a0, a1, a2, a3, a4, a5);\n\t            };\n\t        case 7:\n\t            return function (a0, a1, a2, a3, a4, a5, a6) {\n\t                return fn.call(this, a0, a1, a2, a3, a4, a5, a6);\n\t            };\n\t        case 8:\n\t            return function (a0, a1, a2, a3, a4, a5, a6, a7) {\n\t                return fn.call(this, a0, a1, a2, a3, a4, a5, a6, a7);\n\t            };\n\t        case 9:\n\t            return function (a0, a1, a2, a3, a4, a5, a6, a7, a8) {\n\t                return fn.call(this, a0, a1, a2, a3, a4, a5, a6, a7, a8);\n\t            };\n\t        case 10:\n\t            return function (a0, a1, a2, a3, a4, a5, a6, a7, a8, a9) {\n\t                return fn.call(this, a0, a1, a2, a3, a4, a5, a6, a7, a8, a9);\n\t            };\n\t        default:\n\t            throw new Error('First argument to nAry must be a non-negative integer no greater than ten');\n\t        }\n\t    });\n\t\n\t    /**\n\t     * Negates its argument.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @since v0.9.0\n\t     * @category Math\n\t     * @sig Number -> Number\n\t     * @param {Number} n\n\t     * @return {Number}\n\t     * @example\n\t     *\n\t     *      R.negate(42); //=> -42\n\t     */\n\t    var negate = _curry1(function negate(n) {\n\t        return -n;\n\t    });\n\t\n\t    /**\n\t     * Returns `true` if no elements of the list match the predicate, `false`\n\t     * otherwise.\n\t     *\n\t     * Dispatches to the `any` method of the second argument, if present.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @since v0.12.0\n\t     * @category List\n\t     * @sig (a -> Boolean) -> [a] -> Boolean\n\t     * @param {Function} fn The predicate function.\n\t     * @param {Array} list The array to consider.\n\t     * @return {Boolean} `true` if the predicate is not satisfied by every element, `false` otherwise.\n\t     * @see R.all, R.any\n\t     * @example\n\t     *\n\t     *      var isEven = n => n % 2 === 0;\n\t     *\n\t     *      R.none(isEven, [1, 3, 5, 7, 9, 11]); //=> true\n\t     *      R.none(isEven, [1, 3, 5, 7, 8, 11]); //=> false\n\t     */\n\t    var none = _curry2(_complement(_dispatchable('any', _xany, any)));\n\t\n\t    /**\n\t     * A function that returns the `!` of its argument. It will return `true` when\n\t     * passed false-y value, and `false` when passed a truth-y one.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @since v0.1.0\n\t     * @category Logic\n\t     * @sig * -> Boolean\n\t     * @param {*} a any value\n\t     * @return {Boolean} the logical inverse of passed argument.\n\t     * @see R.complement\n\t     * @example\n\t     *\n\t     *      R.not(true); //=> false\n\t     *      R.not(false); //=> true\n\t     *      R.not(0); => true\n\t     *      R.not(1); => false\n\t     */\n\t    var not = _curry1(function not(a) {\n\t        return !a;\n\t    });\n\t\n\t    /**\n\t     * Returns the nth element of the given list or string. If n is negative the\n\t     * element at index length + n is returned.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @since v0.1.0\n\t     * @category List\n\t     * @sig Number -> [a] -> a | Undefined\n\t     * @sig Number -> String -> String\n\t     * @param {Number} offset\n\t     * @param {*} list\n\t     * @return {*}\n\t     * @example\n\t     *\n\t     *      var list = ['foo', 'bar', 'baz', 'quux'];\n\t     *      R.nth(1, list); //=> 'bar'\n\t     *      R.nth(-1, list); //=> 'quux'\n\t     *      R.nth(-99, list); //=> undefined\n\t     *\n\t     *      R.nth('abc', 2); //=> 'c'\n\t     *      R.nth('abc', 3); //=> ''\n\t     */\n\t    var nth = _curry2(function nth(offset, list) {\n\t        var idx = offset < 0 ? list.length + offset : offset;\n\t        return _isString(list) ? list.charAt(idx) : list[idx];\n\t    });\n\t\n\t    /**\n\t     * Returns a function which returns its nth argument.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @since v0.9.0\n\t     * @category Function\n\t     * @sig Number -> *... -> *\n\t     * @param {Number} n\n\t     * @return {Function}\n\t     * @example\n\t     *\n\t     *      R.nthArg(1)('a', 'b', 'c'); //=> 'b'\n\t     *      R.nthArg(-1)('a', 'b', 'c'); //=> 'c'\n\t     */\n\t    var nthArg = _curry1(function nthArg(n) {\n\t        return function () {\n\t            return nth(n, arguments);\n\t        };\n\t    });\n\t\n\t    /**\n\t     * Creates an object containing a single key:value pair.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @since v0.18.0\n\t     * @category Object\n\t     * @sig String -> a -> {String:a}\n\t     * @param {String} key\n\t     * @param {*} val\n\t     * @return {Object}\n\t     * @see R.pair\n\t     * @example\n\t     *\n\t     *      var matchPhrases = R.compose(\n\t     *        R.objOf('must'),\n\t     *        R.map(R.objOf('match_phrase'))\n\t     *      );\n\t     *      matchPhrases(['foo', 'bar', 'baz']); //=> {must: [{match_phrase: 'foo'}, {match_phrase: 'bar'}, {match_phrase: 'baz'}]}\n\t     */\n\t    var objOf = _curry2(function objOf(key, val) {\n\t        var obj = {};\n\t        obj[key] = val;\n\t        return obj;\n\t    });\n\t\n\t    /**\n\t     * Returns a singleton array containing the value provided.\n\t     *\n\t     * Note this `of` is different from the ES6 `of`; See\n\t     * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/of\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @since v0.3.0\n\t     * @category Function\n\t     * @sig a -> [a]\n\t     * @param {*} x any value\n\t     * @return {Array} An array wrapping `x`.\n\t     * @example\n\t     *\n\t     *      R.of(null); //=> [null]\n\t     *      R.of([42]); //=> [[42]]\n\t     */\n\t    var of = _curry1(_of);\n\t\n\t    /**\n\t     * Accepts a function `fn` and returns a function that guards invocation of\n\t     * `fn` such that `fn` can only ever be called once, no matter how many times\n\t     * the returned function is invoked. The first value calculated is returned in\n\t     * subsequent invocations.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @since v0.1.0\n\t     * @category Function\n\t     * @sig (a... -> b) -> (a... -> b)\n\t     * @param {Function} fn The function to wrap in a call-only-once wrapper.\n\t     * @return {Function} The wrapped function.\n\t     * @example\n\t     *\n\t     *      var addOneOnce = R.once(x => x + 1);\n\t     *      addOneOnce(10); //=> 11\n\t     *      addOneOnce(addOneOnce(50)); //=> 11\n\t     */\n\t    var once = _curry1(function once(fn) {\n\t        var called = false;\n\t        var result;\n\t        return _arity(fn.length, function () {\n\t            if (called) {\n\t                return result;\n\t            }\n\t            called = true;\n\t            result = fn.apply(this, arguments);\n\t            return result;\n\t        });\n\t    });\n\t\n\t    /**\n\t     * Returns `true` if one or both of its arguments are `true`. Returns `false`\n\t     * if both arguments are `false`.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @since v0.1.0\n\t     * @category Logic\n\t     * @sig * -> * -> *\n\t     * @param {Boolean} a A boolean value\n\t     * @param {Boolean} b A boolean value\n\t     * @return {Boolean} `true` if one or both arguments are `true`, `false` otherwise\n\t     * @see R.either\n\t     * @example\n\t     *\n\t     *      R.or(true, true); //=> true\n\t     *      R.or(true, false); //=> true\n\t     *      R.or(false, true); //=> true\n\t     *      R.or(false, false); //=> false\n\t     */\n\t    var or = _curry2(function or(a, b) {\n\t        return a || b;\n\t    });\n\t\n\t    /**\n\t     * Returns the result of \"setting\" the portion of the given data structure\n\t     * focused by the given lens to the result of applying the given function to\n\t     * the focused value.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @since v0.16.0\n\t     * @category Object\n\t     * @typedefn Lens s a = Functor f => (a -> f a) -> s -> f s\n\t     * @sig Lens s a -> (a -> a) -> s -> s\n\t     * @param {Lens} lens\n\t     * @param {*} v\n\t     * @param {*} x\n\t     * @return {*}\n\t     * @see R.prop, R.lensIndex, R.lensProp\n\t     * @example\n\t     *\n\t     *      var headLens = R.lensIndex(0);\n\t     *\n\t     *      R.over(headLens, R.toUpper, ['foo', 'bar', 'baz']); //=> ['FOO', 'bar', 'baz']\n\t     */\n\t    var over = function () {\n\t        var Identity = function (x) {\n\t            return {\n\t                value: x,\n\t                map: function (f) {\n\t                    return Identity(f(x));\n\t                }\n\t            };\n\t        };\n\t        return _curry3(function over(lens, f, x) {\n\t            return lens(function (y) {\n\t                return Identity(f(y));\n\t            })(x).value;\n\t        });\n\t    }();\n\t\n\t    /**\n\t     * Takes two arguments, `fst` and `snd`, and returns `[fst, snd]`.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @since v0.18.0\n\t     * @category List\n\t     * @sig a -> b -> (a,b)\n\t     * @param {*} fst\n\t     * @param {*} snd\n\t     * @return {Array}\n\t     * @see R.createMapEntry, R.of\n\t     * @example\n\t     *\n\t     *      R.pair('foo', 'bar'); //=> ['foo', 'bar']\n\t     */\n\t    var pair = _curry2(function pair(fst, snd) {\n\t        return [\n\t            fst,\n\t            snd\n\t        ];\n\t    });\n\t\n\t    /**\n\t     * Retrieve the value at a given path.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @since v0.2.0\n\t     * @category Object\n\t     * @sig [String] -> {k: v} -> v | Undefined\n\t     * @param {Array} path The path to use.\n\t     * @param {Object} obj The object to retrieve the nested property from.\n\t     * @return {*} The data at `path`.\n\t     * @example\n\t     *\n\t     *      R.path(['a', 'b'], {a: {b: 2}}); //=> 2\n\t     *      R.path(['a', 'b'], {c: {b: 2}}); //=> undefined\n\t     */\n\t    var path = _curry2(function path(paths, obj) {\n\t        var val = obj;\n\t        var idx = 0;\n\t        while (idx < paths.length) {\n\t            if (val == null) {\n\t                return;\n\t            }\n\t            val = val[paths[idx]];\n\t            idx += 1;\n\t        }\n\t        return val;\n\t    });\n\t\n\t    /**\n\t     * If the given, non-null object has a value at the given path, returns the\n\t     * value at that path. Otherwise returns the provided default value.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @since v0.18.0\n\t     * @category Object\n\t     * @sig a -> [String] -> Object -> a\n\t     * @param {*} d The default value.\n\t     * @param {Array} p The path to use.\n\t     * @param {Object} obj The object to retrieve the nested property from.\n\t     * @return {*} The data at `path` of the supplied object or the default value.\n\t     * @example\n\t     *\n\t     *      R.pathOr('N/A', ['a', 'b'], {a: {b: 2}}); //=> 2\n\t     *      R.pathOr('N/A', ['a', 'b'], {c: {b: 2}}); //=> \"N/A\"\n\t     */\n\t    var pathOr = _curry3(function pathOr(d, p, obj) {\n\t        return defaultTo(d, path(p, obj));\n\t    });\n\t\n\t    /**\n\t     * Returns `true` if the specified object property at given path satisfies the\n\t     * given predicate; `false` otherwise.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @since 0.19.1\n\t     * @since 0.19.0\n\t     * @category Logic\n\t     * @sig (a -> Boolean) -> [String] -> Object -> Boolean\n\t     * @param {Function} pred\n\t     * @param {Array} propPath\n\t     * @param {*} obj\n\t     * @return {Boolean}\n\t     * @see R.propSatisfies, R.path\n\t     * @example\n\t     *\n\t     *      R.pathSatisfies(y => y > 0, ['x', 'y'], {x: {y: 2}}); //=> true\n\t     */\n\t    var pathSatisfies = _curry3(function pathSatisfies(pred, propPath, obj) {\n\t        return propPath.length > 0 && pred(path(propPath, obj));\n\t    });\n\t\n\t    /**\n\t     * Returns a partial copy of an object containing only the keys specified. If\n\t     * the key does not exist, the property is ignored.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @since v0.1.0\n\t     * @category Object\n\t     * @sig [k] -> {k: v} -> {k: v}\n\t     * @param {Array} names an array of String property names to copy onto a new object\n\t     * @param {Object} obj The object to copy from\n\t     * @return {Object} A new object with only properties from `names` on it.\n\t     * @see R.omit, R.props\n\t     * @example\n\t     *\n\t     *      R.pick(['a', 'd'], {a: 1, b: 2, c: 3, d: 4}); //=> {a: 1, d: 4}\n\t     *      R.pick(['a', 'e', 'f'], {a: 1, b: 2, c: 3, d: 4}); //=> {a: 1}\n\t     */\n\t    var pick = _curry2(function pick(names, obj) {\n\t        var result = {};\n\t        var idx = 0;\n\t        while (idx < names.length) {\n\t            if (names[idx] in obj) {\n\t                result[names[idx]] = obj[names[idx]];\n\t            }\n\t            idx += 1;\n\t        }\n\t        return result;\n\t    });\n\t\n\t    /**\n\t     * Similar to `pick` except that this one includes a `key: undefined` pair for\n\t     * properties that don't exist.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @since v0.1.0\n\t     * @category Object\n\t     * @sig [k] -> {k: v} -> {k: v}\n\t     * @param {Array} names an array of String property names to copy onto a new object\n\t     * @param {Object} obj The object to copy from\n\t     * @return {Object} A new object with only properties from `names` on it.\n\t     * @see R.pick\n\t     * @example\n\t     *\n\t     *      R.pickAll(['a', 'd'], {a: 1, b: 2, c: 3, d: 4}); //=> {a: 1, d: 4}\n\t     *      R.pickAll(['a', 'e', 'f'], {a: 1, b: 2, c: 3, d: 4}); //=> {a: 1, e: undefined, f: undefined}\n\t     */\n\t    var pickAll = _curry2(function pickAll(names, obj) {\n\t        var result = {};\n\t        var idx = 0;\n\t        var len = names.length;\n\t        while (idx < len) {\n\t            var name = names[idx];\n\t            result[name] = obj[name];\n\t            idx += 1;\n\t        }\n\t        return result;\n\t    });\n\t\n\t    /**\n\t     * Returns a partial copy of an object containing only the keys that satisfy\n\t     * the supplied predicate.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @since v0.8.0\n\t     * @category Object\n\t     * @sig (v, k -> Boolean) -> {k: v} -> {k: v}\n\t     * @param {Function} pred A predicate to determine whether or not a key\n\t     *        should be included on the output object.\n\t     * @param {Object} obj The object to copy from\n\t     * @return {Object} A new object with only properties that satisfy `pred`\n\t     *         on it.\n\t     * @see R.pick, R.filter\n\t     * @example\n\t     *\n\t     *      var isUpperCase = (val, key) => key.toUpperCase() === key;\n\t     *      R.pickBy(isUpperCase, {a: 1, b: 2, A: 3, B: 4}); //=> {A: 3, B: 4}\n\t     */\n\t    var pickBy = _curry2(function pickBy(test, obj) {\n\t        var result = {};\n\t        for (var prop in obj) {\n\t            if (test(obj[prop], prop, obj)) {\n\t                result[prop] = obj[prop];\n\t            }\n\t        }\n\t        return result;\n\t    });\n\t\n\t    /**\n\t     * Returns a new list with the given element at the front, followed by the\n\t     * contents of the list.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @since v0.1.0\n\t     * @category List\n\t     * @sig a -> [a] -> [a]\n\t     * @param {*} el The item to add to the head of the output list.\n\t     * @param {Array} list The array to add to the tail of the output list.\n\t     * @return {Array} A new array.\n\t     * @see R.append\n\t     * @example\n\t     *\n\t     *      R.prepend('fee', ['fi', 'fo', 'fum']); //=> ['fee', 'fi', 'fo', 'fum']\n\t     */\n\t    var prepend = _curry2(function prepend(el, list) {\n\t        return _concat([el], list);\n\t    });\n\t\n\t    /**\n\t     * Returns a function that when supplied an object returns the indicated\n\t     * property of that object, if it exists.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @since v0.1.0\n\t     * @category Object\n\t     * @sig s -> {s: a} -> a | Undefined\n\t     * @param {String} p The property name\n\t     * @param {Object} obj The object to query\n\t     * @return {*} The value at `obj.p`.\n\t     * @example\n\t     *\n\t     *      R.prop('x', {x: 100}); //=> 100\n\t     *      R.prop('x', {}); //=> undefined\n\t     */\n\t    var prop = _curry2(function prop(p, obj) {\n\t        return obj[p];\n\t    });\n\t\n\t    /**\n\t     * If the given, non-null object has an own property with the specified name,\n\t     * returns the value of that property. Otherwise returns the provided default\n\t     * value.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @since v0.6.0\n\t     * @category Object\n\t     * @sig a -> String -> Object -> a\n\t     * @param {*} val The default value.\n\t     * @param {String} p The name of the property to return.\n\t     * @param {Object} obj The object to query.\n\t     * @return {*} The value of given property of the supplied object or the default value.\n\t     * @example\n\t     *\n\t     *      var alice = {\n\t     *        name: 'ALICE',\n\t     *        age: 101\n\t     *      };\n\t     *      var favorite = R.prop('favoriteLibrary');\n\t     *      var favoriteWithDefault = R.propOr('Ramda', 'favoriteLibrary');\n\t     *\n\t     *      favorite(alice);  //=> undefined\n\t     *      favoriteWithDefault(alice);  //=> 'Ramda'\n\t     */\n\t    var propOr = _curry3(function propOr(val, p, obj) {\n\t        return obj != null && _has(p, obj) ? obj[p] : val;\n\t    });\n\t\n\t    /**\n\t     * Returns `true` if the specified object property satisfies the given\n\t     * predicate; `false` otherwise.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @since v0.16.0\n\t     * @category Logic\n\t     * @sig (a -> Boolean) -> String -> {String: a} -> Boolean\n\t     * @param {Function} pred\n\t     * @param {String} name\n\t     * @param {*} obj\n\t     * @return {Boolean}\n\t     * @see R.propEq, R.propIs\n\t     * @example\n\t     *\n\t     *      R.propSatisfies(x => x > 0, 'x', {x: 1, y: 2}); //=> true\n\t     */\n\t    var propSatisfies = _curry3(function propSatisfies(pred, name, obj) {\n\t        return pred(obj[name]);\n\t    });\n\t\n\t    /**\n\t     * Acts as multiple `prop`: array of keys in, array of values out. Preserves\n\t     * order.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @since v0.1.0\n\t     * @category Object\n\t     * @sig [k] -> {k: v} -> [v]\n\t     * @param {Array} ps The property names to fetch\n\t     * @param {Object} obj The object to query\n\t     * @return {Array} The corresponding values or partially applied function.\n\t     * @example\n\t     *\n\t     *      R.props(['x', 'y'], {x: 1, y: 2}); //=> [1, 2]\n\t     *      R.props(['c', 'a', 'b'], {b: 2, a: 1}); //=> [undefined, 1, 2]\n\t     *\n\t     *      var fullName = R.compose(R.join(' '), R.props(['first', 'last']));\n\t     *      fullName({last: 'Bullet-Tooth', age: 33, first: 'Tony'}); //=> 'Tony Bullet-Tooth'\n\t     */\n\t    var props = _curry2(function props(ps, obj) {\n\t        var len = ps.length;\n\t        var out = [];\n\t        var idx = 0;\n\t        while (idx < len) {\n\t            out[idx] = obj[ps[idx]];\n\t            idx += 1;\n\t        }\n\t        return out;\n\t    });\n\t\n\t    /**\n\t     * Returns a list of numbers from `from` (inclusive) to `to` (exclusive).\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @since v0.1.0\n\t     * @category List\n\t     * @sig Number -> Number -> [Number]\n\t     * @param {Number} from The first number in the list.\n\t     * @param {Number} to One more than the last number in the list.\n\t     * @return {Array} The list of numbers in tthe set `[a, b)`.\n\t     * @example\n\t     *\n\t     *      R.range(1, 5);    //=> [1, 2, 3, 4]\n\t     *      R.range(50, 53);  //=> [50, 51, 52]\n\t     */\n\t    var range = _curry2(function range(from, to) {\n\t        if (!(_isNumber(from) && _isNumber(to))) {\n\t            throw new TypeError('Both arguments to range must be numbers');\n\t        }\n\t        var result = [];\n\t        var n = from;\n\t        while (n < to) {\n\t            result.push(n);\n\t            n += 1;\n\t        }\n\t        return result;\n\t    });\n\t\n\t    /**\n\t     * Returns a single item by iterating through the list, successively calling\n\t     * the iterator function and passing it an accumulator value and the current\n\t     * value from the array, and then passing the result to the next call.\n\t     *\n\t     * Similar to `reduce`, except moves through the input list from the right to\n\t     * the left.\n\t     *\n\t     * The iterator function receives two values: *(acc, value)*\n\t     *\n\t     * Note: `R.reduceRight` does not skip deleted or unassigned indices (sparse\n\t     * arrays), unlike the native `Array.prototype.reduce` method. For more details\n\t     * on this behavior, see:\n\t     * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduceRight#Description\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @since v0.1.0\n\t     * @category List\n\t     * @sig (a,b -> a) -> a -> [b] -> a\n\t     * @param {Function} fn The iterator function. Receives two values, the accumulator and the\n\t     *        current element from the array.\n\t     * @param {*} acc The accumulator value.\n\t     * @param {Array} list The list to iterate over.\n\t     * @return {*} The final, accumulated value.\n\t     * @see R.addIndex\n\t     * @example\n\t     *\n\t     *      var pairs = [ ['a', 1], ['b', 2], ['c', 3] ];\n\t     *      var flattenPairs = (acc, pair) => acc.concat(pair);\n\t     *\n\t     *      R.reduceRight(flattenPairs, [], pairs); //=> [ 'c', 3, 'b', 2, 'a', 1 ]\n\t     */\n\t    var reduceRight = _curry3(function reduceRight(fn, acc, list) {\n\t        var idx = list.length - 1;\n\t        while (idx >= 0) {\n\t            acc = fn(acc, list[idx]);\n\t            idx -= 1;\n\t        }\n\t        return acc;\n\t    });\n\t\n\t    /**\n\t     * Returns a value wrapped to indicate that it is the final value of the reduce\n\t     * and transduce functions. The returned value should be considered a black\n\t     * box: the internal structure is not guaranteed to be stable.\n\t     *\n\t     * Note: this optimization is unavailable to functions not explicitly listed\n\t     * above. For instance, it is not currently supported by reduceRight.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @since v0.15.0\n\t     * @category List\n\t     * @sig a -> *\n\t     * @param {*} x The final value of the reduce.\n\t     * @return {*} The wrapped value.\n\t     * @see R.reduce, R.transduce\n\t     * @example\n\t     *\n\t     *      R.reduce(\n\t     *        R.pipe(R.add, R.when(R.gte(R.__, 10), R.reduced)),\n\t     *        0,\n\t     *        [1, 2, 3, 4, 5]) // 10\n\t     */\n\t    var reduced = _curry1(_reduced);\n\t\n\t    /**\n\t     * Removes the sub-list of `list` starting at index `start` and containing\n\t     * `count` elements. _Note that this is not destructive_: it returns a copy of\n\t     * the list with the changes.\n\t     * <small>No lists have been harmed in the application of this function.</small>\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @since v0.2.2\n\t     * @category List\n\t     * @sig Number -> Number -> [a] -> [a]\n\t     * @param {Number} start The position to start removing elements\n\t     * @param {Number} count The number of elements to remove\n\t     * @param {Array} list The list to remove from\n\t     * @return {Array} A new Array with `count` elements from `start` removed.\n\t     * @example\n\t     *\n\t     *      R.remove(2, 3, [1,2,3,4,5,6,7,8]); //=> [1,2,6,7,8]\n\t     */\n\t    var remove = _curry3(function remove(start, count, list) {\n\t        return _concat(_slice(list, 0, Math.min(start, list.length)), _slice(list, Math.min(list.length, start + count)));\n\t    });\n\t\n\t    /**\n\t     * Replace a substring or regex match in a string with a replacement.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @since v0.7.0\n\t     * @category String\n\t     * @sig RegExp|String -> String -> String -> String\n\t     * @param {RegExp|String} pattern A regular expression or a substring to match.\n\t     * @param {String} replacement The string to replace the matches with.\n\t     * @param {String} str The String to do the search and replacement in.\n\t     * @return {String} The result.\n\t     * @example\n\t     *\n\t     *      R.replace('foo', 'bar', 'foo foo foo'); //=> 'bar foo foo'\n\t     *      R.replace(/foo/, 'bar', 'foo foo foo'); //=> 'bar foo foo'\n\t     *\n\t     *      // Use the \"g\" (global) flag to replace all occurrences:\n\t     *      R.replace(/foo/g, 'bar', 'foo foo foo'); //=> 'bar bar bar'\n\t     */\n\t    var replace = _curry3(function replace(regex, replacement, str) {\n\t        return str.replace(regex, replacement);\n\t    });\n\t\n\t    /**\n\t     * Returns a new list or string with the elements or characters in reverse\n\t     * order.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @since v0.1.0\n\t     * @category List\n\t     * @sig [a] -> [a]\n\t     * @sig String -> String\n\t     * @param {Array|String} list\n\t     * @return {Array|String}\n\t     * @example\n\t     *\n\t     *      R.reverse([1, 2, 3]);  //=> [3, 2, 1]\n\t     *      R.reverse([1, 2]);     //=> [2, 1]\n\t     *      R.reverse([1]);        //=> [1]\n\t     *      R.reverse([]);         //=> []\n\t     *\n\t     *      R.reverse('abc');      //=> 'cba'\n\t     *      R.reverse('ab');       //=> 'ba'\n\t     *      R.reverse('a');        //=> 'a'\n\t     *      R.reverse('');         //=> ''\n\t     */\n\t    var reverse = _curry1(function reverse(list) {\n\t        return _isString(list) ? list.split('').reverse().join('') : _slice(list).reverse();\n\t    });\n\t\n\t    /**\n\t     * Scan is similar to reduce, but returns a list of successively reduced values\n\t     * from the left\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @since v0.10.0\n\t     * @category List\n\t     * @sig (a,b -> a) -> a -> [b] -> [a]\n\t     * @param {Function} fn The iterator function. Receives two values, the accumulator and the\n\t     *        current element from the array\n\t     * @param {*} acc The accumulator value.\n\t     * @param {Array} list The list to iterate over.\n\t     * @return {Array} A list of all intermediately reduced values.\n\t     * @example\n\t     *\n\t     *      var numbers = [1, 2, 3, 4];\n\t     *      var factorials = R.scan(R.multiply, 1, numbers); //=> [1, 1, 2, 6, 24]\n\t     */\n\t    var scan = _curry3(function scan(fn, acc, list) {\n\t        var idx = 0;\n\t        var len = list.length;\n\t        var result = [acc];\n\t        while (idx < len) {\n\t            acc = fn(acc, list[idx]);\n\t            result[idx + 1] = acc;\n\t            idx += 1;\n\t        }\n\t        return result;\n\t    });\n\t\n\t    /**\n\t     * Returns the result of \"setting\" the portion of the given data structure\n\t     * focused by the given lens to the given value.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @since v0.16.0\n\t     * @category Object\n\t     * @typedefn Lens s a = Functor f => (a -> f a) -> s -> f s\n\t     * @sig Lens s a -> a -> s -> s\n\t     * @param {Lens} lens\n\t     * @param {*} v\n\t     * @param {*} x\n\t     * @return {*}\n\t     * @see R.prop, R.lensIndex, R.lensProp\n\t     * @example\n\t     *\n\t     *      var xLens = R.lensProp('x');\n\t     *\n\t     *      R.set(xLens, 4, {x: 1, y: 2});  //=> {x: 4, y: 2}\n\t     *      R.set(xLens, 8, {x: 1, y: 2});  //=> {x: 8, y: 2}\n\t     */\n\t    var set = _curry3(function set(lens, v, x) {\n\t        return over(lens, always(v), x);\n\t    });\n\t\n\t    /**\n\t     * Returns the elements of the given list or string (or object with a `slice`\n\t     * method) from `fromIndex` (inclusive) to `toIndex` (exclusive).\n\t     *\n\t     * Dispatches to the `slice` method of the third argument, if present.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @since v0.1.4\n\t     * @category List\n\t     * @sig Number -> Number -> [a] -> [a]\n\t     * @sig Number -> Number -> String -> String\n\t     * @param {Number} fromIndex The start index (inclusive).\n\t     * @param {Number} toIndex The end index (exclusive).\n\t     * @param {*} list\n\t     * @return {*}\n\t     * @example\n\t     *\n\t     *      R.slice(1, 3, ['a', 'b', 'c', 'd']);        //=> ['b', 'c']\n\t     *      R.slice(1, Infinity, ['a', 'b', 'c', 'd']); //=> ['b', 'c', 'd']\n\t     *      R.slice(0, -1, ['a', 'b', 'c', 'd']);       //=> ['a', 'b', 'c']\n\t     *      R.slice(-3, -1, ['a', 'b', 'c', 'd']);      //=> ['b', 'c']\n\t     *      R.slice(0, 3, 'ramda');                     //=> 'ram'\n\t     */\n\t    var slice = _curry3(_checkForMethod('slice', function slice(fromIndex, toIndex, list) {\n\t        return Array.prototype.slice.call(list, fromIndex, toIndex);\n\t    }));\n\t\n\t    /**\n\t     * Returns a copy of the list, sorted according to the comparator function,\n\t     * which should accept two values at a time and return a negative number if the\n\t     * first value is smaller, a positive number if it's larger, and zero if they\n\t     * are equal. Please note that this is a **copy** of the list. It does not\n\t     * modify the original.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @since v0.1.0\n\t     * @category List\n\t     * @sig (a,a -> Number) -> [a] -> [a]\n\t     * @param {Function} comparator A sorting function :: a -> b -> Int\n\t     * @param {Array} list The list to sort\n\t     * @return {Array} a new array with its elements sorted by the comparator function.\n\t     * @example\n\t     *\n\t     *      var diff = function(a, b) { return a - b; };\n\t     *      R.sort(diff, [4,2,7,5]); //=> [2, 4, 5, 7]\n\t     */\n\t    var sort = _curry2(function sort(comparator, list) {\n\t        return _slice(list).sort(comparator);\n\t    });\n\t\n\t    /**\n\t     * Sorts the list according to the supplied function.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @since v0.1.0\n\t     * @category Relation\n\t     * @sig Ord b => (a -> b) -> [a] -> [a]\n\t     * @param {Function} fn\n\t     * @param {Array} list The list to sort.\n\t     * @return {Array} A new list sorted by the keys generated by `fn`.\n\t     * @example\n\t     *\n\t     *      var sortByFirstItem = R.sortBy(R.prop(0));\n\t     *      var sortByNameCaseInsensitive = R.sortBy(R.compose(R.toLower, R.prop('name')));\n\t     *      var pairs = [[-1, 1], [-2, 2], [-3, 3]];\n\t     *      sortByFirstItem(pairs); //=> [[-3, 3], [-2, 2], [-1, 1]]\n\t     *      var alice = {\n\t     *        name: 'ALICE',\n\t     *        age: 101\n\t     *      };\n\t     *      var bob = {\n\t     *        name: 'Bob',\n\t     *        age: -10\n\t     *      };\n\t     *      var clara = {\n\t     *        name: 'clara',\n\t     *        age: 314.159\n\t     *      };\n\t     *      var people = [clara, bob, alice];\n\t     *      sortByNameCaseInsensitive(people); //=> [alice, bob, clara]\n\t     */\n\t    var sortBy = _curry2(function sortBy(fn, list) {\n\t        return _slice(list).sort(function (a, b) {\n\t            var aa = fn(a);\n\t            var bb = fn(b);\n\t            return aa < bb ? -1 : aa > bb ? 1 : 0;\n\t        });\n\t    });\n\t\n\t    /**\n\t     * Splits a given list or string at a given index.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @since 0.19.1\n\t     * @since 0.19.0\n\t     * @category List\n\t     * @sig Number -> [a] -> [[a], [a]]\n\t     * @sig Number -> String -> [String, String]\n\t     * @param {Number} index The index where the array/string is split.\n\t     * @param {Array|String} array The array/string to be split.\n\t     * @return {Array}\n\t     * @example\n\t     *\n\t     *      R.splitAt(1, [1, 2, 3]);          //=> [[1], [2, 3]]\n\t     *      R.splitAt(5, 'hello world');      //=> ['hello', ' world']\n\t     *      R.splitAt(-1, 'foobar');          //=> ['fooba', 'r']\n\t     */\n\t    var splitAt = _curry2(function splitAt(index, array) {\n\t        return [\n\t            slice(0, index, array),\n\t            slice(index, length(array), array)\n\t        ];\n\t    });\n\t\n\t    /**\n\t     * Splits a collection into slices of the specified length.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @since v0.16.0\n\t     * @category List\n\t     * @sig Number -> [a] -> [[a]]\n\t     * @sig Number -> String -> [String]\n\t     * @param {Number} n\n\t     * @param {Array} list\n\t     * @return {Array}\n\t     * @example\n\t     *\n\t     *      R.splitEvery(3, [1, 2, 3, 4, 5, 6, 7]); //=> [[1, 2, 3], [4, 5, 6], [7]]\n\t     *      R.splitEvery(3, 'foobarbaz'); //=> ['foo', 'bar', 'baz']\n\t     */\n\t    var splitEvery = _curry2(function splitEvery(n, list) {\n\t        if (n <= 0) {\n\t            throw new Error('First argument to splitEvery must be a positive integer');\n\t        }\n\t        var result = [];\n\t        var idx = 0;\n\t        while (idx < list.length) {\n\t            result.push(slice(idx, idx += n, list));\n\t        }\n\t        return result;\n\t    });\n\t\n\t    /**\n\t     * Takes a list and a predicate and returns a pair of lists with the following properties:\n\t     *\n\t     *  - the result of concatenating the two output lists is equivalent to the input list;\n\t     *  - none of the elements of the first output list satisfies the predicate; and\n\t     *  - if the second output list is non-empty, its first element satisfies the predicate.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @since 0.19.1\n\t     * @since 0.19.0\n\t     * @category List\n\t     * @sig (a -> Boolean) -> [a] -> [[a], [a]]\n\t     * @param {Function} pred The predicate that determines where the array is split.\n\t     * @param {Array} list The array to be split.\n\t     * @return {Array}\n\t     * @example\n\t     *\n\t     *      R.splitWhen(R.equals(2), [1, 2, 3, 1, 2, 3]);   //=> [[1], [2, 3, 1, 2, 3]]\n\t     */\n\t    var splitWhen = _curry2(function splitWhen(pred, list) {\n\t        var idx = 0;\n\t        var len = list.length;\n\t        var prefix = [];\n\t        while (idx < len && !pred(list[idx])) {\n\t            prefix.push(list[idx]);\n\t            idx += 1;\n\t        }\n\t        return [\n\t            prefix,\n\t            _slice(list, idx)\n\t        ];\n\t    });\n\t\n\t    /**\n\t     * Subtracts two numbers. Equivalent to `a - b` but curried.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @since v0.1.0\n\t     * @category Math\n\t     * @sig Number -> Number -> Number\n\t     * @param {Number} a The first value.\n\t     * @param {Number} b The second value.\n\t     * @return {Number} The result of `a - b`.\n\t     * @see R.add\n\t     * @example\n\t     *\n\t     *      R.subtract(10, 8); //=> 2\n\t     *\n\t     *      var minus5 = R.subtract(R.__, 5);\n\t     *      minus5(17); //=> 12\n\t     *\n\t     *      var complementaryAngle = R.subtract(90);\n\t     *      complementaryAngle(30); //=> 60\n\t     *      complementaryAngle(72); //=> 18\n\t     */\n\t    var subtract = _curry2(function subtract(a, b) {\n\t        return a - b;\n\t    });\n\t\n\t    /**\n\t     * Returns all but the first element of the given list or string (or object\n\t     * with a `tail` method).\n\t     *\n\t     * Dispatches to the `slice` method of the first argument, if present.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @since v0.1.0\n\t     * @category List\n\t     * @sig [a] -> [a]\n\t     * @sig String -> String\n\t     * @param {*} list\n\t     * @return {*}\n\t     * @see R.head, R.init, R.last\n\t     * @example\n\t     *\n\t     *      R.tail([1, 2, 3]);  //=> [2, 3]\n\t     *      R.tail([1, 2]);     //=> [2]\n\t     *      R.tail([1]);        //=> []\n\t     *      R.tail([]);         //=> []\n\t     *\n\t     *      R.tail('abc');  //=> 'bc'\n\t     *      R.tail('ab');   //=> 'b'\n\t     *      R.tail('a');    //=> ''\n\t     *      R.tail('');     //=> ''\n\t     */\n\t    var tail = _checkForMethod('tail', slice(1, Infinity));\n\t\n\t    /**\n\t     * Returns the first `n` elements of the given list, string, or\n\t     * transducer/transformer (or object with a `take` method).\n\t     *\n\t     * Dispatches to the `take` method of the second argument, if present.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @since v0.1.0\n\t     * @category List\n\t     * @sig Number -> [a] -> [a]\n\t     * @sig Number -> String -> String\n\t     * @param {Number} n\n\t     * @param {*} list\n\t     * @return {*}\n\t     * @see R.drop\n\t     * @example\n\t     *\n\t     *      R.take(1, ['foo', 'bar', 'baz']); //=> ['foo']\n\t     *      R.take(2, ['foo', 'bar', 'baz']); //=> ['foo', 'bar']\n\t     *      R.take(3, ['foo', 'bar', 'baz']); //=> ['foo', 'bar', 'baz']\n\t     *      R.take(4, ['foo', 'bar', 'baz']); //=> ['foo', 'bar', 'baz']\n\t     *      R.take(3, 'ramda');               //=> 'ram'\n\t     *\n\t     *      var personnel = [\n\t     *        'Dave Brubeck',\n\t     *        'Paul Desmond',\n\t     *        'Eugene Wright',\n\t     *        'Joe Morello',\n\t     *        'Gerry Mulligan',\n\t     *        'Bob Bates',\n\t     *        'Joe Dodge',\n\t     *        'Ron Crotty'\n\t     *      ];\n\t     *\n\t     *      var takeFive = R.take(5);\n\t     *      takeFive(personnel);\n\t     *      //=> ['Dave Brubeck', 'Paul Desmond', 'Eugene Wright', 'Joe Morello', 'Gerry Mulligan']\n\t     */\n\t    var take = _curry2(_dispatchable('take', _xtake, function take(n, xs) {\n\t        return slice(0, n < 0 ? Infinity : n, xs);\n\t    }));\n\t\n\t    /**\n\t     * Returns a new list containing the last `n` elements of a given list, passing\n\t     * each value to the supplied predicate function, and terminating when the\n\t     * predicate function returns `false`. Excludes the element that caused the\n\t     * predicate function to fail. The predicate function is passed one argument:\n\t     * *(value)*.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @since v0.16.0\n\t     * @category List\n\t     * @sig (a -> Boolean) -> [a] -> [a]\n\t     * @param {Function} fn The function called per iteration.\n\t     * @param {Array} list The collection to iterate over.\n\t     * @return {Array} A new array.\n\t     * @see R.dropLastWhile, R.addIndex\n\t     * @example\n\t     *\n\t     *      var isNotOne = x => x !== 1;\n\t     *\n\t     *      R.takeLastWhile(isNotOne, [1, 2, 3, 4]); //=> [2, 3, 4]\n\t     */\n\t    var takeLastWhile = _curry2(function takeLastWhile(fn, list) {\n\t        var idx = list.length - 1;\n\t        while (idx >= 0 && fn(list[idx])) {\n\t            idx -= 1;\n\t        }\n\t        return _slice(list, idx + 1, Infinity);\n\t    });\n\t\n\t    /**\n\t     * Returns a new list containing the first `n` elements of a given list,\n\t     * passing each value to the supplied predicate function, and terminating when\n\t     * the predicate function returns `false`. Excludes the element that caused the\n\t     * predicate function to fail. The predicate function is passed one argument:\n\t     * *(value)*.\n\t     *\n\t     * Dispatches to the `takeWhile` method of the second argument, if present.\n\t     *\n\t     * Acts as a transducer if a transformer is given in list position.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @since v0.1.0\n\t     * @category List\n\t     * @sig (a -> Boolean) -> [a] -> [a]\n\t     * @param {Function} fn The function called per iteration.\n\t     * @param {Array} list The collection to iterate over.\n\t     * @return {Array} A new array.\n\t     * @see R.dropWhile, R.transduce, R.addIndex\n\t     * @example\n\t     *\n\t     *      var isNotFour = x => x !== 4;\n\t     *\n\t     *      R.takeWhile(isNotFour, [1, 2, 3, 4, 3, 2, 1]); //=> [1, 2, 3]\n\t     */\n\t    var takeWhile = _curry2(_dispatchable('takeWhile', _xtakeWhile, function takeWhile(fn, list) {\n\t        var idx = 0;\n\t        var len = list.length;\n\t        while (idx < len && fn(list[idx])) {\n\t            idx += 1;\n\t        }\n\t        return _slice(list, 0, idx);\n\t    }));\n\t\n\t    /**\n\t     * Runs the given function with the supplied object, then returns the object.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @since v0.1.0\n\t     * @category Function\n\t     * @sig (a -> *) -> a -> a\n\t     * @param {Function} fn The function to call with `x`. The return value of `fn` will be thrown away.\n\t     * @param {*} x\n\t     * @return {*} `x`.\n\t     * @example\n\t     *\n\t     *      var sayX = x => console.log('x is ' + x);\n\t     *      R.tap(sayX, 100); //=> 100\n\t     *      //-> 'x is 100'\n\t     */\n\t    var tap = _curry2(function tap(fn, x) {\n\t        fn(x);\n\t        return x;\n\t    });\n\t\n\t    /**\n\t     * Calls an input function `n` times, returning an array containing the results\n\t     * of those function calls.\n\t     *\n\t     * `fn` is passed one argument: The current value of `n`, which begins at `0`\n\t     * and is gradually incremented to `n - 1`.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @since v0.2.3\n\t     * @category List\n\t     * @sig (Number -> a) -> Number -> [a]\n\t     * @param {Function} fn The function to invoke. Passed one argument, the current value of `n`.\n\t     * @param {Number} n A value between `0` and `n - 1`. Increments after each function call.\n\t     * @return {Array} An array containing the return values of all calls to `fn`.\n\t     * @example\n\t     *\n\t     *      R.times(R.identity, 5); //=> [0, 1, 2, 3, 4]\n\t     */\n\t    var times = _curry2(function times(fn, n) {\n\t        var len = Number(n);\n\t        var idx = 0;\n\t        var list;\n\t        if (len < 0 || isNaN(len)) {\n\t            throw new RangeError('n must be a non-negative number');\n\t        }\n\t        list = new Array(len);\n\t        while (idx < len) {\n\t            list[idx] = fn(idx);\n\t            idx += 1;\n\t        }\n\t        return list;\n\t    });\n\t\n\t    /**\n\t     * Converts an object into an array of key, value arrays. Only the object's\n\t     * own properties are used.\n\t     * Note that the order of the output array is not guaranteed to be consistent\n\t     * across different JS platforms.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @since v0.4.0\n\t     * @category Object\n\t     * @sig {String: *} -> [[String,*]]\n\t     * @param {Object} obj The object to extract from\n\t     * @return {Array} An array of key, value arrays from the object's own properties.\n\t     * @see R.fromPairs\n\t     * @example\n\t     *\n\t     *      R.toPairs({a: 1, b: 2, c: 3}); //=> [['a', 1], ['b', 2], ['c', 3]]\n\t     */\n\t    var toPairs = _curry1(function toPairs(obj) {\n\t        var pairs = [];\n\t        for (var prop in obj) {\n\t            if (_has(prop, obj)) {\n\t                pairs[pairs.length] = [\n\t                    prop,\n\t                    obj[prop]\n\t                ];\n\t            }\n\t        }\n\t        return pairs;\n\t    });\n\t\n\t    /**\n\t     * Converts an object into an array of key, value arrays. The object's own\n\t     * properties and prototype properties are used. Note that the order of the\n\t     * output array is not guaranteed to be consistent across different JS\n\t     * platforms.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @since v0.4.0\n\t     * @category Object\n\t     * @sig {String: *} -> [[String,*]]\n\t     * @param {Object} obj The object to extract from\n\t     * @return {Array} An array of key, value arrays from the object's own\n\t     *         and prototype properties.\n\t     * @example\n\t     *\n\t     *      var F = function() { this.x = 'X'; };\n\t     *      F.prototype.y = 'Y';\n\t     *      var f = new F();\n\t     *      R.toPairsIn(f); //=> [['x','X'], ['y','Y']]\n\t     */\n\t    var toPairsIn = _curry1(function toPairsIn(obj) {\n\t        var pairs = [];\n\t        for (var prop in obj) {\n\t            pairs[pairs.length] = [\n\t                prop,\n\t                obj[prop]\n\t            ];\n\t        }\n\t        return pairs;\n\t    });\n\t\n\t    /**\n\t     * Transposes the rows and columns of a 2D list.\n\t     * When passed a list of `n` lists of length `x`,\n\t     * returns a list of `x` lists of length `n`.\n\t     *\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @since 0.19.1\n\t     * @since 0.19.0\n\t     * @category List\n\t     * @sig [[a]] -> [[a]]\n\t     * @param {Array} list A 2D list\n\t     * @return {Array} A 2D list\n\t     * @example\n\t     *\n\t     *      R.transpose([[1, 'a'], [2, 'b'], [3, 'c']]) //=> [[1, 2, 3], ['a', 'b', 'c']]\n\t     *      R.transpose([[1, 2, 3], ['a', 'b', 'c']]) //=> [[1, 'a'], [2, 'b'], [3, 'c']]\n\t     *\n\t     * If some of the rows are shorter than the following rows, their elements are skipped:\n\t     *\n\t     *      R.transpose([[10, 11], [20], [], [30, 31, 32]]) //=> [[10, 20, 30], [11, 31], [32]]\n\t     */\n\t    var transpose = _curry1(function transpose(outerlist) {\n\t        var i = 0;\n\t        var result = [];\n\t        while (i < outerlist.length) {\n\t            var innerlist = outerlist[i];\n\t            var j = 0;\n\t            while (j < innerlist.length) {\n\t                if (typeof result[j] === 'undefined') {\n\t                    result[j] = [];\n\t                }\n\t                result[j].push(innerlist[j]);\n\t                j += 1;\n\t            }\n\t            i += 1;\n\t        }\n\t        return result;\n\t    });\n\t\n\t    /**\n\t     * Removes (strips) whitespace from both ends of the string.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @since v0.6.0\n\t     * @category String\n\t     * @sig String -> String\n\t     * @param {String} str The string to trim.\n\t     * @return {String} Trimmed version of `str`.\n\t     * @example\n\t     *\n\t     *      R.trim('   xyz  '); //=> 'xyz'\n\t     *      R.map(R.trim, R.split(',', 'x, y, z')); //=> ['x', 'y', 'z']\n\t     */\n\t    var trim = function () {\n\t        var ws = '\\t\\n\\x0B\\f\\r \\xA0\\u1680\\u180E\\u2000\\u2001\\u2002\\u2003' + '\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200A\\u202F\\u205F\\u3000\\u2028' + '\\u2029\\uFEFF';\n\t        var zeroWidth = '\\u200B';\n\t        var hasProtoTrim = typeof String.prototype.trim === 'function';\n\t        if (!hasProtoTrim || (ws.trim() || !zeroWidth.trim())) {\n\t            return _curry1(function trim(str) {\n\t                var beginRx = new RegExp('^[' + ws + '][' + ws + ']*');\n\t                var endRx = new RegExp('[' + ws + '][' + ws + ']*$');\n\t                return str.replace(beginRx, '').replace(endRx, '');\n\t            });\n\t        } else {\n\t            return _curry1(function trim(str) {\n\t                return str.trim();\n\t            });\n\t        }\n\t    }();\n\t\n\t    /**\n\t     * Gives a single-word string description of the (native) type of a value,\n\t     * returning such answers as 'Object', 'Number', 'Array', or 'Null'. Does not\n\t     * attempt to distinguish user Object types any further, reporting them all as\n\t     * 'Object'.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @since v0.8.0\n\t     * @category Type\n\t     * @sig (* -> {*}) -> String\n\t     * @param {*} val The value to test\n\t     * @return {String}\n\t     * @example\n\t     *\n\t     *      R.type({}); //=> \"Object\"\n\t     *      R.type(1); //=> \"Number\"\n\t     *      R.type(false); //=> \"Boolean\"\n\t     *      R.type('s'); //=> \"String\"\n\t     *      R.type(null); //=> \"Null\"\n\t     *      R.type([]); //=> \"Array\"\n\t     *      R.type(/[A-z]/); //=> \"RegExp\"\n\t     */\n\t    var type = _curry1(function type(val) {\n\t        return val === null ? 'Null' : val === undefined ? 'Undefined' : Object.prototype.toString.call(val).slice(8, -1);\n\t    });\n\t\n\t    /**\n\t     * Takes a function `fn`, which takes a single array argument, and returns a\n\t     * function which:\n\t     *\n\t     *   - takes any number of positional arguments;\n\t     *   - passes these arguments to `fn` as an array; and\n\t     *   - returns the result.\n\t     *\n\t     * In other words, R.unapply derives a variadic function from a function which\n\t     * takes an array. R.unapply is the inverse of R.apply.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @since v0.8.0\n\t     * @category Function\n\t     * @sig ([*...] -> a) -> (*... -> a)\n\t     * @param {Function} fn\n\t     * @return {Function}\n\t     * @see R.apply\n\t     * @example\n\t     *\n\t     *      R.unapply(JSON.stringify)(1, 2, 3); //=> '[1,2,3]'\n\t     */\n\t    var unapply = _curry1(function unapply(fn) {\n\t        return function () {\n\t            return fn(_slice(arguments));\n\t        };\n\t    });\n\t\n\t    /**\n\t     * Wraps a function of any arity (including nullary) in a function that accepts\n\t     * exactly 1 parameter. Any extraneous parameters will not be passed to the\n\t     * supplied function.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @since v0.2.0\n\t     * @category Function\n\t     * @sig (* -> b) -> (a -> b)\n\t     * @param {Function} fn The function to wrap.\n\t     * @return {Function} A new function wrapping `fn`. The new function is guaranteed to be of\n\t     *         arity 1.\n\t     * @example\n\t     *\n\t     *      var takesTwoArgs = function(a, b) {\n\t     *        return [a, b];\n\t     *      };\n\t     *      takesTwoArgs.length; //=> 2\n\t     *      takesTwoArgs(1, 2); //=> [1, 2]\n\t     *\n\t     *      var takesOneArg = R.unary(takesTwoArgs);\n\t     *      takesOneArg.length; //=> 1\n\t     *      // Only 1 argument is passed to the wrapped function\n\t     *      takesOneArg(1, 2); //=> [1, undefined]\n\t     */\n\t    var unary = _curry1(function unary(fn) {\n\t        return nAry(1, fn);\n\t    });\n\t\n\t    /**\n\t     * Returns a function of arity `n` from a (manually) curried function.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @since v0.14.0\n\t     * @category Function\n\t     * @sig Number -> (a -> b) -> (a -> c)\n\t     * @param {Number} length The arity for the returned function.\n\t     * @param {Function} fn The function to uncurry.\n\t     * @return {Function} A new function.\n\t     * @see R.curry\n\t     * @example\n\t     *\n\t     *      var addFour = a => b => c => d => a + b + c + d;\n\t     *\n\t     *      var uncurriedAddFour = R.uncurryN(4, addFour);\n\t     *      uncurriedAddFour(1, 2, 3, 4); //=> 10\n\t     */\n\t    var uncurryN = _curry2(function uncurryN(depth, fn) {\n\t        return curryN(depth, function () {\n\t            var currentDepth = 1;\n\t            var value = fn;\n\t            var idx = 0;\n\t            var endIdx;\n\t            while (currentDepth <= depth && typeof value === 'function') {\n\t                endIdx = currentDepth === depth ? arguments.length : idx + value.length;\n\t                value = value.apply(this, _slice(arguments, idx, endIdx));\n\t                currentDepth += 1;\n\t                idx = endIdx;\n\t            }\n\t            return value;\n\t        });\n\t    });\n\t\n\t    /**\n\t     * Builds a list from a seed value. Accepts an iterator function, which returns\n\t     * either false to stop iteration or an array of length 2 containing the value\n\t     * to add to the resulting list and the seed to be used in the next call to the\n\t     * iterator function.\n\t     *\n\t     * The iterator function receives one argument: *(seed)*.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @since v0.10.0\n\t     * @category List\n\t     * @sig (a -> [b]) -> * -> [b]\n\t     * @param {Function} fn The iterator function. receives one argument, `seed`, and returns\n\t     *        either false to quit iteration or an array of length two to proceed. The element\n\t     *        at index 0 of this array will be added to the resulting array, and the element\n\t     *        at index 1 will be passed to the next call to `fn`.\n\t     * @param {*} seed The seed value.\n\t     * @return {Array} The final list.\n\t     * @example\n\t     *\n\t     *      var f = n => n > 50 ? false : [-n, n + 10];\n\t     *      R.unfold(f, 10); //=> [-10, -20, -30, -40, -50]\n\t     */\n\t    var unfold = _curry2(function unfold(fn, seed) {\n\t        var pair = fn(seed);\n\t        var result = [];\n\t        while (pair && pair.length) {\n\t            result[result.length] = pair[0];\n\t            pair = fn(pair[1]);\n\t        }\n\t        return result;\n\t    });\n\t\n\t    /**\n\t     * Returns a new list containing only one copy of each element in the original\n\t     * list, based upon the value returned by applying the supplied predicate to\n\t     * two list elements. Prefers the first item if two items compare equal based\n\t     * on the predicate.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @since v0.2.0\n\t     * @category List\n\t     * @sig (a, a -> Boolean) -> [a] -> [a]\n\t     * @param {Function} pred A predicate used to test whether two items are equal.\n\t     * @param {Array} list The array to consider.\n\t     * @return {Array} The list of unique items.\n\t     * @example\n\t     *\n\t     *      var strEq = R.eqBy(String);\n\t     *      R.uniqWith(strEq)([1, '1', 2, 1]); //=> [1, 2]\n\t     *      R.uniqWith(strEq)([{}, {}]);       //=> [{}]\n\t     *      R.uniqWith(strEq)([1, '1', 1]);    //=> [1]\n\t     *      R.uniqWith(strEq)(['1', 1, 1]);    //=> ['1']\n\t     */\n\t    var uniqWith = _curry2(function uniqWith(pred, list) {\n\t        var idx = 0;\n\t        var len = list.length;\n\t        var result = [];\n\t        var item;\n\t        while (idx < len) {\n\t            item = list[idx];\n\t            if (!_containsWith(pred, item, result)) {\n\t                result[result.length] = item;\n\t            }\n\t            idx += 1;\n\t        }\n\t        return result;\n\t    });\n\t\n\t    /**\n\t     * Tests the final argument by passing it to the given predicate function. If\n\t     * the predicate is not satisfied, the function will return the result of\n\t     * calling the `whenFalseFn` function with the same argument. If the predicate\n\t     * is satisfied, the argument is returned as is.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @since v0.18.0\n\t     * @category Logic\n\t     * @sig (a -> Boolean) -> (a -> a) -> a -> a\n\t     * @param {Function} pred        A predicate function\n\t     * @param {Function} whenFalseFn A function to invoke when the `pred` evaluates\n\t     *                               to a falsy value.\n\t     * @param {*}        x           An object to test with the `pred` function and\n\t     *                               pass to `whenFalseFn` if necessary.\n\t     * @return {*} Either `x` or the result of applying `x` to `whenFalseFn`.\n\t     * @see R.ifElse, R.when\n\t     * @example\n\t     *\n\t     *      // coerceArray :: (a|[a]) -> [a]\n\t     *      var coerceArray = R.unless(R.isArrayLike, R.of);\n\t     *      coerceArray([1, 2, 3]); //=> [1, 2, 3]\n\t     *      coerceArray(1);         //=> [1]\n\t     */\n\t    var unless = _curry3(function unless(pred, whenFalseFn, x) {\n\t        return pred(x) ? x : whenFalseFn(x);\n\t    });\n\t\n\t    /**\n\t     * Returns a new copy of the array with the element at the provided index\n\t     * replaced with the given value.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @since v0.14.0\n\t     * @category List\n\t     * @sig Number -> a -> [a] -> [a]\n\t     * @param {Number} idx The index to update.\n\t     * @param {*} x The value to exist at the given index of the returned array.\n\t     * @param {Array|Arguments} list The source array-like object to be updated.\n\t     * @return {Array} A copy of `list` with the value at index `idx` replaced with `x`.\n\t     * @see R.adjust\n\t     * @example\n\t     *\n\t     *      R.update(1, 11, [0, 1, 2]);     //=> [0, 11, 2]\n\t     *      R.update(1)(11)([0, 1, 2]);     //=> [0, 11, 2]\n\t     */\n\t    var update = _curry3(function update(idx, x, list) {\n\t        return adjust(always(x), idx, list);\n\t    });\n\t\n\t    /**\n\t     * Accepts a function `fn` and a list of transformer functions and returns a\n\t     * new curried function. When the new function is invoked, it calls the\n\t     * function `fn` with parameters consisting of the result of calling each\n\t     * supplied handler on successive arguments to the new function.\n\t     *\n\t     * If more arguments are passed to the returned function than transformer\n\t     * functions, those arguments are passed directly to `fn` as additional\n\t     * parameters. If you expect additional arguments that don't need to be\n\t     * transformed, although you can ignore them, it's best to pass an identity\n\t     * function so that the new function reports the correct arity.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @since v0.1.0\n\t     * @category Function\n\t     * @sig (x1 -> x2 -> ... -> z) -> [(a -> x1), (b -> x2), ...] -> (a -> b -> ... -> z)\n\t     * @param {Function} fn The function to wrap.\n\t     * @param {Array} transformers A list of transformer functions\n\t     * @return {Function} The wrapped function.\n\t     * @example\n\t     *\n\t     *      R.useWith(Math.pow, [R.identity, R.identity])(3, 4); //=> 81\n\t     *      R.useWith(Math.pow, [R.identity, R.identity])(3)(4); //=> 81\n\t     *      R.useWith(Math.pow, [R.dec, R.inc])(3, 4); //=> 32\n\t     *      R.useWith(Math.pow, [R.dec, R.inc])(3)(4); //=> 32\n\t     */\n\t    var useWith = _curry2(function useWith(fn, transformers) {\n\t        return curryN(transformers.length, function () {\n\t            var args = [];\n\t            var idx = 0;\n\t            while (idx < transformers.length) {\n\t                args.push(transformers[idx].call(this, arguments[idx]));\n\t                idx += 1;\n\t            }\n\t            return fn.apply(this, args.concat(_slice(arguments, transformers.length)));\n\t        });\n\t    });\n\t\n\t    /**\n\t     * Returns a list of all the enumerable own properties of the supplied object.\n\t     * Note that the order of the output array is not guaranteed across different\n\t     * JS platforms.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @since v0.1.0\n\t     * @category Object\n\t     * @sig {k: v} -> [v]\n\t     * @param {Object} obj The object to extract values from\n\t     * @return {Array} An array of the values of the object's own properties.\n\t     * @example\n\t     *\n\t     *      R.values({a: 1, b: 2, c: 3}); //=> [1, 2, 3]\n\t     */\n\t    var values = _curry1(function values(obj) {\n\t        var props = keys(obj);\n\t        var len = props.length;\n\t        var vals = [];\n\t        var idx = 0;\n\t        while (idx < len) {\n\t            vals[idx] = obj[props[idx]];\n\t            idx += 1;\n\t        }\n\t        return vals;\n\t    });\n\t\n\t    /**\n\t     * Returns a list of all the properties, including prototype properties, of the\n\t     * supplied object.\n\t     * Note that the order of the output array is not guaranteed to be consistent\n\t     * across different JS platforms.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @since v0.2.0\n\t     * @category Object\n\t     * @sig {k: v} -> [v]\n\t     * @param {Object} obj The object to extract values from\n\t     * @return {Array} An array of the values of the object's own and prototype properties.\n\t     * @example\n\t     *\n\t     *      var F = function() { this.x = 'X'; };\n\t     *      F.prototype.y = 'Y';\n\t     *      var f = new F();\n\t     *      R.valuesIn(f); //=> ['X', 'Y']\n\t     */\n\t    var valuesIn = _curry1(function valuesIn(obj) {\n\t        var prop;\n\t        var vs = [];\n\t        for (prop in obj) {\n\t            vs[vs.length] = obj[prop];\n\t        }\n\t        return vs;\n\t    });\n\t\n\t    /**\n\t     * Returns a \"view\" of the given data structure, determined by the given lens.\n\t     * The lens's focus determines which portion of the data structure is visible.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @since v0.16.0\n\t     * @category Object\n\t     * @typedefn Lens s a = Functor f => (a -> f a) -> s -> f s\n\t     * @sig Lens s a -> s -> a\n\t     * @param {Lens} lens\n\t     * @param {*} x\n\t     * @return {*}\n\t     * @see R.prop, R.lensIndex, R.lensProp\n\t     * @example\n\t     *\n\t     *      var xLens = R.lensProp('x');\n\t     *\n\t     *      R.view(xLens, {x: 1, y: 2});  //=> 1\n\t     *      R.view(xLens, {x: 4, y: 2});  //=> 4\n\t     */\n\t    var view = function () {\n\t        var Const = function (x) {\n\t            return {\n\t                value: x,\n\t                map: function () {\n\t                    return this;\n\t                }\n\t            };\n\t        };\n\t        return _curry2(function view(lens, x) {\n\t            return lens(Const)(x).value;\n\t        });\n\t    }();\n\t\n\t    /**\n\t     * Tests the final argument by passing it to the given predicate function. If\n\t     * the predicate is satisfied, the function will return the result of calling\n\t     * the `whenTrueFn` function with the same argument. If the predicate is not\n\t     * satisfied, the argument is returned as is.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @since v0.18.0\n\t     * @category Logic\n\t     * @sig (a -> Boolean) -> (a -> a) -> a -> a\n\t     * @param {Function} pred       A predicate function\n\t     * @param {Function} whenTrueFn A function to invoke when the `condition`\n\t     *                              evaluates to a truthy value.\n\t     * @param {*}        x          An object to test with the `pred` function and\n\t     *                              pass to `whenTrueFn` if necessary.\n\t     * @return {*} Either `x` or the result of applying `x` to `whenTrueFn`.\n\t     * @see R.ifElse, R.unless\n\t     * @example\n\t     *\n\t     *      // truncate :: String -> String\n\t     *      var truncate = R.when(\n\t     *        R.propSatisfies(R.gt(R.__, 10), 'length'),\n\t     *        R.pipe(R.take(10), R.append('…'), R.join(''))\n\t     *      );\n\t     *      truncate('12345');         //=> '12345'\n\t     *      truncate('0123456789ABC'); //=> '0123456789…'\n\t     */\n\t    var when = _curry3(function when(pred, whenTrueFn, x) {\n\t        return pred(x) ? whenTrueFn(x) : x;\n\t    });\n\t\n\t    /**\n\t     * Takes a spec object and a test object; returns true if the test satisfies\n\t     * the spec. Each of the spec's own properties must be a predicate function.\n\t     * Each predicate is applied to the value of the corresponding property of the\n\t     * test object. `where` returns true if all the predicates return true, false\n\t     * otherwise.\n\t     *\n\t     * `where` is well suited to declaratively expressing constraints for other\n\t     * functions such as `filter` and `find`.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @since v0.1.1\n\t     * @category Object\n\t     * @sig {String: (* -> Boolean)} -> {String: *} -> Boolean\n\t     * @param {Object} spec\n\t     * @param {Object} testObj\n\t     * @return {Boolean}\n\t     * @example\n\t     *\n\t     *      // pred :: Object -> Boolean\n\t     *      var pred = R.where({\n\t     *        a: R.equals('foo'),\n\t     *        b: R.complement(R.equals('bar')),\n\t     *        x: R.gt(_, 10),\n\t     *        y: R.lt(_, 20)\n\t     *      });\n\t     *\n\t     *      pred({a: 'foo', b: 'xxx', x: 11, y: 19}); //=> true\n\t     *      pred({a: 'xxx', b: 'xxx', x: 11, y: 19}); //=> false\n\t     *      pred({a: 'foo', b: 'bar', x: 11, y: 19}); //=> false\n\t     *      pred({a: 'foo', b: 'xxx', x: 10, y: 19}); //=> false\n\t     *      pred({a: 'foo', b: 'xxx', x: 11, y: 20}); //=> false\n\t     */\n\t    var where = _curry2(function where(spec, testObj) {\n\t        for (var prop in spec) {\n\t            if (_has(prop, spec) && !spec[prop](testObj[prop])) {\n\t                return false;\n\t            }\n\t        }\n\t        return true;\n\t    });\n\t\n\t    /**\n\t     * Wrap a function inside another to allow you to make adjustments to the\n\t     * parameters, or do other processing either before the internal function is\n\t     * called or with its results.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @since v0.1.0\n\t     * @category Function\n\t     * @sig (a... -> b) -> ((a... -> b) -> a... -> c) -> (a... -> c)\n\t     * @param {Function} fn The function to wrap.\n\t     * @param {Function} wrapper The wrapper function.\n\t     * @return {Function} The wrapped function.\n\t     * @example\n\t     *\n\t     *      var greet = name => 'Hello ' + name;\n\t     *\n\t     *      var shoutedGreet = R.wrap(greet, (gr, name) => gr(name).toUpperCase());\n\t     *\n\t     *      shoutedGreet(\"Kathy\"); //=> \"HELLO KATHY\"\n\t     *\n\t     *      var shortenedGreet = R.wrap(greet, function(gr, name) {\n\t     *        return gr(name.substring(0, 3));\n\t     *      });\n\t     *      shortenedGreet(\"Robert\"); //=> \"Hello Rob\"\n\t     */\n\t    var wrap = _curry2(function wrap(fn, wrapper) {\n\t        return curryN(fn.length, function () {\n\t            return wrapper.apply(this, _concat([fn], arguments));\n\t        });\n\t    });\n\t\n\t    /**\n\t     * Creates a new list out of the two supplied by creating each possible pair\n\t     * from the lists.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @since v0.1.0\n\t     * @category List\n\t     * @sig [a] -> [b] -> [[a,b]]\n\t     * @param {Array} as The first list.\n\t     * @param {Array} bs The second list.\n\t     * @return {Array} The list made by combining each possible pair from\n\t     *         `as` and `bs` into pairs (`[a, b]`).\n\t     * @example\n\t     *\n\t     *      R.xprod([1, 2], ['a', 'b']); //=> [[1, 'a'], [1, 'b'], [2, 'a'], [2, 'b']]\n\t     */\n\t    // = xprodWith(prepend); (takes about 3 times as long...)\n\t    var xprod = _curry2(function xprod(a, b) {\n\t        // = xprodWith(prepend); (takes about 3 times as long...)\n\t        var idx = 0;\n\t        var ilen = a.length;\n\t        var j;\n\t        var jlen = b.length;\n\t        var result = [];\n\t        while (idx < ilen) {\n\t            j = 0;\n\t            while (j < jlen) {\n\t                result[result.length] = [\n\t                    a[idx],\n\t                    b[j]\n\t                ];\n\t                j += 1;\n\t            }\n\t            idx += 1;\n\t        }\n\t        return result;\n\t    });\n\t\n\t    /**\n\t     * Creates a new list out of the two supplied by pairing up equally-positioned\n\t     * items from both lists. The returned list is truncated to the length of the\n\t     * shorter of the two input lists.\n\t     * Note: `zip` is equivalent to `zipWith(function(a, b) { return [a, b] })`.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @since v0.1.0\n\t     * @category List\n\t     * @sig [a] -> [b] -> [[a,b]]\n\t     * @param {Array} list1 The first array to consider.\n\t     * @param {Array} list2 The second array to consider.\n\t     * @return {Array} The list made by pairing up same-indexed elements of `list1` and `list2`.\n\t     * @example\n\t     *\n\t     *      R.zip([1, 2, 3], ['a', 'b', 'c']); //=> [[1, 'a'], [2, 'b'], [3, 'c']]\n\t     */\n\t    var zip = _curry2(function zip(a, b) {\n\t        var rv = [];\n\t        var idx = 0;\n\t        var len = Math.min(a.length, b.length);\n\t        while (idx < len) {\n\t            rv[idx] = [\n\t                a[idx],\n\t                b[idx]\n\t            ];\n\t            idx += 1;\n\t        }\n\t        return rv;\n\t    });\n\t\n\t    /**\n\t     * Creates a new object out of a list of keys and a list of values.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @since v0.3.0\n\t     * @category List\n\t     * @sig [String] -> [*] -> {String: *}\n\t     * @param {Array} keys The array that will be properties on the output object.\n\t     * @param {Array} values The list of values on the output object.\n\t     * @return {Object} The object made by pairing up same-indexed elements of `keys` and `values`.\n\t     * @example\n\t     *\n\t     *      R.zipObj(['a', 'b', 'c'], [1, 2, 3]); //=> {a: 1, b: 2, c: 3}\n\t     */\n\t    var zipObj = _curry2(function zipObj(keys, values) {\n\t        var idx = 0;\n\t        var len = keys.length;\n\t        var out = {};\n\t        while (idx < len) {\n\t            out[keys[idx]] = values[idx];\n\t            idx += 1;\n\t        }\n\t        return out;\n\t    });\n\t\n\t    /**\n\t     * Creates a new list out of the two supplied by applying the function to each\n\t     * equally-positioned pair in the lists. The returned list is truncated to the\n\t     * length of the shorter of the two input lists.\n\t     *\n\t     * @function\n\t     * @memberOf R\n\t     * @since v0.1.0\n\t     * @category List\n\t     * @sig (a,b -> c) -> [a] -> [b] -> [c]\n\t     * @param {Function} fn The function used to combine the two elements into one value.\n\t     * @param {Array} list1 The first array to consider.\n\t     * @param {Array} list2 The second array to consider.\n\t     * @return {Array} The list made by combining same-indexed elements of `list1` and `list2`\n\t     *         using `fn`.\n\t     * @example\n\t     *\n\t     *      var f = (x, y) => {\n\t     *        // ...\n\t     *      };\n\t     *      R.zipWith(f, [1, 2, 3], ['a', 'b', 'c']);\n\t     *      //=> [f(1, 'a'), f(2, 'b'), f(3, 'c')]\n\t     */\n\t    var zipWith = _curry3(function zipWith(fn, a, b) {\n\t        var rv = [];\n\t        var idx = 0;\n\t        var len = Math.min(a.length, b.length);\n\t        while (idx < len) {\n\t            rv[idx] = fn(a[idx], b[idx]);\n\t            idx += 1;\n\t        }\n\t        return rv;\n\t    });\n\t\n\t    /**\n\t     * A function that always returns `false`. Any passed in parameters are ignored.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @since v0.9.0\n\t     * @category Function\n\t     * @sig * -> Boolean\n\t     * @param {*}\n\t     * @return {Boolean}\n\t     * @see R.always, R.T\n\t     * @example\n\t     *\n\t     *      R.F(); //=> false\n\t     */\n\t    var F = always(false);\n\t\n\t    /**\n\t     * A function that always returns `true`. Any passed in parameters are ignored.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @since v0.9.0\n\t     * @category Function\n\t     * @sig * -> Boolean\n\t     * @param {*}\n\t     * @return {Boolean}\n\t     * @see R.always, R.F\n\t     * @example\n\t     *\n\t     *      R.T(); //=> true\n\t     */\n\t    var T = always(true);\n\t\n\t    /**\n\t     * Copies an object.\n\t     *\n\t     * @private\n\t     * @param {*} value The value to be copied\n\t     * @param {Array} refFrom Array containing the source references\n\t     * @param {Array} refTo Array containing the copied source references\n\t     * @return {*} The copied value.\n\t     */\n\t    var _clone = function _clone(value, refFrom, refTo) {\n\t        var copy = function copy(copiedValue) {\n\t            var len = refFrom.length;\n\t            var idx = 0;\n\t            while (idx < len) {\n\t                if (value === refFrom[idx]) {\n\t                    return refTo[idx];\n\t                }\n\t                idx += 1;\n\t            }\n\t            refFrom[idx + 1] = value;\n\t            refTo[idx + 1] = copiedValue;\n\t            for (var key in value) {\n\t                copiedValue[key] = _clone(value[key], refFrom, refTo);\n\t            }\n\t            return copiedValue;\n\t        };\n\t        switch (type(value)) {\n\t        case 'Object':\n\t            return copy({});\n\t        case 'Array':\n\t            return copy([]);\n\t        case 'Date':\n\t            return new Date(value.valueOf());\n\t        case 'RegExp':\n\t            return _cloneRegExp(value);\n\t        default:\n\t            return value;\n\t        }\n\t    };\n\t\n\t    var _createPartialApplicator = function _createPartialApplicator(concat) {\n\t        return _curry2(function (fn, args) {\n\t            return _arity(Math.max(0, fn.length - args.length), function () {\n\t                return fn.apply(this, concat(args, arguments));\n\t            });\n\t        });\n\t    };\n\t\n\t    var _dropLast = function dropLast(n, xs) {\n\t        return take(n < xs.length ? xs.length - n : 0, xs);\n\t    };\n\t\n\t    // Values of other types are only equal if identical.\n\t    var _equals = function _equals(a, b, stackA, stackB) {\n\t        if (identical(a, b)) {\n\t            return true;\n\t        }\n\t        if (type(a) !== type(b)) {\n\t            return false;\n\t        }\n\t        if (a == null || b == null) {\n\t            return false;\n\t        }\n\t        if (typeof a.equals === 'function' || typeof b.equals === 'function') {\n\t            return typeof a.equals === 'function' && a.equals(b) && typeof b.equals === 'function' && b.equals(a);\n\t        }\n\t        switch (type(a)) {\n\t        case 'Arguments':\n\t        case 'Array':\n\t        case 'Object':\n\t            break;\n\t        case 'Boolean':\n\t        case 'Number':\n\t        case 'String':\n\t            if (!(typeof a === typeof b && identical(a.valueOf(), b.valueOf()))) {\n\t                return false;\n\t            }\n\t            break;\n\t        case 'Date':\n\t            if (!identical(a.valueOf(), b.valueOf())) {\n\t                return false;\n\t            }\n\t            break;\n\t        case 'Error':\n\t            return a.name === b.name && a.message === b.message;\n\t        case 'RegExp':\n\t            if (!(a.source === b.source && a.global === b.global && a.ignoreCase === b.ignoreCase && a.multiline === b.multiline && a.sticky === b.sticky && a.unicode === b.unicode)) {\n\t                return false;\n\t            }\n\t            break;\n\t        case 'Map':\n\t        case 'Set':\n\t            if (!_equals(_arrayFromIterator(a.entries()), _arrayFromIterator(b.entries()), stackA, stackB)) {\n\t                return false;\n\t            }\n\t            break;\n\t        case 'Int8Array':\n\t        case 'Uint8Array':\n\t        case 'Uint8ClampedArray':\n\t        case 'Int16Array':\n\t        case 'Uint16Array':\n\t        case 'Int32Array':\n\t        case 'Uint32Array':\n\t        case 'Float32Array':\n\t        case 'Float64Array':\n\t            break;\n\t        case 'ArrayBuffer':\n\t            break;\n\t        default:\n\t            // Values of other types are only equal if identical.\n\t            return false;\n\t        }\n\t        var keysA = keys(a);\n\t        if (keysA.length !== keys(b).length) {\n\t            return false;\n\t        }\n\t        var idx = stackA.length - 1;\n\t        while (idx >= 0) {\n\t            if (stackA[idx] === a) {\n\t                return stackB[idx] === b;\n\t            }\n\t            idx -= 1;\n\t        }\n\t        stackA.push(a);\n\t        stackB.push(b);\n\t        idx = keysA.length - 1;\n\t        while (idx >= 0) {\n\t            var key = keysA[idx];\n\t            if (!(_has(key, b) && _equals(b[key], a[key], stackA, stackB))) {\n\t                return false;\n\t            }\n\t            idx -= 1;\n\t        }\n\t        stackA.pop();\n\t        stackB.pop();\n\t        return true;\n\t    };\n\t\n\t    /**\n\t     * `_makeFlat` is a helper function that returns a one-level or fully recursive\n\t     * function based on the flag passed in.\n\t     *\n\t     * @private\n\t     */\n\t    var _makeFlat = function _makeFlat(recursive) {\n\t        return function flatt(list) {\n\t            var value, jlen, j;\n\t            var result = [];\n\t            var idx = 0;\n\t            var ilen = list.length;\n\t            while (idx < ilen) {\n\t                if (isArrayLike(list[idx])) {\n\t                    value = recursive ? flatt(list[idx]) : list[idx];\n\t                    j = 0;\n\t                    jlen = value.length;\n\t                    while (j < jlen) {\n\t                        result[result.length] = value[j];\n\t                        j += 1;\n\t                    }\n\t                } else {\n\t                    result[result.length] = list[idx];\n\t                }\n\t                idx += 1;\n\t            }\n\t            return result;\n\t        };\n\t    };\n\t\n\t    var _reduce = function () {\n\t        function _arrayReduce(xf, acc, list) {\n\t            var idx = 0;\n\t            var len = list.length;\n\t            while (idx < len) {\n\t                acc = xf['@@transducer/step'](acc, list[idx]);\n\t                if (acc && acc['@@transducer/reduced']) {\n\t                    acc = acc['@@transducer/value'];\n\t                    break;\n\t                }\n\t                idx += 1;\n\t            }\n\t            return xf['@@transducer/result'](acc);\n\t        }\n\t        function _iterableReduce(xf, acc, iter) {\n\t            var step = iter.next();\n\t            while (!step.done) {\n\t                acc = xf['@@transducer/step'](acc, step.value);\n\t                if (acc && acc['@@transducer/reduced']) {\n\t                    acc = acc['@@transducer/value'];\n\t                    break;\n\t                }\n\t                step = iter.next();\n\t            }\n\t            return xf['@@transducer/result'](acc);\n\t        }\n\t        function _methodReduce(xf, acc, obj) {\n\t            return xf['@@transducer/result'](obj.reduce(bind(xf['@@transducer/step'], xf), acc));\n\t        }\n\t        var symIterator = typeof Symbol !== 'undefined' ? Symbol.iterator : '@@iterator';\n\t        return function _reduce(fn, acc, list) {\n\t            if (typeof fn === 'function') {\n\t                fn = _xwrap(fn);\n\t            }\n\t            if (isArrayLike(list)) {\n\t                return _arrayReduce(fn, acc, list);\n\t            }\n\t            if (typeof list.reduce === 'function') {\n\t                return _methodReduce(fn, acc, list);\n\t            }\n\t            if (list[symIterator] != null) {\n\t                return _iterableReduce(fn, acc, list[symIterator]());\n\t            }\n\t            if (typeof list.next === 'function') {\n\t                return _iterableReduce(fn, acc, list);\n\t            }\n\t            throw new TypeError('reduce: list must be array or iterable');\n\t        };\n\t    }();\n\t\n\t    var _xdropLastWhile = function () {\n\t        function XDropLastWhile(fn, xf) {\n\t            this.f = fn;\n\t            this.retained = [];\n\t            this.xf = xf;\n\t        }\n\t        XDropLastWhile.prototype['@@transducer/init'] = _xfBase.init;\n\t        XDropLastWhile.prototype['@@transducer/result'] = function (result) {\n\t            this.retained = null;\n\t            return this.xf['@@transducer/result'](result);\n\t        };\n\t        XDropLastWhile.prototype['@@transducer/step'] = function (result, input) {\n\t            return this.f(input) ? this.retain(result, input) : this.flush(result, input);\n\t        };\n\t        XDropLastWhile.prototype.flush = function (result, input) {\n\t            result = _reduce(this.xf['@@transducer/step'], result, this.retained);\n\t            this.retained = [];\n\t            return this.xf['@@transducer/step'](result, input);\n\t        };\n\t        XDropLastWhile.prototype.retain = function (result, input) {\n\t            this.retained.push(input);\n\t            return result;\n\t        };\n\t        return _curry2(function _xdropLastWhile(fn, xf) {\n\t            return new XDropLastWhile(fn, xf);\n\t        });\n\t    }();\n\t\n\t    var _xgroupBy = function () {\n\t        function XGroupBy(f, xf) {\n\t            this.xf = xf;\n\t            this.f = f;\n\t            this.inputs = {};\n\t        }\n\t        XGroupBy.prototype['@@transducer/init'] = _xfBase.init;\n\t        XGroupBy.prototype['@@transducer/result'] = function (result) {\n\t            var key;\n\t            for (key in this.inputs) {\n\t                if (_has(key, this.inputs)) {\n\t                    result = this.xf['@@transducer/step'](result, this.inputs[key]);\n\t                    if (result['@@transducer/reduced']) {\n\t                        result = result['@@transducer/value'];\n\t                        break;\n\t                    }\n\t                }\n\t            }\n\t            this.inputs = null;\n\t            return this.xf['@@transducer/result'](result);\n\t        };\n\t        XGroupBy.prototype['@@transducer/step'] = function (result, input) {\n\t            var key = this.f(input);\n\t            this.inputs[key] = this.inputs[key] || [\n\t                key,\n\t                []\n\t            ];\n\t            this.inputs[key][1] = append(input, this.inputs[key][1]);\n\t            return result;\n\t        };\n\t        return _curry2(function _xgroupBy(f, xf) {\n\t            return new XGroupBy(f, xf);\n\t        });\n\t    }();\n\t\n\t    /**\n\t     * Creates a new list iteration function from an existing one by adding two new\n\t     * parameters to its callback function: the current index, and the entire list.\n\t     *\n\t     * This would turn, for instance, Ramda's simple `map` function into one that\n\t     * more closely resembles `Array.prototype.map`. Note that this will only work\n\t     * for functions in which the iteration callback function is the first\n\t     * parameter, and where the list is the last parameter. (This latter might be\n\t     * unimportant if the list parameter is not used.)\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @since v0.15.0\n\t     * @category Function\n\t     * @category List\n\t     * @sig ((a ... -> b) ... -> [a] -> *) -> (a ..., Int, [a] -> b) ... -> [a] -> *)\n\t     * @param {Function} fn A list iteration function that does not pass index or list to its callback\n\t     * @return {Function} An altered list iteration function that passes (item, index, list) to its callback\n\t     * @example\n\t     *\n\t     *      var mapIndexed = R.addIndex(R.map);\n\t     *      mapIndexed((val, idx) => idx + '-' + val, ['f', 'o', 'o', 'b', 'a', 'r']);\n\t     *      //=> ['0-f', '1-o', '2-o', '3-b', '4-a', '5-r']\n\t     */\n\t    var addIndex = _curry1(function addIndex(fn) {\n\t        return curryN(fn.length, function () {\n\t            var idx = 0;\n\t            var origFn = arguments[0];\n\t            var list = arguments[arguments.length - 1];\n\t            var args = _slice(arguments);\n\t            args[0] = function () {\n\t                var result = origFn.apply(this, _concat(arguments, [\n\t                    idx,\n\t                    list\n\t                ]));\n\t                idx += 1;\n\t                return result;\n\t            };\n\t            return fn.apply(this, args);\n\t        });\n\t    });\n\t\n\t    /**\n\t     * Wraps a function of any arity (including nullary) in a function that accepts\n\t     * exactly 2 parameters. Any extraneous parameters will not be passed to the\n\t     * supplied function.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @since v0.2.0\n\t     * @category Function\n\t     * @sig (* -> c) -> (a, b -> c)\n\t     * @param {Function} fn The function to wrap.\n\t     * @return {Function} A new function wrapping `fn`. The new function is guaranteed to be of\n\t     *         arity 2.\n\t     * @example\n\t     *\n\t     *      var takesThreeArgs = function(a, b, c) {\n\t     *        return [a, b, c];\n\t     *      };\n\t     *      takesThreeArgs.length; //=> 3\n\t     *      takesThreeArgs(1, 2, 3); //=> [1, 2, 3]\n\t     *\n\t     *      var takesTwoArgs = R.binary(takesThreeArgs);\n\t     *      takesTwoArgs.length; //=> 2\n\t     *      // Only 2 arguments are passed to the wrapped function\n\t     *      takesTwoArgs(1, 2, 3); //=> [1, 2, undefined]\n\t     */\n\t    var binary = _curry1(function binary(fn) {\n\t        return nAry(2, fn);\n\t    });\n\t\n\t    /**\n\t     * Creates a deep copy of the value which may contain (nested) `Array`s and\n\t     * `Object`s, `Number`s, `String`s, `Boolean`s and `Date`s. `Function`s are not\n\t     * copied, but assigned by their reference.\n\t     *\n\t     * Dispatches to a `clone` method if present.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @since v0.1.0\n\t     * @category Object\n\t     * @sig {*} -> {*}\n\t     * @param {*} value The object or array to clone\n\t     * @return {*} A new object or array.\n\t     * @example\n\t     *\n\t     *      var objects = [{}, {}, {}];\n\t     *      var objectsClone = R.clone(objects);\n\t     *      objects[0] === objectsClone[0]; //=> false\n\t     */\n\t    var clone = _curry1(function clone(value) {\n\t        return value != null && typeof value.clone === 'function' ? value.clone() : _clone(value, [], []);\n\t    });\n\t\n\t    /**\n\t     * Returns a curried equivalent of the provided function. The curried function\n\t     * has two unusual capabilities. First, its arguments needn't be provided one\n\t     * at a time. If `f` is a ternary function and `g` is `R.curry(f)`, the\n\t     * following are equivalent:\n\t     *\n\t     *   - `g(1)(2)(3)`\n\t     *   - `g(1)(2, 3)`\n\t     *   - `g(1, 2)(3)`\n\t     *   - `g(1, 2, 3)`\n\t     *\n\t     * Secondly, the special placeholder value `R.__` may be used to specify\n\t     * \"gaps\", allowing partial application of any combination of arguments,\n\t     * regardless of their positions. If `g` is as above and `_` is `R.__`, the\n\t     * following are equivalent:\n\t     *\n\t     *   - `g(1, 2, 3)`\n\t     *   - `g(_, 2, 3)(1)`\n\t     *   - `g(_, _, 3)(1)(2)`\n\t     *   - `g(_, _, 3)(1, 2)`\n\t     *   - `g(_, 2)(1)(3)`\n\t     *   - `g(_, 2)(1, 3)`\n\t     *   - `g(_, 2)(_, 3)(1)`\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @since v0.1.0\n\t     * @category Function\n\t     * @sig (* -> a) -> (* -> a)\n\t     * @param {Function} fn The function to curry.\n\t     * @return {Function} A new, curried function.\n\t     * @see R.curryN\n\t     * @example\n\t     *\n\t     *      var addFourNumbers = (a, b, c, d) => a + b + c + d;\n\t     *\n\t     *      var curriedAddFourNumbers = R.curry(addFourNumbers);\n\t     *      var f = curriedAddFourNumbers(1, 2);\n\t     *      var g = f(3);\n\t     *      g(4); //=> 10\n\t     */\n\t    var curry = _curry1(function curry(fn) {\n\t        return curryN(fn.length, fn);\n\t    });\n\t\n\t    /**\n\t     * Returns all but the first `n` elements of the given list, string, or\n\t     * transducer/transformer (or object with a `drop` method).\n\t     *\n\t     * Dispatches to the `drop` method of the second argument, if present.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @since v0.1.0\n\t     * @category List\n\t     * @sig Number -> [a] -> [a]\n\t     * @sig Number -> String -> String\n\t     * @param {Number} n\n\t     * @param {*} list\n\t     * @return {*}\n\t     * @see R.take, R.transduce\n\t     * @example\n\t     *\n\t     *      R.drop(1, ['foo', 'bar', 'baz']); //=> ['bar', 'baz']\n\t     *      R.drop(2, ['foo', 'bar', 'baz']); //=> ['baz']\n\t     *      R.drop(3, ['foo', 'bar', 'baz']); //=> []\n\t     *      R.drop(4, ['foo', 'bar', 'baz']); //=> []\n\t     *      R.drop(3, 'ramda');               //=> 'da'\n\t     */\n\t    var drop = _curry2(_dispatchable('drop', _xdrop, function drop(n, xs) {\n\t        return slice(Math.max(0, n), Infinity, xs);\n\t    }));\n\t\n\t    /**\n\t     * Returns a list containing all but the last `n` elements of the given `list`.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @since v0.16.0\n\t     * @category List\n\t     * @sig Number -> [a] -> [a]\n\t     * @sig Number -> String -> String\n\t     * @param {Number} n The number of elements of `xs` to skip.\n\t     * @param {Array} xs The collection to consider.\n\t     * @return {Array}\n\t     * @see R.takeLast\n\t     * @example\n\t     *\n\t     *      R.dropLast(1, ['foo', 'bar', 'baz']); //=> ['foo', 'bar']\n\t     *      R.dropLast(2, ['foo', 'bar', 'baz']); //=> ['foo']\n\t     *      R.dropLast(3, ['foo', 'bar', 'baz']); //=> []\n\t     *      R.dropLast(4, ['foo', 'bar', 'baz']); //=> []\n\t     *      R.dropLast(3, 'ramda');               //=> 'ra'\n\t     */\n\t    var dropLast = _curry2(_dispatchable('dropLast', _xdropLast, _dropLast));\n\t\n\t    /**\n\t     * Returns a new list containing all but last the`n` elements of a given list,\n\t     * passing each value from the right to the supplied predicate function,\n\t     * skipping elements while the predicate function returns `true`. The predicate\n\t     * function is passed one argument: (value)*.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @since v0.16.0\n\t     * @category List\n\t     * @sig (a -> Boolean) -> [a] -> [a]\n\t     * @param {Function} fn The function called per iteration.\n\t     * @param {Array} list The collection to iterate over.\n\t     * @return {Array} A new array.\n\t     * @see R.takeLastWhile, R.addIndex\n\t     * @example\n\t     *\n\t     *      var lteThree = x => x <= 3;\n\t     *\n\t     *      R.dropLastWhile(lteThree, [1, 2, 3, 4, 3, 2, 1]); //=> [1, 2, 3, 4]\n\t     */\n\t    var dropLastWhile = _curry2(_dispatchable('dropLastWhile', _xdropLastWhile, _dropLastWhile));\n\t\n\t    /**\n\t     * Returns `true` if its arguments are equivalent, `false` otherwise. Handles\n\t     * cyclical data structures.\n\t     *\n\t     * Dispatches symmetrically to the `equals` methods of both arguments, if\n\t     * present.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @since v0.15.0\n\t     * @category Relation\n\t     * @sig a -> b -> Boolean\n\t     * @param {*} a\n\t     * @param {*} b\n\t     * @return {Boolean}\n\t     * @example\n\t     *\n\t     *      R.equals(1, 1); //=> true\n\t     *      R.equals(1, '1'); //=> false\n\t     *      R.equals([1, 2, 3], [1, 2, 3]); //=> true\n\t     *\n\t     *      var a = {}; a.v = a;\n\t     *      var b = {}; b.v = b;\n\t     *      R.equals(a, b); //=> true\n\t     */\n\t    var equals = _curry2(function equals(a, b) {\n\t        return _equals(a, b, [], []);\n\t    });\n\t\n\t    /**\n\t     * Takes a predicate and a \"filterable\", and returns a new filterable of the\n\t     * same type containing the members of the given filterable which satisfy the\n\t     * given predicate.\n\t     *\n\t     * Dispatches to the `filter` method of the second argument, if present.\n\t     *\n\t     * Acts as a transducer if a transformer is given in list position.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @since v0.1.0\n\t     * @category List\n\t     * @sig Filterable f => (a -> Boolean) -> f a -> f a\n\t     * @param {Function} pred\n\t     * @param {Array} filterable\n\t     * @return {Array}\n\t     * @see R.reject, R.transduce, R.addIndex\n\t     * @example\n\t     *\n\t     *      var isEven = n => n % 2 === 0;\n\t     *\n\t     *      R.filter(isEven, [1, 2, 3, 4]); //=> [2, 4]\n\t     *\n\t     *      R.filter(isEven, {a: 1, b: 2, c: 3, d: 4}); //=> {b: 2, d: 4}\n\t     */\n\t    // else\n\t    var filter = _curry2(_dispatchable('filter', _xfilter, function (pred, filterable) {\n\t        return _isObject(filterable) ? _reduce(function (acc, key) {\n\t            if (pred(filterable[key])) {\n\t                acc[key] = filterable[key];\n\t            }\n\t            return acc;\n\t        }, {}, keys(filterable)) : // else\n\t        _filter(pred, filterable);\n\t    }));\n\t\n\t    /**\n\t     * Returns a new list by pulling every item out of it (and all its sub-arrays)\n\t     * and putting them in a new array, depth-first.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @since v0.1.0\n\t     * @category List\n\t     * @sig [a] -> [b]\n\t     * @param {Array} list The array to consider.\n\t     * @return {Array} The flattened list.\n\t     * @see R.unnest\n\t     * @example\n\t     *\n\t     *      R.flatten([1, 2, [3, 4], 5, [6, [7, 8, [9, [10, 11], 12]]]]);\n\t     *      //=> [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]\n\t     */\n\t    var flatten = _curry1(_makeFlat(true));\n\t\n\t    /**\n\t     * Returns a new function much like the supplied one, except that the first two\n\t     * arguments' order is reversed.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @since v0.1.0\n\t     * @category Function\n\t     * @sig (a -> b -> c -> ... -> z) -> (b -> a -> c -> ... -> z)\n\t     * @param {Function} fn The function to invoke with its first two parameters reversed.\n\t     * @return {*} The result of invoking `fn` with its first two parameters' order reversed.\n\t     * @example\n\t     *\n\t     *      var mergeThree = (a, b, c) => [].concat(a, b, c);\n\t     *\n\t     *      mergeThree(1, 2, 3); //=> [1, 2, 3]\n\t     *\n\t     *      R.flip(mergeThree)(1, 2, 3); //=> [2, 1, 3]\n\t     */\n\t    var flip = _curry1(function flip(fn) {\n\t        return curry(function (a, b) {\n\t            var args = _slice(arguments);\n\t            args[0] = b;\n\t            args[1] = a;\n\t            return fn.apply(this, args);\n\t        });\n\t    });\n\t\n\t    /**\n\t     * Splits a list into sub-lists stored in an object, based on the result of\n\t     * calling a String-returning function on each element, and grouping the\n\t     * results according to values returned.\n\t     *\n\t     * Dispatches to the `groupBy` method of the second argument, if present.\n\t     *\n\t     * Acts as a transducer if a transformer is given in list position.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @since v0.1.0\n\t     * @category List\n\t     * @sig (a -> String) -> [a] -> {String: [a]}\n\t     * @param {Function} fn Function :: a -> String\n\t     * @param {Array} list The array to group\n\t     * @return {Object} An object with the output of `fn` for keys, mapped to arrays of elements\n\t     *         that produced that key when passed to `fn`.\n\t     * @see R.transduce\n\t     * @example\n\t     *\n\t     *      var byGrade = R.groupBy(function(student) {\n\t     *        var score = student.score;\n\t     *        return score < 65 ? 'F' :\n\t     *               score < 70 ? 'D' :\n\t     *               score < 80 ? 'C' :\n\t     *               score < 90 ? 'B' : 'A';\n\t     *      });\n\t     *      var students = [{name: 'Abby', score: 84},\n\t     *                      {name: 'Eddy', score: 58},\n\t     *                      // ...\n\t     *                      {name: 'Jack', score: 69}];\n\t     *      byGrade(students);\n\t     *      // {\n\t     *      //   'A': [{name: 'Dianne', score: 99}],\n\t     *      //   'B': [{name: 'Abby', score: 84}]\n\t     *      //   // ...,\n\t     *      //   'F': [{name: 'Eddy', score: 58}]\n\t     *      // }\n\t     */\n\t    var groupBy = _curry2(_dispatchable('groupBy', _xgroupBy, function groupBy(fn, list) {\n\t        return _reduce(function (acc, elt) {\n\t            var key = fn(elt);\n\t            acc[key] = append(elt, acc[key] || (acc[key] = []));\n\t            return acc;\n\t        }, {}, list);\n\t    }));\n\t\n\t    /**\n\t     * Returns the first element of the given list or string. In some libraries\n\t     * this function is named `first`.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @since v0.1.0\n\t     * @category List\n\t     * @sig [a] -> a | Undefined\n\t     * @sig String -> String\n\t     * @param {Array|String} list\n\t     * @return {*}\n\t     * @see R.tail, R.init, R.last\n\t     * @example\n\t     *\n\t     *      R.head(['fi', 'fo', 'fum']); //=> 'fi'\n\t     *      R.head([]); //=> undefined\n\t     *\n\t     *      R.head('abc'); //=> 'a'\n\t     *      R.head(''); //=> ''\n\t     */\n\t    var head = nth(0);\n\t\n\t    /**\n\t     * Given a function that generates a key, turns a list of objects into an\n\t     * object indexing the objects by the given key. Note that if multiple\n\t     * objects generate the same value for the indexing key only the last value\n\t     * will be included in the generated object.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @since 0.19.1\n\t     * @since 0.19.0\n\t     * @category List\n\t     * @sig (a -> String) -> [{k: v}] -> {k: {k: v}}\n\t     * @param {Function} fn Function :: a -> String\n\t     * @param {Array} array The array of objects to index\n\t     * @return {Object} An object indexing each array element by the given property.\n\t     * @example\n\t     *\n\t     *      var list = [{id: 'xyz', title: 'A'}, {id: 'abc', title: 'B'}];\n\t     *      R.indexBy(R.prop('id'), list);\n\t     *      //=> {abc: {id: 'abc', title: 'B'}, xyz: {id: 'xyz', title: 'A'}}\n\t     */\n\t    var indexBy = _curry2(function indexBy(fn, list) {\n\t        return _reduce(function (acc, elem) {\n\t            var key = fn(elem);\n\t            acc[key] = elem;\n\t            return acc;\n\t        }, {}, list);\n\t    });\n\t\n\t    /**\n\t     * Returns all but the last element of the given list or string.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @since v0.9.0\n\t     * @category List\n\t     * @sig [a] -> [a]\n\t     * @sig String -> String\n\t     * @param {*} list\n\t     * @return {*}\n\t     * @see R.last, R.head, R.tail\n\t     * @example\n\t     *\n\t     *      R.init([1, 2, 3]);  //=> [1, 2]\n\t     *      R.init([1, 2]);     //=> [1]\n\t     *      R.init([1]);        //=> []\n\t     *      R.init([]);         //=> []\n\t     *\n\t     *      R.init('abc');  //=> 'ab'\n\t     *      R.init('ab');   //=> 'a'\n\t     *      R.init('a');    //=> ''\n\t     *      R.init('');     //=> ''\n\t     */\n\t    var init = slice(0, -1);\n\t\n\t    /**\n\t     * Combines two lists into a set (i.e. no duplicates) composed of those\n\t     * elements common to both lists. Duplication is determined according to the\n\t     * value returned by applying the supplied predicate to two list elements.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @since v0.1.0\n\t     * @category Relation\n\t     * @sig (a -> a -> Boolean) -> [*] -> [*] -> [*]\n\t     * @param {Function} pred A predicate function that determines whether\n\t     *        the two supplied elements are equal.\n\t     * @param {Array} list1 One list of items to compare\n\t     * @param {Array} list2 A second list of items to compare\n\t     * @return {Array} A new list containing those elements common to both lists.\n\t     * @see R.intersection\n\t     * @example\n\t     *\n\t     *      var buffaloSpringfield = [\n\t     *        {id: 824, name: 'Richie Furay'},\n\t     *        {id: 956, name: 'Dewey Martin'},\n\t     *        {id: 313, name: 'Bruce Palmer'},\n\t     *        {id: 456, name: 'Stephen Stills'},\n\t     *        {id: 177, name: 'Neil Young'}\n\t     *      ];\n\t     *      var csny = [\n\t     *        {id: 204, name: 'David Crosby'},\n\t     *        {id: 456, name: 'Stephen Stills'},\n\t     *        {id: 539, name: 'Graham Nash'},\n\t     *        {id: 177, name: 'Neil Young'}\n\t     *      ];\n\t     *\n\t     *      R.intersectionWith(R.eqBy(R.prop('id')), buffaloSpringfield, csny);\n\t     *      //=> [{id: 456, name: 'Stephen Stills'}, {id: 177, name: 'Neil Young'}]\n\t     */\n\t    var intersectionWith = _curry3(function intersectionWith(pred, list1, list2) {\n\t        var results = [];\n\t        var idx = 0;\n\t        while (idx < list1.length) {\n\t            if (_containsWith(pred, list1[idx], list2)) {\n\t                results[results.length] = list1[idx];\n\t            }\n\t            idx += 1;\n\t        }\n\t        return uniqWith(pred, results);\n\t    });\n\t\n\t    /**\n\t     * Same as R.invertObj, however this accounts for objects with duplicate values\n\t     * by putting the values into an array.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @since v0.9.0\n\t     * @category Object\n\t     * @sig {s: x} -> {x: [ s, ... ]}\n\t     * @param {Object} obj The object or array to invert\n\t     * @return {Object} out A new object with keys\n\t     * in an array.\n\t     * @example\n\t     *\n\t     *      var raceResultsByFirstName = {\n\t     *        first: 'alice',\n\t     *        second: 'jake',\n\t     *        third: 'alice',\n\t     *      };\n\t     *      R.invert(raceResultsByFirstName);\n\t     *      //=> { 'alice': ['first', 'third'], 'jake':['second'] }\n\t     */\n\t    var invert = _curry1(function invert(obj) {\n\t        var props = keys(obj);\n\t        var len = props.length;\n\t        var idx = 0;\n\t        var out = {};\n\t        while (idx < len) {\n\t            var key = props[idx];\n\t            var val = obj[key];\n\t            var list = _has(val, out) ? out[val] : out[val] = [];\n\t            list[list.length] = key;\n\t            idx += 1;\n\t        }\n\t        return out;\n\t    });\n\t\n\t    /**\n\t     * Returns a new object with the keys of the given object as values, and the\n\t     * values of the given object, which are coerced to strings, as keys. Note\n\t     * that the last key found is preferred when handling the same value.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @since v0.9.0\n\t     * @category Object\n\t     * @sig {s: x} -> {x: s}\n\t     * @param {Object} obj The object or array to invert\n\t     * @return {Object} out A new object\n\t     * @example\n\t     *\n\t     *      var raceResults = {\n\t     *        first: 'alice',\n\t     *        second: 'jake'\n\t     *      };\n\t     *      R.invertObj(raceResults);\n\t     *      //=> { 'alice': 'first', 'jake':'second' }\n\t     *\n\t     *      // Alternatively:\n\t     *      var raceResults = ['alice', 'jake'];\n\t     *      R.invertObj(raceResults);\n\t     *      //=> { 'alice': '0', 'jake':'1' }\n\t     */\n\t    var invertObj = _curry1(function invertObj(obj) {\n\t        var props = keys(obj);\n\t        var len = props.length;\n\t        var idx = 0;\n\t        var out = {};\n\t        while (idx < len) {\n\t            var key = props[idx];\n\t            out[obj[key]] = key;\n\t            idx += 1;\n\t        }\n\t        return out;\n\t    });\n\t\n\t    /**\n\t     * Returns `true` if the given value is its type's empty value; `false`\n\t     * otherwise.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @since v0.1.0\n\t     * @category Logic\n\t     * @sig a -> Boolean\n\t     * @param {*} x\n\t     * @return {Boolean}\n\t     * @see R.empty\n\t     * @example\n\t     *\n\t     *      R.isEmpty([1, 2, 3]);   //=> false\n\t     *      R.isEmpty([]);          //=> true\n\t     *      R.isEmpty('');          //=> true\n\t     *      R.isEmpty(null);        //=> false\n\t     *      R.isEmpty({});          //=> true\n\t     *      R.isEmpty({length: 0}); //=> false\n\t     */\n\t    var isEmpty = _curry1(function isEmpty(x) {\n\t        return x != null && equals(x, empty(x));\n\t    });\n\t\n\t    /**\n\t     * Returns the last element of the given list or string.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @since v0.1.4\n\t     * @category List\n\t     * @sig [a] -> a | Undefined\n\t     * @sig String -> String\n\t     * @param {*} list\n\t     * @return {*}\n\t     * @see R.init, R.head, R.tail\n\t     * @example\n\t     *\n\t     *      R.last(['fi', 'fo', 'fum']); //=> 'fum'\n\t     *      R.last([]); //=> undefined\n\t     *\n\t     *      R.last('abc'); //=> 'c'\n\t     *      R.last(''); //=> ''\n\t     */\n\t    var last = nth(-1);\n\t\n\t    /**\n\t     * Returns the position of the last occurrence of an item in an array, or -1 if\n\t     * the item is not included in the array. `R.equals` is used to determine\n\t     * equality.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @since v0.1.0\n\t     * @category List\n\t     * @sig a -> [a] -> Number\n\t     * @param {*} target The item to find.\n\t     * @param {Array} xs The array to search in.\n\t     * @return {Number} the index of the target, or -1 if the target is not found.\n\t     * @see R.indexOf\n\t     * @example\n\t     *\n\t     *      R.lastIndexOf(3, [-1,3,3,0,1,2,3,4]); //=> 6\n\t     *      R.lastIndexOf(10, [1,2,3,4]); //=> -1\n\t     */\n\t    var lastIndexOf = _curry2(function lastIndexOf(target, xs) {\n\t        if (typeof xs.lastIndexOf === 'function' && !_isArray(xs)) {\n\t            return xs.lastIndexOf(target);\n\t        } else {\n\t            var idx = xs.length - 1;\n\t            while (idx >= 0) {\n\t                if (equals(xs[idx], target)) {\n\t                    return idx;\n\t                }\n\t                idx -= 1;\n\t            }\n\t            return -1;\n\t        }\n\t    });\n\t\n\t    /**\n\t     * Takes a function and\n\t     * a [functor](https://github.com/fantasyland/fantasy-land#functor),\n\t     * applies the function to each of the functor's values, and returns\n\t     * a functor of the same shape.\n\t     *\n\t     * Ramda provides suitable `map` implementations for `Array` and `Object`,\n\t     * so this function may be applied to `[1, 2, 3]` or `{x: 1, y: 2, z: 3}`.\n\t     *\n\t     * Dispatches to the `map` method of the second argument, if present.\n\t     *\n\t     * Acts as a transducer if a transformer is given in list position.\n\t     *\n\t     * Also treats functions as functors and will compose them together.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @since v0.1.0\n\t     * @category List\n\t     * @sig Functor f => (a -> b) -> f a -> f b\n\t     * @param {Function} fn The function to be called on every element of the input `list`.\n\t     * @param {Array} list The list to be iterated over.\n\t     * @return {Array} The new list.\n\t     * @see R.transduce, R.addIndex\n\t     * @example\n\t     *\n\t     *      var double = x => x * 2;\n\t     *\n\t     *      R.map(double, [1, 2, 3]); //=> [2, 4, 6]\n\t     *\n\t     *      R.map(double, {x: 1, y: 2, z: 3}); //=> {x: 2, y: 4, z: 6}\n\t     */\n\t    var map = _curry2(_dispatchable('map', _xmap, function map(fn, functor) {\n\t        switch (Object.prototype.toString.call(functor)) {\n\t        case '[object Function]':\n\t            return curryN(functor.length, function () {\n\t                return fn.call(this, functor.apply(this, arguments));\n\t            });\n\t        case '[object Object]':\n\t            return _reduce(function (acc, key) {\n\t                acc[key] = fn(functor[key]);\n\t                return acc;\n\t            }, {}, keys(functor));\n\t        default:\n\t            return _map(fn, functor);\n\t        }\n\t    }));\n\t\n\t    /**\n\t     * An Object-specific version of `map`. The function is applied to three\n\t     * arguments: *(value, key, obj)*. If only the value is significant, use\n\t     * `map` instead.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @since v0.9.0\n\t     * @category Object\n\t     * @sig ((*, String, Object) -> *) -> Object -> Object\n\t     * @param {Function} fn\n\t     * @param {Object} obj\n\t     * @return {Object}\n\t     * @see R.map\n\t     * @example\n\t     *\n\t     *      var values = { x: 1, y: 2, z: 3 };\n\t     *      var prependKeyAndDouble = (num, key, obj) => key + (num * 2);\n\t     *\n\t     *      R.mapObjIndexed(prependKeyAndDouble, values); //=> { x: 'x2', y: 'y4', z: 'z6' }\n\t     */\n\t    var mapObjIndexed = _curry2(function mapObjIndexed(fn, obj) {\n\t        return _reduce(function (acc, key) {\n\t            acc[key] = fn(obj[key], key, obj);\n\t            return acc;\n\t        }, {}, keys(obj));\n\t    });\n\t\n\t    /**\n\t     * Creates a new object with the own properties of the two provided objects. If\n\t     * a key exists in both objects, the provided function is applied to the values\n\t     * associated with the key in each object, with the result being used as the\n\t     * value associated with the key in the returned object. The key will be\n\t     * excluded from the returned object if the resulting value is `undefined`.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @since 0.19.1\n\t     * @since 0.19.0\n\t     * @category Object\n\t     * @sig (a -> a -> a) -> {a} -> {a} -> {a}\n\t     * @param {Function} fn\n\t     * @param {Object} l\n\t     * @param {Object} r\n\t     * @return {Object}\n\t     * @see R.merge, R.mergeWithKey\n\t     * @example\n\t     *\n\t     *      R.mergeWith(R.concat,\n\t     *                  { a: true, values: [10, 20] },\n\t     *                  { b: true, values: [15, 35] });\n\t     *      //=> { a: true, b: true, values: [10, 20, 15, 35] }\n\t     */\n\t    var mergeWith = _curry3(function mergeWith(fn, l, r) {\n\t        return mergeWithKey(function (_, _l, _r) {\n\t            return fn(_l, _r);\n\t        }, l, r);\n\t    });\n\t\n\t    /**\n\t     * Takes a function `f` and a list of arguments, and returns a function `g`.\n\t     * When applied, `g` returns the result of applying `f` to the arguments\n\t     * provided initially followed by the arguments provided to `g`.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @since v0.10.0\n\t     * @category Function\n\t     * @sig ((a, b, c, ..., n) -> x) -> [a, b, c, ...] -> ((d, e, f, ..., n) -> x)\n\t     * @param {Function} f\n\t     * @param {Array} args\n\t     * @return {Function}\n\t     * @see R.partialRight\n\t     * @example\n\t     *\n\t     *      var multiply = (a, b) => a * b;\n\t     *      var double = R.partial(multiply, [2]);\n\t     *      double(2); //=> 4\n\t     *\n\t     *      var greet = (salutation, title, firstName, lastName) =>\n\t     *        salutation + ', ' + title + ' ' + firstName + ' ' + lastName + '!';\n\t     *\n\t     *      var sayHello = R.partial(greet, ['Hello']);\n\t     *      var sayHelloToMs = R.partial(sayHello, ['Ms.']);\n\t     *      sayHelloToMs('Jane', 'Jones'); //=> 'Hello, Ms. Jane Jones!'\n\t     */\n\t    var partial = _createPartialApplicator(_concat);\n\t\n\t    /**\n\t     * Takes a function `f` and a list of arguments, and returns a function `g`.\n\t     * When applied, `g` returns the result of applying `f` to the arguments\n\t     * provided to `g` followed by the arguments provided initially.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @since v0.10.0\n\t     * @category Function\n\t     * @sig ((a, b, c, ..., n) -> x) -> [d, e, f, ..., n] -> ((a, b, c, ...) -> x)\n\t     * @param {Function} f\n\t     * @param {Array} args\n\t     * @return {Function}\n\t     * @see R.partial\n\t     * @example\n\t     *\n\t     *      var greet = (salutation, title, firstName, lastName) =>\n\t     *        salutation + ', ' + title + ' ' + firstName + ' ' + lastName + '!';\n\t     *\n\t     *      var greetMsJaneJones = R.partialRight(greet, ['Ms.', 'Jane', 'Jones']);\n\t     *\n\t     *      greetMsJaneJones('Hello'); //=> 'Hello, Ms. Jane Jones!'\n\t     */\n\t    var partialRight = _createPartialApplicator(flip(_concat));\n\t\n\t    /**\n\t     * Takes a predicate and a list and returns the pair of lists of elements which\n\t     * do and do not satisfy the predicate, respectively.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @since v0.1.4\n\t     * @category List\n\t     * @sig (a -> Boolean) -> [a] -> [[a],[a]]\n\t     * @param {Function} pred A predicate to determine which array the element belongs to.\n\t     * @param {Array} list The array to partition.\n\t     * @return {Array} A nested array, containing first an array of elements that satisfied the predicate,\n\t     *         and second an array of elements that did not satisfy.\n\t     * @see R.filter, R.reject\n\t     * @example\n\t     *\n\t     *      R.partition(R.contains('s'), ['sss', 'ttt', 'foo', 'bars']);\n\t     *      //=> [ [ 'sss', 'bars' ],  [ 'ttt', 'foo' ] ]\n\t     */\n\t    var partition = _curry2(function partition(pred, list) {\n\t        return _reduce(function (acc, elt) {\n\t            var xs = acc[pred(elt) ? 0 : 1];\n\t            xs[xs.length] = elt;\n\t            return acc;\n\t        }, [\n\t            [],\n\t            []\n\t        ], list);\n\t    });\n\t\n\t    /**\n\t     * Determines whether a nested path on an object has a specific value, in\n\t     * `R.equals` terms. Most likely used to filter a list.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @since v0.7.0\n\t     * @category Relation\n\t     * @sig [String] -> * -> {String: *} -> Boolean\n\t     * @param {Array} path The path of the nested property to use\n\t     * @param {*} val The value to compare the nested property with\n\t     * @param {Object} obj The object to check the nested property in\n\t     * @return {Boolean} `true` if the value equals the nested object property,\n\t     *         `false` otherwise.\n\t     * @example\n\t     *\n\t     *      var user1 = { address: { zipCode: 90210 } };\n\t     *      var user2 = { address: { zipCode: 55555 } };\n\t     *      var user3 = { name: 'Bob' };\n\t     *      var users = [ user1, user2, user3 ];\n\t     *      var isFamous = R.pathEq(['address', 'zipCode'], 90210);\n\t     *      R.filter(isFamous, users); //=> [ user1 ]\n\t     */\n\t    var pathEq = _curry3(function pathEq(_path, val, obj) {\n\t        return equals(path(_path, obj), val);\n\t    });\n\t\n\t    /**\n\t     * Returns a new list by plucking the same named property off all objects in\n\t     * the list supplied.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @since v0.1.0\n\t     * @category List\n\t     * @sig k -> [{k: v}] -> [v]\n\t     * @param {Number|String} key The key name to pluck off of each object.\n\t     * @param {Array} list The array to consider.\n\t     * @return {Array} The list of values for the given key.\n\t     * @see R.props\n\t     * @example\n\t     *\n\t     *      R.pluck('a')([{a: 1}, {a: 2}]); //=> [1, 2]\n\t     *      R.pluck(0)([[1, 2], [3, 4]]);   //=> [1, 3]\n\t     */\n\t    var pluck = _curry2(function pluck(p, list) {\n\t        return map(prop(p), list);\n\t    });\n\t\n\t    /**\n\t     * Reasonable analog to SQL `select` statement.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @since v0.1.0\n\t     * @category Object\n\t     * @category Relation\n\t     * @sig [k] -> [{k: v}] -> [{k: v}]\n\t     * @param {Array} props The property names to project\n\t     * @param {Array} objs The objects to query\n\t     * @return {Array} An array of objects with just the `props` properties.\n\t     * @example\n\t     *\n\t     *      var abby = {name: 'Abby', age: 7, hair: 'blond', grade: 2};\n\t     *      var fred = {name: 'Fred', age: 12, hair: 'brown', grade: 7};\n\t     *      var kids = [abby, fred];\n\t     *      R.project(['name', 'grade'], kids); //=> [{name: 'Abby', grade: 2}, {name: 'Fred', grade: 7}]\n\t     */\n\t    // passing `identity` gives correct arity\n\t    var project = useWith(_map, [\n\t        pickAll,\n\t        identity\n\t    ]);\n\t\n\t    /**\n\t     * Returns `true` if the specified object property is equal, in `R.equals`\n\t     * terms, to the given value; `false` otherwise.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @since v0.1.0\n\t     * @category Relation\n\t     * @sig String -> a -> Object -> Boolean\n\t     * @param {String} name\n\t     * @param {*} val\n\t     * @param {*} obj\n\t     * @return {Boolean}\n\t     * @see R.equals, R.propSatisfies\n\t     * @example\n\t     *\n\t     *      var abby = {name: 'Abby', age: 7, hair: 'blond'};\n\t     *      var fred = {name: 'Fred', age: 12, hair: 'brown'};\n\t     *      var rusty = {name: 'Rusty', age: 10, hair: 'brown'};\n\t     *      var alois = {name: 'Alois', age: 15, disposition: 'surly'};\n\t     *      var kids = [abby, fred, rusty, alois];\n\t     *      var hasBrownHair = R.propEq('hair', 'brown');\n\t     *      R.filter(hasBrownHair, kids); //=> [fred, rusty]\n\t     */\n\t    var propEq = _curry3(function propEq(name, val, obj) {\n\t        return propSatisfies(equals(val), name, obj);\n\t    });\n\t\n\t    /**\n\t     * Returns `true` if the specified object property is of the given type;\n\t     * `false` otherwise.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @since v0.16.0\n\t     * @category Type\n\t     * @sig Type -> String -> Object -> Boolean\n\t     * @param {Function} type\n\t     * @param {String} name\n\t     * @param {*} obj\n\t     * @return {Boolean}\n\t     * @see R.is, R.propSatisfies\n\t     * @example\n\t     *\n\t     *      R.propIs(Number, 'x', {x: 1, y: 2});  //=> true\n\t     *      R.propIs(Number, 'x', {x: 'foo'});    //=> false\n\t     *      R.propIs(Number, 'x', {});            //=> false\n\t     */\n\t    var propIs = _curry3(function propIs(type, name, obj) {\n\t        return propSatisfies(is(type), name, obj);\n\t    });\n\t\n\t    /**\n\t     * Returns a single item by iterating through the list, successively calling\n\t     * the iterator function and passing it an accumulator value and the current\n\t     * value from the array, and then passing the result to the next call.\n\t     *\n\t     * The iterator function receives two values: *(acc, value)*. It may use\n\t     * `R.reduced` to shortcut the iteration.\n\t     *\n\t     * Note: `R.reduce` does not skip deleted or unassigned indices (sparse\n\t     * arrays), unlike the native `Array.prototype.reduce` method. For more details\n\t     * on this behavior, see:\n\t     * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce#Description\n\t     *\n\t     * Dispatches to the `reduce` method of the third argument, if present.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @since v0.1.0\n\t     * @category List\n\t     * @sig ((a, b) -> a) -> a -> [b] -> a\n\t     * @param {Function} fn The iterator function. Receives two values, the accumulator and the\n\t     *        current element from the array.\n\t     * @param {*} acc The accumulator value.\n\t     * @param {Array} list The list to iterate over.\n\t     * @return {*} The final, accumulated value.\n\t     * @see R.reduced, R.addIndex\n\t     * @example\n\t     *\n\t     *      var numbers = [1, 2, 3];\n\t     *      var add = (a, b) => a + b;\n\t     *\n\t     *      R.reduce(add, 10, numbers); //=> 16\n\t     */\n\t    var reduce = _curry3(_reduce);\n\t\n\t    /**\n\t     * The complement of `filter`.\n\t     *\n\t     * Acts as a transducer if a transformer is given in list position.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @since v0.1.0\n\t     * @category List\n\t     * @sig Filterable f => (a -> Boolean) -> f a -> f a\n\t     * @param {Function} pred\n\t     * @param {Array} filterable\n\t     * @return {Array}\n\t     * @see R.filter, R.transduce, R.addIndex\n\t     * @example\n\t     *\n\t     *      var isOdd = (n) => n % 2 === 1;\n\t     *\n\t     *      R.reject(isOdd, [1, 2, 3, 4]); //=> [2, 4]\n\t     *\n\t     *      R.reject(isOdd, {a: 1, b: 2, c: 3, d: 4}); //=> {b: 2, d: 4}\n\t     */\n\t    var reject = _curry2(function reject(pred, filterable) {\n\t        return filter(_complement(pred), filterable);\n\t    });\n\t\n\t    /**\n\t     * Returns a fixed list of size `n` containing a specified identical value.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @since v0.1.1\n\t     * @category List\n\t     * @sig a -> n -> [a]\n\t     * @param {*} value The value to repeat.\n\t     * @param {Number} n The desired size of the output list.\n\t     * @return {Array} A new array containing `n` `value`s.\n\t     * @example\n\t     *\n\t     *      R.repeat('hi', 5); //=> ['hi', 'hi', 'hi', 'hi', 'hi']\n\t     *\n\t     *      var obj = {};\n\t     *      var repeatedObjs = R.repeat(obj, 5); //=> [{}, {}, {}, {}, {}]\n\t     *      repeatedObjs[0] === repeatedObjs[1]; //=> true\n\t     */\n\t    var repeat = _curry2(function repeat(value, n) {\n\t        return times(always(value), n);\n\t    });\n\t\n\t    /**\n\t     * Adds together all the elements of a list.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @since v0.1.0\n\t     * @category Math\n\t     * @sig [Number] -> Number\n\t     * @param {Array} list An array of numbers\n\t     * @return {Number} The sum of all the numbers in the list.\n\t     * @see R.reduce\n\t     * @example\n\t     *\n\t     *      R.sum([2,4,6,8,100,1]); //=> 121\n\t     */\n\t    var sum = reduce(add, 0);\n\t\n\t    /**\n\t     * Returns a new list containing the last `n` elements of the given list.\n\t     * If `n > list.length`, returns a list of `list.length` elements.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @since v0.16.0\n\t     * @category List\n\t     * @sig Number -> [a] -> [a]\n\t     * @sig Number -> String -> String\n\t     * @param {Number} n The number of elements to return.\n\t     * @param {Array} xs The collection to consider.\n\t     * @return {Array}\n\t     * @see R.dropLast\n\t     * @example\n\t     *\n\t     *      R.takeLast(1, ['foo', 'bar', 'baz']); //=> ['baz']\n\t     *      R.takeLast(2, ['foo', 'bar', 'baz']); //=> ['bar', 'baz']\n\t     *      R.takeLast(3, ['foo', 'bar', 'baz']); //=> ['foo', 'bar', 'baz']\n\t     *      R.takeLast(4, ['foo', 'bar', 'baz']); //=> ['foo', 'bar', 'baz']\n\t     *      R.takeLast(3, 'ramda');               //=> 'mda'\n\t     */\n\t    var takeLast = _curry2(function takeLast(n, xs) {\n\t        return drop(n >= 0 ? xs.length - n : 0, xs);\n\t    });\n\t\n\t    /**\n\t     * Initializes a transducer using supplied iterator function. Returns a single\n\t     * item by iterating through the list, successively calling the transformed\n\t     * iterator function and passing it an accumulator value and the current value\n\t     * from the array, and then passing the result to the next call.\n\t     *\n\t     * The iterator function receives two values: *(acc, value)*. It will be\n\t     * wrapped as a transformer to initialize the transducer. A transformer can be\n\t     * passed directly in place of an iterator function. In both cases, iteration\n\t     * may be stopped early with the `R.reduced` function.\n\t     *\n\t     * A transducer is a function that accepts a transformer and returns a\n\t     * transformer and can be composed directly.\n\t     *\n\t     * A transformer is an an object that provides a 2-arity reducing iterator\n\t     * function, step, 0-arity initial value function, init, and 1-arity result\n\t     * extraction function, result. The step function is used as the iterator\n\t     * function in reduce. The result function is used to convert the final\n\t     * accumulator into the return type and in most cases is R.identity. The init\n\t     * function can be used to provide an initial accumulator, but is ignored by\n\t     * transduce.\n\t     *\n\t     * The iteration is performed with R.reduce after initializing the transducer.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @since v0.12.0\n\t     * @category List\n\t     * @sig (c -> c) -> (a,b -> a) -> a -> [b] -> a\n\t     * @param {Function} xf The transducer function. Receives a transformer and returns a transformer.\n\t     * @param {Function} fn The iterator function. Receives two values, the accumulator and the\n\t     *        current element from the array. Wrapped as transformer, if necessary, and used to\n\t     *        initialize the transducer\n\t     * @param {*} acc The initial accumulator value.\n\t     * @param {Array} list The list to iterate over.\n\t     * @return {*} The final, accumulated value.\n\t     * @see R.reduce, R.reduced, R.into\n\t     * @example\n\t     *\n\t     *      var numbers = [1, 2, 3, 4];\n\t     *      var transducer = R.compose(R.map(R.add(1)), R.take(2));\n\t     *\n\t     *      R.transduce(transducer, R.flip(R.append), [], numbers); //=> [2, 3]\n\t     */\n\t    var transduce = curryN(4, function transduce(xf, fn, acc, list) {\n\t        return _reduce(xf(typeof fn === 'function' ? _xwrap(fn) : fn), acc, list);\n\t    });\n\t\n\t    /**\n\t     * Combines two lists into a set (i.e. no duplicates) composed of the elements\n\t     * of each list. Duplication is determined according to the value returned by\n\t     * applying the supplied predicate to two list elements.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @since v0.1.0\n\t     * @category Relation\n\t     * @sig (a -> a -> Boolean) -> [*] -> [*] -> [*]\n\t     * @param {Function} pred A predicate used to test whether two items are equal.\n\t     * @param {Array} list1 The first list.\n\t     * @param {Array} list2 The second list.\n\t     * @return {Array} The first and second lists concatenated, with\n\t     *         duplicates removed.\n\t     * @see R.union\n\t     * @example\n\t     *\n\t     *      var l1 = [{a: 1}, {a: 2}];\n\t     *      var l2 = [{a: 1}, {a: 4}];\n\t     *      R.unionWith(R.eqBy(R.prop('a')), l1, l2); //=> [{a: 1}, {a: 2}, {a: 4}]\n\t     */\n\t    var unionWith = _curry3(function unionWith(pred, list1, list2) {\n\t        return uniqWith(pred, _concat(list1, list2));\n\t    });\n\t\n\t    /**\n\t     * Takes a spec object and a test object; returns true if the test satisfies\n\t     * the spec, false otherwise. An object satisfies the spec if, for each of the\n\t     * spec's own properties, accessing that property of the object gives the same\n\t     * value (in `R.equals` terms) as accessing that property of the spec.\n\t     *\n\t     * `whereEq` is a specialization of [`where`](#where).\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @since v0.14.0\n\t     * @category Object\n\t     * @sig {String: *} -> {String: *} -> Boolean\n\t     * @param {Object} spec\n\t     * @param {Object} testObj\n\t     * @return {Boolean}\n\t     * @see R.where\n\t     * @example\n\t     *\n\t     *      // pred :: Object -> Boolean\n\t     *      var pred = R.whereEq({a: 1, b: 2});\n\t     *\n\t     *      pred({a: 1});              //=> false\n\t     *      pred({a: 1, b: 2});        //=> true\n\t     *      pred({a: 1, b: 2, c: 3});  //=> true\n\t     *      pred({a: 1, b: 1});        //=> false\n\t     */\n\t    var whereEq = _curry2(function whereEq(spec, testObj) {\n\t        return where(map(equals, spec), testObj);\n\t    });\n\t\n\t    var _flatCat = function () {\n\t        var preservingReduced = function (xf) {\n\t            return {\n\t                '@@transducer/init': _xfBase.init,\n\t                '@@transducer/result': function (result) {\n\t                    return xf['@@transducer/result'](result);\n\t                },\n\t                '@@transducer/step': function (result, input) {\n\t                    var ret = xf['@@transducer/step'](result, input);\n\t                    return ret['@@transducer/reduced'] ? _forceReduced(ret) : ret;\n\t                }\n\t            };\n\t        };\n\t        return function _xcat(xf) {\n\t            var rxf = preservingReduced(xf);\n\t            return {\n\t                '@@transducer/init': _xfBase.init,\n\t                '@@transducer/result': function (result) {\n\t                    return rxf['@@transducer/result'](result);\n\t                },\n\t                '@@transducer/step': function (result, input) {\n\t                    return !isArrayLike(input) ? _reduce(rxf, result, [input]) : _reduce(rxf, result, input);\n\t                }\n\t            };\n\t        };\n\t    }();\n\t\n\t    // Array.prototype.indexOf doesn't exist below IE9\n\t    // manually crawl the list to distinguish between +0 and -0\n\t    // NaN\n\t    // non-zero numbers can utilise Set\n\t    // all these types can utilise Set\n\t    // null can utilise Set\n\t    // anything else not covered above, defer to R.equals\n\t    var _indexOf = function _indexOf(list, a, idx) {\n\t        var inf, item;\n\t        // Array.prototype.indexOf doesn't exist below IE9\n\t        if (typeof list.indexOf === 'function') {\n\t            switch (typeof a) {\n\t            case 'number':\n\t                if (a === 0) {\n\t                    // manually crawl the list to distinguish between +0 and -0\n\t                    inf = 1 / a;\n\t                    while (idx < list.length) {\n\t                        item = list[idx];\n\t                        if (item === 0 && 1 / item === inf) {\n\t                            return idx;\n\t                        }\n\t                        idx += 1;\n\t                    }\n\t                    return -1;\n\t                } else if (a !== a) {\n\t                    // NaN\n\t                    while (idx < list.length) {\n\t                        item = list[idx];\n\t                        if (typeof item === 'number' && item !== item) {\n\t                            return idx;\n\t                        }\n\t                        idx += 1;\n\t                    }\n\t                    return -1;\n\t                }\n\t                // non-zero numbers can utilise Set\n\t                return list.indexOf(a, idx);\n\t            // all these types can utilise Set\n\t            case 'string':\n\t            case 'boolean':\n\t            case 'function':\n\t            case 'undefined':\n\t                return list.indexOf(a, idx);\n\t            case 'object':\n\t                if (a === null) {\n\t                    // null can utilise Set\n\t                    return list.indexOf(a, idx);\n\t                }\n\t            }\n\t        }\n\t        // anything else not covered above, defer to R.equals\n\t        while (idx < list.length) {\n\t            if (equals(list[idx], a)) {\n\t                return idx;\n\t            }\n\t            idx += 1;\n\t        }\n\t        return -1;\n\t    };\n\t\n\t    var _xchain = _curry2(function _xchain(f, xf) {\n\t        return map(f, _flatCat(xf));\n\t    });\n\t\n\t    /**\n\t     * Takes a list of predicates and returns a predicate that returns true for a\n\t     * given list of arguments if every one of the provided predicates is satisfied\n\t     * by those arguments.\n\t     *\n\t     * The function returned is a curried function whose arity matches that of the\n\t     * highest-arity predicate.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @since v0.9.0\n\t     * @category Logic\n\t     * @sig [(*... -> Boolean)] -> (*... -> Boolean)\n\t     * @param {Array} preds\n\t     * @return {Function}\n\t     * @see R.anyPass\n\t     * @example\n\t     *\n\t     *      var isQueen = R.propEq('rank', 'Q');\n\t     *      var isSpade = R.propEq('suit', '♠︎');\n\t     *      var isQueenOfSpades = R.allPass([isQueen, isSpade]);\n\t     *\n\t     *      isQueenOfSpades({rank: 'Q', suit: '♣︎'}); //=> false\n\t     *      isQueenOfSpades({rank: 'Q', suit: '♠︎'}); //=> true\n\t     */\n\t    var allPass = _curry1(function allPass(preds) {\n\t        return curryN(reduce(max, 0, pluck('length', preds)), function () {\n\t            var idx = 0;\n\t            var len = preds.length;\n\t            while (idx < len) {\n\t                if (!preds[idx].apply(this, arguments)) {\n\t                    return false;\n\t                }\n\t                idx += 1;\n\t            }\n\t            return true;\n\t        });\n\t    });\n\t\n\t    /**\n\t     * Returns `true` if all elements are unique, in `R.equals` terms, otherwise\n\t     * `false`.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @since v0.18.0\n\t     * @category List\n\t     * @sig [a] -> Boolean\n\t     * @param {Array} list The array to consider.\n\t     * @return {Boolean} `true` if all elements are unique, else `false`.\n\t     * @example\n\t     *\n\t     *      R.allUniq(['1', 1]); //=> true\n\t     *      R.allUniq([1, 1]);   //=> false\n\t     *      R.allUniq([[42], [42]]); //=> false\n\t     */\n\t    var allUniq = _curry1(function allUniq(list) {\n\t        var len = list.length;\n\t        var idx = 0;\n\t        while (idx < len) {\n\t            if (_indexOf(list, list[idx], idx + 1) >= 0) {\n\t                return false;\n\t            }\n\t            idx += 1;\n\t        }\n\t        return true;\n\t    });\n\t\n\t    /**\n\t     * Takes a list of predicates and returns a predicate that returns true for a\n\t     * given list of arguments if at least one of the provided predicates is\n\t     * satisfied by those arguments.\n\t     *\n\t     * The function returned is a curried function whose arity matches that of the\n\t     * highest-arity predicate.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @since v0.9.0\n\t     * @category Logic\n\t     * @sig [(*... -> Boolean)] -> (*... -> Boolean)\n\t     * @param {Array} preds\n\t     * @return {Function}\n\t     * @see R.allPass\n\t     * @example\n\t     *\n\t     *      var gte = R.anyPass([R.gt, R.equals]);\n\t     *\n\t     *      gte(3, 2); //=> true\n\t     *      gte(2, 2); //=> true\n\t     *      gte(2, 3); //=> false\n\t     */\n\t    var anyPass = _curry1(function anyPass(preds) {\n\t        return curryN(reduce(max, 0, pluck('length', preds)), function () {\n\t            var idx = 0;\n\t            var len = preds.length;\n\t            while (idx < len) {\n\t                if (preds[idx].apply(this, arguments)) {\n\t                    return true;\n\t                }\n\t                idx += 1;\n\t            }\n\t            return false;\n\t        });\n\t    });\n\t\n\t    /**\n\t     * ap applies a list of functions to a list of values.\n\t     *\n\t     * Dispatches to the `ap` method of the second argument, if present. Also\n\t     * treats functions as applicatives.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @since v0.3.0\n\t     * @category Function\n\t     * @sig [f] -> [a] -> [f a]\n\t     * @param {Array} fns An array of functions\n\t     * @param {Array} vs An array of values\n\t     * @return {Array} An array of results of applying each of `fns` to all of `vs` in turn.\n\t     * @example\n\t     *\n\t     *      R.ap([R.multiply(2), R.add(3)], [1,2,3]); //=> [2, 4, 6, 4, 5, 6]\n\t     */\n\t    // else\n\t    var ap = _curry2(function ap(applicative, fn) {\n\t        return typeof applicative.ap === 'function' ? applicative.ap(fn) : typeof applicative === 'function' ? curryN(Math.max(applicative.length, fn.length), function () {\n\t            return applicative.apply(this, arguments)(fn.apply(this, arguments));\n\t        }) : // else\n\t        _reduce(function (acc, f) {\n\t            return _concat(acc, map(f, fn));\n\t        }, [], applicative);\n\t    });\n\t\n\t    /**\n\t     * Returns the result of calling its first argument with the remaining\n\t     * arguments. This is occasionally useful as a converging function for\n\t     * `R.converge`: the left branch can produce a function while the right branch\n\t     * produces a value to be passed to that function as an argument.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @since v0.9.0\n\t     * @category Function\n\t     * @sig (*... -> a),*... -> a\n\t     * @param {Function} fn The function to apply to the remaining arguments.\n\t     * @param {...*} args Any number of positional arguments.\n\t     * @return {*}\n\t     * @see R.apply\n\t     * @example\n\t     *\n\t     *      var indentN = R.pipe(R.times(R.always(' ')),\n\t     *                           R.join(''),\n\t     *                           R.replace(/^(?!$)/gm));\n\t     *\n\t     *      var format = R.converge(R.call, [\n\t     *                                  R.pipe(R.prop('indent'), indentN),\n\t     *                                  R.prop('value')\n\t     *                              ]);\n\t     *\n\t     *      format({indent: 2, value: 'foo\\nbar\\nbaz\\n'}); //=> '  foo\\n  bar\\n  baz\\n'\n\t     */\n\t    var call = curry(function call(fn) {\n\t        return fn.apply(this, _slice(arguments, 1));\n\t    });\n\t\n\t    /**\n\t     * `chain` maps a function over a list and concatenates the results. `chain`\n\t     * is also known as `flatMap` in some libraries\n\t     *\n\t     * Dispatches to the `chain` method of the second argument, if present.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @since v0.3.0\n\t     * @category List\n\t     * @sig (a -> [b]) -> [a] -> [b]\n\t     * @param {Function} fn\n\t     * @param {Array} list\n\t     * @return {Array}\n\t     * @example\n\t     *\n\t     *      var duplicate = n => [n, n];\n\t     *      R.chain(duplicate, [1, 2, 3]); //=> [1, 1, 2, 2, 3, 3]\n\t     */\n\t    var chain = _curry2(_dispatchable('chain', _xchain, function chain(fn, monad) {\n\t        if (typeof monad === 'function') {\n\t            return function () {\n\t                return monad.call(this, fn.apply(this, arguments)).apply(this, arguments);\n\t            };\n\t        }\n\t        return _makeFlat(false)(map(fn, monad));\n\t    }));\n\t\n\t    /**\n\t     * Turns a list of Functors into a Functor of a list, applying a mapping\n\t     * function to the elements of the list along the way.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @since v0.8.0\n\t     * @category List\n\t     * @sig Functor f => (a -> f b) -> (x -> f x) -> [a] -> f [b]\n\t     * @param {Function} fn The transformation function\n\t     * @param {Function} of A function that returns the data type to return\n\t     * @param {Array} list An array of functors of the same type\n\t     * @return {*}\n\t     * @see R.traverse\n\t     * @deprecated since v0.19.0\n\t     * @example\n\t     *\n\t     *      var add10 = R.map(R.add(10));\n\t     *      R.commuteMap(add10, R.of, [[1], [2, 3]]);   //=> [[11, 12], [11, 13]]\n\t     *      R.commuteMap(add10, R.of, [[1, 2], [3]]);   //=> [[11, 13], [12, 13]]\n\t     *      R.commuteMap(add10, R.of, [[1], [2], [3]]); //=> [[11, 12, 13]]\n\t     *      R.commuteMap(add10, Maybe.of, [Just(1), Just(2), Just(3)]);   //=> Just([11, 12, 13])\n\t     *      R.commuteMap(add10, Maybe.of, [Just(1), Just(2), Nothing()]); //=> Nothing()\n\t     *\n\t     *      var fetch = url => Future((rej, res) => http.get(url, res).on('error', rej));\n\t     *      R.commuteMap(fetch, Future.of, [\n\t     *        'http://ramdajs.com',\n\t     *        'http://github.com/ramda'\n\t     *      ]); //=> Future([IncomingMessage, IncomingMessage])\n\t     */\n\t    var commuteMap = _curry3(function commuteMap(fn, of, list) {\n\t        function consF(acc, x) {\n\t            return ap(map(prepend, fn(x)), acc);\n\t        }\n\t        return reduceRight(consF, of([]), list);\n\t    });\n\t\n\t    /**\n\t     * Wraps a constructor function inside a curried function that can be called\n\t     * with the same arguments and returns the same type. The arity of the function\n\t     * returned is specified to allow using variadic constructor functions.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @since v0.4.0\n\t     * @category Function\n\t     * @sig Number -> (* -> {*}) -> (* -> {*})\n\t     * @param {Number} n The arity of the constructor function.\n\t     * @param {Function} Fn The constructor function to wrap.\n\t     * @return {Function} A wrapped, curried constructor function.\n\t     * @example\n\t     *\n\t     *      // Variadic constructor function\n\t     *      var Widget = () => {\n\t     *        this.children = Array.prototype.slice.call(arguments);\n\t     *        // ...\n\t     *      };\n\t     *      Widget.prototype = {\n\t     *        // ...\n\t     *      };\n\t     *      var allConfigs = [\n\t     *        // ...\n\t     *      ];\n\t     *      R.map(R.constructN(1, Widget), allConfigs); // a list of Widgets\n\t     */\n\t    var constructN = _curry2(function constructN(n, Fn) {\n\t        if (n > 10) {\n\t            throw new Error('Constructor with greater than ten arguments');\n\t        }\n\t        if (n === 0) {\n\t            return function () {\n\t                return new Fn();\n\t            };\n\t        }\n\t        return curry(nAry(n, function ($0, $1, $2, $3, $4, $5, $6, $7, $8, $9) {\n\t            switch (arguments.length) {\n\t            case 1:\n\t                return new Fn($0);\n\t            case 2:\n\t                return new Fn($0, $1);\n\t            case 3:\n\t                return new Fn($0, $1, $2);\n\t            case 4:\n\t                return new Fn($0, $1, $2, $3);\n\t            case 5:\n\t                return new Fn($0, $1, $2, $3, $4);\n\t            case 6:\n\t                return new Fn($0, $1, $2, $3, $4, $5);\n\t            case 7:\n\t                return new Fn($0, $1, $2, $3, $4, $5, $6);\n\t            case 8:\n\t                return new Fn($0, $1, $2, $3, $4, $5, $6, $7);\n\t            case 9:\n\t                return new Fn($0, $1, $2, $3, $4, $5, $6, $7, $8);\n\t            case 10:\n\t                return new Fn($0, $1, $2, $3, $4, $5, $6, $7, $8, $9);\n\t            }\n\t        }));\n\t    });\n\t\n\t    /**\n\t     * Accepts a converging function and a list of branching functions and returns\n\t     * a new function. When invoked, this new function is applied to some\n\t     * arguments, each branching function is applied to those same arguments. The\n\t     * results of each branching function are passed as arguments to the converging\n\t     * function to produce the return value.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @since v0.4.2\n\t     * @category Function\n\t     * @sig (x1 -> x2 -> ... -> z) -> [(a -> b -> ... -> x1), (a -> b -> ... -> x2), ...] -> (a -> b -> ... -> z)\n\t     * @param {Function} after A function. `after` will be invoked with the return values of\n\t     *        `fn1` and `fn2` as its arguments.\n\t     * @param {Array} functions A list of functions.\n\t     * @return {Function} A new function.\n\t     * @example\n\t     *\n\t     *      var add = (a, b) => a + b;\n\t     *      var multiply = (a, b) => a * b;\n\t     *      var subtract = (a, b) => a - b;\n\t     *\n\t     *      //≅ multiply( add(1, 2), subtract(1, 2) );\n\t     *      R.converge(multiply, [add, subtract])(1, 2); //=> -3\n\t     *\n\t     *      var add3 = (a, b, c) => a + b + c;\n\t     *      R.converge(add3, [multiply, add, subtract])(1, 2); //=> 4\n\t     */\n\t    var converge = _curry2(function converge(after, fns) {\n\t        return curryN(Math.max.apply(Math, pluck('length', fns)), function () {\n\t            var args = arguments;\n\t            var context = this;\n\t            return after.apply(context, _map(function (fn) {\n\t                return fn.apply(context, args);\n\t            }, fns));\n\t        });\n\t    });\n\t\n\t    /**\n\t     * Returns a new list without any consecutively repeating elements. Equality is\n\t     * determined by applying the supplied predicate two consecutive elements. The\n\t     * first element in a series of equal element is the one being preserved.\n\t     *\n\t     * Dispatches to the `dropRepeatsWith` method of the second argument, if present.\n\t     *\n\t     * Acts as a transducer if a transformer is given in list position.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @since v0.14.0\n\t     * @category List\n\t     * @sig (a, a -> Boolean) -> [a] -> [a]\n\t     * @param {Function} pred A predicate used to test whether two items are equal.\n\t     * @param {Array} list The array to consider.\n\t     * @return {Array} `list` without repeating elements.\n\t     * @see R.transduce\n\t     * @example\n\t     *\n\t     *      var lengthEq = (x, y) => Math.abs(x) === Math.abs(y);\n\t     *      var l = [1, -1, 1, 3, 4, -4, -4, -5, 5, 3, 3];\n\t     *      R.dropRepeatsWith(R.eqBy(Math.abs), l); //=> [1, 3, 4, -5, 3]\n\t     */\n\t    var dropRepeatsWith = _curry2(_dispatchable('dropRepeatsWith', _xdropRepeatsWith, function dropRepeatsWith(pred, list) {\n\t        var result = [];\n\t        var idx = 1;\n\t        var len = list.length;\n\t        if (len !== 0) {\n\t            result[0] = list[0];\n\t            while (idx < len) {\n\t                if (!pred(last(result), list[idx])) {\n\t                    result[result.length] = list[idx];\n\t                }\n\t                idx += 1;\n\t            }\n\t        }\n\t        return result;\n\t    }));\n\t\n\t    /**\n\t     * Takes a function and two values in its domain and returns `true` if the\n\t     * values map to the same value in the codomain; `false` otherwise.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @since v0.18.0\n\t     * @category Relation\n\t     * @sig (a -> b) -> a -> a -> Boolean\n\t     * @param {Function} f\n\t     * @param {*} x\n\t     * @param {*} y\n\t     * @return {Boolean}\n\t     * @example\n\t     *\n\t     *      R.eqBy(Math.abs, 5, -5); //=> true\n\t     */\n\t    var eqBy = _curry3(function eqBy(f, x, y) {\n\t        return equals(f(x), f(y));\n\t    });\n\t\n\t    /**\n\t     * Reports whether two objects have the same value, in `R.equals` terms, for\n\t     * the specified property. Useful as a curried predicate.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @since v0.1.0\n\t     * @category Object\n\t     * @sig k -> {k: v} -> {k: v} -> Boolean\n\t     * @param {String} prop The name of the property to compare\n\t     * @param {Object} obj1\n\t     * @param {Object} obj2\n\t     * @return {Boolean}\n\t     *\n\t     * @example\n\t     *\n\t     *      var o1 = { a: 1, b: 2, c: 3, d: 4 };\n\t     *      var o2 = { a: 10, b: 20, c: 3, d: 40 };\n\t     *      R.eqProps('a', o1, o2); //=> false\n\t     *      R.eqProps('c', o1, o2); //=> true\n\t     */\n\t    var eqProps = _curry3(function eqProps(prop, obj1, obj2) {\n\t        return equals(obj1[prop], obj2[prop]);\n\t    });\n\t\n\t    /**\n\t     * Returns the position of the first occurrence of an item in an array, or -1\n\t     * if the item is not included in the array. `R.equals` is used to determine\n\t     * equality.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @since v0.1.0\n\t     * @category List\n\t     * @sig a -> [a] -> Number\n\t     * @param {*} target The item to find.\n\t     * @param {Array} xs The array to search in.\n\t     * @return {Number} the index of the target, or -1 if the target is not found.\n\t     * @see R.lastIndexOf\n\t     * @example\n\t     *\n\t     *      R.indexOf(3, [1,2,3,4]); //=> 2\n\t     *      R.indexOf(10, [1,2,3,4]); //=> -1\n\t     */\n\t    var indexOf = _curry2(function indexOf(target, xs) {\n\t        return typeof xs.indexOf === 'function' && !_isArray(xs) ? xs.indexOf(target) : _indexOf(xs, target, 0);\n\t    });\n\t\n\t    /**\n\t     * juxt applies a list of functions to a list of values.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @since 0.19.1\n\t     * @since 0.19.0\n\t     * @category Function\n\t     * @sig [(a, b, ..., m) -> n] -> ((a, b, ..., m) -> [n])\n\t     * @param {Array} fns An array of functions\n\t     * @return {Function} A function that returns a list of values after applying each of the original `fns` to its parameters.\n\t     * @example\n\t     *\n\t     *      var range = R.juxt([Math.min, Math.max]);\n\t     *      range(3, 4, 9, -3); //=> [-3, 9]\n\t     */\n\t    var juxt = _curry1(function juxt(fns) {\n\t        return function () {\n\t            return map(apply(__, arguments), fns);\n\t        };\n\t    });\n\t\n\t    /**\n\t     * Returns a lens for the given getter and setter functions. The getter \"gets\"\n\t     * the value of the focus; the setter \"sets\" the value of the focus. The setter\n\t     * should not mutate the data structure.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @since v0.8.0\n\t     * @category Object\n\t     * @typedefn Lens s a = Functor f => (a -> f a) -> s -> f s\n\t     * @sig (s -> a) -> ((a, s) -> s) -> Lens s a\n\t     * @param {Function} getter\n\t     * @param {Function} setter\n\t     * @return {Lens}\n\t     * @see R.view, R.set, R.over, R.lensIndex, R.lensProp\n\t     * @example\n\t     *\n\t     *      var xLens = R.lens(R.prop('x'), R.assoc('x'));\n\t     *\n\t     *      R.view(xLens, {x: 1, y: 2});            //=> 1\n\t     *      R.set(xLens, 4, {x: 1, y: 2});          //=> {x: 4, y: 2}\n\t     *      R.over(xLens, R.negate, {x: 1, y: 2});  //=> {x: -1, y: 2}\n\t     */\n\t    var lens = _curry2(function lens(getter, setter) {\n\t        return function (f) {\n\t            return function (s) {\n\t                return map(function (v) {\n\t                    return setter(v, s);\n\t                }, f(getter(s)));\n\t            };\n\t        };\n\t    });\n\t\n\t    /**\n\t     * Returns a lens whose focus is the specified index.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @since v0.14.0\n\t     * @category Object\n\t     * @typedefn Lens s a = Functor f => (a -> f a) -> s -> f s\n\t     * @sig Number -> Lens s a\n\t     * @param {Number} n\n\t     * @return {Lens}\n\t     * @see R.view, R.set, R.over\n\t     * @example\n\t     *\n\t     *      var headLens = R.lensIndex(0);\n\t     *\n\t     *      R.view(headLens, ['a', 'b', 'c']);            //=> 'a'\n\t     *      R.set(headLens, 'x', ['a', 'b', 'c']);        //=> ['x', 'b', 'c']\n\t     *      R.over(headLens, R.toUpper, ['a', 'b', 'c']); //=> ['A', 'b', 'c']\n\t     */\n\t    var lensIndex = _curry1(function lensIndex(n) {\n\t        return lens(nth(n), update(n));\n\t    });\n\t\n\t    /**\n\t     * Returns a lens whose focus is the specified path.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @since 0.19.1\n\t     * @since 0.19.0\n\t     * @category Object\n\t     * @typedefn Lens s a = Functor f => (a -> f a) -> s -> f s\n\t     * @sig [String] -> Lens s a\n\t     * @param {Array} path The path to use.\n\t     * @return {Lens}\n\t     * @see R.view, R.set, R.over\n\t     * @example\n\t     *\n\t     *      var xyLens = R.lensPath(['x', 'y']);\n\t     *\n\t     *      R.view(xyLens, {x: {y: 2, z: 3}});            //=> 2\n\t     *      R.set(xyLens, 4, {x: {y: 2, z: 3}});          //=> {x: {y: 4, z: 3}}\n\t     *      R.over(xyLens, R.negate, {x: {y: 2, z: 3}});  //=> {x: {y: -2, z: 3}}\n\t     */\n\t    var lensPath = _curry1(function lensPath(p) {\n\t        return lens(path(p), assocPath(p));\n\t    });\n\t\n\t    /**\n\t     * Returns a lens whose focus is the specified property.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @since v0.14.0\n\t     * @category Object\n\t     * @typedefn Lens s a = Functor f => (a -> f a) -> s -> f s\n\t     * @sig String -> Lens s a\n\t     * @param {String} k\n\t     * @return {Lens}\n\t     * @see R.view, R.set, R.over\n\t     * @example\n\t     *\n\t     *      var xLens = R.lensProp('x');\n\t     *\n\t     *      R.view(xLens, {x: 1, y: 2});            //=> 1\n\t     *      R.set(xLens, 4, {x: 1, y: 2});          //=> {x: 4, y: 2}\n\t     *      R.over(xLens, R.negate, {x: 1, y: 2});  //=> {x: -1, y: 2}\n\t     */\n\t    var lensProp = _curry1(function lensProp(k) {\n\t        return lens(prop(k), assoc(k));\n\t    });\n\t\n\t    /**\n\t     * \"lifts\" a function to be the specified arity, so that it may \"map over\" that\n\t     * many lists (or other objects that satisfies the [FantasyLand Apply spec](https://github.com/fantasyland/fantasy-land#apply)).\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @since v0.7.0\n\t     * @category Function\n\t     * @sig Number -> (*... -> *) -> ([*]... -> [*])\n\t     * @param {Function} fn The function to lift into higher context\n\t     * @return {Function} The lifted function.\n\t     * @see R.lift\n\t     * @example\n\t     *\n\t     *      var madd3 = R.liftN(3, R.curryN(3, (...args) => R.sum(args)));\n\t     *      madd3([1,2,3], [1,2,3], [1]); //=> [3, 4, 5, 4, 5, 6, 5, 6, 7]\n\t     */\n\t    var liftN = _curry2(function liftN(arity, fn) {\n\t        var lifted = curryN(arity, fn);\n\t        return curryN(arity, function () {\n\t            return _reduce(ap, map(lifted, arguments[0]), _slice(arguments, 1));\n\t        });\n\t    });\n\t\n\t    /**\n\t     * Returns the mean of the given list of numbers.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @since v0.14.0\n\t     * @category Math\n\t     * @sig [Number] -> Number\n\t     * @param {Array} list\n\t     * @return {Number}\n\t     * @example\n\t     *\n\t     *      R.mean([2, 7, 9]); //=> 6\n\t     *      R.mean([]); //=> NaN\n\t     */\n\t    var mean = _curry1(function mean(list) {\n\t        return sum(list) / list.length;\n\t    });\n\t\n\t    /**\n\t     * Returns the median of the given list of numbers.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @since v0.14.0\n\t     * @category Math\n\t     * @sig [Number] -> Number\n\t     * @param {Array} list\n\t     * @return {Number}\n\t     * @example\n\t     *\n\t     *      R.median([2, 9, 7]); //=> 7\n\t     *      R.median([7, 2, 10, 9]); //=> 8\n\t     *      R.median([]); //=> NaN\n\t     */\n\t    var median = _curry1(function median(list) {\n\t        var len = list.length;\n\t        if (len === 0) {\n\t            return NaN;\n\t        }\n\t        var width = 2 - len % 2;\n\t        var idx = (len - width) / 2;\n\t        return mean(_slice(list).sort(function (a, b) {\n\t            return a < b ? -1 : a > b ? 1 : 0;\n\t        }).slice(idx, idx + width));\n\t    });\n\t\n\t    /**\n\t     * Create a new object with the own properties of the first object merged with\n\t     * the own properties of the second object. If a key exists in both objects,\n\t     * the value from the second object will be used.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @since v0.1.0\n\t     * @category Object\n\t     * @sig {k: v} -> {k: v} -> {k: v}\n\t     * @param {Object} l\n\t     * @param {Object} r\n\t     * @return {Object}\n\t     * @see R.mergeWith, R.mergeWithKey\n\t     * @example\n\t     *\n\t     *      R.merge({ 'name': 'fred', 'age': 10 }, { 'age': 40 });\n\t     *      //=> { 'name': 'fred', 'age': 40 }\n\t     *\n\t     *      var resetToDefault = R.merge(R.__, {x: 0});\n\t     *      resetToDefault({x: 5, y: 2}); //=> {x: 0, y: 2}\n\t     */\n\t    var merge = mergeWith(function (l, r) {\n\t        return r;\n\t    });\n\t\n\t    /**\n\t     * Merges a list of objects together into one object.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @since v0.10.0\n\t     * @category List\n\t     * @sig [{k: v}] -> {k: v}\n\t     * @param {Array} list An array of objects\n\t     * @return {Object} A merged object.\n\t     * @see R.reduce\n\t     * @example\n\t     *\n\t     *      R.mergeAll([{foo:1},{bar:2},{baz:3}]); //=> {foo:1,bar:2,baz:3}\n\t     *      R.mergeAll([{foo:1},{foo:2},{bar:2}]); //=> {foo:2,bar:2}\n\t     */\n\t    var mergeAll = _curry1(function mergeAll(list) {\n\t        return reduce(merge, {}, list);\n\t    });\n\t\n\t    /**\n\t     * Performs left-to-right function composition. The leftmost function may have\n\t     * any arity; the remaining functions must be unary.\n\t     *\n\t     * In some libraries this function is named `sequence`.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @since v0.1.0\n\t     * @category Function\n\t     * @sig (((a, b, ..., n) -> o), (o -> p), ..., (x -> y), (y -> z)) -> ((a, b, ..., n) -> z)\n\t     * @param {...Function} functions\n\t     * @return {Function}\n\t     * @see R.compose\n\t     * @example\n\t     *\n\t     *      var f = R.pipe(Math.pow, R.negate, R.inc);\n\t     *\n\t     *      f(3, 4); // -(3^4) + 1\n\t     */\n\t    var pipe = function pipe() {\n\t        if (arguments.length === 0) {\n\t            throw new Error('pipe requires at least one argument');\n\t        }\n\t        return _arity(arguments[0].length, reduce(_pipe, arguments[0], tail(arguments)));\n\t    };\n\t\n\t    /**\n\t     * Performs left-to-right composition of one or more Promise-returning\n\t     * functions. The leftmost function may have any arity; the remaining functions\n\t     * must be unary.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @since v0.10.0\n\t     * @category Function\n\t     * @sig ((a -> Promise b), (b -> Promise c), ..., (y -> Promise z)) -> (a -> Promise z)\n\t     * @param {...Function} functions\n\t     * @return {Function}\n\t     * @see R.composeP\n\t     * @example\n\t     *\n\t     *      //  followersForUser :: String -> Promise [User]\n\t     *      var followersForUser = R.pipeP(db.getUserById, db.getFollowers);\n\t     */\n\t    var pipeP = function pipeP() {\n\t        if (arguments.length === 0) {\n\t            throw new Error('pipeP requires at least one argument');\n\t        }\n\t        return _arity(arguments[0].length, reduce(_pipeP, arguments[0], tail(arguments)));\n\t    };\n\t\n\t    /**\n\t     * Multiplies together all the elements of a list.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @since v0.1.0\n\t     * @category Math\n\t     * @sig [Number] -> Number\n\t     * @param {Array} list An array of numbers\n\t     * @return {Number} The product of all the numbers in the list.\n\t     * @see R.reduce\n\t     * @example\n\t     *\n\t     *      R.product([2,4,6,8,100,1]); //=> 38400\n\t     */\n\t    var product = reduce(multiply, 1);\n\t\n\t    /**\n\t     * Transforms a [Traversable](https://github.com/fantasyland/fantasy-land#traversable)\n\t     * of [Applicative](https://github.com/fantasyland/fantasy-land#applicative) into an\n\t     * Applicative of Traversable.\n\t     *\n\t     * Dispatches to the `sequence` method of the second argument, if present.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @since 0.19.1\n\t     * @since 0.19.0\n\t     * @category List\n\t     * @sig (Applicative f, Traversable t) => (a -> f a) -> t (f a) -> f (t a)\n\t     * @param {Function} of\n\t     * @param {*} traversable\n\t     * @return {*}\n\t     * @see R.traverse\n\t     * @example\n\t     *\n\t     *      R.sequence(Maybe.of, [Just(1), Just(2), Just(3)]);   //=> Just([1, 2, 3])\n\t     *      R.sequence(Maybe.of, [Just(1), Just(2), Nothing()]); //=> Nothing()\n\t     *\n\t     *      R.sequence(R.of, Just([1, 2, 3])); //=> [Just(1), Just(2), Just(3)]\n\t     *      R.sequence(R.of, Nothing());       //=> [Nothing()]\n\t     */\n\t    var sequence = _curry2(function sequence(of, traversable) {\n\t        return typeof traversable.sequence === 'function' ? traversable.sequence(of) : reduceRight(function (acc, x) {\n\t            return ap(map(prepend, x), acc);\n\t        }, of([]), traversable);\n\t    });\n\t\n\t    /**\n\t     * Maps an [Applicative](https://github.com/fantasyland/fantasy-land#applicative)-returning\n\t     * function over a [Traversable](https://github.com/fantasyland/fantasy-land#traversable),\n\t     * then uses [`sequence`](#sequence) to transform the resulting Traversable of Applicative\n\t     * into an Applicative of Traversable.\n\t     *\n\t     * Dispatches to the `sequence` method of the third argument, if present.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @since 0.19.1\n\t     * @since 0.19.0\n\t     * @category List\n\t     * @sig (Applicative f, Traversable t) => (a -> f a) -> (a -> f b) -> t a -> f (t b)\n\t     * @param {Function} of\n\t     * @param {Function} f\n\t     * @param {*} traversable\n\t     * @return {*}\n\t     * @see R.sequence\n\t     * @example\n\t     *\n\t     *      R.traverse(Maybe.of, R.negate, [Just(1), Just(2), Just(3)]);   //=> Just([-1, -2, -3])\n\t     *      R.traverse(Maybe.of, R.negate, [Just(1), Just(2), Nothing()]); //=> Nothing()\n\t     *\n\t     *      R.traverse(R.of, R.negate, Just([1, 2, 3])); //=> [Just(-1), Just(-2), Just(-3)]\n\t     *      R.traverse(R.of, R.negate, Nothing());       //=> [Nothing()]\n\t     */\n\t    var traverse = _curry3(function traverse(of, f, traversable) {\n\t        return sequence(of, map(f, traversable));\n\t    });\n\t\n\t    /**\n\t     * Shorthand for `R.chain(R.identity)`, which removes one level of nesting from\n\t     * any [Chain](https://github.com/fantasyland/fantasy-land#chain).\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @since v0.3.0\n\t     * @category List\n\t     * @sig Chain c => c (c a) -> c a\n\t     * @param {*} list\n\t     * @return {*}\n\t     * @see R.flatten, R.chain\n\t     * @example\n\t     *\n\t     *      R.unnest([1, [2], [[3]]]); //=> [1, 2, [3]]\n\t     *      R.unnest([[1, 2], [3, 4], [5, 6]]); //=> [1, 2, 3, 4, 5, 6]\n\t     */\n\t    var unnest = chain(_identity);\n\t\n\t    var _contains = function _contains(a, list) {\n\t        return _indexOf(list, a, 0) >= 0;\n\t    };\n\t\n\t    var _stepCat = function () {\n\t        var _stepCatArray = {\n\t            '@@transducer/init': Array,\n\t            '@@transducer/step': function (xs, x) {\n\t                return _concat(xs, [x]);\n\t            },\n\t            '@@transducer/result': _identity\n\t        };\n\t        var _stepCatString = {\n\t            '@@transducer/init': String,\n\t            '@@transducer/step': function (a, b) {\n\t                return a + b;\n\t            },\n\t            '@@transducer/result': _identity\n\t        };\n\t        var _stepCatObject = {\n\t            '@@transducer/init': Object,\n\t            '@@transducer/step': function (result, input) {\n\t                return merge(result, isArrayLike(input) ? objOf(input[0], input[1]) : input);\n\t            },\n\t            '@@transducer/result': _identity\n\t        };\n\t        return function _stepCat(obj) {\n\t            if (_isTransformer(obj)) {\n\t                return obj;\n\t            }\n\t            if (isArrayLike(obj)) {\n\t                return _stepCatArray;\n\t            }\n\t            if (typeof obj === 'string') {\n\t                return _stepCatString;\n\t            }\n\t            if (typeof obj === 'object') {\n\t                return _stepCatObject;\n\t            }\n\t            throw new Error('Cannot create transformer for ' + obj);\n\t        };\n\t    }();\n\t\n\t    //  mapPairs :: (Object, [String]) -> [String]\n\t    var _toString = function _toString(x, seen) {\n\t        var recur = function recur(y) {\n\t            var xs = seen.concat([x]);\n\t            return _contains(y, xs) ? '<Circular>' : _toString(y, xs);\n\t        };\n\t        //  mapPairs :: (Object, [String]) -> [String]\n\t        var mapPairs = function (obj, keys) {\n\t            return _map(function (k) {\n\t                return _quote(k) + ': ' + recur(obj[k]);\n\t            }, keys.slice().sort());\n\t        };\n\t        switch (Object.prototype.toString.call(x)) {\n\t        case '[object Arguments]':\n\t            return '(function() { return arguments; }(' + _map(recur, x).join(', ') + '))';\n\t        case '[object Array]':\n\t            return '[' + _map(recur, x).concat(mapPairs(x, reject(function (k) {\n\t                return /^\\d+$/.test(k);\n\t            }, keys(x)))).join(', ') + ']';\n\t        case '[object Boolean]':\n\t            return typeof x === 'object' ? 'new Boolean(' + recur(x.valueOf()) + ')' : x.toString();\n\t        case '[object Date]':\n\t            return 'new Date(' + (isNaN(x.valueOf()) ? recur(NaN) : _quote(_toISOString(x))) + ')';\n\t        case '[object Null]':\n\t            return 'null';\n\t        case '[object Number]':\n\t            return typeof x === 'object' ? 'new Number(' + recur(x.valueOf()) + ')' : 1 / x === -Infinity ? '-0' : x.toString(10);\n\t        case '[object String]':\n\t            return typeof x === 'object' ? 'new String(' + recur(x.valueOf()) + ')' : _quote(x);\n\t        case '[object Undefined]':\n\t            return 'undefined';\n\t        default:\n\t            if (typeof x.toString === 'function') {\n\t                var repr = x.toString();\n\t                if (repr !== '[object Object]') {\n\t                    return repr;\n\t                }\n\t            }\n\t            return '{' + mapPairs(x, keys(x)).join(', ') + '}';\n\t        }\n\t    };\n\t\n\t    /**\n\t     * Turns a list of Functors into a Functor of a list.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @since v0.8.0\n\t     * @category List\n\t     * @sig Functor f => (x -> f x) -> [f a] -> f [a]\n\t     * @param {Function} of A function that returns the data type to return\n\t     * @param {Array} list An array of functors of the same type\n\t     * @return {*}\n\t     * @see R.sequence\n\t     * @deprecated since v0.19.0\n\t     * @example\n\t     *\n\t     *      R.commute(R.of, [[1], [2, 3]]);   //=> [[1, 2], [1, 3]]\n\t     *      R.commute(R.of, [[1, 2], [3]]);   //=> [[1, 3], [2, 3]]\n\t     *      R.commute(R.of, [[1], [2], [3]]); //=> [[1, 2, 3]]\n\t     *      R.commute(Maybe.of, [Just(1), Just(2), Just(3)]);   //=> Just([1, 2, 3])\n\t     *      R.commute(Maybe.of, [Just(1), Just(2), Nothing()]); //=> Nothing()\n\t     */\n\t    var commute = commuteMap(identity);\n\t\n\t    /**\n\t     * Performs right-to-left function composition. The rightmost function may have\n\t     * any arity; the remaining functions must be unary.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @since v0.1.0\n\t     * @category Function\n\t     * @sig ((y -> z), (x -> y), ..., (o -> p), ((a, b, ..., n) -> o)) -> ((a, b, ..., n) -> z)\n\t     * @param {...Function} functions\n\t     * @return {Function}\n\t     * @see R.pipe\n\t     * @example\n\t     *\n\t     *      var f = R.compose(R.inc, R.negate, Math.pow);\n\t     *\n\t     *      f(3, 4); // -(3^4) + 1\n\t     */\n\t    var compose = function compose() {\n\t        if (arguments.length === 0) {\n\t            throw new Error('compose requires at least one argument');\n\t        }\n\t        return pipe.apply(this, reverse(arguments));\n\t    };\n\t\n\t    /**\n\t     * Returns the right-to-left Kleisli composition of the provided functions,\n\t     * each of which must return a value of a type supported by [`chain`](#chain).\n\t     *\n\t     * `R.composeK(h, g, f)` is equivalent to `R.compose(R.chain(h), R.chain(g), R.chain(f))`.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @since v0.16.0\n\t     * @category Function\n\t     * @sig Chain m => ((y -> m z), (x -> m y), ..., (a -> m b)) -> (m a -> m z)\n\t     * @param {...Function}\n\t     * @return {Function}\n\t     * @see R.pipeK\n\t     * @example\n\t     *\n\t     *      //  parseJson :: String -> Maybe *\n\t     *      //  get :: String -> Object -> Maybe *\n\t     *\n\t     *      //  getStateCode :: Maybe String -> Maybe String\n\t     *      var getStateCode = R.composeK(\n\t     *        R.compose(Maybe.of, R.toUpper),\n\t     *        get('state'),\n\t     *        get('address'),\n\t     *        get('user'),\n\t     *        parseJson\n\t     *      );\n\t     *\n\t     *      getStateCode(Maybe.of('{\"user\":{\"address\":{\"state\":\"ny\"}}}'));\n\t     *      //=> Just('NY')\n\t     *      getStateCode(Maybe.of('[Invalid JSON]'));\n\t     *      //=> Nothing()\n\t     */\n\t    var composeK = function composeK() {\n\t        return compose.apply(this, prepend(identity, map(chain, arguments)));\n\t    };\n\t\n\t    /**\n\t     * Performs right-to-left composition of one or more Promise-returning\n\t     * functions. The rightmost function may have any arity; the remaining\n\t     * functions must be unary.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @since v0.10.0\n\t     * @category Function\n\t     * @sig ((y -> Promise z), (x -> Promise y), ..., (a -> Promise b)) -> (a -> Promise z)\n\t     * @param {...Function} functions\n\t     * @return {Function}\n\t     * @see R.pipeP\n\t     * @example\n\t     *\n\t     *      //  followersForUser :: String -> Promise [User]\n\t     *      var followersForUser = R.composeP(db.getFollowers, db.getUserById);\n\t     */\n\t    var composeP = function composeP() {\n\t        if (arguments.length === 0) {\n\t            throw new Error('composeP requires at least one argument');\n\t        }\n\t        return pipeP.apply(this, reverse(arguments));\n\t    };\n\t\n\t    /**\n\t     * Wraps a constructor function inside a curried function that can be called\n\t     * with the same arguments and returns the same type.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @since v0.1.0\n\t     * @category Function\n\t     * @sig (* -> {*}) -> (* -> {*})\n\t     * @param {Function} Fn The constructor function to wrap.\n\t     * @return {Function} A wrapped, curried constructor function.\n\t     * @example\n\t     *\n\t     *      // Constructor function\n\t     *      var Widget = config => {\n\t     *        // ...\n\t     *      };\n\t     *      Widget.prototype = {\n\t     *        // ...\n\t     *      };\n\t     *      var allConfigs = [\n\t     *        // ...\n\t     *      ];\n\t     *      R.map(R.construct(Widget), allConfigs); // a list of Widgets\n\t     */\n\t    var construct = _curry1(function construct(Fn) {\n\t        return constructN(Fn.length, Fn);\n\t    });\n\t\n\t    /**\n\t     * Returns `true` if the specified value is equal, in `R.equals` terms, to at\n\t     * least one element of the given list; `false` otherwise.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @since v0.1.0\n\t     * @category List\n\t     * @sig a -> [a] -> Boolean\n\t     * @param {Object} a The item to compare against.\n\t     * @param {Array} list The array to consider.\n\t     * @return {Boolean} `true` if the item is in the list, `false` otherwise.\n\t     * @see R.any\n\t     * @example\n\t     *\n\t     *      R.contains(3, [1, 2, 3]); //=> true\n\t     *      R.contains(4, [1, 2, 3]); //=> false\n\t     *      R.contains([42], [[42]]); //=> true\n\t     */\n\t    var contains = _curry2(_contains);\n\t\n\t    /**\n\t     * Finds the set (i.e. no duplicates) of all elements in the first list not\n\t     * contained in the second list.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @since v0.1.0\n\t     * @category Relation\n\t     * @sig [*] -> [*] -> [*]\n\t     * @param {Array} list1 The first list.\n\t     * @param {Array} list2 The second list.\n\t     * @return {Array} The elements in `list1` that are not in `list2`.\n\t     * @see R.differenceWith\n\t     * @example\n\t     *\n\t     *      R.difference([1,2,3,4], [7,6,5,4,3]); //=> [1,2]\n\t     *      R.difference([7,6,5,4,3], [1,2,3,4]); //=> [7,6,5]\n\t     */\n\t    var difference = _curry2(function difference(first, second) {\n\t        var out = [];\n\t        var idx = 0;\n\t        var firstLen = first.length;\n\t        while (idx < firstLen) {\n\t            if (!_contains(first[idx], second) && !_contains(first[idx], out)) {\n\t                out[out.length] = first[idx];\n\t            }\n\t            idx += 1;\n\t        }\n\t        return out;\n\t    });\n\t\n\t    /**\n\t     * Returns a new list without any consecutively repeating elements. `R.equals`\n\t     * is used to determine equality.\n\t     *\n\t     * Dispatches to the `dropRepeats` method of the first argument, if present.\n\t     *\n\t     * Acts as a transducer if a transformer is given in list position.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @since v0.14.0\n\t     * @category List\n\t     * @sig [a] -> [a]\n\t     * @param {Array} list The array to consider.\n\t     * @return {Array} `list` without repeating elements.\n\t     * @see R.transduce\n\t     * @example\n\t     *\n\t     *     R.dropRepeats([1, 1, 1, 2, 3, 4, 4, 2, 2]); //=> [1, 2, 3, 4, 2]\n\t     */\n\t    var dropRepeats = _curry1(_dispatchable('dropRepeats', _xdropRepeatsWith(equals), dropRepeatsWith(equals)));\n\t\n\t    /**\n\t     * Transforms the items of the list with the transducer and appends the\n\t     * transformed items to the accumulator using an appropriate iterator function\n\t     * based on the accumulator type.\n\t     *\n\t     * The accumulator can be an array, string, object or a transformer. Iterated\n\t     * items will be appended to arrays and concatenated to strings. Objects will\n\t     * be merged directly or 2-item arrays will be merged as key, value pairs.\n\t     *\n\t     * The accumulator can also be a transformer object that provides a 2-arity\n\t     * reducing iterator function, step, 0-arity initial value function, init, and\n\t     * 1-arity result extraction function result. The step function is used as the\n\t     * iterator function in reduce. The result function is used to convert the\n\t     * final accumulator into the return type and in most cases is R.identity. The\n\t     * init function is used to provide the initial accumulator.\n\t     *\n\t     * The iteration is performed with R.reduce after initializing the transducer.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @since v0.12.0\n\t     * @category List\n\t     * @sig a -> (b -> b) -> [c] -> a\n\t     * @param {*} acc The initial accumulator value.\n\t     * @param {Function} xf The transducer function. Receives a transformer and returns a transformer.\n\t     * @param {Array} list The list to iterate over.\n\t     * @return {*} The final, accumulated value.\n\t     * @example\n\t     *\n\t     *      var numbers = [1, 2, 3, 4];\n\t     *      var transducer = R.compose(R.map(R.add(1)), R.take(2));\n\t     *\n\t     *      R.into([], transducer, numbers); //=> [2, 3]\n\t     *\n\t     *      var intoArray = R.into([]);\n\t     *      intoArray(transducer, numbers); //=> [2, 3]\n\t     */\n\t    var into = _curry3(function into(acc, xf, list) {\n\t        return _isTransformer(acc) ? _reduce(xf(acc), acc['@@transducer/init'](), list) : _reduce(xf(_stepCat(acc)), acc, list);\n\t    });\n\t\n\t    /**\n\t     * \"lifts\" a function of arity > 1 so that it may \"map over\" an Array or other\n\t     * object that satisfies the [FantasyLand Apply spec](https://github.com/fantasyland/fantasy-land#apply).\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @since v0.7.0\n\t     * @category Function\n\t     * @sig (*... -> *) -> ([*]... -> [*])\n\t     * @param {Function} fn The function to lift into higher context\n\t     * @return {Function} The lifted function.\n\t     * @see R.liftN\n\t     * @example\n\t     *\n\t     *      var madd3 = R.lift(R.curry((a, b, c) => a + b + c));\n\t     *\n\t     *      madd3([1,2,3], [1,2,3], [1]); //=> [3, 4, 5, 4, 5, 6, 5, 6, 7]\n\t     *\n\t     *      var madd5 = R.lift(R.curry((a, b, c, d, e) => a + b + c + d + e));\n\t     *\n\t     *      madd5([1,2], [3], [4, 5], [6], [7, 8]); //=> [21, 22, 22, 23, 22, 23, 23, 24]\n\t     */\n\t    var lift = _curry1(function lift(fn) {\n\t        return liftN(fn.length, fn);\n\t    });\n\t\n\t    /**\n\t     * Returns a partial copy of an object omitting the keys specified.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @since v0.1.0\n\t     * @category Object\n\t     * @sig [String] -> {String: *} -> {String: *}\n\t     * @param {Array} names an array of String property names to omit from the new object\n\t     * @param {Object} obj The object to copy from\n\t     * @return {Object} A new object with properties from `names` not on it.\n\t     * @see R.pick\n\t     * @example\n\t     *\n\t     *      R.omit(['a', 'd'], {a: 1, b: 2, c: 3, d: 4}); //=> {b: 2, c: 3}\n\t     */\n\t    var omit = _curry2(function omit(names, obj) {\n\t        var result = {};\n\t        for (var prop in obj) {\n\t            if (!_contains(prop, names)) {\n\t                result[prop] = obj[prop];\n\t            }\n\t        }\n\t        return result;\n\t    });\n\t\n\t    /**\n\t     * Returns the left-to-right Kleisli composition of the provided functions,\n\t     * each of which must return a value of a type supported by [`chain`](#chain).\n\t     *\n\t     * `R.pipeK(f, g, h)` is equivalent to `R.pipe(R.chain(f), R.chain(g), R.chain(h))`.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @since v0.16.0\n\t     * @category Function\n\t     * @sig Chain m => ((a -> m b), (b -> m c), ..., (y -> m z)) -> (m a -> m z)\n\t     * @param {...Function}\n\t     * @return {Function}\n\t     * @see R.composeK\n\t     * @example\n\t     *\n\t     *      //  parseJson :: String -> Maybe *\n\t     *      //  get :: String -> Object -> Maybe *\n\t     *\n\t     *      //  getStateCode :: Maybe String -> Maybe String\n\t     *      var getStateCode = R.pipeK(\n\t     *        parseJson,\n\t     *        get('user'),\n\t     *        get('address'),\n\t     *        get('state'),\n\t     *        R.compose(Maybe.of, R.toUpper)\n\t     *      );\n\t     *\n\t     *      getStateCode(Maybe.of('{\"user\":{\"address\":{\"state\":\"ny\"}}}'));\n\t     *      //=> Just('NY')\n\t     *      getStateCode(Maybe.of('[Invalid JSON]'));\n\t     *      //=> Nothing()\n\t     */\n\t    var pipeK = function pipeK() {\n\t        return composeK.apply(this, reverse(arguments));\n\t    };\n\t\n\t    /**\n\t     * Returns the string representation of the given value. `eval`'ing the output\n\t     * should result in a value equivalent to the input value. Many of the built-in\n\t     * `toString` methods do not satisfy this requirement.\n\t     *\n\t     * If the given value is an `[object Object]` with a `toString` method other\n\t     * than `Object.prototype.toString`, this method is invoked with no arguments\n\t     * to produce the return value. This means user-defined constructor functions\n\t     * can provide a suitable `toString` method. For example:\n\t     *\n\t     *     function Point(x, y) {\n\t     *       this.x = x;\n\t     *       this.y = y;\n\t     *     }\n\t     *\n\t     *     Point.prototype.toString = function() {\n\t     *       return 'new Point(' + this.x + ', ' + this.y + ')';\n\t     *     };\n\t     *\n\t     *     R.toString(new Point(1, 2)); //=> 'new Point(1, 2)'\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @since v0.14.0\n\t     * @category String\n\t     * @sig * -> String\n\t     * @param {*} val\n\t     * @return {String}\n\t     * @example\n\t     *\n\t     *      R.toString(42); //=> '42'\n\t     *      R.toString('abc'); //=> '\"abc\"'\n\t     *      R.toString([1, 2, 3]); //=> '[1, 2, 3]'\n\t     *      R.toString({foo: 1, bar: 2, baz: 3}); //=> '{\"bar\": 2, \"baz\": 3, \"foo\": 1}'\n\t     *      R.toString(new Date('2001-02-03T04:05:06Z')); //=> 'new Date(\"2001-02-03T04:05:06.000Z\")'\n\t     */\n\t    var toString = _curry1(function toString(val) {\n\t        return _toString(val, []);\n\t    });\n\t\n\t    /**\n\t     * Returns a new list containing only one copy of each element in the original\n\t     * list, based upon the value returned by applying the supplied function to\n\t     * each list element. Prefers the first item if the supplied function produces\n\t     * the same value on two items. `R.equals` is used for comparison.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @since v0.16.0\n\t     * @category List\n\t     * @sig (a -> b) -> [a] -> [a]\n\t     * @param {Function} fn A function used to produce a value to use during comparisons.\n\t     * @param {Array} list The array to consider.\n\t     * @return {Array} The list of unique items.\n\t     * @example\n\t     *\n\t     *      R.uniqBy(Math.abs, [-1, -5, 2, 10, 1, 2]); //=> [-1, -5, 2, 10]\n\t     */\n\t    /* globals Set */\n\t    // distinguishing between +0 and -0 is not supported by Set\n\t    /* falls through */\n\t    // these types can all utilise Set\n\t    // prevent scan for null by tracking as a boolean\n\t    /* falls through */\n\t    // scan through all previously applied items\n\t    var uniqBy = _curry2(/* globals Set */\n\t    typeof Set === 'undefined' ? function uniqBy(fn, list) {\n\t        var idx = 0;\n\t        var applied = [];\n\t        var result = [];\n\t        var appliedItem, item;\n\t        while (idx < list.length) {\n\t            item = list[idx];\n\t            appliedItem = fn(item);\n\t            if (!_contains(appliedItem, applied)) {\n\t                result.push(item);\n\t                applied.push(appliedItem);\n\t            }\n\t            idx += 1;\n\t        }\n\t        return result;\n\t    } : function uniqBySet(fn, list) {\n\t        var set = new Set();\n\t        var applied = [];\n\t        var prevSetSize = 0;\n\t        var result = [];\n\t        var nullExists = false;\n\t        var negZeroExists = false;\n\t        var idx = 0;\n\t        var appliedItem, item, newSetSize;\n\t        while (idx < list.length) {\n\t            item = list[idx];\n\t            appliedItem = fn(item);\n\t            switch (typeof appliedItem) {\n\t            case 'number':\n\t                // distinguishing between +0 and -0 is not supported by Set\n\t                if (appliedItem === 0 && !negZeroExists && 1 / appliedItem === -Infinity) {\n\t                    negZeroExists = true;\n\t                    result.push(item);\n\t                    break;\n\t                }\n\t            /* falls through */\n\t            case 'string':\n\t            case 'boolean':\n\t            case 'function':\n\t            case 'undefined':\n\t                // these types can all utilise Set\n\t                set.add(appliedItem);\n\t                newSetSize = set.size;\n\t                if (newSetSize > prevSetSize) {\n\t                    result.push(item);\n\t                    prevSetSize = newSetSize;\n\t                }\n\t                break;\n\t            case 'object':\n\t                if (appliedItem === null) {\n\t                    if (!nullExists) {\n\t                        // prevent scan for null by tracking as a boolean\n\t                        nullExists = true;\n\t                        result.push(null);\n\t                    }\n\t                    break;\n\t                }\n\t            /* falls through */\n\t            default:\n\t                // scan through all previously applied items\n\t                if (!_contains(appliedItem, applied)) {\n\t                    applied.push(appliedItem);\n\t                    result.push(item);\n\t                }\n\t            }\n\t            idx += 1;\n\t        }\n\t        return result;\n\t    });\n\t\n\t    /**\n\t     * Returns a new list without values in the first argument.\n\t     * `R.equals` is used to determine equality.\n\t     *\n\t     * Acts as a transducer if a transformer is given in list position.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @since 0.19.1\n\t     * @since 0.19.0\n\t     * @category List\n\t     * @sig [a] -> [a] -> [a]\n\t     * @param {Array} list1 The values to be removed from `list2`.\n\t     * @param {Array} list2 The array to remove values from.\n\t     * @return {Array} The new array without values in `list1`.\n\t     * @see R.transduce\n\t     * @example\n\t     *\n\t     *      R.without([1, 2], [1, 2, 1, 3, 4]); //=> [3, 4]\n\t     */\n\t    var without = _curry2(function (xs, list) {\n\t        return reject(flip(_contains)(xs), list);\n\t    });\n\t\n\t    /**\n\t     * Takes a function `f` and returns a function `g` such that:\n\t     *\n\t     *   - applying `g` to zero or more arguments will give __true__ if applying\n\t     *     the same arguments to `f` gives a logical __false__ value; and\n\t     *\n\t     *   - applying `g` to zero or more arguments will give __false__ if applying\n\t     *     the same arguments to `f` gives a logical __true__ value.\n\t     *\n\t     * `R.complement` will work on all other functors as well.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @since v0.12.0\n\t     * @category Logic\n\t     * @sig (*... -> *) -> (*... -> Boolean)\n\t     * @param {Function} f\n\t     * @return {Function}\n\t     * @see R.not\n\t     * @example\n\t     *\n\t     *      var isEven = n => n % 2 === 0;\n\t     *      var isOdd = R.complement(isEven);\n\t     *      isOdd(21); //=> true\n\t     *      isOdd(42); //=> false\n\t     */\n\t    var complement = lift(not);\n\t\n\t    /**\n\t     * Turns a named method with a specified arity into a function that can be\n\t     * called directly supplied with arguments and a target object.\n\t     *\n\t     * The returned function is curried and accepts `arity + 1` parameters where\n\t     * the final parameter is the target object.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @since v0.1.0\n\t     * @category Function\n\t     * @sig Number -> String -> (a -> b -> ... -> n -> Object -> *)\n\t     * @param {Number} arity Number of arguments the returned function should take\n\t     *        before the target object.\n\t     * @param {String} method Name of the method to call.\n\t     * @return {Function} A new curried function.\n\t     * @example\n\t     *\n\t     *      var sliceFrom = R.invoker(1, 'slice');\n\t     *      sliceFrom(6, 'abcdefghijklm'); //=> 'ghijklm'\n\t     *      var sliceFrom6 = R.invoker(2, 'slice')(6);\n\t     *      sliceFrom6(8, 'abcdefghijklm'); //=> 'gh'\n\t     */\n\t    var invoker = _curry2(function invoker(arity, method) {\n\t        return curryN(arity + 1, function () {\n\t            var target = arguments[arity];\n\t            if (target != null && is(Function, target[method])) {\n\t                return target[method].apply(target, _slice(arguments, 0, arity));\n\t            }\n\t            throw new TypeError(toString(target) + ' does not have a method named \"' + method + '\"');\n\t        });\n\t    });\n\t\n\t    /**\n\t     * Returns a string made by inserting the `separator` between each element and\n\t     * concatenating all the elements into a single string.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @since v0.1.0\n\t     * @category List\n\t     * @sig String -> [a] -> String\n\t     * @param {Number|String} separator The string used to separate the elements.\n\t     * @param {Array} xs The elements to join into a string.\n\t     * @return {String} str The string made by concatenating `xs` with `separator`.\n\t     * @see R.split\n\t     * @example\n\t     *\n\t     *      var spacer = R.join(' ');\n\t     *      spacer(['a', 2, 3.4]);   //=> 'a 2 3.4'\n\t     *      R.join('|', [1, 2, 3]);    //=> '1|2|3'\n\t     */\n\t    var join = invoker(1, 'join');\n\t\n\t    /**\n\t     * Creates a new function that, when invoked, caches the result of calling `fn`\n\t     * for a given argument set and returns the result. Subsequent calls to the\n\t     * memoized `fn` with the same argument set will not result in an additional\n\t     * call to `fn`; instead, the cached result for that set of arguments will be\n\t     * returned.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @since v0.1.0\n\t     * @category Function\n\t     * @sig (*... -> a) -> (*... -> a)\n\t     * @param {Function} fn The function to memoize.\n\t     * @return {Function} Memoized version of `fn`.\n\t     * @example\n\t     *\n\t     *      var count = 0;\n\t     *      var factorial = R.memoize(n => {\n\t     *        count += 1;\n\t     *        return R.product(R.range(1, n + 1));\n\t     *      });\n\t     *      factorial(5); //=> 120\n\t     *      factorial(5); //=> 120\n\t     *      factorial(5); //=> 120\n\t     *      count; //=> 1\n\t     */\n\t    var memoize = _curry1(function memoize(fn) {\n\t        var cache = {};\n\t        return _arity(fn.length, function () {\n\t            var key = toString(arguments);\n\t            if (!_has(key, cache)) {\n\t                cache[key] = fn.apply(this, arguments);\n\t            }\n\t            return cache[key];\n\t        });\n\t    });\n\t\n\t    /**\n\t     * Splits a string into an array of strings based on the given\n\t     * separator.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @since v0.1.0\n\t     * @category String\n\t     * @sig (String | RegExp) -> String -> [String]\n\t     * @param {String|RegExp} sep The pattern.\n\t     * @param {String} str The string to separate into an array.\n\t     * @return {Array} The array of strings from `str` separated by `str`.\n\t     * @see R.join\n\t     * @example\n\t     *\n\t     *      var pathComponents = R.split('/');\n\t     *      R.tail(pathComponents('/usr/local/bin/node')); //=> ['usr', 'local', 'bin', 'node']\n\t     *\n\t     *      R.split('.', 'a.b.c.xyz.d'); //=> ['a', 'b', 'c', 'xyz', 'd']\n\t     */\n\t    var split = invoker(1, 'split');\n\t\n\t    /**\n\t     * Determines whether a given string matches a given regular expression.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @since v0.12.0\n\t     * @category String\n\t     * @sig RegExp -> String -> Boolean\n\t     * @param {RegExp} pattern\n\t     * @param {String} str\n\t     * @return {Boolean}\n\t     * @see R.match\n\t     * @example\n\t     *\n\t     *      R.test(/^x/, 'xyz'); //=> true\n\t     *      R.test(/^y/, 'xyz'); //=> false\n\t     */\n\t    var test = _curry2(function test(pattern, str) {\n\t        if (!_isRegExp(pattern)) {\n\t            throw new TypeError('\\u2018test\\u2019 requires a value of type RegExp as its first argument; received ' + toString(pattern));\n\t        }\n\t        return _cloneRegExp(pattern).test(str);\n\t    });\n\t\n\t    /**\n\t     * The lower case version of a string.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @since v0.9.0\n\t     * @category String\n\t     * @sig String -> String\n\t     * @param {String} str The string to lower case.\n\t     * @return {String} The lower case version of `str`.\n\t     * @see R.toUpper\n\t     * @example\n\t     *\n\t     *      R.toLower('XYZ'); //=> 'xyz'\n\t     */\n\t    var toLower = invoker(0, 'toLowerCase');\n\t\n\t    /**\n\t     * The upper case version of a string.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @since v0.9.0\n\t     * @category String\n\t     * @sig String -> String\n\t     * @param {String} str The string to upper case.\n\t     * @return {String} The upper case version of `str`.\n\t     * @see R.toLower\n\t     * @example\n\t     *\n\t     *      R.toUpper('abc'); //=> 'ABC'\n\t     */\n\t    var toUpper = invoker(0, 'toUpperCase');\n\t\n\t    /**\n\t     * Returns a new list containing only one copy of each element in the original\n\t     * list. `R.equals` is used to determine equality.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @since v0.1.0\n\t     * @category List\n\t     * @sig [a] -> [a]\n\t     * @param {Array} list The array to consider.\n\t     * @return {Array} The list of unique items.\n\t     * @example\n\t     *\n\t     *      R.uniq([1, 1, 2, 1]); //=> [1, 2]\n\t     *      R.uniq([1, '1']);     //=> [1, '1']\n\t     *      R.uniq([[42], [42]]); //=> [[42]]\n\t     */\n\t    var uniq = uniqBy(identity);\n\t\n\t    /**\n\t     * Returns the result of concatenating the given lists or strings.\n\t     *\n\t     * Dispatches to the `concat` method of the second argument, if present.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @since v0.1.0\n\t     * @category List\n\t     * @sig [a] -> [a] -> [a]\n\t     * @sig String -> String -> String\n\t     * @param {Array|String} a\n\t     * @param {Array|String} b\n\t     * @return {Array|String}\n\t     *\n\t     * @example\n\t     *\n\t     *      R.concat([], []); //=> []\n\t     *      R.concat([4, 5, 6], [1, 2, 3]); //=> [4, 5, 6, 1, 2, 3]\n\t     *      R.concat('ABC', 'DEF'); // 'ABCDEF'\n\t     */\n\t    var concat = flip(invoker(1, 'concat'));\n\t\n\t    /**\n\t     * Combines two lists into a set (i.e. no duplicates) composed of those\n\t     * elements common to both lists.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @since v0.1.0\n\t     * @category Relation\n\t     * @sig [*] -> [*] -> [*]\n\t     * @param {Array} list1 The first list.\n\t     * @param {Array} list2 The second list.\n\t     * @return {Array} The list of elements found in both `list1` and `list2`.\n\t     * @see R.intersectionWith\n\t     * @example\n\t     *\n\t     *      R.intersection([1,2,3,4], [7,6,5,4,3]); //=> [4, 3]\n\t     */\n\t    var intersection = _curry2(function intersection(list1, list2) {\n\t        return uniq(_filter(flip(_contains)(list1), list2));\n\t    });\n\t\n\t    /**\n\t     * Finds the set (i.e. no duplicates) of all elements contained in the first or\n\t     * second list, but not both.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @since 0.19.1\n\t     * @since 0.19.0\n\t     * @category Relation\n\t     * @sig [*] -> [*] -> [*]\n\t     * @param {Array} list1 The first list.\n\t     * @param {Array} list2 The second list.\n\t     * @return {Array} The elements in `list1` or `list2`, but not both.\n\t     * @see R.symmetricDifferenceWith\n\t     * @example\n\t     *\n\t     *      R.symmetricDifference([1,2,3,4], [7,6,5,4,3]); //=> [1,2,7,6,5]\n\t     *      R.symmetricDifference([7,6,5,4,3], [1,2,3,4]); //=> [7,6,5,1,2]\n\t     */\n\t    var symmetricDifference = _curry2(function symmetricDifference(list1, list2) {\n\t        return concat(difference(list1, list2), difference(list2, list1));\n\t    });\n\t\n\t    /**\n\t     * Finds the set (i.e. no duplicates) of all elements contained in the first or\n\t     * second list, but not both. Duplication is determined according to the value\n\t     * returned by applying the supplied predicate to two list elements.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @since 0.19.1\n\t     * @since 0.19.0\n\t     * @category Relation\n\t     * @sig (a -> a -> Boolean) -> [a] -> [a] -> [a]\n\t     * @param {Function} pred A predicate used to test whether two items are equal.\n\t     * @param {Array} list1 The first list.\n\t     * @param {Array} list2 The second list.\n\t     * @return {Array} The elements in `list1` or `list2`, but not both.\n\t     * @see R.symmetricDifference\n\t     * @example\n\t     *\n\t     *      var eqA = R.eqBy(R.prop('a'));\n\t     *      var l1 = [{a: 1}, {a: 2}, {a: 3}, {a: 4}];\n\t     *      var l2 = [{a: 3}, {a: 4}, {a: 5}, {a: 6}];\n\t     *      R.symmetricDifferenceWith(eqA, l1, l2); //=> [{a: 1}, {a: 2}, {a: 5}, {a: 6}]\n\t     */\n\t    var symmetricDifferenceWith = _curry3(function symmetricDifferenceWith(pred, list1, list2) {\n\t        return concat(differenceWith(pred, list1, list2), differenceWith(pred, list2, list1));\n\t    });\n\t\n\t    /**\n\t     * Combines two lists into a set (i.e. no duplicates) composed of the elements\n\t     * of each list.\n\t     *\n\t     * @func\n\t     * @memberOf R\n\t     * @since v0.1.0\n\t     * @category Relation\n\t     * @sig [*] -> [*] -> [*]\n\t     * @param {Array} as The first list.\n\t     * @param {Array} bs The second list.\n\t     * @return {Array} The first and second lists concatenated, with\n\t     *         duplicates removed.\n\t     * @example\n\t     *\n\t     *      R.union([1, 2, 3], [2, 3, 4]); //=> [1, 2, 3, 4]\n\t     */\n\t    var union = _curry2(compose(uniq, _concat));\n\t\n\t    var R = {\n\t        F: F,\n\t        T: T,\n\t        __: __,\n\t        add: add,\n\t        addIndex: addIndex,\n\t        adjust: adjust,\n\t        all: all,\n\t        allPass: allPass,\n\t        allUniq: allUniq,\n\t        always: always,\n\t        and: and,\n\t        any: any,\n\t        anyPass: anyPass,\n\t        ap: ap,\n\t        aperture: aperture,\n\t        append: append,\n\t        apply: apply,\n\t        assoc: assoc,\n\t        assocPath: assocPath,\n\t        binary: binary,\n\t        bind: bind,\n\t        both: both,\n\t        call: call,\n\t        chain: chain,\n\t        clone: clone,\n\t        commute: commute,\n\t        commuteMap: commuteMap,\n\t        comparator: comparator,\n\t        complement: complement,\n\t        compose: compose,\n\t        composeK: composeK,\n\t        composeP: composeP,\n\t        concat: concat,\n\t        cond: cond,\n\t        construct: construct,\n\t        constructN: constructN,\n\t        contains: contains,\n\t        converge: converge,\n\t        countBy: countBy,\n\t        curry: curry,\n\t        curryN: curryN,\n\t        dec: dec,\n\t        defaultTo: defaultTo,\n\t        difference: difference,\n\t        differenceWith: differenceWith,\n\t        dissoc: dissoc,\n\t        dissocPath: dissocPath,\n\t        divide: divide,\n\t        drop: drop,\n\t        dropLast: dropLast,\n\t        dropLastWhile: dropLastWhile,\n\t        dropRepeats: dropRepeats,\n\t        dropRepeatsWith: dropRepeatsWith,\n\t        dropWhile: dropWhile,\n\t        either: either,\n\t        empty: empty,\n\t        eqBy: eqBy,\n\t        eqProps: eqProps,\n\t        equals: equals,\n\t        evolve: evolve,\n\t        filter: filter,\n\t        find: find,\n\t        findIndex: findIndex,\n\t        findLast: findLast,\n\t        findLastIndex: findLastIndex,\n\t        flatten: flatten,\n\t        flip: flip,\n\t        forEach: forEach,\n\t        fromPairs: fromPairs,\n\t        groupBy: groupBy,\n\t        gt: gt,\n\t        gte: gte,\n\t        has: has,\n\t        hasIn: hasIn,\n\t        head: head,\n\t        identical: identical,\n\t        identity: identity,\n\t        ifElse: ifElse,\n\t        inc: inc,\n\t        indexBy: indexBy,\n\t        indexOf: indexOf,\n\t        init: init,\n\t        insert: insert,\n\t        insertAll: insertAll,\n\t        intersection: intersection,\n\t        intersectionWith: intersectionWith,\n\t        intersperse: intersperse,\n\t        into: into,\n\t        invert: invert,\n\t        invertObj: invertObj,\n\t        invoker: invoker,\n\t        is: is,\n\t        isArrayLike: isArrayLike,\n\t        isEmpty: isEmpty,\n\t        isNil: isNil,\n\t        join: join,\n\t        juxt: juxt,\n\t        keys: keys,\n\t        keysIn: keysIn,\n\t        last: last,\n\t        lastIndexOf: lastIndexOf,\n\t        length: length,\n\t        lens: lens,\n\t        lensIndex: lensIndex,\n\t        lensPath: lensPath,\n\t        lensProp: lensProp,\n\t        lift: lift,\n\t        liftN: liftN,\n\t        lt: lt,\n\t        lte: lte,\n\t        map: map,\n\t        mapAccum: mapAccum,\n\t        mapAccumRight: mapAccumRight,\n\t        mapObjIndexed: mapObjIndexed,\n\t        match: match,\n\t        mathMod: mathMod,\n\t        max: max,\n\t        maxBy: maxBy,\n\t        mean: mean,\n\t        median: median,\n\t        memoize: memoize,\n\t        merge: merge,\n\t        mergeAll: mergeAll,\n\t        mergeWith: mergeWith,\n\t        mergeWithKey: mergeWithKey,\n\t        min: min,\n\t        minBy: minBy,\n\t        modulo: modulo,\n\t        multiply: multiply,\n\t        nAry: nAry,\n\t        negate: negate,\n\t        none: none,\n\t        not: not,\n\t        nth: nth,\n\t        nthArg: nthArg,\n\t        objOf: objOf,\n\t        of: of,\n\t        omit: omit,\n\t        once: once,\n\t        or: or,\n\t        over: over,\n\t        pair: pair,\n\t        partial: partial,\n\t        partialRight: partialRight,\n\t        partition: partition,\n\t        path: path,\n\t        pathEq: pathEq,\n\t        pathOr: pathOr,\n\t        pathSatisfies: pathSatisfies,\n\t        pick: pick,\n\t        pickAll: pickAll,\n\t        pickBy: pickBy,\n\t        pipe: pipe,\n\t        pipeK: pipeK,\n\t        pipeP: pipeP,\n\t        pluck: pluck,\n\t        prepend: prepend,\n\t        product: product,\n\t        project: project,\n\t        prop: prop,\n\t        propEq: propEq,\n\t        propIs: propIs,\n\t        propOr: propOr,\n\t        propSatisfies: propSatisfies,\n\t        props: props,\n\t        range: range,\n\t        reduce: reduce,\n\t        reduceRight: reduceRight,\n\t        reduced: reduced,\n\t        reject: reject,\n\t        remove: remove,\n\t        repeat: repeat,\n\t        replace: replace,\n\t        reverse: reverse,\n\t        scan: scan,\n\t        sequence: sequence,\n\t        set: set,\n\t        slice: slice,\n\t        sort: sort,\n\t        sortBy: sortBy,\n\t        split: split,\n\t        splitAt: splitAt,\n\t        splitEvery: splitEvery,\n\t        splitWhen: splitWhen,\n\t        subtract: subtract,\n\t        sum: sum,\n\t        symmetricDifference: symmetricDifference,\n\t        symmetricDifferenceWith: symmetricDifferenceWith,\n\t        tail: tail,\n\t        take: take,\n\t        takeLast: takeLast,\n\t        takeLastWhile: takeLastWhile,\n\t        takeWhile: takeWhile,\n\t        tap: tap,\n\t        test: test,\n\t        times: times,\n\t        toLower: toLower,\n\t        toPairs: toPairs,\n\t        toPairsIn: toPairsIn,\n\t        toString: toString,\n\t        toUpper: toUpper,\n\t        transduce: transduce,\n\t        transpose: transpose,\n\t        traverse: traverse,\n\t        trim: trim,\n\t        type: type,\n\t        unapply: unapply,\n\t        unary: unary,\n\t        uncurryN: uncurryN,\n\t        unfold: unfold,\n\t        union: union,\n\t        unionWith: unionWith,\n\t        uniq: uniq,\n\t        uniqBy: uniqBy,\n\t        uniqWith: uniqWith,\n\t        unless: unless,\n\t        unnest: unnest,\n\t        update: update,\n\t        useWith: useWith,\n\t        values: values,\n\t        valuesIn: valuesIn,\n\t        view: view,\n\t        when: when,\n\t        where: where,\n\t        whereEq: whereEq,\n\t        without: without,\n\t        wrap: wrap,\n\t        xprod: xprod,\n\t        zip: zip,\n\t        zipObj: zipObj,\n\t        zipWith: zipWith\n\t    };\n\t  /* eslint-env amd */\n\t\n\t  /* TEST_ENTRY_POINT */\n\t\n\t  if (true) {\n\t    module.exports = R;\n\t  } else if (typeof define === 'function' && define.amd) {\n\t    define(function() { return R; });\n\t  } else {\n\t    this.R = R;\n\t  }\n\t\n\t}.call(this));\n\n\n/***/ },\n/* 9 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t\tvalue: true\n\t});\n\t\n\tvar _classCallCheck2 = __webpack_require__(3);\n\t\n\tvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\t\n\tvar _createClass2 = __webpack_require__(4);\n\t\n\tvar _createClass3 = _interopRequireDefault(_createClass2);\n\t\n\tvar _ramda = __webpack_require__(8);\n\t\n\tvar _ramda2 = _interopRequireDefault(_ramda);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tvar participants = [\"Graphene\", \"Carbon\"];\n\t\n\tvar dialogue = [{\n\t\tname: \"intro_dialog\",\n\t\tarray: [{ //loc: 0\n\t\t\t//say: \"Loerm ipsum\"\n\t\t\twho: \"Карбон\",\n\t\t\tsay: \"Кой си ти?\",\n\t\t\tloc: 1\n\t\t}, { //loc: 1\n\t\t\twho: \"Графен\",\n\t\t\tsay: \"Аз съм материал създаден от един ред въглеродни атоми и имам уникални свойства!\",\n\t\t\tloc: 2\n\t\t}, { //loc: 2\n\t\t\twho: \"Карбон\",\n\t\t\tsay: \"Хаха, за много по-полезен ли се мислиш?\",\n\t\t\tloc: 3\n\t\t}, { //loc: 3\n\t\t\twho: \"Графен\",\n\t\t\tanswer: [{ say: \"Покажи свойствата си.\", loc: 4 }, { say: \"Опитай да решиш всичко с думи.\", loc: 6 /* scene: \"use_words\" */ }, { say: \"Игнорирай го.\", loc: 9 }]\n\t\t}, { //loc: 4\n\t\t\twho: \"Графен\",\n\t\t\tsay: \"Да.\",\n\t\t\tloc: 5\n\t\t}, { //loc: 5\n\t\t\twho: \"Карбон\",\n\t\t\tsay: \"Не мисля, че е възможно да имаш по-добри характеристики от моите.\",\n\t\t\tloc: 13\n\t\t}, { //loc: 6\n\t\t\twho: \"Графен\",\n\t\t\tsay: \"Няма смисъл да спорим.\",\n\t\t\tloc: 7\n\t\n\t\t}, { //loc: 7\n\t\t\twho: \"Карбон\",\n\t\t\tsay: \"Да прав си!\",\n\t\t\tloc: 8\n\t\t}, { //loc: 8\n\t\t\twho: \"Графен\",\n\t\t\tanswer: [{ say: \"Остави го да говори.\", loc: 16 }, { say: \"Все пак му покажи възможностите си.\", loc: 18 }]\n\t\t}, { //loc: 9\n\t\t\twho: \"Карбон\",\n\t\t\tsay: \"Защо ме игнорираш, да не ме имаш за много по-слаб?\",\n\t\t\tloc: 10\n\t\t}, { //loc: 10\n\t\t\twho: \"Карбон\",\n\t\t\tsay: \"Сигурно те е страх, че не можеш да покажеш нищо кой знае какво!?\",\n\t\t\tloc: 11\n\t\t}, { //loc: 11\n\t\t\twho: \"Графен\",\n\t\t\tsay: \"Не искам да навлизам в излишни конфликти.\",\n\t\t\tloc: 12\n\t\t}, { //loc: 12\n\t\t\twho: \"Карбон\",\n\t\t\tsay: \"Така ли? Покажи ми какво можеш тогава.\",\n\t\t\tloc: 13 //\"conductivity\"\n\t\t}, { //loc: 13\n\t\t\twho: \"Графен\",\n\t\t\tsay: \"С моята невероятната здравина от 1100 GPa, ще спра метеорита летящ към земята.\", //\"Сега не е времето за това!! Виж метеорит е на път да се разбие в земята, трябва да го спрем!!!\",\n\t\t\tloc: 14\n\t\t}, { //loc: 14\n\t\t\twho: \"Карбон\",\n\t\t\tsay: \"Не ми трябваш, аз мога да се справя сам.\",\n\t\t\tscene: \"mech_force\"\n\t\t}, { //loc: 15\n\t\t\twho: \"Графен\",\n\t\t\tsay: \"...\",\n\t\t\tscene: \"mech_force\"\n\t\t}, { //loc: 16\n\t\t\twho: \"Карбон\",\n\t\t\tsay: \"Почуствах се застрашен. Не искам да повярвам, че има по-полезна вариация на въглерода от мен.\",\n\t\t\tloc: 17\n\t\t}, { //loc: 17\n\t\t\twho: \"Карбон\",\n\t\t\tsay: \"Аз съм здрав, лек и всичко което някой би искал.\",\n\t\t\tloc: 18\n\t\t}, { //loc: 18\n\t\t\twho: \"Графен\",\n\t\t\tsay: \"Ами да, но е факт, че аз съм по-електропроводим, здрав и с по-голяма енергийна плътност\",\n\t\t\tloc: 19\n\t\t}, { //loc: 19\n\t\t\twho: \"Карбон\",\n\t\t\tsay: \"Разбира се!\",\n\t\t\tloc: 20\n\t\t}, { //loc: 20\n\t\t\twho: \"Графен\",\n\t\t\tsay: \"Например благодарение на моята електропроводимост от\\n 1738 siemens/m мога да заредя телефон за секунди!\",\n\t\t\tscene: \"conductivity_good\"\n\t\t}, { //loc: 21\n\t\t\twho: \"Графен\",\n\t\t\tsay: \"С моята невероятната здравина от 1100 GPa ще спра метеорита летящ към земята!\",\n\t\t\tloc: 13\n\t\t}]\n\t}, {\n\t\tname: \"asteroid_dialog\",\n\t\tarray: [{ //loc: 0\n\t\t\twho: \"Карбон\",\n\t\t\tsay: \"Просто изкара късмет, че нямах време да направя стената по-голяма.\",\n\t\t\tloc: 1\n\t\t}, {\n\t\t\twho: \"Графен\",\n\t\t\tsay: \"Дали? Или просто аз съм по-здравия?\",\n\t\t\tloc: 2\n\t\t}, { //loc: 2\n\t\t\twho: \"Карбон\",\n\t\t\tsay: \"Да видим другите ти свойства тогава.\",\n\t\t\tloc: 3\n\t\t}, { //loc: 3\n\t\t\twho: \"Графен\",\n\t\t\tsay: \"Както пожелаеш.\",\n\t\t\tscene: \"compete_hard\"\n\t\t}]\n\t}, {\n\t\tname: \"compete_hard_dialog\",\n\t\tarray: [{ //loc: 0\n\t\t\twho: \"Карбон\",\n\t\t\tsay: \"Чакам. \",\n\t\t\tloc: 1\n\t\t}, { //loc: 1\n\t\t\twho: \"Графен\",\n\t\t\tanswer: [{ say: \"Покажи - електропроводимост\\n от 1738 siemens/m.\", loc: 2 }, { say: \"Покажи - енергийна плътност\\n от 75 F/g и 31·9 Wh/kg.\", loc: 3 }]\n\t\t}, { //loc: 2\n\t\t\twho: \"Графен\",\n\t\t\tsay: \"Ето виж!\",\n\t\t\tscene: \"conductivity\"\n\t\t}, { //loc: 3\n\t\t\twho: \"Графен\",\n\t\t\tsay: \"A знаеше ли, че бaтерия и акумулатор, направена с моята помощ,\\n издържа в пъти повече от нормална батерия?\",\n\t\t\tscene: \"electrical_density\"\n\t\t}]\n\t}, {\n\t\tname: \"good_dialog\",\n\t\tarray: [{ //loc: 0\n\t\t\twho: \"Графен\",\n\t\t\tsay: \"A също така, бaтерия и акумулатор, направена с моята помощ,\\n издържа в пъти повече от нормална батерия.\",\n\t\t\tscene: \"electrical_density_good\"\n\t\t}]\n\t}, {\n\t\tname: \"ed_c_dialog\",\n\t\tarray: [{ //loc: 0\n\t\t\twho: \"Графен\",\n\t\t\tsay: \"А виж какво мога, благодарение на моята електропроводимост от 1738 siemens/m.\",\n\t\t\tscene: \"conductivity_2\"\n\t\t}]\n\t}, {\n\t\tname: \"c_c_dialog\",\n\t\tarray: [{ //loc: 0\n\t\t\twho: \"Графен\",\n\t\t\tsay: \"А виж какво мога, благодарение на моята енергийна плътност от 75 F/g и 31·9 Wh/kg.\\n Заради нея, могат да се направят много по издържливи батерии и акумулатори.\",\n\t\t\tscene: \"electrical_density_2\"\n\t\t}]\n\t}, {\n\t\tname: \"ending_dialog_1\",\n\t\tarray: [{\n\t\t\twho: \"Карбон\",\n\t\t\tsay: \"Добре признавам, че си по-полезен в повечето ситуации!\",\n\t\t\tscene: \"end_true\"\n\t\t}]\n\t}, {\n\t\tname: \"ending_dialog_2\",\n\t\tarray: [{\n\t\t\twho: \"Карбон\",\n\t\t\tsay: \"Разбирам и признавам, че си по-полезен!\",\n\t\t\tscene: \"end_true\"\n\t\t}]\n\t}];\n\t\n\twindow.d = dialogue;\n\t\n\tvar Dialogue = function () {\n\t\tfunction Dialogue() {\n\t\t\t(0, _classCallCheck3.default)(this, Dialogue);\n\t\n\t\t\tthis.dialogue = dialogue;\n\t\t}\n\t\n\t\t(0, _createClass3.default)(Dialogue, [{\n\t\t\tkey: \"select\",\n\t\t\tvalue: function select(name) {\n\t\t\t\tthis.currentDialogue = _ramda2.default.find(_ramda2.default.propEq(\"name\", name))(this.dialogue);\n\t\t\t\tthis.currentPhrase = this.currentDialogue.array[0];\n\t\t\t}\n\t\t}, {\n\t\t\tkey: \"phrase\",\n\t\t\tvalue: function phrase(loc) {\n\t\t\t\treturn this.currentDialogue.array[loc];\n\t\t\t}\n\t\t}, {\n\t\t\tkey: \"choices\",\n\t\t\tvalue: function choices() {\n\t\t\t\treturn this.currentPhrase.answer.map(function (o) {\n\t\t\t\t\treturn o.say;\n\t\t\t\t});\n\t\t\t}\n\t\t}, {\n\t\t\tkey: \"hasChoices\",\n\t\t\tvalue: function hasChoices() {\n\t\t\t\tif (this.currentPhrase) {\n\t\t\t\t\treturn this.currentPhrase.answer != null;\n\t\t\t\t}\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}, {\n\t\t\tkey: \"say\",\n\t\t\tvalue: function say() {\n\t\t\t\treturn this.currentPhrase;\n\t\t\t}\n\t\t}, {\n\t\t\tkey: \"hasNext\",\n\t\t\tvalue: function hasNext() {\n\t\t\t\treturn this.loc < this.currentDialogue.array.length() - 1;\n\t\t\t}\n\t\t}, {\n\t\t\tkey: \"next\",\n\t\t\tvalue: function next(choice) {\n\t\t\t\tif (this.currentPhrase.answer) {\n\t\t\t\t\tif (arguments.length > 0) {\n\t\t\t\t\t\tif (choice <= this.currentPhrase.answer.length) {\n\t\t\t\t\t\t\tif (this.currentPhrase.answer[choice].scene) {\n\t\t\t\t\t\t\t\treturn this.currentPhrase.answer[choice].scene;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tthis.loc = this.currentPhrase.answer[choice].loc;\n\t\t\t\t\t\t\tthis.currentPhrase = this.phrase(this.currentPhrase.answer[choice].loc);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tthrow \"This answer does not exists\";\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthrow \"This transition to the next phrase requires an argument\";\n\t\t\t\t\t}\n\t\t\t\t} else if (this.currentPhrase.loc) {\n\t\t\t\t\tthis.loc = this.currentPhrase.loc;\n\t\t\t\t\tthis.currentPhrase = this.phrase(this.currentPhrase.loc);\n\t\t\t\t} else if (this.currentPhrase.scene) {\n\t\t\t\t\treturn this.currentPhrase.scene;\n\t\t\t\t}\n\t\n\t\t\t\tconsole.log(this.loc);\n\t\t\t}\n\t\t}]);\n\t\treturn Dialogue;\n\t}();\n\n\texports.default = Dialogue;\n\n/***/ },\n/* 10 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/*! Kefir.js v3.2.1\n\t *  https://github.com/rpominov/kefir\n\t */\n\t\n\t(function (global, factory) {\n\t   true ? factory(exports) :\n\t  typeof define === 'function' && define.amd ? define(['exports'], factory) :\n\t  (factory((global.Kefir = global.Kefir || {})));\n\t}(this, function (exports) { 'use strict';\n\t\n\t  function createObj(proto) {\n\t    var F = function () {};\n\t    F.prototype = proto;\n\t    return new F();\n\t  }\n\t\n\t  function extend(target /*, mixin1, mixin2...*/) {\n\t    var length = arguments.length,\n\t        i = undefined,\n\t        prop = undefined;\n\t    for (i = 1; i < length; i++) {\n\t      for (prop in arguments[i]) {\n\t        target[prop] = arguments[i][prop];\n\t      }\n\t    }\n\t    return target;\n\t  }\n\t\n\t  function inherit(Child, Parent /*, mixin1, mixin2...*/) {\n\t    var length = arguments.length,\n\t        i = undefined;\n\t    Child.prototype = createObj(Parent.prototype);\n\t    Child.prototype.constructor = Child;\n\t    for (i = 2; i < length; i++) {\n\t      extend(Child.prototype, arguments[i]);\n\t    }\n\t    return Child;\n\t  }\n\t\n\t  var NOTHING = ['<nothing>'];\n\t  var END = 'end';\n\t  var VALUE = 'value';\n\t  var ERROR = 'error';\n\t  var ANY = 'any';\n\t\n\t  function concat(a, b) {\n\t    var result = undefined,\n\t        length = undefined,\n\t        i = undefined,\n\t        j = undefined;\n\t    if (a.length === 0) {\n\t      return b;\n\t    }\n\t    if (b.length === 0) {\n\t      return a;\n\t    }\n\t    j = 0;\n\t    result = new Array(a.length + b.length);\n\t    length = a.length;\n\t    for (i = 0; i < length; i++, j++) {\n\t      result[j] = a[i];\n\t    }\n\t    length = b.length;\n\t    for (i = 0; i < length; i++, j++) {\n\t      result[j] = b[i];\n\t    }\n\t    return result;\n\t  }\n\t\n\t  function find(arr, value) {\n\t    var length = arr.length,\n\t        i = undefined;\n\t    for (i = 0; i < length; i++) {\n\t      if (arr[i] === value) {\n\t        return i;\n\t      }\n\t    }\n\t    return -1;\n\t  }\n\t\n\t  function findByPred(arr, pred) {\n\t    var length = arr.length,\n\t        i = undefined;\n\t    for (i = 0; i < length; i++) {\n\t      if (pred(arr[i])) {\n\t        return i;\n\t      }\n\t    }\n\t    return -1;\n\t  }\n\t\n\t  function cloneArray(input) {\n\t    var length = input.length,\n\t        result = new Array(length),\n\t        i = undefined;\n\t    for (i = 0; i < length; i++) {\n\t      result[i] = input[i];\n\t    }\n\t    return result;\n\t  }\n\t\n\t  function remove(input, index) {\n\t    var length = input.length,\n\t        result = undefined,\n\t        i = undefined,\n\t        j = undefined;\n\t    if (index >= 0 && index < length) {\n\t      if (length === 1) {\n\t        return [];\n\t      } else {\n\t        result = new Array(length - 1);\n\t        for (i = 0, j = 0; i < length; i++) {\n\t          if (i !== index) {\n\t            result[j] = input[i];\n\t            j++;\n\t          }\n\t        }\n\t        return result;\n\t      }\n\t    } else {\n\t      return input;\n\t    }\n\t  }\n\t\n\t  function map(input, fn) {\n\t    var length = input.length,\n\t        result = new Array(length),\n\t        i = undefined;\n\t    for (i = 0; i < length; i++) {\n\t      result[i] = fn(input[i]);\n\t    }\n\t    return result;\n\t  }\n\t\n\t  function forEach(arr, fn) {\n\t    var length = arr.length,\n\t        i = undefined;\n\t    for (i = 0; i < length; i++) {\n\t      fn(arr[i]);\n\t    }\n\t  }\n\t\n\t  function fillArray(arr, value) {\n\t    var length = arr.length,\n\t        i = undefined;\n\t    for (i = 0; i < length; i++) {\n\t      arr[i] = value;\n\t    }\n\t  }\n\t\n\t  function contains(arr, value) {\n\t    return find(arr, value) !== -1;\n\t  }\n\t\n\t  function slide(cur, next, max) {\n\t    var length = Math.min(max, cur.length + 1),\n\t        offset = cur.length - length + 1,\n\t        result = new Array(length),\n\t        i = undefined;\n\t    for (i = offset; i < length; i++) {\n\t      result[i - offset] = cur[i];\n\t    }\n\t    result[length - 1] = next;\n\t    return result;\n\t  }\n\t\n\t  function callSubscriber(type, fn, event) {\n\t    if (type === ANY) {\n\t      fn(event);\n\t    } else if (type === event.type) {\n\t      if (type === VALUE || type === ERROR) {\n\t        fn(event.value);\n\t      } else {\n\t        fn();\n\t      }\n\t    }\n\t  }\n\t\n\t  function Dispatcher() {\n\t    this._items = [];\n\t    this._inLoop = 0;\n\t    this._removedItems = null;\n\t  }\n\t\n\t  extend(Dispatcher.prototype, {\n\t    add: function (type, fn) {\n\t      this._items = concat(this._items, [{ type: type, fn: fn }]);\n\t      return this._items.length;\n\t    },\n\t    remove: function (type, fn) {\n\t      var index = findByPred(this._items, function (x) {\n\t        return x.type === type && x.fn === fn;\n\t      });\n\t\n\t      // if we're currently in a notification loop,\n\t      // remember this subscriber was removed\n\t      if (this._inLoop !== 0 && index !== -1) {\n\t        if (this._removedItems === null) {\n\t          this._removedItems = [];\n\t        }\n\t        this._removedItems.push(this._items[index]);\n\t      }\n\t\n\t      this._items = remove(this._items, index);\n\t      return this._items.length;\n\t    },\n\t    dispatch: function (event) {\n\t      this._inLoop++;\n\t      for (var i = 0, items = this._items; i < items.length; i++) {\n\t\n\t        // cleanup was called\n\t        if (this._items === null) {\n\t          break;\n\t        }\n\t\n\t        // this subscriber was removed\n\t        if (this._removedItems !== null && contains(this._removedItems, items[i])) {\n\t          continue;\n\t        }\n\t\n\t        callSubscriber(items[i].type, items[i].fn, event);\n\t      }\n\t      this._inLoop--;\n\t      if (this._inLoop === 0) {\n\t        this._removedItems = null;\n\t      }\n\t    },\n\t    cleanup: function () {\n\t      this._items = null;\n\t    }\n\t  });\n\t\n\t  function Observable() {\n\t    this._dispatcher = new Dispatcher();\n\t    this._active = false;\n\t    this._alive = true;\n\t    this._activating = false;\n\t    this._logHandlers = null;\n\t  }\n\t\n\t  extend(Observable.prototype, {\n\t\n\t    _name: 'observable',\n\t\n\t    _onActivation: function () {},\n\t    _onDeactivation: function () {},\n\t    _setActive: function (active) {\n\t      if (this._active !== active) {\n\t        this._active = active;\n\t        if (active) {\n\t          this._activating = true;\n\t          this._onActivation();\n\t          this._activating = false;\n\t        } else {\n\t          this._onDeactivation();\n\t        }\n\t      }\n\t    },\n\t    _clear: function () {\n\t      this._setActive(false);\n\t      this._dispatcher.cleanup();\n\t      this._dispatcher = null;\n\t      this._logHandlers = null;\n\t    },\n\t    _emit: function (type, x) {\n\t      switch (type) {\n\t        case VALUE:\n\t          return this._emitValue(x);\n\t        case ERROR:\n\t          return this._emitError(x);\n\t        case END:\n\t          return this._emitEnd();\n\t      }\n\t    },\n\t    _emitValue: function (value) {\n\t      if (this._alive) {\n\t        this._dispatcher.dispatch({ type: VALUE, value: value });\n\t      }\n\t    },\n\t    _emitError: function (value) {\n\t      if (this._alive) {\n\t        this._dispatcher.dispatch({ type: ERROR, value: value });\n\t      }\n\t    },\n\t    _emitEnd: function () {\n\t      if (this._alive) {\n\t        this._alive = false;\n\t        this._dispatcher.dispatch({ type: END });\n\t        this._clear();\n\t      }\n\t    },\n\t    _on: function (type, fn) {\n\t      if (this._alive) {\n\t        this._dispatcher.add(type, fn);\n\t        this._setActive(true);\n\t      } else {\n\t        callSubscriber(type, fn, { type: END });\n\t      }\n\t      return this;\n\t    },\n\t    _off: function (type, fn) {\n\t      if (this._alive) {\n\t        var count = this._dispatcher.remove(type, fn);\n\t        if (count === 0) {\n\t          this._setActive(false);\n\t        }\n\t      }\n\t      return this;\n\t    },\n\t    onValue: function (fn) {\n\t      return this._on(VALUE, fn);\n\t    },\n\t    onError: function (fn) {\n\t      return this._on(ERROR, fn);\n\t    },\n\t    onEnd: function (fn) {\n\t      return this._on(END, fn);\n\t    },\n\t    onAny: function (fn) {\n\t      return this._on(ANY, fn);\n\t    },\n\t    offValue: function (fn) {\n\t      return this._off(VALUE, fn);\n\t    },\n\t    offError: function (fn) {\n\t      return this._off(ERROR, fn);\n\t    },\n\t    offEnd: function (fn) {\n\t      return this._off(END, fn);\n\t    },\n\t    offAny: function (fn) {\n\t      return this._off(ANY, fn);\n\t    },\n\t\n\t\n\t    // A and B must be subclasses of Stream and Property (order doesn't matter)\n\t    _ofSameType: function (A, B) {\n\t      return A.prototype.getType() === this.getType() ? A : B;\n\t    },\n\t    setName: function (sourceObs /* optional */, selfName) {\n\t      this._name = selfName ? sourceObs._name + '.' + selfName : sourceObs;\n\t      return this;\n\t    },\n\t    log: function () {\n\t      var name = arguments.length <= 0 || arguments[0] === undefined ? this.toString() : arguments[0];\n\t\n\t\n\t      var isCurrent = undefined;\n\t      var handler = function (event) {\n\t        var type = '<' + event.type + (isCurrent ? ':current' : '') + '>';\n\t        if (event.type === END) {\n\t          console.log(name, type);\n\t        } else {\n\t          console.log(name, type, event.value);\n\t        }\n\t      };\n\t\n\t      if (this._alive) {\n\t        if (!this._logHandlers) {\n\t          this._logHandlers = [];\n\t        }\n\t        this._logHandlers.push({ name: name, handler: handler });\n\t      }\n\t\n\t      isCurrent = true;\n\t      this.onAny(handler);\n\t      isCurrent = false;\n\t\n\t      return this;\n\t    },\n\t    offLog: function () {\n\t      var name = arguments.length <= 0 || arguments[0] === undefined ? this.toString() : arguments[0];\n\t\n\t\n\t      if (this._logHandlers) {\n\t        var handlerIndex = findByPred(this._logHandlers, function (obj) {\n\t          return obj.name === name;\n\t        });\n\t        if (handlerIndex !== -1) {\n\t          this.offAny(this._logHandlers[handlerIndex].handler);\n\t          this._logHandlers.splice(handlerIndex, 1);\n\t        }\n\t      }\n\t\n\t      return this;\n\t    }\n\t  });\n\t\n\t  // extend() can't handle `toString` in IE8\n\t  Observable.prototype.toString = function () {\n\t    return '[' + this._name + ']';\n\t  };\n\t\n\t  function Stream() {\n\t    Observable.call(this);\n\t  }\n\t\n\t  inherit(Stream, Observable, {\n\t\n\t    _name: 'stream',\n\t\n\t    getType: function () {\n\t      return 'stream';\n\t    }\n\t  });\n\t\n\t  function Property() {\n\t    Observable.call(this);\n\t    this._currentEvent = null;\n\t  }\n\t\n\t  inherit(Property, Observable, {\n\t\n\t    _name: 'property',\n\t\n\t    _emitValue: function (value) {\n\t      if (this._alive) {\n\t        this._currentEvent = { type: VALUE, value: value };\n\t        if (!this._activating) {\n\t          this._dispatcher.dispatch({ type: VALUE, value: value });\n\t        }\n\t      }\n\t    },\n\t    _emitError: function (value) {\n\t      if (this._alive) {\n\t        this._currentEvent = { type: ERROR, value: value };\n\t        if (!this._activating) {\n\t          this._dispatcher.dispatch({ type: ERROR, value: value });\n\t        }\n\t      }\n\t    },\n\t    _emitEnd: function () {\n\t      if (this._alive) {\n\t        this._alive = false;\n\t        if (!this._activating) {\n\t          this._dispatcher.dispatch({ type: END });\n\t        }\n\t        this._clear();\n\t      }\n\t    },\n\t    _on: function (type, fn) {\n\t      if (this._alive) {\n\t        this._dispatcher.add(type, fn);\n\t        this._setActive(true);\n\t      }\n\t      if (this._currentEvent !== null) {\n\t        callSubscriber(type, fn, this._currentEvent);\n\t      }\n\t      if (!this._alive) {\n\t        callSubscriber(type, fn, { type: END });\n\t      }\n\t      return this;\n\t    },\n\t    getType: function () {\n\t      return 'property';\n\t    }\n\t  });\n\t\n\t  var neverS = new Stream();\n\t  neverS._emitEnd();\n\t  neverS._name = 'never';\n\t\n\t  function never() {\n\t    return neverS;\n\t  }\n\t\n\t  function timeBased(mixin) {\n\t\n\t    function AnonymousStream(wait, options) {\n\t      var _this = this;\n\t\n\t      Stream.call(this);\n\t      this._wait = wait;\n\t      this._intervalId = null;\n\t      this._$onTick = function () {\n\t        return _this._onTick();\n\t      };\n\t      this._init(options);\n\t    }\n\t\n\t    inherit(AnonymousStream, Stream, {\n\t      _init: function () {},\n\t      _free: function () {},\n\t      _onTick: function () {},\n\t      _onActivation: function () {\n\t        this._intervalId = setInterval(this._$onTick, this._wait);\n\t      },\n\t      _onDeactivation: function () {\n\t        if (this._intervalId !== null) {\n\t          clearInterval(this._intervalId);\n\t          this._intervalId = null;\n\t        }\n\t      },\n\t      _clear: function () {\n\t        Stream.prototype._clear.call(this);\n\t        this._$onTick = null;\n\t        this._free();\n\t      }\n\t    }, mixin);\n\t\n\t    return AnonymousStream;\n\t  }\n\t\n\t  var S = timeBased({\n\t\n\t    _name: 'later',\n\t\n\t    _init: function (_ref) {\n\t      var x = _ref.x;\n\t\n\t      this._x = x;\n\t    },\n\t    _free: function () {\n\t      this._x = null;\n\t    },\n\t    _onTick: function () {\n\t      this._emitValue(this._x);\n\t      this._emitEnd();\n\t    }\n\t  });\n\t\n\t  function later(wait, x) {\n\t    return new S(wait, { x: x });\n\t  }\n\t\n\t  var S$1 = timeBased({\n\t\n\t    _name: 'interval',\n\t\n\t    _init: function (_ref) {\n\t      var x = _ref.x;\n\t\n\t      this._x = x;\n\t    },\n\t    _free: function () {\n\t      this._x = null;\n\t    },\n\t    _onTick: function () {\n\t      this._emitValue(this._x);\n\t    }\n\t  });\n\t\n\t  function interval(wait, x) {\n\t    return new S$1(wait, { x: x });\n\t  }\n\t\n\t  var S$2 = timeBased({\n\t\n\t    _name: 'sequentially',\n\t\n\t    _init: function (_ref) {\n\t      var xs = _ref.xs;\n\t\n\t      this._xs = cloneArray(xs);\n\t    },\n\t    _free: function () {\n\t      this._xs = null;\n\t    },\n\t    _onTick: function () {\n\t      if (this._xs.length === 1) {\n\t        this._emitValue(this._xs[0]);\n\t        this._emitEnd();\n\t      } else {\n\t        this._emitValue(this._xs.shift());\n\t      }\n\t    }\n\t  });\n\t\n\t  function sequentially(wait, xs) {\n\t    return xs.length === 0 ? never() : new S$2(wait, { xs: xs });\n\t  }\n\t\n\t  var S$3 = timeBased({\n\t\n\t    _name: 'fromPoll',\n\t\n\t    _init: function (_ref) {\n\t      var fn = _ref.fn;\n\t\n\t      this._fn = fn;\n\t    },\n\t    _free: function () {\n\t      this._fn = null;\n\t    },\n\t    _onTick: function () {\n\t      var fn = this._fn;\n\t      this._emitValue(fn());\n\t    }\n\t  });\n\t\n\t  function fromPoll(wait, fn) {\n\t    return new S$3(wait, { fn: fn });\n\t  }\n\t\n\t  function emitter(obs) {\n\t\n\t    function value(x) {\n\t      obs._emitValue(x);\n\t      return obs._active;\n\t    }\n\t\n\t    function error(x) {\n\t      obs._emitError(x);\n\t      return obs._active;\n\t    }\n\t\n\t    function end() {\n\t      obs._emitEnd();\n\t      return obs._active;\n\t    }\n\t\n\t    function event(e) {\n\t      obs._emit(e.type, e.value);\n\t      return obs._active;\n\t    }\n\t\n\t    return { value: value, error: error, end: end, event: event, emit: value, emitEvent: event };\n\t  }\n\t\n\t  var S$4 = timeBased({\n\t\n\t    _name: 'withInterval',\n\t\n\t    _init: function (_ref) {\n\t      var fn = _ref.fn;\n\t\n\t      this._fn = fn;\n\t      this._emitter = emitter(this);\n\t    },\n\t    _free: function () {\n\t      this._fn = null;\n\t      this._emitter = null;\n\t    },\n\t    _onTick: function () {\n\t      var fn = this._fn;\n\t      fn(this._emitter);\n\t    }\n\t  });\n\t\n\t  function withInterval(wait, fn) {\n\t    return new S$4(wait, { fn: fn });\n\t  }\n\t\n\t  function S$5(fn) {\n\t    Stream.call(this);\n\t    this._fn = fn;\n\t    this._unsubscribe = null;\n\t  }\n\t\n\t  inherit(S$5, Stream, {\n\t\n\t    _name: 'stream',\n\t\n\t    _onActivation: function () {\n\t      var fn = this._fn;\n\t      var unsubscribe = fn(emitter(this));\n\t      this._unsubscribe = typeof unsubscribe === 'function' ? unsubscribe : null;\n\t\n\t      // fix https://github.com/rpominov/kefir/issues/35\n\t      if (!this._active) {\n\t        this._callUnsubscribe();\n\t      }\n\t    },\n\t    _callUnsubscribe: function () {\n\t      if (this._unsubscribe !== null) {\n\t        this._unsubscribe();\n\t        this._unsubscribe = null;\n\t      }\n\t    },\n\t    _onDeactivation: function () {\n\t      this._callUnsubscribe();\n\t    },\n\t    _clear: function () {\n\t      Stream.prototype._clear.call(this);\n\t      this._fn = null;\n\t    }\n\t  });\n\t\n\t  function stream(fn) {\n\t    return new S$5(fn);\n\t  }\n\t\n\t  function fromCallback(callbackConsumer) {\n\t\n\t    var called = false;\n\t\n\t    return stream(function (emitter) {\n\t\n\t      if (!called) {\n\t        callbackConsumer(function (x) {\n\t          emitter.emit(x);\n\t          emitter.end();\n\t        });\n\t        called = true;\n\t      }\n\t    }).setName('fromCallback');\n\t  }\n\t\n\t  function fromNodeCallback(callbackConsumer) {\n\t\n\t    var called = false;\n\t\n\t    return stream(function (emitter) {\n\t\n\t      if (!called) {\n\t        callbackConsumer(function (error, x) {\n\t          if (error) {\n\t            emitter.error(error);\n\t          } else {\n\t            emitter.emit(x);\n\t          }\n\t          emitter.end();\n\t        });\n\t        called = true;\n\t      }\n\t    }).setName('fromNodeCallback');\n\t  }\n\t\n\t  function spread(fn, length) {\n\t    switch (length) {\n\t      case 0:\n\t        return function () {\n\t          return fn();\n\t        };\n\t      case 1:\n\t        return function (a) {\n\t          return fn(a[0]);\n\t        };\n\t      case 2:\n\t        return function (a) {\n\t          return fn(a[0], a[1]);\n\t        };\n\t      case 3:\n\t        return function (a) {\n\t          return fn(a[0], a[1], a[2]);\n\t        };\n\t      case 4:\n\t        return function (a) {\n\t          return fn(a[0], a[1], a[2], a[3]);\n\t        };\n\t      default:\n\t        return function (a) {\n\t          return fn.apply(null, a);\n\t        };\n\t    }\n\t  }\n\t\n\t  function apply(fn, c, a) {\n\t    var aLength = a ? a.length : 0;\n\t    if (c == null) {\n\t      switch (aLength) {\n\t        case 0:\n\t          return fn();\n\t        case 1:\n\t          return fn(a[0]);\n\t        case 2:\n\t          return fn(a[0], a[1]);\n\t        case 3:\n\t          return fn(a[0], a[1], a[2]);\n\t        case 4:\n\t          return fn(a[0], a[1], a[2], a[3]);\n\t        default:\n\t          return fn.apply(null, a);\n\t      }\n\t    } else {\n\t      switch (aLength) {\n\t        case 0:\n\t          return fn.call(c);\n\t        default:\n\t          return fn.apply(c, a);\n\t      }\n\t    }\n\t  }\n\t\n\t  function fromSubUnsub(sub, unsub, transformer /* Function | falsey */) {\n\t    return stream(function (emitter) {\n\t\n\t      var handler = transformer ? function () {\n\t        emitter.emit(apply(transformer, this, arguments));\n\t      } : function (x) {\n\t        emitter.emit(x);\n\t      };\n\t\n\t      sub(handler);\n\t      return function () {\n\t        return unsub(handler);\n\t      };\n\t    }).setName('fromSubUnsub');\n\t  }\n\t\n\t  var pairs = [['addEventListener', 'removeEventListener'], ['addListener', 'removeListener'], ['on', 'off']];\n\t\n\t  function fromEvents(target, eventName, transformer) {\n\t    var sub = undefined,\n\t        unsub = undefined;\n\t\n\t    for (var i = 0; i < pairs.length; i++) {\n\t      if (typeof target[pairs[i][0]] === 'function' && typeof target[pairs[i][1]] === 'function') {\n\t        sub = pairs[i][0];\n\t        unsub = pairs[i][1];\n\t        break;\n\t      }\n\t    }\n\t\n\t    if (sub === undefined) {\n\t      throw new Error('target don\\'t support any of ' + 'addEventListener/removeEventListener, addListener/removeListener, on/off method pair');\n\t    }\n\t\n\t    return fromSubUnsub(function (handler) {\n\t      return target[sub](eventName, handler);\n\t    }, function (handler) {\n\t      return target[unsub](eventName, handler);\n\t    }, transformer).setName('fromEvents');\n\t  }\n\t\n\t  // HACK:\n\t  //   We don't call parent Class constructor, but instead putting all necessary\n\t  //   properties into prototype to simulate ended Property\n\t  //   (see Propperty and Observable classes).\n\t\n\t  function P(value) {\n\t    this._currentEvent = { type: 'value', value: value, current: true };\n\t  }\n\t\n\t  inherit(P, Property, {\n\t    _name: 'constant',\n\t    _active: false,\n\t    _activating: false,\n\t    _alive: false,\n\t    _dispatcher: null,\n\t    _logHandlers: null\n\t  });\n\t\n\t  function constant(x) {\n\t    return new P(x);\n\t  }\n\t\n\t  // HACK:\n\t  //   We don't call parent Class constructor, but instead putting all necessary\n\t  //   properties into prototype to simulate ended Property\n\t  //   (see Propperty and Observable classes).\n\t\n\t  function P$1(value) {\n\t    this._currentEvent = { type: 'error', value: value, current: true };\n\t  }\n\t\n\t  inherit(P$1, Property, {\n\t    _name: 'constantError',\n\t    _active: false,\n\t    _activating: false,\n\t    _alive: false,\n\t    _dispatcher: null,\n\t    _logHandlers: null\n\t  });\n\t\n\t  function constantError(x) {\n\t    return new P$1(x);\n\t  }\n\t\n\t  function createConstructor(BaseClass, name) {\n\t    return function AnonymousObservable(source, options) {\n\t      var _this = this;\n\t\n\t      BaseClass.call(this);\n\t      this._source = source;\n\t      this._name = source._name + '.' + name;\n\t      this._init(options);\n\t      this._$handleAny = function (event) {\n\t        return _this._handleAny(event);\n\t      };\n\t    };\n\t  }\n\t\n\t  function createClassMethods(BaseClass) {\n\t    return {\n\t      _init: function () {},\n\t      _free: function () {},\n\t      _handleValue: function (x) {\n\t        this._emitValue(x);\n\t      },\n\t      _handleError: function (x) {\n\t        this._emitError(x);\n\t      },\n\t      _handleEnd: function () {\n\t        this._emitEnd();\n\t      },\n\t      _handleAny: function (event) {\n\t        switch (event.type) {\n\t          case VALUE:\n\t            return this._handleValue(event.value);\n\t          case ERROR:\n\t            return this._handleError(event.value);\n\t          case END:\n\t            return this._handleEnd();\n\t        }\n\t      },\n\t      _onActivation: function () {\n\t        this._source.onAny(this._$handleAny);\n\t      },\n\t      _onDeactivation: function () {\n\t        this._source.offAny(this._$handleAny);\n\t      },\n\t      _clear: function () {\n\t        BaseClass.prototype._clear.call(this);\n\t        this._source = null;\n\t        this._$handleAny = null;\n\t        this._free();\n\t      }\n\t    };\n\t  }\n\t\n\t  function createStream(name, mixin) {\n\t    var S = createConstructor(Stream, name);\n\t    inherit(S, Stream, createClassMethods(Stream), mixin);\n\t    return S;\n\t  }\n\t\n\t  function createProperty(name, mixin) {\n\t    var P = createConstructor(Property, name);\n\t    inherit(P, Property, createClassMethods(Property), mixin);\n\t    return P;\n\t  }\n\t\n\t  var P$2 = createProperty('toProperty', {\n\t    _init: function (_ref) {\n\t      var fn = _ref.fn;\n\t\n\t      this._getInitialCurrent = fn;\n\t    },\n\t    _onActivation: function () {\n\t      if (this._getInitialCurrent !== null) {\n\t        var getInitial = this._getInitialCurrent;\n\t        this._emitValue(getInitial());\n\t      }\n\t      this._source.onAny(this._$handleAny); // copied from patterns/one-source\n\t    }\n\t  });\n\t\n\t  function toProperty(obs) {\n\t    var fn = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];\n\t\n\t    if (fn !== null && typeof fn !== 'function') {\n\t      throw new Error('You should call toProperty() with a function or no arguments.');\n\t    }\n\t    return new P$2(obs, { fn: fn });\n\t  }\n\t\n\t  var S$6 = createStream('changes', {\n\t    _handleValue: function (x) {\n\t      if (!this._activating) {\n\t        this._emitValue(x);\n\t      }\n\t    },\n\t    _handleError: function (x) {\n\t      if (!this._activating) {\n\t        this._emitError(x);\n\t      }\n\t    }\n\t  });\n\t\n\t  function changes(obs) {\n\t    return new S$6(obs);\n\t  }\n\t\n\t  function fromPromise(promise) {\n\t\n\t    var called = false;\n\t\n\t    var result = stream(function (emitter) {\n\t      if (!called) {\n\t        var onValue = function (x) {\n\t          emitter.emit(x);\n\t          emitter.end();\n\t        };\n\t        var onError = function (x) {\n\t          emitter.error(x);\n\t          emitter.end();\n\t        };\n\t        var _promise = promise.then(onValue, onError);\n\t\n\t        // prevent libraries like 'Q' or 'when' from swallowing exceptions\n\t        if (_promise && typeof _promise.done === 'function') {\n\t          _promise.done();\n\t        }\n\t\n\t        called = true;\n\t      }\n\t    });\n\t\n\t    return toProperty(result, null).setName('fromPromise');\n\t  }\n\t\n\t  function getGlodalPromise() {\n\t    if (typeof Promise === 'function') {\n\t      return Promise;\n\t    } else {\n\t      throw new Error('There isn\\'t default Promise, use shim or parameter');\n\t    }\n\t  }\n\t\n\t  function toPromise (obs) {\n\t    var Promise = arguments.length <= 1 || arguments[1] === undefined ? getGlodalPromise() : arguments[1];\n\t\n\t    var last = null;\n\t    return new Promise(function (resolve, reject) {\n\t      obs.onAny(function (event) {\n\t        if (event.type === END && last !== null) {\n\t          (last.type === VALUE ? resolve : reject)(last.value);\n\t          last = null;\n\t        } else {\n\t          last = event;\n\t        }\n\t      });\n\t    });\n\t  }\n\t\n\t  function symbol_ (key) {\n\t    if (typeof Symbol !== 'undefined' && Symbol[key]) {\n\t      return Symbol[key];\n\t    } else if (typeof Symbol !== 'undefined' && typeof Symbol.for === 'function') {\n\t      return Symbol.for(key);\n\t    } else {\n\t      return '@@' + key;\n\t    }\n\t  }\n\t\n\t  var symbol = symbol_('observable');\n\t\n\t  function fromESObservable(_observable) {\n\t    var observable = _observable[symbol] ? _observable[symbol]() : _observable;\n\t    return stream(function (emitter) {\n\t      var unsub = observable.subscribe({\n\t        error: function (error) {\n\t          emitter.error(error);\n\t          emitter.end();\n\t        },\n\t        next: function (value) {\n\t          emitter.emit(value);\n\t        },\n\t        complete: function () {\n\t          emitter.end();\n\t        }\n\t      });\n\t\n\t      if (unsub.unsubscribe) {\n\t        return function () {\n\t          unsub.unsubscribe();\n\t        };\n\t      } else {\n\t        return unsub;\n\t      }\n\t    }).setName('fromESObservable');\n\t  }\n\t\n\t  function ESObservable(observable) {\n\t    this._observable = observable.takeErrors(1);\n\t  }\n\t\n\t  extend(ESObservable.prototype, {\n\t    subscribe: function (observer) {\n\t      var _this = this;\n\t\n\t      var fn = function (event) {\n\t        if (event.type === VALUE && observer.next) {\n\t          observer.next(event.value);\n\t        } else if (event.type === ERROR && observer.error) {\n\t          observer.error(event.value);\n\t        } else if (event.type === END && observer.complete) {\n\t          observer.complete(event.value);\n\t        }\n\t      };\n\t\n\t      this._observable.onAny(fn);\n\t      return function () {\n\t        return _this._observable.offAny(fn);\n\t      };\n\t    }\n\t  });\n\t\n\t  function toESObservable() {\n\t    return new ESObservable(this);\n\t  }\n\t\n\t  var mixin = {\n\t    _init: function (_ref) {\n\t      var fn = _ref.fn;\n\t\n\t      this._fn = fn;\n\t    },\n\t    _free: function () {\n\t      this._fn = null;\n\t    },\n\t    _handleValue: function (x) {\n\t      var fn = this._fn;\n\t      this._emitValue(fn(x));\n\t    }\n\t  };\n\t\n\t  var S$7 = createStream('map', mixin);\n\t  var P$3 = createProperty('map', mixin);\n\t\n\t  var id = function (x) {\n\t    return x;\n\t  };\n\t\n\t  function map$1(obs) {\n\t    var fn = arguments.length <= 1 || arguments[1] === undefined ? id : arguments[1];\n\t\n\t    return new (obs._ofSameType(S$7, P$3))(obs, { fn: fn });\n\t  }\n\t\n\t  var mixin$1 = {\n\t    _init: function (_ref) {\n\t      var fn = _ref.fn;\n\t\n\t      this._fn = fn;\n\t    },\n\t    _free: function () {\n\t      this._fn = null;\n\t    },\n\t    _handleValue: function (x) {\n\t      var fn = this._fn;\n\t      if (fn(x)) {\n\t        this._emitValue(x);\n\t      }\n\t    }\n\t  };\n\t\n\t  var S$8 = createStream('filter', mixin$1);\n\t  var P$4 = createProperty('filter', mixin$1);\n\t\n\t  var id$1 = function (x) {\n\t    return x;\n\t  };\n\t\n\t  function filter(obs) {\n\t    var fn = arguments.length <= 1 || arguments[1] === undefined ? id$1 : arguments[1];\n\t\n\t    return new (obs._ofSameType(S$8, P$4))(obs, { fn: fn });\n\t  }\n\t\n\t  var mixin$2 = {\n\t    _init: function (_ref) {\n\t      var n = _ref.n;\n\t\n\t      this._n = n;\n\t      if (n <= 0) {\n\t        this._emitEnd();\n\t      }\n\t    },\n\t    _handleValue: function (x) {\n\t      this._n--;\n\t      this._emitValue(x);\n\t      if (this._n === 0) {\n\t        this._emitEnd();\n\t      }\n\t    }\n\t  };\n\t\n\t  var S$9 = createStream('take', mixin$2);\n\t  var P$5 = createProperty('take', mixin$2);\n\t\n\t  function take(obs, n) {\n\t    return new (obs._ofSameType(S$9, P$5))(obs, { n: n });\n\t  }\n\t\n\t  var mixin$3 = {\n\t    _init: function (_ref) {\n\t      var n = _ref.n;\n\t\n\t      this._n = n;\n\t      if (n <= 0) {\n\t        this._emitEnd();\n\t      }\n\t    },\n\t    _handleError: function (x) {\n\t      this._n--;\n\t      this._emitError(x);\n\t      if (this._n === 0) {\n\t        this._emitEnd();\n\t      }\n\t    }\n\t  };\n\t\n\t  var S$10 = createStream('takeErrors', mixin$3);\n\t  var P$6 = createProperty('takeErrors', mixin$3);\n\t\n\t  function takeErrors(obs, n) {\n\t    return new (obs._ofSameType(S$10, P$6))(obs, { n: n });\n\t  }\n\t\n\t  var mixin$4 = {\n\t    _init: function (_ref) {\n\t      var fn = _ref.fn;\n\t\n\t      this._fn = fn;\n\t    },\n\t    _free: function () {\n\t      this._fn = null;\n\t    },\n\t    _handleValue: function (x) {\n\t      var fn = this._fn;\n\t      if (fn(x)) {\n\t        this._emitValue(x);\n\t      } else {\n\t        this._emitEnd();\n\t      }\n\t    }\n\t  };\n\t\n\t  var S$11 = createStream('takeWhile', mixin$4);\n\t  var P$7 = createProperty('takeWhile', mixin$4);\n\t\n\t  var id$2 = function (x) {\n\t    return x;\n\t  };\n\t\n\t  function takeWhile(obs) {\n\t    var fn = arguments.length <= 1 || arguments[1] === undefined ? id$2 : arguments[1];\n\t\n\t    return new (obs._ofSameType(S$11, P$7))(obs, { fn: fn });\n\t  }\n\t\n\t  var mixin$5 = {\n\t    _init: function () {\n\t      this._lastValue = NOTHING;\n\t    },\n\t    _free: function () {\n\t      this._lastValue = null;\n\t    },\n\t    _handleValue: function (x) {\n\t      this._lastValue = x;\n\t    },\n\t    _handleEnd: function () {\n\t      if (this._lastValue !== NOTHING) {\n\t        this._emitValue(this._lastValue);\n\t      }\n\t      this._emitEnd();\n\t    }\n\t  };\n\t\n\t  var S$12 = createStream('last', mixin$5);\n\t  var P$8 = createProperty('last', mixin$5);\n\t\n\t  function last(obs) {\n\t    return new (obs._ofSameType(S$12, P$8))(obs);\n\t  }\n\t\n\t  var mixin$6 = {\n\t    _init: function (_ref) {\n\t      var n = _ref.n;\n\t\n\t      this._n = Math.max(0, n);\n\t    },\n\t    _handleValue: function (x) {\n\t      if (this._n === 0) {\n\t        this._emitValue(x);\n\t      } else {\n\t        this._n--;\n\t      }\n\t    }\n\t  };\n\t\n\t  var S$13 = createStream('skip', mixin$6);\n\t  var P$9 = createProperty('skip', mixin$6);\n\t\n\t  function skip(obs, n) {\n\t    return new (obs._ofSameType(S$13, P$9))(obs, { n: n });\n\t  }\n\t\n\t  var mixin$7 = {\n\t    _init: function (_ref) {\n\t      var fn = _ref.fn;\n\t\n\t      this._fn = fn;\n\t    },\n\t    _free: function () {\n\t      this._fn = null;\n\t    },\n\t    _handleValue: function (x) {\n\t      var fn = this._fn;\n\t      if (this._fn !== null && !fn(x)) {\n\t        this._fn = null;\n\t      }\n\t      if (this._fn === null) {\n\t        this._emitValue(x);\n\t      }\n\t    }\n\t  };\n\t\n\t  var S$14 = createStream('skipWhile', mixin$7);\n\t  var P$10 = createProperty('skipWhile', mixin$7);\n\t\n\t  var id$3 = function (x) {\n\t    return x;\n\t  };\n\t\n\t  function skipWhile(obs) {\n\t    var fn = arguments.length <= 1 || arguments[1] === undefined ? id$3 : arguments[1];\n\t\n\t    return new (obs._ofSameType(S$14, P$10))(obs, { fn: fn });\n\t  }\n\t\n\t  var mixin$8 = {\n\t    _init: function (_ref) {\n\t      var fn = _ref.fn;\n\t\n\t      this._fn = fn;\n\t      this._prev = NOTHING;\n\t    },\n\t    _free: function () {\n\t      this._fn = null;\n\t      this._prev = null;\n\t    },\n\t    _handleValue: function (x) {\n\t      var fn = this._fn;\n\t      if (this._prev === NOTHING || !fn(this._prev, x)) {\n\t        this._prev = x;\n\t        this._emitValue(x);\n\t      }\n\t    }\n\t  };\n\t\n\t  var S$15 = createStream('skipDuplicates', mixin$8);\n\t  var P$11 = createProperty('skipDuplicates', mixin$8);\n\t\n\t  var eq = function (a, b) {\n\t    return a === b;\n\t  };\n\t\n\t  function skipDuplicates(obs) {\n\t    var fn = arguments.length <= 1 || arguments[1] === undefined ? eq : arguments[1];\n\t\n\t    return new (obs._ofSameType(S$15, P$11))(obs, { fn: fn });\n\t  }\n\t\n\t  var mixin$9 = {\n\t    _init: function (_ref) {\n\t      var fn = _ref.fn;\n\t      var seed = _ref.seed;\n\t\n\t      this._fn = fn;\n\t      this._prev = seed;\n\t    },\n\t    _free: function () {\n\t      this._prev = null;\n\t      this._fn = null;\n\t    },\n\t    _handleValue: function (x) {\n\t      if (this._prev !== NOTHING) {\n\t        var fn = this._fn;\n\t        this._emitValue(fn(this._prev, x));\n\t      }\n\t      this._prev = x;\n\t    }\n\t  };\n\t\n\t  var S$16 = createStream('diff', mixin$9);\n\t  var P$12 = createProperty('diff', mixin$9);\n\t\n\t  function defaultFn(a, b) {\n\t    return [a, b];\n\t  }\n\t\n\t  function diff(obs, fn) {\n\t    var seed = arguments.length <= 2 || arguments[2] === undefined ? NOTHING : arguments[2];\n\t\n\t    return new (obs._ofSameType(S$16, P$12))(obs, { fn: fn || defaultFn, seed: seed });\n\t  }\n\t\n\t  var P$13 = createProperty('scan', {\n\t    _init: function (_ref) {\n\t      var fn = _ref.fn;\n\t      var seed = _ref.seed;\n\t\n\t      this._fn = fn;\n\t      this._seed = seed;\n\t      if (seed !== NOTHING) {\n\t        this._emitValue(seed);\n\t      }\n\t    },\n\t    _free: function () {\n\t      this._fn = null;\n\t      this._seed = null;\n\t    },\n\t    _handleValue: function (x) {\n\t      var fn = this._fn;\n\t      if (this._currentEvent === null || this._currentEvent.type === ERROR) {\n\t        this._emitValue(this._seed === NOTHING ? x : fn(this._seed, x));\n\t      } else {\n\t        this._emitValue(fn(this._currentEvent.value, x));\n\t      }\n\t    }\n\t  });\n\t\n\t  function scan(obs, fn) {\n\t    var seed = arguments.length <= 2 || arguments[2] === undefined ? NOTHING : arguments[2];\n\t\n\t    return new P$13(obs, { fn: fn, seed: seed });\n\t  }\n\t\n\t  var mixin$10 = {\n\t    _init: function (_ref) {\n\t      var fn = _ref.fn;\n\t\n\t      this._fn = fn;\n\t    },\n\t    _free: function () {\n\t      this._fn = null;\n\t    },\n\t    _handleValue: function (x) {\n\t      var fn = this._fn;\n\t      var xs = fn(x);\n\t      for (var i = 0; i < xs.length; i++) {\n\t        this._emitValue(xs[i]);\n\t      }\n\t    }\n\t  };\n\t\n\t  var S$17 = createStream('flatten', mixin$10);\n\t\n\t  var id$4 = function (x) {\n\t    return x;\n\t  };\n\t\n\t  function flatten(obs) {\n\t    var fn = arguments.length <= 1 || arguments[1] === undefined ? id$4 : arguments[1];\n\t\n\t    return new S$17(obs, { fn: fn });\n\t  }\n\t\n\t  var END_MARKER = {};\n\t\n\t  var mixin$11 = {\n\t    _init: function (_ref) {\n\t      var _this = this;\n\t\n\t      var wait = _ref.wait;\n\t\n\t      this._wait = Math.max(0, wait);\n\t      this._buff = [];\n\t      this._$shiftBuff = function () {\n\t        var value = _this._buff.shift();\n\t        if (value === END_MARKER) {\n\t          _this._emitEnd();\n\t        } else {\n\t          _this._emitValue(value);\n\t        }\n\t      };\n\t    },\n\t    _free: function () {\n\t      this._buff = null;\n\t      this._$shiftBuff = null;\n\t    },\n\t    _handleValue: function (x) {\n\t      if (this._activating) {\n\t        this._emitValue(x);\n\t      } else {\n\t        this._buff.push(x);\n\t        setTimeout(this._$shiftBuff, this._wait);\n\t      }\n\t    },\n\t    _handleEnd: function () {\n\t      if (this._activating) {\n\t        this._emitEnd();\n\t      } else {\n\t        this._buff.push(END_MARKER);\n\t        setTimeout(this._$shiftBuff, this._wait);\n\t      }\n\t    }\n\t  };\n\t\n\t  var S$18 = createStream('delay', mixin$11);\n\t  var P$14 = createProperty('delay', mixin$11);\n\t\n\t  function delay(obs, wait) {\n\t    return new (obs._ofSameType(S$18, P$14))(obs, { wait: wait });\n\t  }\n\t\n\t  var now = Date.now ? function () {\n\t    return Date.now();\n\t  } : function () {\n\t    return new Date().getTime();\n\t  };\n\t\n\t  var mixin$12 = {\n\t    _init: function (_ref) {\n\t      var _this = this;\n\t\n\t      var wait = _ref.wait;\n\t      var leading = _ref.leading;\n\t      var trailing = _ref.trailing;\n\t\n\t      this._wait = Math.max(0, wait);\n\t      this._leading = leading;\n\t      this._trailing = trailing;\n\t      this._trailingValue = null;\n\t      this._timeoutId = null;\n\t      this._endLater = false;\n\t      this._lastCallTime = 0;\n\t      this._$trailingCall = function () {\n\t        return _this._trailingCall();\n\t      };\n\t    },\n\t    _free: function () {\n\t      this._trailingValue = null;\n\t      this._$trailingCall = null;\n\t    },\n\t    _handleValue: function (x) {\n\t      if (this._activating) {\n\t        this._emitValue(x);\n\t      } else {\n\t        var curTime = now();\n\t        if (this._lastCallTime === 0 && !this._leading) {\n\t          this._lastCallTime = curTime;\n\t        }\n\t        var remaining = this._wait - (curTime - this._lastCallTime);\n\t        if (remaining <= 0) {\n\t          this._cancelTrailing();\n\t          this._lastCallTime = curTime;\n\t          this._emitValue(x);\n\t        } else if (this._trailing) {\n\t          this._cancelTrailing();\n\t          this._trailingValue = x;\n\t          this._timeoutId = setTimeout(this._$trailingCall, remaining);\n\t        }\n\t      }\n\t    },\n\t    _handleEnd: function () {\n\t      if (this._activating) {\n\t        this._emitEnd();\n\t      } else {\n\t        if (this._timeoutId) {\n\t          this._endLater = true;\n\t        } else {\n\t          this._emitEnd();\n\t        }\n\t      }\n\t    },\n\t    _cancelTrailing: function () {\n\t      if (this._timeoutId !== null) {\n\t        clearTimeout(this._timeoutId);\n\t        this._timeoutId = null;\n\t      }\n\t    },\n\t    _trailingCall: function () {\n\t      this._emitValue(this._trailingValue);\n\t      this._timeoutId = null;\n\t      this._trailingValue = null;\n\t      this._lastCallTime = !this._leading ? 0 : now();\n\t      if (this._endLater) {\n\t        this._emitEnd();\n\t      }\n\t    }\n\t  };\n\t\n\t  var S$19 = createStream('throttle', mixin$12);\n\t  var P$15 = createProperty('throttle', mixin$12);\n\t\n\t  function throttle(obs, wait) {\n\t    var _ref2 = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];\n\t\n\t    var _ref2$leading = _ref2.leading;\n\t    var leading = _ref2$leading === undefined ? true : _ref2$leading;\n\t    var _ref2$trailing = _ref2.trailing;\n\t    var trailing = _ref2$trailing === undefined ? true : _ref2$trailing;\n\t\n\t    return new (obs._ofSameType(S$19, P$15))(obs, { wait: wait, leading: leading, trailing: trailing });\n\t  }\n\t\n\t  var mixin$13 = {\n\t    _init: function (_ref) {\n\t      var _this = this;\n\t\n\t      var wait = _ref.wait;\n\t      var immediate = _ref.immediate;\n\t\n\t      this._wait = Math.max(0, wait);\n\t      this._immediate = immediate;\n\t      this._lastAttempt = 0;\n\t      this._timeoutId = null;\n\t      this._laterValue = null;\n\t      this._endLater = false;\n\t      this._$later = function () {\n\t        return _this._later();\n\t      };\n\t    },\n\t    _free: function () {\n\t      this._laterValue = null;\n\t      this._$later = null;\n\t    },\n\t    _handleValue: function (x) {\n\t      if (this._activating) {\n\t        this._emitValue(x);\n\t      } else {\n\t        this._lastAttempt = now();\n\t        if (this._immediate && !this._timeoutId) {\n\t          this._emitValue(x);\n\t        }\n\t        if (!this._timeoutId) {\n\t          this._timeoutId = setTimeout(this._$later, this._wait);\n\t        }\n\t        if (!this._immediate) {\n\t          this._laterValue = x;\n\t        }\n\t      }\n\t    },\n\t    _handleEnd: function () {\n\t      if (this._activating) {\n\t        this._emitEnd();\n\t      } else {\n\t        if (this._timeoutId && !this._immediate) {\n\t          this._endLater = true;\n\t        } else {\n\t          this._emitEnd();\n\t        }\n\t      }\n\t    },\n\t    _later: function () {\n\t      var last = now() - this._lastAttempt;\n\t      if (last < this._wait && last >= 0) {\n\t        this._timeoutId = setTimeout(this._$later, this._wait - last);\n\t      } else {\n\t        this._timeoutId = null;\n\t        if (!this._immediate) {\n\t          this._emitValue(this._laterValue);\n\t          this._laterValue = null;\n\t        }\n\t        if (this._endLater) {\n\t          this._emitEnd();\n\t        }\n\t      }\n\t    }\n\t  };\n\t\n\t  var S$20 = createStream('debounce', mixin$13);\n\t  var P$16 = createProperty('debounce', mixin$13);\n\t\n\t  function debounce(obs, wait) {\n\t    var _ref2 = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];\n\t\n\t    var _ref2$immediate = _ref2.immediate;\n\t    var immediate = _ref2$immediate === undefined ? false : _ref2$immediate;\n\t\n\t    return new (obs._ofSameType(S$20, P$16))(obs, { wait: wait, immediate: immediate });\n\t  }\n\t\n\t  var mixin$14 = {\n\t    _init: function (_ref) {\n\t      var fn = _ref.fn;\n\t\n\t      this._fn = fn;\n\t    },\n\t    _free: function () {\n\t      this._fn = null;\n\t    },\n\t    _handleError: function (x) {\n\t      var fn = this._fn;\n\t      this._emitError(fn(x));\n\t    }\n\t  };\n\t\n\t  var S$21 = createStream('mapErrors', mixin$14);\n\t  var P$17 = createProperty('mapErrors', mixin$14);\n\t\n\t  var id$5 = function (x) {\n\t    return x;\n\t  };\n\t\n\t  function mapErrors(obs) {\n\t    var fn = arguments.length <= 1 || arguments[1] === undefined ? id$5 : arguments[1];\n\t\n\t    return new (obs._ofSameType(S$21, P$17))(obs, { fn: fn });\n\t  }\n\t\n\t  var mixin$15 = {\n\t    _init: function (_ref) {\n\t      var fn = _ref.fn;\n\t\n\t      this._fn = fn;\n\t    },\n\t    _free: function () {\n\t      this._fn = null;\n\t    },\n\t    _handleError: function (x) {\n\t      var fn = this._fn;\n\t      if (fn(x)) {\n\t        this._emitError(x);\n\t      }\n\t    }\n\t  };\n\t\n\t  var S$22 = createStream('filterErrors', mixin$15);\n\t  var P$18 = createProperty('filterErrors', mixin$15);\n\t\n\t  var id$6 = function (x) {\n\t    return x;\n\t  };\n\t\n\t  function filterErrors(obs) {\n\t    var fn = arguments.length <= 1 || arguments[1] === undefined ? id$6 : arguments[1];\n\t\n\t    return new (obs._ofSameType(S$22, P$18))(obs, { fn: fn });\n\t  }\n\t\n\t  var mixin$16 = {\n\t    _handleValue: function () {}\n\t  };\n\t\n\t  var S$23 = createStream('ignoreValues', mixin$16);\n\t  var P$19 = createProperty('ignoreValues', mixin$16);\n\t\n\t  function ignoreValues(obs) {\n\t    return new (obs._ofSameType(S$23, P$19))(obs);\n\t  }\n\t\n\t  var mixin$17 = {\n\t    _handleError: function () {}\n\t  };\n\t\n\t  var S$24 = createStream('ignoreErrors', mixin$17);\n\t  var P$20 = createProperty('ignoreErrors', mixin$17);\n\t\n\t  function ignoreErrors(obs) {\n\t    return new (obs._ofSameType(S$24, P$20))(obs);\n\t  }\n\t\n\t  var mixin$18 = {\n\t    _handleEnd: function () {}\n\t  };\n\t\n\t  var S$25 = createStream('ignoreEnd', mixin$18);\n\t  var P$21 = createProperty('ignoreEnd', mixin$18);\n\t\n\t  function ignoreEnd(obs) {\n\t    return new (obs._ofSameType(S$25, P$21))(obs);\n\t  }\n\t\n\t  var mixin$19 = {\n\t    _init: function (_ref) {\n\t      var fn = _ref.fn;\n\t\n\t      this._fn = fn;\n\t    },\n\t    _free: function () {\n\t      this._fn = null;\n\t    },\n\t    _handleEnd: function () {\n\t      var fn = this._fn;\n\t      this._emitValue(fn());\n\t      this._emitEnd();\n\t    }\n\t  };\n\t\n\t  var S$26 = createStream('beforeEnd', mixin$19);\n\t  var P$22 = createProperty('beforeEnd', mixin$19);\n\t\n\t  function beforeEnd(obs, fn) {\n\t    return new (obs._ofSameType(S$26, P$22))(obs, { fn: fn });\n\t  }\n\t\n\t  var mixin$20 = {\n\t    _init: function (_ref) {\n\t      var min = _ref.min;\n\t      var max = _ref.max;\n\t\n\t      this._max = max;\n\t      this._min = min;\n\t      this._buff = [];\n\t    },\n\t    _free: function () {\n\t      this._buff = null;\n\t    },\n\t    _handleValue: function (x) {\n\t      this._buff = slide(this._buff, x, this._max);\n\t      if (this._buff.length >= this._min) {\n\t        this._emitValue(this._buff);\n\t      }\n\t    }\n\t  };\n\t\n\t  var S$27 = createStream('slidingWindow', mixin$20);\n\t  var P$23 = createProperty('slidingWindow', mixin$20);\n\t\n\t  function slidingWindow(obs, max) {\n\t    var min = arguments.length <= 2 || arguments[2] === undefined ? 0 : arguments[2];\n\t\n\t    return new (obs._ofSameType(S$27, P$23))(obs, { min: min, max: max });\n\t  }\n\t\n\t  var mixin$21 = {\n\t    _init: function (_ref) {\n\t      var fn = _ref.fn;\n\t      var flushOnEnd = _ref.flushOnEnd;\n\t\n\t      this._fn = fn;\n\t      this._flushOnEnd = flushOnEnd;\n\t      this._buff = [];\n\t    },\n\t    _free: function () {\n\t      this._buff = null;\n\t    },\n\t    _flush: function () {\n\t      if (this._buff !== null && this._buff.length !== 0) {\n\t        this._emitValue(this._buff);\n\t        this._buff = [];\n\t      }\n\t    },\n\t    _handleValue: function (x) {\n\t      this._buff.push(x);\n\t      var fn = this._fn;\n\t      if (!fn(x)) {\n\t        this._flush();\n\t      }\n\t    },\n\t    _handleEnd: function () {\n\t      if (this._flushOnEnd) {\n\t        this._flush();\n\t      }\n\t      this._emitEnd();\n\t    }\n\t  };\n\t\n\t  var S$28 = createStream('bufferWhile', mixin$21);\n\t  var P$24 = createProperty('bufferWhile', mixin$21);\n\t\n\t  var id$7 = function (x) {\n\t    return x;\n\t  };\n\t\n\t  function bufferWhile(obs, fn) {\n\t    var _ref2 = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];\n\t\n\t    var _ref2$flushOnEnd = _ref2.flushOnEnd;\n\t    var flushOnEnd = _ref2$flushOnEnd === undefined ? true : _ref2$flushOnEnd;\n\t\n\t    return new (obs._ofSameType(S$28, P$24))(obs, { fn: fn || id$7, flushOnEnd: flushOnEnd });\n\t  }\n\t\n\t  var mixin$22 = {\n\t    _init: function (_ref) {\n\t      var count = _ref.count;\n\t      var flushOnEnd = _ref.flushOnEnd;\n\t\n\t      this._count = count;\n\t      this._flushOnEnd = flushOnEnd;\n\t      this._buff = [];\n\t    },\n\t    _free: function () {\n\t      this._buff = null;\n\t    },\n\t    _flush: function () {\n\t      if (this._buff !== null && this._buff.length !== 0) {\n\t        this._emitValue(this._buff);\n\t        this._buff = [];\n\t      }\n\t    },\n\t    _handleValue: function (x) {\n\t      this._buff.push(x);\n\t      if (this._buff.length >= this._count) {\n\t        this._flush();\n\t      }\n\t    },\n\t    _handleEnd: function () {\n\t      if (this._flushOnEnd) {\n\t        this._flush();\n\t      }\n\t      this._emitEnd();\n\t    }\n\t  };\n\t\n\t  var S$29 = createStream('bufferWithCount', mixin$22);\n\t  var P$25 = createProperty('bufferWithCount', mixin$22);\n\t\n\t  function bufferWhile$1(obs, count) {\n\t    var _ref2 = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];\n\t\n\t    var _ref2$flushOnEnd = _ref2.flushOnEnd;\n\t    var flushOnEnd = _ref2$flushOnEnd === undefined ? true : _ref2$flushOnEnd;\n\t\n\t    return new (obs._ofSameType(S$29, P$25))(obs, { count: count, flushOnEnd: flushOnEnd });\n\t  }\n\t\n\t  var mixin$23 = {\n\t    _init: function (_ref) {\n\t      var _this = this;\n\t\n\t      var wait = _ref.wait;\n\t      var count = _ref.count;\n\t      var flushOnEnd = _ref.flushOnEnd;\n\t\n\t      this._wait = wait;\n\t      this._count = count;\n\t      this._flushOnEnd = flushOnEnd;\n\t      this._intervalId = null;\n\t      this._$onTick = function () {\n\t        return _this._flush();\n\t      };\n\t      this._buff = [];\n\t    },\n\t    _free: function () {\n\t      this._$onTick = null;\n\t      this._buff = null;\n\t    },\n\t    _flush: function () {\n\t      if (this._buff !== null) {\n\t        this._emitValue(this._buff);\n\t        this._buff = [];\n\t      }\n\t    },\n\t    _handleValue: function (x) {\n\t      this._buff.push(x);\n\t      if (this._buff.length >= this._count) {\n\t        clearInterval(this._intervalId);\n\t        this._flush();\n\t        this._intervalId = setInterval(this._$onTick, this._wait);\n\t      }\n\t    },\n\t    _handleEnd: function () {\n\t      if (this._flushOnEnd && this._buff.length !== 0) {\n\t        this._flush();\n\t      }\n\t      this._emitEnd();\n\t    },\n\t    _onActivation: function () {\n\t      this._source.onAny(this._$handleAny); // copied from patterns/one-source\n\t      this._intervalId = setInterval(this._$onTick, this._wait);\n\t    },\n\t    _onDeactivation: function () {\n\t      if (this._intervalId !== null) {\n\t        clearInterval(this._intervalId);\n\t        this._intervalId = null;\n\t      }\n\t      this._source.offAny(this._$handleAny); // copied from patterns/one-source\n\t    }\n\t  };\n\t\n\t  var S$30 = createStream('bufferWithTimeOrCount', mixin$23);\n\t  var P$26 = createProperty('bufferWithTimeOrCount', mixin$23);\n\t\n\t  function bufferWithTimeOrCount(obs, wait, count) {\n\t    var _ref2 = arguments.length <= 3 || arguments[3] === undefined ? {} : arguments[3];\n\t\n\t    var _ref2$flushOnEnd = _ref2.flushOnEnd;\n\t    var flushOnEnd = _ref2$flushOnEnd === undefined ? true : _ref2$flushOnEnd;\n\t\n\t    return new (obs._ofSameType(S$30, P$26))(obs, { wait: wait, count: count, flushOnEnd: flushOnEnd });\n\t  }\n\t\n\t  function xformForObs(obs) {\n\t    return {\n\t      '@@transducer/step': function (res, input) {\n\t        obs._emitValue(input);\n\t        return null;\n\t      },\n\t      '@@transducer/result': function () {\n\t        obs._emitEnd();\n\t        return null;\n\t      }\n\t    };\n\t  }\n\t\n\t  var mixin$24 = {\n\t    _init: function (_ref) {\n\t      var transducer = _ref.transducer;\n\t\n\t      this._xform = transducer(xformForObs(this));\n\t    },\n\t    _free: function () {\n\t      this._xform = null;\n\t    },\n\t    _handleValue: function (x) {\n\t      if (this._xform['@@transducer/step'](null, x) !== null) {\n\t        this._xform['@@transducer/result'](null);\n\t      }\n\t    },\n\t    _handleEnd: function () {\n\t      this._xform['@@transducer/result'](null);\n\t    }\n\t  };\n\t\n\t  var S$31 = createStream('transduce', mixin$24);\n\t  var P$27 = createProperty('transduce', mixin$24);\n\t\n\t  function transduce(obs, transducer) {\n\t    return new (obs._ofSameType(S$31, P$27))(obs, { transducer: transducer });\n\t  }\n\t\n\t  var mixin$25 = {\n\t    _init: function (_ref) {\n\t      var fn = _ref.fn;\n\t\n\t      this._handler = fn;\n\t      this._emitter = emitter(this);\n\t    },\n\t    _free: function () {\n\t      this._handler = null;\n\t      this._emitter = null;\n\t    },\n\t    _handleAny: function (event) {\n\t      this._handler(this._emitter, event);\n\t    }\n\t  };\n\t\n\t  var S$32 = createStream('withHandler', mixin$25);\n\t  var P$28 = createProperty('withHandler', mixin$25);\n\t\n\t  function withHandler(obs, fn) {\n\t    return new (obs._ofSameType(S$32, P$28))(obs, { fn: fn });\n\t  }\n\t\n\t  function defaultErrorsCombinator(errors) {\n\t    var latestError = undefined;\n\t    for (var i = 0; i < errors.length; i++) {\n\t      if (errors[i] !== undefined) {\n\t        if (latestError === undefined || latestError.index < errors[i].index) {\n\t          latestError = errors[i];\n\t        }\n\t      }\n\t    }\n\t    return latestError.error;\n\t  }\n\t\n\t  function Combine(active, passive, combinator) {\n\t    var _this = this;\n\t\n\t    Stream.call(this);\n\t    this._activeCount = active.length;\n\t    this._sources = concat(active, passive);\n\t    this._combinator = combinator ? spread(combinator, this._sources.length) : function (x) {\n\t      return x;\n\t    };\n\t    this._aliveCount = 0;\n\t    this._latestValues = new Array(this._sources.length);\n\t    this._latestErrors = new Array(this._sources.length);\n\t    fillArray(this._latestValues, NOTHING);\n\t    this._emitAfterActivation = false;\n\t    this._endAfterActivation = false;\n\t    this._latestErrorIndex = 0;\n\t\n\t    this._$handlers = [];\n\t\n\t    var _loop = function (i) {\n\t      _this._$handlers.push(function (event) {\n\t        return _this._handleAny(i, event);\n\t      });\n\t    };\n\t\n\t    for (var i = 0; i < this._sources.length; i++) {\n\t      _loop(i);\n\t    }\n\t  }\n\t\n\t  inherit(Combine, Stream, {\n\t\n\t    _name: 'combine',\n\t\n\t    _onActivation: function () {\n\t      this._aliveCount = this._activeCount;\n\t\n\t      // we need to suscribe to _passive_ sources before _active_\n\t      // (see https://github.com/rpominov/kefir/issues/98)\n\t      for (var i = this._activeCount; i < this._sources.length; i++) {\n\t        this._sources[i].onAny(this._$handlers[i]);\n\t      }\n\t      for (var i = 0; i < this._activeCount; i++) {\n\t        this._sources[i].onAny(this._$handlers[i]);\n\t      }\n\t\n\t      if (this._emitAfterActivation) {\n\t        this._emitAfterActivation = false;\n\t        this._emitIfFull();\n\t      }\n\t      if (this._endAfterActivation) {\n\t        this._emitEnd();\n\t      }\n\t    },\n\t    _onDeactivation: function () {\n\t      var length = this._sources.length,\n\t          i = undefined;\n\t      for (i = 0; i < length; i++) {\n\t        this._sources[i].offAny(this._$handlers[i]);\n\t      }\n\t    },\n\t    _emitIfFull: function () {\n\t      var hasAllValues = true;\n\t      var hasErrors = false;\n\t      var length = this._latestValues.length;\n\t      var valuesCopy = new Array(length);\n\t      var errorsCopy = new Array(length);\n\t\n\t      for (var i = 0; i < length; i++) {\n\t        valuesCopy[i] = this._latestValues[i];\n\t        errorsCopy[i] = this._latestErrors[i];\n\t\n\t        if (valuesCopy[i] === NOTHING) {\n\t          hasAllValues = false;\n\t        }\n\t\n\t        if (errorsCopy[i] !== undefined) {\n\t          hasErrors = true;\n\t        }\n\t      }\n\t\n\t      if (hasAllValues) {\n\t        var combinator = this._combinator;\n\t        this._emitValue(combinator(valuesCopy));\n\t      }\n\t      if (hasErrors) {\n\t        this._emitError(defaultErrorsCombinator(errorsCopy));\n\t      }\n\t    },\n\t    _handleAny: function (i, event) {\n\t\n\t      if (event.type === VALUE || event.type === ERROR) {\n\t\n\t        if (event.type === VALUE) {\n\t          this._latestValues[i] = event.value;\n\t          this._latestErrors[i] = undefined;\n\t        }\n\t        if (event.type === ERROR) {\n\t          this._latestValues[i] = NOTHING;\n\t          this._latestErrors[i] = {\n\t            index: this._latestErrorIndex++,\n\t            error: event.value\n\t          };\n\t        }\n\t\n\t        if (i < this._activeCount) {\n\t          if (this._activating) {\n\t            this._emitAfterActivation = true;\n\t          } else {\n\t            this._emitIfFull();\n\t          }\n\t        }\n\t      } else {\n\t        // END\n\t\n\t        if (i < this._activeCount) {\n\t          this._aliveCount--;\n\t          if (this._aliveCount === 0) {\n\t            if (this._activating) {\n\t              this._endAfterActivation = true;\n\t            } else {\n\t              this._emitEnd();\n\t            }\n\t          }\n\t        }\n\t      }\n\t    },\n\t    _clear: function () {\n\t      Stream.prototype._clear.call(this);\n\t      this._sources = null;\n\t      this._latestValues = null;\n\t      this._latestErrors = null;\n\t      this._combinator = null;\n\t      this._$handlers = null;\n\t    }\n\t  });\n\t\n\t  function combine(active) {\n\t    var passive = arguments.length <= 1 || arguments[1] === undefined ? [] : arguments[1];\n\t    var combinator = arguments[2];\n\t\n\t    if (typeof passive === 'function') {\n\t      combinator = passive;\n\t      passive = [];\n\t    }\n\t    return active.length === 0 ? never() : new Combine(active, passive, combinator);\n\t  }\n\t\n\t  var isArray = Array.isArray || function (xs) {\n\t    return Object.prototype.toString.call(xs) === '[object Array]';\n\t  };\n\t\n\t  function Zip(sources, combinator) {\n\t    var _this = this;\n\t\n\t    Stream.call(this);\n\t\n\t    this._buffers = map(sources, function (source) {\n\t      return isArray(source) ? cloneArray(source) : [];\n\t    });\n\t    this._sources = map(sources, function (source) {\n\t      return isArray(source) ? never() : source;\n\t    });\n\t\n\t    this._combinator = combinator ? spread(combinator, this._sources.length) : function (x) {\n\t      return x;\n\t    };\n\t    this._aliveCount = 0;\n\t\n\t    this._$handlers = [];\n\t\n\t    var _loop = function (i) {\n\t      _this._$handlers.push(function (event) {\n\t        return _this._handleAny(i, event);\n\t      });\n\t    };\n\t\n\t    for (var i = 0; i < this._sources.length; i++) {\n\t      _loop(i);\n\t    }\n\t  }\n\t\n\t  inherit(Zip, Stream, {\n\t\n\t    _name: 'zip',\n\t\n\t    _onActivation: function () {\n\t\n\t      // if all sources are arrays\n\t      while (this._isFull()) {\n\t        this._emit();\n\t      }\n\t\n\t      var length = this._sources.length;\n\t      this._aliveCount = length;\n\t      for (var i = 0; i < length && this._active; i++) {\n\t        this._sources[i].onAny(this._$handlers[i]);\n\t      }\n\t    },\n\t    _onDeactivation: function () {\n\t      for (var i = 0; i < this._sources.length; i++) {\n\t        this._sources[i].offAny(this._$handlers[i]);\n\t      }\n\t    },\n\t    _emit: function () {\n\t      var values = new Array(this._buffers.length);\n\t      for (var i = 0; i < this._buffers.length; i++) {\n\t        values[i] = this._buffers[i].shift();\n\t      }\n\t      var combinator = this._combinator;\n\t      this._emitValue(combinator(values));\n\t    },\n\t    _isFull: function () {\n\t      for (var i = 0; i < this._buffers.length; i++) {\n\t        if (this._buffers[i].length === 0) {\n\t          return false;\n\t        }\n\t      }\n\t      return true;\n\t    },\n\t    _handleAny: function (i, event) {\n\t      if (event.type === VALUE) {\n\t        this._buffers[i].push(event.value);\n\t        if (this._isFull()) {\n\t          this._emit();\n\t        }\n\t      }\n\t      if (event.type === ERROR) {\n\t        this._emitError(event.value);\n\t      }\n\t      if (event.type === END) {\n\t        this._aliveCount--;\n\t        if (this._aliveCount === 0) {\n\t          this._emitEnd();\n\t        }\n\t      }\n\t    },\n\t    _clear: function () {\n\t      Stream.prototype._clear.call(this);\n\t      this._sources = null;\n\t      this._buffers = null;\n\t      this._combinator = null;\n\t      this._$handlers = null;\n\t    }\n\t  });\n\t\n\t  function zip(observables, combinator /* Function | falsey */) {\n\t    return observables.length === 0 ? never() : new Zip(observables, combinator);\n\t  }\n\t\n\t  var id$8 = function (x) {\n\t    return x;\n\t  };\n\t\n\t  function AbstractPool() {\n\t    var _this = this;\n\t\n\t    var _ref = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\n\t\n\t    var _ref$queueLim = _ref.queueLim;\n\t    var queueLim = _ref$queueLim === undefined ? 0 : _ref$queueLim;\n\t    var _ref$concurLim = _ref.concurLim;\n\t    var concurLim = _ref$concurLim === undefined ? -1 : _ref$concurLim;\n\t    var _ref$drop = _ref.drop;\n\t    var drop = _ref$drop === undefined ? 'new' : _ref$drop;\n\t\n\t    Stream.call(this);\n\t\n\t    this._queueLim = queueLim < 0 ? -1 : queueLim;\n\t    this._concurLim = concurLim < 0 ? -1 : concurLim;\n\t    this._drop = drop;\n\t    this._queue = [];\n\t    this._curSources = [];\n\t    this._$handleSubAny = function (event) {\n\t      return _this._handleSubAny(event);\n\t    };\n\t    this._$endHandlers = [];\n\t    this._currentlyAdding = null;\n\t\n\t    if (this._concurLim === 0) {\n\t      this._emitEnd();\n\t    }\n\t  }\n\t\n\t  inherit(AbstractPool, Stream, {\n\t\n\t    _name: 'abstractPool',\n\t\n\t    _add: function (obj, toObs /* Function | falsey */) {\n\t      toObs = toObs || id$8;\n\t      if (this._concurLim === -1 || this._curSources.length < this._concurLim) {\n\t        this._addToCur(toObs(obj));\n\t      } else {\n\t        if (this._queueLim === -1 || this._queue.length < this._queueLim) {\n\t          this._addToQueue(toObs(obj));\n\t        } else if (this._drop === 'old') {\n\t          this._removeOldest();\n\t          this._add(obj, toObs);\n\t        }\n\t      }\n\t    },\n\t    _addAll: function (obss) {\n\t      var _this2 = this;\n\t\n\t      forEach(obss, function (obs) {\n\t        return _this2._add(obs);\n\t      });\n\t    },\n\t    _remove: function (obs) {\n\t      if (this._removeCur(obs) === -1) {\n\t        this._removeQueue(obs);\n\t      }\n\t    },\n\t    _addToQueue: function (obs) {\n\t      this._queue = concat(this._queue, [obs]);\n\t    },\n\t    _addToCur: function (obs) {\n\t      if (this._active) {\n\t\n\t        // HACK:\n\t        //\n\t        // We have two optimizations for cases when `obs` is ended. We don't want\n\t        // to add such observable to the list, but only want to emit events\n\t        // from it (if it has some).\n\t        //\n\t        // Instead of this hacks, we could just did following,\n\t        // but it would be 5-8 times slower:\n\t        //\n\t        //     this._curSources = concat(this._curSources, [obs]);\n\t        //     this._subscribe(obs);\n\t        //\n\t\n\t        // #1\n\t        // This one for cases when `obs` already ended\n\t        // e.g., Kefir.constant() or Kefir.never()\n\t        if (!obs._alive) {\n\t          if (obs._currentEvent) {\n\t            this._emit(obs._currentEvent.type, obs._currentEvent.value);\n\t          }\n\t          return;\n\t        }\n\t\n\t        // #2\n\t        // This one is for cases when `obs` going to end synchronously on\n\t        // first subscriber e.g., Kefir.stream(em => {em.emit(1); em.end()})\n\t        this._currentlyAdding = obs;\n\t        obs.onAny(this._$handleSubAny);\n\t        this._currentlyAdding = null;\n\t        if (obs._alive) {\n\t          this._curSources = concat(this._curSources, [obs]);\n\t          if (this._active) {\n\t            this._subToEnd(obs);\n\t          }\n\t        }\n\t      } else {\n\t        this._curSources = concat(this._curSources, [obs]);\n\t      }\n\t    },\n\t    _subToEnd: function (obs) {\n\t      var _this3 = this;\n\t\n\t      var onEnd = function () {\n\t        return _this3._removeCur(obs);\n\t      };\n\t      this._$endHandlers.push({ obs: obs, handler: onEnd });\n\t      obs.onEnd(onEnd);\n\t    },\n\t    _subscribe: function (obs) {\n\t      obs.onAny(this._$handleSubAny);\n\t\n\t      // it can become inactive in responce of subscribing to `obs.onAny` above\n\t      if (this._active) {\n\t        this._subToEnd(obs);\n\t      }\n\t    },\n\t    _unsubscribe: function (obs) {\n\t      obs.offAny(this._$handleSubAny);\n\t\n\t      var onEndI = findByPred(this._$endHandlers, function (obj) {\n\t        return obj.obs === obs;\n\t      });\n\t      if (onEndI !== -1) {\n\t        obs.offEnd(this._$endHandlers[onEndI].handler);\n\t        this._$endHandlers.splice(onEndI, 1);\n\t      }\n\t    },\n\t    _handleSubAny: function (event) {\n\t      if (event.type === VALUE) {\n\t        this._emitValue(event.value);\n\t      } else if (event.type === ERROR) {\n\t        this._emitError(event.value);\n\t      }\n\t    },\n\t    _removeQueue: function (obs) {\n\t      var index = find(this._queue, obs);\n\t      this._queue = remove(this._queue, index);\n\t      return index;\n\t    },\n\t    _removeCur: function (obs) {\n\t      if (this._active) {\n\t        this._unsubscribe(obs);\n\t      }\n\t      var index = find(this._curSources, obs);\n\t      this._curSources = remove(this._curSources, index);\n\t      if (index !== -1) {\n\t        if (this._queue.length !== 0) {\n\t          this._pullQueue();\n\t        } else if (this._curSources.length === 0) {\n\t          this._onEmpty();\n\t        }\n\t      }\n\t      return index;\n\t    },\n\t    _removeOldest: function () {\n\t      this._removeCur(this._curSources[0]);\n\t    },\n\t    _pullQueue: function () {\n\t      if (this._queue.length !== 0) {\n\t        this._queue = cloneArray(this._queue);\n\t        this._addToCur(this._queue.shift());\n\t      }\n\t    },\n\t    _onActivation: function () {\n\t      for (var i = 0, sources = this._curSources; i < sources.length && this._active; i++) {\n\t        this._subscribe(sources[i]);\n\t      }\n\t    },\n\t    _onDeactivation: function () {\n\t      for (var i = 0, sources = this._curSources; i < sources.length; i++) {\n\t        this._unsubscribe(sources[i]);\n\t      }\n\t      if (this._currentlyAdding !== null) {\n\t        this._unsubscribe(this._currentlyAdding);\n\t      }\n\t    },\n\t    _isEmpty: function () {\n\t      return this._curSources.length === 0;\n\t    },\n\t    _onEmpty: function () {},\n\t    _clear: function () {\n\t      Stream.prototype._clear.call(this);\n\t      this._queue = null;\n\t      this._curSources = null;\n\t      this._$handleSubAny = null;\n\t      this._$endHandlers = null;\n\t    }\n\t  });\n\t\n\t  function Merge(sources) {\n\t    AbstractPool.call(this);\n\t    this._addAll(sources);\n\t    this._initialised = true;\n\t  }\n\t\n\t  inherit(Merge, AbstractPool, {\n\t\n\t    _name: 'merge',\n\t\n\t    _onEmpty: function () {\n\t      if (this._initialised) {\n\t        this._emitEnd();\n\t      }\n\t    }\n\t  });\n\t\n\t  function merge(observables) {\n\t    return observables.length === 0 ? never() : new Merge(observables);\n\t  }\n\t\n\t  function S$33(generator) {\n\t    var _this = this;\n\t\n\t    Stream.call(this);\n\t    this._generator = generator;\n\t    this._source = null;\n\t    this._inLoop = false;\n\t    this._iteration = 0;\n\t    this._$handleAny = function (event) {\n\t      return _this._handleAny(event);\n\t    };\n\t  }\n\t\n\t  inherit(S$33, Stream, {\n\t\n\t    _name: 'repeat',\n\t\n\t    _handleAny: function (event) {\n\t      if (event.type === END) {\n\t        this._source = null;\n\t        this._getSource();\n\t      } else {\n\t        this._emit(event.type, event.value);\n\t      }\n\t    },\n\t    _getSource: function () {\n\t      if (!this._inLoop) {\n\t        this._inLoop = true;\n\t        var generator = this._generator;\n\t        while (this._source === null && this._alive && this._active) {\n\t          this._source = generator(this._iteration++);\n\t          if (this._source) {\n\t            this._source.onAny(this._$handleAny);\n\t          } else {\n\t            this._emitEnd();\n\t          }\n\t        }\n\t        this._inLoop = false;\n\t      }\n\t    },\n\t    _onActivation: function () {\n\t      if (this._source) {\n\t        this._source.onAny(this._$handleAny);\n\t      } else {\n\t        this._getSource();\n\t      }\n\t    },\n\t    _onDeactivation: function () {\n\t      if (this._source) {\n\t        this._source.offAny(this._$handleAny);\n\t      }\n\t    },\n\t    _clear: function () {\n\t      Stream.prototype._clear.call(this);\n\t      this._generator = null;\n\t      this._source = null;\n\t      this._$handleAny = null;\n\t    }\n\t  });\n\t\n\t  function repeat (generator) {\n\t    return new S$33(generator);\n\t  }\n\t\n\t  function concat$1(observables) {\n\t    return repeat(function (index) {\n\t      return observables.length > index ? observables[index] : false;\n\t    }).setName('concat');\n\t  }\n\t\n\t  function Pool() {\n\t    AbstractPool.call(this);\n\t  }\n\t\n\t  inherit(Pool, AbstractPool, {\n\t\n\t    _name: 'pool',\n\t\n\t    plug: function (obs) {\n\t      this._add(obs);\n\t      return this;\n\t    },\n\t    unplug: function (obs) {\n\t      this._remove(obs);\n\t      return this;\n\t    }\n\t  });\n\t\n\t  function FlatMap(source, fn, options) {\n\t    var _this = this;\n\t\n\t    AbstractPool.call(this, options);\n\t    this._source = source;\n\t    this._fn = fn;\n\t    this._mainEnded = false;\n\t    this._lastCurrent = null;\n\t    this._$handleMain = function (event) {\n\t      return _this._handleMain(event);\n\t    };\n\t  }\n\t\n\t  inherit(FlatMap, AbstractPool, {\n\t    _onActivation: function () {\n\t      AbstractPool.prototype._onActivation.call(this);\n\t      if (this._active) {\n\t        this._source.onAny(this._$handleMain);\n\t      }\n\t    },\n\t    _onDeactivation: function () {\n\t      AbstractPool.prototype._onDeactivation.call(this);\n\t      this._source.offAny(this._$handleMain);\n\t      this._hadNoEvSinceDeact = true;\n\t    },\n\t    _handleMain: function (event) {\n\t\n\t      if (event.type === VALUE) {\n\t        // Is latest value before deactivation survived, and now is 'current' on this activation?\n\t        // We don't want to handle such values, to prevent to constantly add\n\t        // same observale on each activation/deactivation when our main source\n\t        // is a `Kefir.conatant()` for example.\n\t        var sameCurr = this._activating && this._hadNoEvSinceDeact && this._lastCurrent === event.value;\n\t        if (!sameCurr) {\n\t          this._add(event.value, this._fn);\n\t        }\n\t        this._lastCurrent = event.value;\n\t        this._hadNoEvSinceDeact = false;\n\t      }\n\t\n\t      if (event.type === ERROR) {\n\t        this._emitError(event.value);\n\t      }\n\t\n\t      if (event.type === END) {\n\t        if (this._isEmpty()) {\n\t          this._emitEnd();\n\t        } else {\n\t          this._mainEnded = true;\n\t        }\n\t      }\n\t    },\n\t    _onEmpty: function () {\n\t      if (this._mainEnded) {\n\t        this._emitEnd();\n\t      }\n\t    },\n\t    _clear: function () {\n\t      AbstractPool.prototype._clear.call(this);\n\t      this._source = null;\n\t      this._lastCurrent = null;\n\t      this._$handleMain = null;\n\t    }\n\t  });\n\t\n\t  function FlatMapErrors(source, fn) {\n\t    FlatMap.call(this, source, fn);\n\t  }\n\t\n\t  inherit(FlatMapErrors, FlatMap, {\n\t\n\t    // Same as in FlatMap, only VALUE/ERROR flipped\n\t\n\t    _handleMain: function (event) {\n\t\n\t      if (event.type === ERROR) {\n\t        var sameCurr = this._activating && this._hadNoEvSinceDeact && this._lastCurrent === event.value;\n\t        if (!sameCurr) {\n\t          this._add(event.value, this._fn);\n\t        }\n\t        this._lastCurrent = event.value;\n\t        this._hadNoEvSinceDeact = false;\n\t      }\n\t\n\t      if (event.type === VALUE) {\n\t        this._emitValue(event.value);\n\t      }\n\t\n\t      if (event.type === END) {\n\t        if (this._isEmpty()) {\n\t          this._emitEnd();\n\t        } else {\n\t          this._mainEnded = true;\n\t        }\n\t      }\n\t    }\n\t  });\n\t\n\t  function createConstructor$1(BaseClass, name) {\n\t    return function AnonymousObservable(primary, secondary, options) {\n\t      var _this = this;\n\t\n\t      BaseClass.call(this);\n\t      this._primary = primary;\n\t      this._secondary = secondary;\n\t      this._name = primary._name + '.' + name;\n\t      this._lastSecondary = NOTHING;\n\t      this._$handleSecondaryAny = function (event) {\n\t        return _this._handleSecondaryAny(event);\n\t      };\n\t      this._$handlePrimaryAny = function (event) {\n\t        return _this._handlePrimaryAny(event);\n\t      };\n\t      this._init(options);\n\t    };\n\t  }\n\t\n\t  function createClassMethods$1(BaseClass) {\n\t    return {\n\t      _init: function () {},\n\t      _free: function () {},\n\t      _handlePrimaryValue: function (x) {\n\t        this._emitValue(x);\n\t      },\n\t      _handlePrimaryError: function (x) {\n\t        this._emitError(x);\n\t      },\n\t      _handlePrimaryEnd: function () {\n\t        this._emitEnd();\n\t      },\n\t      _handleSecondaryValue: function (x) {\n\t        this._lastSecondary = x;\n\t      },\n\t      _handleSecondaryError: function (x) {\n\t        this._emitError(x);\n\t      },\n\t      _handleSecondaryEnd: function () {},\n\t      _handlePrimaryAny: function (event) {\n\t        switch (event.type) {\n\t          case VALUE:\n\t            return this._handlePrimaryValue(event.value);\n\t          case ERROR:\n\t            return this._handlePrimaryError(event.value);\n\t          case END:\n\t            return this._handlePrimaryEnd(event.value);\n\t        }\n\t      },\n\t      _handleSecondaryAny: function (event) {\n\t        switch (event.type) {\n\t          case VALUE:\n\t            return this._handleSecondaryValue(event.value);\n\t          case ERROR:\n\t            return this._handleSecondaryError(event.value);\n\t          case END:\n\t            this._handleSecondaryEnd(event.value);\n\t            this._removeSecondary();\n\t        }\n\t      },\n\t      _removeSecondary: function () {\n\t        if (this._secondary !== null) {\n\t          this._secondary.offAny(this._$handleSecondaryAny);\n\t          this._$handleSecondaryAny = null;\n\t          this._secondary = null;\n\t        }\n\t      },\n\t      _onActivation: function () {\n\t        if (this._secondary !== null) {\n\t          this._secondary.onAny(this._$handleSecondaryAny);\n\t        }\n\t        if (this._active) {\n\t          this._primary.onAny(this._$handlePrimaryAny);\n\t        }\n\t      },\n\t      _onDeactivation: function () {\n\t        if (this._secondary !== null) {\n\t          this._secondary.offAny(this._$handleSecondaryAny);\n\t        }\n\t        this._primary.offAny(this._$handlePrimaryAny);\n\t      },\n\t      _clear: function () {\n\t        BaseClass.prototype._clear.call(this);\n\t        this._primary = null;\n\t        this._secondary = null;\n\t        this._lastSecondary = null;\n\t        this._$handleSecondaryAny = null;\n\t        this._$handlePrimaryAny = null;\n\t        this._free();\n\t      }\n\t    };\n\t  }\n\t\n\t  function createStream$1(name, mixin) {\n\t    var S = createConstructor$1(Stream, name);\n\t    inherit(S, Stream, createClassMethods$1(Stream), mixin);\n\t    return S;\n\t  }\n\t\n\t  function createProperty$1(name, mixin) {\n\t    var P = createConstructor$1(Property, name);\n\t    inherit(P, Property, createClassMethods$1(Property), mixin);\n\t    return P;\n\t  }\n\t\n\t  var mixin$26 = {\n\t    _handlePrimaryValue: function (x) {\n\t      if (this._lastSecondary !== NOTHING && this._lastSecondary) {\n\t        this._emitValue(x);\n\t      }\n\t    },\n\t    _handleSecondaryEnd: function () {\n\t      if (this._lastSecondary === NOTHING || !this._lastSecondary) {\n\t        this._emitEnd();\n\t      }\n\t    }\n\t  };\n\t\n\t  var S$34 = createStream$1('filterBy', mixin$26);\n\t  var P$29 = createProperty$1('filterBy', mixin$26);\n\t\n\t  function filterBy(primary, secondary) {\n\t    return new (primary._ofSameType(S$34, P$29))(primary, secondary);\n\t  }\n\t\n\t  var id2 = function (_, x) {\n\t    return x;\n\t  };\n\t\n\t  function sampledBy(passive, active, combinator) {\n\t    var _combinator = combinator ? function (a, b) {\n\t      return combinator(b, a);\n\t    } : id2;\n\t    return combine([active], [passive], _combinator).setName(passive, 'sampledBy');\n\t  }\n\t\n\t  var mixin$27 = {\n\t    _handlePrimaryValue: function (x) {\n\t      if (this._lastSecondary !== NOTHING) {\n\t        this._emitValue(x);\n\t      }\n\t    },\n\t    _handleSecondaryEnd: function () {\n\t      if (this._lastSecondary === NOTHING) {\n\t        this._emitEnd();\n\t      }\n\t    }\n\t  };\n\t\n\t  var S$35 = createStream$1('skipUntilBy', mixin$27);\n\t  var P$30 = createProperty$1('skipUntilBy', mixin$27);\n\t\n\t  function skipUntilBy(primary, secondary) {\n\t    return new (primary._ofSameType(S$35, P$30))(primary, secondary);\n\t  }\n\t\n\t  var mixin$28 = {\n\t    _handleSecondaryValue: function () {\n\t      this._emitEnd();\n\t    }\n\t  };\n\t\n\t  var S$36 = createStream$1('takeUntilBy', mixin$28);\n\t  var P$31 = createProperty$1('takeUntilBy', mixin$28);\n\t\n\t  function takeUntilBy(primary, secondary) {\n\t    return new (primary._ofSameType(S$36, P$31))(primary, secondary);\n\t  }\n\t\n\t  var mixin$29 = {\n\t    _init: function () {\n\t      var _ref = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\n\t\n\t      var _ref$flushOnEnd = _ref.flushOnEnd;\n\t      var flushOnEnd = _ref$flushOnEnd === undefined ? true : _ref$flushOnEnd;\n\t\n\t      this._buff = [];\n\t      this._flushOnEnd = flushOnEnd;\n\t    },\n\t    _free: function () {\n\t      this._buff = null;\n\t    },\n\t    _flush: function () {\n\t      if (this._buff !== null) {\n\t        this._emitValue(this._buff);\n\t        this._buff = [];\n\t      }\n\t    },\n\t    _handlePrimaryEnd: function () {\n\t      if (this._flushOnEnd) {\n\t        this._flush();\n\t      }\n\t      this._emitEnd();\n\t    },\n\t    _onActivation: function () {\n\t      this._primary.onAny(this._$handlePrimaryAny);\n\t      if (this._alive && this._secondary !== null) {\n\t        this._secondary.onAny(this._$handleSecondaryAny);\n\t      }\n\t    },\n\t    _handlePrimaryValue: function (x) {\n\t      this._buff.push(x);\n\t    },\n\t    _handleSecondaryValue: function () {\n\t      this._flush();\n\t    },\n\t    _handleSecondaryEnd: function () {\n\t      if (!this._flushOnEnd) {\n\t        this._emitEnd();\n\t      }\n\t    }\n\t  };\n\t\n\t  var S$37 = createStream$1('bufferBy', mixin$29);\n\t  var P$32 = createProperty$1('bufferBy', mixin$29);\n\t\n\t  function bufferBy(primary, secondary, options /* optional */) {\n\t    return new (primary._ofSameType(S$37, P$32))(primary, secondary, options);\n\t  }\n\t\n\t  var mixin$30 = {\n\t    _init: function () {\n\t      var _ref = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\n\t\n\t      var _ref$flushOnEnd = _ref.flushOnEnd;\n\t      var flushOnEnd = _ref$flushOnEnd === undefined ? true : _ref$flushOnEnd;\n\t      var _ref$flushOnChange = _ref.flushOnChange;\n\t      var flushOnChange = _ref$flushOnChange === undefined ? false : _ref$flushOnChange;\n\t\n\t      this._buff = [];\n\t      this._flushOnEnd = flushOnEnd;\n\t      this._flushOnChange = flushOnChange;\n\t    },\n\t    _free: function () {\n\t      this._buff = null;\n\t    },\n\t    _flush: function () {\n\t      if (this._buff !== null) {\n\t        this._emitValue(this._buff);\n\t        this._buff = [];\n\t      }\n\t    },\n\t    _handlePrimaryEnd: function () {\n\t      if (this._flushOnEnd) {\n\t        this._flush();\n\t      }\n\t      this._emitEnd();\n\t    },\n\t    _handlePrimaryValue: function (x) {\n\t      this._buff.push(x);\n\t      if (this._lastSecondary !== NOTHING && !this._lastSecondary) {\n\t        this._flush();\n\t      }\n\t    },\n\t    _handleSecondaryEnd: function () {\n\t      if (!this._flushOnEnd && (this._lastSecondary === NOTHING || this._lastSecondary)) {\n\t        this._emitEnd();\n\t      }\n\t    },\n\t    _handleSecondaryValue: function (x) {\n\t      if (this._flushOnChange && !x) {\n\t        this._flush();\n\t      }\n\t\n\t      // from default _handleSecondaryValue\n\t      this._lastSecondary = x;\n\t    }\n\t  };\n\t\n\t  var S$38 = createStream$1('bufferWhileBy', mixin$30);\n\t  var P$33 = createProperty$1('bufferWhileBy', mixin$30);\n\t\n\t  function bufferWhileBy(primary, secondary, options /* optional */) {\n\t    return new (primary._ofSameType(S$38, P$33))(primary, secondary, options);\n\t  }\n\t\n\t  var f = function () {\n\t    return false;\n\t  };\n\t  var t = function () {\n\t    return true;\n\t  };\n\t\n\t  function awaiting(a, b) {\n\t    var result = merge([map$1(a, t), map$1(b, f)]);\n\t    result = skipDuplicates(result);\n\t    result = toProperty(result, f);\n\t    return result.setName(a, 'awaiting');\n\t  }\n\t\n\t  var mixin$31 = {\n\t    _init: function (_ref) {\n\t      var fn = _ref.fn;\n\t\n\t      this._fn = fn;\n\t    },\n\t    _free: function () {\n\t      this._fn = null;\n\t    },\n\t    _handleValue: function (x) {\n\t      var fn = this._fn;\n\t      var result = fn(x);\n\t      if (result.convert) {\n\t        this._emitError(result.error);\n\t      } else {\n\t        this._emitValue(x);\n\t      }\n\t    }\n\t  };\n\t\n\t  var S$39 = createStream('valuesToErrors', mixin$31);\n\t  var P$34 = createProperty('valuesToErrors', mixin$31);\n\t\n\t  var defFn = function (x) {\n\t    return { convert: true, error: x };\n\t  };\n\t\n\t  function valuesToErrors(obs) {\n\t    var fn = arguments.length <= 1 || arguments[1] === undefined ? defFn : arguments[1];\n\t\n\t    return new (obs._ofSameType(S$39, P$34))(obs, { fn: fn });\n\t  }\n\t\n\t  var mixin$32 = {\n\t    _init: function (_ref) {\n\t      var fn = _ref.fn;\n\t\n\t      this._fn = fn;\n\t    },\n\t    _free: function () {\n\t      this._fn = null;\n\t    },\n\t    _handleError: function (x) {\n\t      var fn = this._fn;\n\t      var result = fn(x);\n\t      if (result.convert) {\n\t        this._emitValue(result.value);\n\t      } else {\n\t        this._emitError(x);\n\t      }\n\t    }\n\t  };\n\t\n\t  var S$40 = createStream('errorsToValues', mixin$32);\n\t  var P$35 = createProperty('errorsToValues', mixin$32);\n\t\n\t  var defFn$1 = function (x) {\n\t    return { convert: true, value: x };\n\t  };\n\t\n\t  function errorsToValues(obs) {\n\t    var fn = arguments.length <= 1 || arguments[1] === undefined ? defFn$1 : arguments[1];\n\t\n\t    return new (obs._ofSameType(S$40, P$35))(obs, { fn: fn });\n\t  }\n\t\n\t  var mixin$33 = {\n\t    _handleError: function (x) {\n\t      this._emitError(x);\n\t      this._emitEnd();\n\t    }\n\t  };\n\t\n\t  var S$41 = createStream('endOnError', mixin$33);\n\t  var P$36 = createProperty('endOnError', mixin$33);\n\t\n\t  function endOnError(obs) {\n\t    return new (obs._ofSameType(S$41, P$36))(obs);\n\t  }\n\t\n\t  Observable.prototype.toProperty = function (fn) {\n\t    return toProperty(this, fn);\n\t  };\n\t\n\t  Observable.prototype.changes = function () {\n\t    return changes(this);\n\t  };\n\t\n\t  Observable.prototype.toPromise = function (Promise) {\n\t    return toPromise(this, Promise);\n\t  };\n\t\n\t  Observable.prototype.toESObservable = toESObservable;\n\t  Observable.prototype[symbol_('observable')] = toESObservable;\n\t\n\t  Observable.prototype.map = function (fn) {\n\t    return map$1(this, fn);\n\t  };\n\t\n\t  Observable.prototype.filter = function (fn) {\n\t    return filter(this, fn);\n\t  };\n\t\n\t  Observable.prototype.take = function (n) {\n\t    return take(this, n);\n\t  };\n\t\n\t  Observable.prototype.takeErrors = function (n) {\n\t    return takeErrors(this, n);\n\t  };\n\t\n\t  Observable.prototype.takeWhile = function (fn) {\n\t    return takeWhile(this, fn);\n\t  };\n\t\n\t  Observable.prototype.last = function () {\n\t    return last(this);\n\t  };\n\t\n\t  Observable.prototype.skip = function (n) {\n\t    return skip(this, n);\n\t  };\n\t\n\t  Observable.prototype.skipWhile = function (fn) {\n\t    return skipWhile(this, fn);\n\t  };\n\t\n\t  Observable.prototype.skipDuplicates = function (fn) {\n\t    return skipDuplicates(this, fn);\n\t  };\n\t\n\t  Observable.prototype.diff = function (fn, seed) {\n\t    return diff(this, fn, seed);\n\t  };\n\t\n\t  Observable.prototype.scan = function (fn, seed) {\n\t    return scan(this, fn, seed);\n\t  };\n\t\n\t  Observable.prototype.flatten = function (fn) {\n\t    return flatten(this, fn);\n\t  };\n\t\n\t  Observable.prototype.delay = function (wait) {\n\t    return delay(this, wait);\n\t  };\n\t\n\t  Observable.prototype.throttle = function (wait, options) {\n\t    return throttle(this, wait, options);\n\t  };\n\t\n\t  Observable.prototype.debounce = function (wait, options) {\n\t    return debounce(this, wait, options);\n\t  };\n\t\n\t  Observable.prototype.mapErrors = function (fn) {\n\t    return mapErrors(this, fn);\n\t  };\n\t\n\t  Observable.prototype.filterErrors = function (fn) {\n\t    return filterErrors(this, fn);\n\t  };\n\t\n\t  Observable.prototype.ignoreValues = function () {\n\t    return ignoreValues(this);\n\t  };\n\t\n\t  Observable.prototype.ignoreErrors = function () {\n\t    return ignoreErrors(this);\n\t  };\n\t\n\t  Observable.prototype.ignoreEnd = function () {\n\t    return ignoreEnd(this);\n\t  };\n\t\n\t  Observable.prototype.beforeEnd = function (fn) {\n\t    return beforeEnd(this, fn);\n\t  };\n\t\n\t  Observable.prototype.slidingWindow = function (max, min) {\n\t    return slidingWindow(this, max, min);\n\t  };\n\t\n\t  Observable.prototype.bufferWhile = function (fn, options) {\n\t    return bufferWhile(this, fn, options);\n\t  };\n\t\n\t  Observable.prototype.bufferWithCount = function (count, options) {\n\t    return bufferWhile$1(this, count, options);\n\t  };\n\t\n\t  Observable.prototype.bufferWithTimeOrCount = function (wait, count, options) {\n\t    return bufferWithTimeOrCount(this, wait, count, options);\n\t  };\n\t\n\t  Observable.prototype.transduce = function (transducer) {\n\t    return transduce(this, transducer);\n\t  };\n\t\n\t  Observable.prototype.withHandler = function (fn) {\n\t    return withHandler(this, fn);\n\t  };\n\t\n\t  Observable.prototype.combine = function (other, combinator) {\n\t    return combine([this, other], combinator);\n\t  };\n\t\n\t  Observable.prototype.zip = function (other, combinator) {\n\t    return zip([this, other], combinator);\n\t  };\n\t\n\t  Observable.prototype.merge = function (other) {\n\t    return merge([this, other]);\n\t  };\n\t\n\t  Observable.prototype.concat = function (other) {\n\t    return concat$1([this, other]);\n\t  };\n\t\n\t  var pool = function () {\n\t    return new Pool();\n\t  };\n\t\n\t  Observable.prototype.flatMap = function (fn) {\n\t    return new FlatMap(this, fn).setName(this, 'flatMap');\n\t  };\n\t  Observable.prototype.flatMapLatest = function (fn) {\n\t    return new FlatMap(this, fn, { concurLim: 1, drop: 'old' }).setName(this, 'flatMapLatest');\n\t  };\n\t  Observable.prototype.flatMapFirst = function (fn) {\n\t    return new FlatMap(this, fn, { concurLim: 1 }).setName(this, 'flatMapFirst');\n\t  };\n\t  Observable.prototype.flatMapConcat = function (fn) {\n\t    return new FlatMap(this, fn, { queueLim: -1, concurLim: 1 }).setName(this, 'flatMapConcat');\n\t  };\n\t  Observable.prototype.flatMapConcurLimit = function (fn, limit) {\n\t    return new FlatMap(this, fn, { queueLim: -1, concurLim: limit }).setName(this, 'flatMapConcurLimit');\n\t  };\n\t\n\t  Observable.prototype.flatMapErrors = function (fn) {\n\t    return new FlatMapErrors(this, fn).setName(this, 'flatMapErrors');\n\t  };\n\t\n\t  Observable.prototype.filterBy = function (other) {\n\t    return filterBy(this, other);\n\t  };\n\t\n\t  Observable.prototype.sampledBy = function (other, combinator) {\n\t    return sampledBy(this, other, combinator);\n\t  };\n\t\n\t  Observable.prototype.skipUntilBy = function (other) {\n\t    return skipUntilBy(this, other);\n\t  };\n\t\n\t  Observable.prototype.takeUntilBy = function (other) {\n\t    return takeUntilBy(this, other);\n\t  };\n\t\n\t  Observable.prototype.bufferBy = function (other, options) {\n\t    return bufferBy(this, other, options);\n\t  };\n\t\n\t  Observable.prototype.bufferWhileBy = function (other, options) {\n\t    return bufferWhileBy(this, other, options);\n\t  };\n\t\n\t  // Deprecated\n\t  // -----------------------------------------------------------------------------\n\t\n\t  function warn(msg) {\n\t    if (Kefir.DEPRECATION_WARNINGS !== false && console && typeof console.warn === 'function') {\n\t      var msg2 = '\\nHere is an Error object for you containing the call stack:';\n\t      console.warn(msg, msg2, new Error());\n\t    }\n\t  }\n\t\n\t  Observable.prototype.awaiting = function (other) {\n\t    warn('You are using deprecated .awaiting() method, see https://github.com/rpominov/kefir/issues/145');\n\t    return awaiting(this, other);\n\t  };\n\t\n\t  Observable.prototype.valuesToErrors = function (fn) {\n\t    warn('You are using deprecated .valuesToErrors() method, see https://github.com/rpominov/kefir/issues/149');\n\t    return valuesToErrors(this, fn);\n\t  };\n\t\n\t  Observable.prototype.errorsToValues = function (fn) {\n\t    warn('You are using deprecated .errorsToValues() method, see https://github.com/rpominov/kefir/issues/149');\n\t    return errorsToValues(this, fn);\n\t  };\n\t\n\t  Observable.prototype.endOnError = function () {\n\t    warn('You are using deprecated .endOnError() method, see https://github.com/rpominov/kefir/issues/150');\n\t    return endOnError(this);\n\t  };\n\t\n\t  // Exports\n\t  // --------------------------------------------------------------------------\n\t\n\t  var Kefir = { Observable: Observable, Stream: Stream, Property: Property, never: never, later: later, interval: interval, sequentially: sequentially,\n\t    fromPoll: fromPoll, withInterval: withInterval, fromCallback: fromCallback, fromNodeCallback: fromNodeCallback, fromEvents: fromEvents, stream: stream,\n\t    constant: constant, constantError: constantError, fromPromise: fromPromise, fromESObservable: fromESObservable, combine: combine, zip: zip, merge: merge,\n\t    concat: concat$1, Pool: Pool, pool: pool, repeat: repeat };\n\t\n\t  Kefir.Kefir = Kefir;\n\t\n\t  exports.Kefir = Kefir;\n\t  exports.Observable = Observable;\n\t  exports.Stream = Stream;\n\t  exports.Property = Property;\n\t  exports.never = never;\n\t  exports.later = later;\n\t  exports.interval = interval;\n\t  exports.sequentially = sequentially;\n\t  exports.fromPoll = fromPoll;\n\t  exports.withInterval = withInterval;\n\t  exports.fromCallback = fromCallback;\n\t  exports.fromNodeCallback = fromNodeCallback;\n\t  exports.fromEvents = fromEvents;\n\t  exports.stream = stream;\n\t  exports.constant = constant;\n\t  exports.constantError = constantError;\n\t  exports.fromPromise = fromPromise;\n\t  exports.fromESObservable = fromESObservable;\n\t  exports.combine = combine;\n\t  exports.zip = zip;\n\t  exports.merge = merge;\n\t  exports.concat = concat$1;\n\t  exports.Pool = Pool;\n\t  exports.pool = pool;\n\t  exports.repeat = repeat;\n\t  exports['default'] = Kefir;\n\t\n\t}));\n\n/***/ },\n/* 11 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\texports.Atom = exports.LensedAtom = exports.AbstractMutable = undefined;\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tvar _kefir = __webpack_require__(10);\n\t\n\tvar _kefir2 = _interopRequireDefault(_kefir);\n\t\n\tvar _partial = __webpack_require__(12);\n\t\n\tvar _partial2 = _interopRequireDefault(_partial);\n\t\n\tvar _ramda = __webpack_require__(8);\n\t\n\tvar _ramda2 = _interopRequireDefault(_ramda);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\t\n\tfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\t\n\t//\n\t\n\tvar AbstractMutable = exports.AbstractMutable = function (_Kefir$Property) {\n\t  _inherits(AbstractMutable, _Kefir$Property);\n\t\n\t  function AbstractMutable() {\n\t    _classCallCheck(this, AbstractMutable);\n\t\n\t    return _possibleConstructorReturn(this, Object.getPrototypeOf(AbstractMutable).apply(this, arguments));\n\t  }\n\t\n\t  _createClass(AbstractMutable, [{\n\t    key: \"set\",\n\t    value: function set(value) {\n\t      this.modify(function () {\n\t        return value;\n\t      });\n\t    }\n\t  }, {\n\t    key: \"lens\",\n\t    value: function lens(l) {\n\t      for (var _len = arguments.length, ls = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n\t        ls[_key - 1] = arguments[_key];\n\t      }\n\t\n\t      return new LensedAtom(this, ls.length === 0 ? l : _partial2.default.apply(undefined, [l].concat(ls)));\n\t    }\n\t  }, {\n\t    key: \"view\",\n\t    value: function view(l) {\n\t      for (var _len2 = arguments.length, ls = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n\t        ls[_key2 - 1] = arguments[_key2];\n\t      }\n\t\n\t      return this.lens.apply(this, [l].concat(ls));\n\t    }\n\t  }, {\n\t    key: \"_maybeEmitValue\",\n\t    value: function _maybeEmitValue(next) {\n\t      var prev = this._currentEvent;\n\t      if (!prev || !_ramda2.default.equals(prev.value, next)) this._emitValue(next);\n\t    }\n\t  }]);\n\t\n\t  return AbstractMutable;\n\t}(_kefir2.default.Property);\n\t\n\t//\n\t\n\tvar LensedAtom = exports.LensedAtom = function (_AbstractMutable) {\n\t  _inherits(LensedAtom, _AbstractMutable);\n\t\n\t  function LensedAtom(source, lens) {\n\t    _classCallCheck(this, LensedAtom);\n\t\n\t    var _this2 = _possibleConstructorReturn(this, Object.getPrototypeOf(LensedAtom).call(this));\n\t\n\t    _this2._source = source;\n\t    _this2._lens = lens;\n\t    _this2._$handleValue = null;\n\t    return _this2;\n\t  }\n\t\n\t  _createClass(LensedAtom, [{\n\t    key: \"get\",\n\t    value: function get() {\n\t      return _partial2.default.view(this._lens, this._source.get());\n\t    }\n\t  }, {\n\t    key: \"modify\",\n\t    value: function modify(fn) {\n\t      this._source.modify(_partial2.default.over(this._lens, fn));\n\t    }\n\t  }, {\n\t    key: \"_handleValue\",\n\t    value: function _handleValue(context) {\n\t      this._maybeEmitValue(_partial2.default.view(this._lens, context));\n\t    }\n\t  }, {\n\t    key: \"_onActivation\",\n\t    value: function _onActivation() {\n\t      var _this3 = this;\n\t\n\t      var handleValue = function handleValue(value) {\n\t        return _this3._handleValue(value);\n\t      };\n\t      this._$handleValue = handleValue;\n\t      this._source.onValue(handleValue);\n\t    }\n\t  }, {\n\t    key: \"_onDeactivation\",\n\t    value: function _onDeactivation() {\n\t      this._source.offValue(this._$handleValue);\n\t      this._$handleValue = null;\n\t      this._currentEvent = null;\n\t    }\n\t  }]);\n\t\n\t  return LensedAtom;\n\t}(AbstractMutable);\n\t\n\t//\n\t\n\tvar Atom = exports.Atom = function (_AbstractMutable2) {\n\t  _inherits(Atom, _AbstractMutable2);\n\t\n\t  function Atom(value) {\n\t    _classCallCheck(this, Atom);\n\t\n\t    var _this4 = _possibleConstructorReturn(this, Object.getPrototypeOf(Atom).call(this));\n\t\n\t    _this4._emitValue(value);\n\t    return _this4;\n\t  }\n\t\n\t  _createClass(Atom, [{\n\t    key: \"get\",\n\t    value: function get() {\n\t      return this._currentEvent.value;\n\t    }\n\t  }, {\n\t    key: \"modify\",\n\t    value: function modify(fn) {\n\t      this._maybeEmitValue(fn(this.get()));\n\t    }\n\t  }]);\n\t\n\t  return Atom;\n\t}(AbstractMutable);\n\t\n\t//\n\t\n\texports.default = function (value) {\n\t  return new Atom(value);\n\t};\n\t//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9rZWZpci5hdG9tLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7SUFNYTs7Ozs7Ozs7Ozs7d0JBQ1AsT0FBTztBQUNULFdBQUssTUFBTCxDQUFZO2VBQU07T0FBTixDQUFaLENBRFM7Ozs7eUJBR04sR0FBVTt3Q0FBSjs7T0FBSTs7QUFDYixhQUFPLElBQUksVUFBSixDQUFlLElBQWYsRUFBcUIsR0FBRyxNQUFILEtBQWMsQ0FBZCxHQUFrQixDQUFsQixHQUFzQixvQ0FBRSxVQUFNLEdBQVIsQ0FBdEIsQ0FBNUIsQ0FEYTs7Ozt5QkFHVixHQUFVO3lDQUFKOztPQUFJOztBQUNiLGFBQU8sS0FBSyxJQUFMLGNBQVUsVUFBTSxHQUFoQixDQUFQLENBRGE7Ozs7b0NBR0MsTUFBTTtBQUNwQixVQUFNLE9BQU8sS0FBSyxhQUFMLENBRE87QUFFcEIsVUFBSSxDQUFDLElBQUQsSUFBUyxDQUFDLGdCQUFFLE1BQUYsQ0FBUyxLQUFLLEtBQUwsRUFBWSxJQUFyQixDQUFELEVBQ1gsS0FBSyxVQUFMLENBQWdCLElBQWhCLEVBREY7Ozs7U0FaUztFQUF3QixnQkFBTSxRQUFOOzs7O0lBbUJ4Qjs7O0FBQ1gsV0FEVyxVQUNYLENBQVksTUFBWixFQUFvQixJQUFwQixFQUEwQjswQkFEZixZQUNlOzt3RUFEZix3QkFDZTs7QUFFeEIsV0FBSyxPQUFMLEdBQWUsTUFBZixDQUZ3QjtBQUd4QixXQUFLLEtBQUwsR0FBYSxJQUFiLENBSHdCO0FBSXhCLFdBQUssYUFBTCxHQUFxQixJQUFyQixDQUp3Qjs7R0FBMUI7O2VBRFc7OzBCQU9MO0FBQ0osYUFBTyxrQkFBRSxJQUFGLENBQU8sS0FBSyxLQUFMLEVBQVksS0FBSyxPQUFMLENBQWEsR0FBYixFQUFuQixDQUFQLENBREk7Ozs7MkJBR0MsSUFBSTtBQUNULFdBQUssT0FBTCxDQUFhLE1BQWIsQ0FBb0Isa0JBQUUsSUFBRixDQUFPLEtBQUssS0FBTCxFQUFZLEVBQW5CLENBQXBCLEVBRFM7Ozs7aUNBR0UsU0FBUztBQUNwQixXQUFLLGVBQUwsQ0FBcUIsa0JBQUUsSUFBRixDQUFPLEtBQUssS0FBTCxFQUFZLE9BQW5CLENBQXJCLEVBRG9COzs7O29DQUdOOzs7QUFDZCxVQUFNLGNBQWMsU0FBZCxXQUFjO2VBQVMsT0FBSyxZQUFMLENBQWtCLEtBQWxCO09BQVQsQ0FETjtBQUVkLFdBQUssYUFBTCxHQUFxQixXQUFyQixDQUZjO0FBR2QsV0FBSyxPQUFMLENBQWEsT0FBYixDQUFxQixXQUFyQixFQUhjOzs7O3NDQUtFO0FBQ2hCLFdBQUssT0FBTCxDQUFhLFFBQWIsQ0FBc0IsS0FBSyxhQUFMLENBQXRCLENBRGdCO0FBRWhCLFdBQUssYUFBTCxHQUFxQixJQUFyQixDQUZnQjtBQUdoQixXQUFLLGFBQUwsR0FBcUIsSUFBckIsQ0FIZ0I7Ozs7U0FyQlA7RUFBbUI7Ozs7SUE4Qm5COzs7QUFDWCxXQURXLElBQ1gsQ0FBWSxLQUFaLEVBQW1COzBCQURSLE1BQ1E7O3dFQURSLGtCQUNROztBQUVqQixXQUFLLFVBQUwsQ0FBZ0IsS0FBaEIsRUFGaUI7O0dBQW5COztlQURXOzswQkFLTDtBQUNKLGFBQU8sS0FBSyxhQUFMLENBQW1CLEtBQW5CLENBREg7Ozs7MkJBR0MsSUFBSTtBQUNULFdBQUssZUFBTCxDQUFxQixHQUFHLEtBQUssR0FBTCxFQUFILENBQXJCLEVBRFM7Ozs7U0FSQTtFQUFhOzs7O2tCQWVYO1NBQVMsSUFBSSxJQUFKLENBQVMsS0FBVDtDQUFUIiwiZmlsZSI6ImtlZmlyLmF0b20uanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgS2VmaXIgZnJvbSBcImtlZmlyXCJcbmltcG9ydCBMICAgICBmcm9tIFwicGFydGlhbC5sZW5zZXNcIlxuaW1wb3J0IFIgICAgIGZyb20gXCJyYW1kYVwiXG5cbi8vXG5cbmV4cG9ydCBjbGFzcyBBYnN0cmFjdE11dGFibGUgZXh0ZW5kcyBLZWZpci5Qcm9wZXJ0eSB7XG4gIHNldCh2YWx1ZSkge1xuICAgIHRoaXMubW9kaWZ5KCgpID0+IHZhbHVlKVxuICB9XG4gIGxlbnMobCwgLi4ubHMpIHtcbiAgICByZXR1cm4gbmV3IExlbnNlZEF0b20odGhpcywgbHMubGVuZ3RoID09PSAwID8gbCA6IEwobCwgLi4ubHMpKVxuICB9XG4gIHZpZXcobCwgLi4ubHMpIHtcbiAgICByZXR1cm4gdGhpcy5sZW5zKGwsIC4uLmxzKVxuICB9XG4gIF9tYXliZUVtaXRWYWx1ZShuZXh0KSB7XG4gICAgY29uc3QgcHJldiA9IHRoaXMuX2N1cnJlbnRFdmVudFxuICAgIGlmICghcHJldiB8fCAhUi5lcXVhbHMocHJldi52YWx1ZSwgbmV4dCkpXG4gICAgICB0aGlzLl9lbWl0VmFsdWUobmV4dClcbiAgfVxufVxuXG4vL1xuXG5leHBvcnQgY2xhc3MgTGVuc2VkQXRvbSBleHRlbmRzIEFic3RyYWN0TXV0YWJsZSB7XG4gIGNvbnN0cnVjdG9yKHNvdXJjZSwgbGVucykge1xuICAgIHN1cGVyKClcbiAgICB0aGlzLl9zb3VyY2UgPSBzb3VyY2VcbiAgICB0aGlzLl9sZW5zID0gbGVuc1xuICAgIHRoaXMuXyRoYW5kbGVWYWx1ZSA9IG51bGxcbiAgfVxuICBnZXQoKSB7XG4gICAgcmV0dXJuIEwudmlldyh0aGlzLl9sZW5zLCB0aGlzLl9zb3VyY2UuZ2V0KCkpXG4gIH1cbiAgbW9kaWZ5KGZuKSB7XG4gICAgdGhpcy5fc291cmNlLm1vZGlmeShMLm92ZXIodGhpcy5fbGVucywgZm4pKVxuICB9XG4gIF9oYW5kbGVWYWx1ZShjb250ZXh0KSB7XG4gICAgdGhpcy5fbWF5YmVFbWl0VmFsdWUoTC52aWV3KHRoaXMuX2xlbnMsIGNvbnRleHQpKVxuICB9XG4gIF9vbkFjdGl2YXRpb24oKSB7XG4gICAgY29uc3QgaGFuZGxlVmFsdWUgPSB2YWx1ZSA9PiB0aGlzLl9oYW5kbGVWYWx1ZSh2YWx1ZSlcbiAgICB0aGlzLl8kaGFuZGxlVmFsdWUgPSBoYW5kbGVWYWx1ZVxuICAgIHRoaXMuX3NvdXJjZS5vblZhbHVlKGhhbmRsZVZhbHVlKVxuICB9XG4gIF9vbkRlYWN0aXZhdGlvbigpIHtcbiAgICB0aGlzLl9zb3VyY2Uub2ZmVmFsdWUodGhpcy5fJGhhbmRsZVZhbHVlKVxuICAgIHRoaXMuXyRoYW5kbGVWYWx1ZSA9IG51bGxcbiAgICB0aGlzLl9jdXJyZW50RXZlbnQgPSBudWxsXG4gIH1cbn1cblxuLy9cblxuZXhwb3J0IGNsYXNzIEF0b20gZXh0ZW5kcyBBYnN0cmFjdE11dGFibGUge1xuICBjb25zdHJ1Y3Rvcih2YWx1ZSkge1xuICAgIHN1cGVyKClcbiAgICB0aGlzLl9lbWl0VmFsdWUodmFsdWUpXG4gIH1cbiAgZ2V0KCkge1xuICAgIHJldHVybiB0aGlzLl9jdXJyZW50RXZlbnQudmFsdWVcbiAgfVxuICBtb2RpZnkoZm4pIHtcbiAgICB0aGlzLl9tYXliZUVtaXRWYWx1ZShmbih0aGlzLmdldCgpKSlcbiAgfVxufVxuXG4vL1xuXG5leHBvcnQgZGVmYXVsdCB2YWx1ZSA9PiBuZXcgQXRvbSh2YWx1ZSlcbiJdfQ==\n\n/***/ },\n/* 12 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\texports.lift = undefined;\n\t\n\tvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\t\n\tvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol ? \"symbol\" : typeof obj; };\n\t\n\tvar _ramda = __webpack_require__(8);\n\t\n\tvar _ramda2 = _interopRequireDefault(_ramda);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\t\n\tfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\t\n\t//\n\t\n\tvar deleteKey = function deleteKey(k, o) {\n\t  if (o === undefined || !(k in o)) return o;\n\t  var r = undefined;\n\t  for (var p in o) {\n\t    if (p !== k) {\n\t      if (undefined === r) r = {};\n\t      r[p] = o[p];\n\t    }\n\t  }\n\t  return r;\n\t};\n\t\n\tvar setKey = function setKey(k, v, o) {\n\t  if (o === undefined) return _defineProperty({}, k, v);\n\t  if (k in o && _ramda2.default.equals(v, o[k])) return o;\n\t  var r = _defineProperty({}, k, v);\n\t  for (var p in o) {\n\t    if (p !== k) r[p] = o[p];\n\t  }return r;\n\t};\n\t\n\t//\n\t\n\tvar dropped = function dropped(xs) {\n\t  return Object.keys(xs).length === 0 ? undefined : xs;\n\t};\n\t\n\t//\n\t\n\tvar toPartial = function toPartial(transform) {\n\t  return function (x) {\n\t    return undefined === x ? x : transform(x);\n\t  };\n\t};\n\t\n\t//\n\t\n\tvar conserve = function conserve(c0, c1) {\n\t  return _ramda2.default.equals(c0, c1) ? c0 : c1;\n\t};\n\t\n\tvar toConserve = function toConserve(f) {\n\t  return function (y, c0) {\n\t    return conserve(c0, f(y, c0));\n\t  };\n\t};\n\t\n\t//\n\t\n\tvar lift = exports.lift = function lift(l) {\n\t  switch (typeof l === \"undefined\" ? \"undefined\" : _typeof(l)) {\n\t    case \"string\":\n\t      return L.prop(l);\n\t    case \"number\":\n\t      return L.index(l);\n\t    default:\n\t      return l;\n\t  }\n\t};\n\t\n\tvar L = function L(l) {\n\t  for (var _len = arguments.length, ls = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n\t    ls[_key - 1] = arguments[_key];\n\t  }\n\t\n\t  return ls.length === 0 ? lift(l) : _ramda2.default.compose.apply(_ramda2.default, [lift(l)].concat(_toConsumableArray(ls.map(lift))));\n\t};\n\t\n\tL.compose = L;\n\tL.delete = _ramda2.default.curry(function (l, s) {\n\t  return _ramda2.default.set(lift(l), undefined, s);\n\t});\n\tL.deleteAll = _ramda2.default.curry(function (lens, data) {\n\t  while (L.view(lens, data) !== undefined) {\n\t    data = L.delete(lens, data);\n\t  }return data;\n\t});\n\tL.lens = _ramda2.default.lens;\n\tL.over = _ramda2.default.curry(function (l, x2x, s) {\n\t  return _ramda2.default.over(lift(l), x2x, s);\n\t});\n\tL.set = _ramda2.default.curry(function (l, x, s) {\n\t  return _ramda2.default.set(lift(l), x, s);\n\t});\n\tL.view = _ramda2.default.curry(function (l, s) {\n\t  return _ramda2.default.view(lift(l), s);\n\t});\n\t\n\tL.choose = function (x2yL) {\n\t  return function (toFunctor) {\n\t    return function (target) {\n\t      var l = lift(x2yL(target));\n\t      return _ramda2.default.map(function (focus) {\n\t        return _ramda2.default.set(l, focus, target);\n\t      }, toFunctor(_ramda2.default.view(l, target)));\n\t    };\n\t  };\n\t};\n\t\n\tL.firstOf = function (l) {\n\t  for (var _len2 = arguments.length, ls = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n\t    ls[_key2 - 1] = arguments[_key2];\n\t  }\n\t\n\t  return L.choose(function (x) {\n\t    var lls = [l].concat(ls);\n\t    return lls[Math.max(0, lls.findIndex(function (l) {\n\t      return L.view(l, x) !== undefined;\n\t    }))];\n\t  });\n\t};\n\t\n\tL.replace = _ramda2.default.curry(function (inn, out) {\n\t  return _ramda2.default.lens(function (x) {\n\t    return _ramda2.default.equals(x, inn) ? out : x;\n\t  }, toConserve(function (y) {\n\t    return _ramda2.default.equals(y, out) ? inn : y;\n\t  }));\n\t});\n\t\n\tL.default = L.replace(undefined);\n\tL.required = function (inn) {\n\t  return L.replace(inn, undefined);\n\t};\n\tL.define = function (v) {\n\t  return _ramda2.default.compose(L.required(v), L.default(v));\n\t};\n\t\n\tL.normalize = function (transform) {\n\t  return _ramda2.default.lens(toPartial(transform), toConserve(toPartial(transform)));\n\t};\n\t\n\tL.prop = function (k) {\n\t  return _ramda2.default.lens(function (o) {\n\t    return o && o[k];\n\t  }, function (v, o) {\n\t    return v === undefined ? deleteKey(k, o) : setKey(k, v, o);\n\t  });\n\t};\n\t\n\tL.find = function (predicate) {\n\t  return L.choose(function (xs) {\n\t    if (xs === undefined) return L.append;\n\t    var i = xs.findIndex(predicate);\n\t    return i < 0 ? L.append : i;\n\t  });\n\t};\n\t\n\tL.findWith = function (l) {\n\t  for (var _len3 = arguments.length, ls = Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {\n\t    ls[_key3 - 1] = arguments[_key3];\n\t  }\n\t\n\t  var lls = L.apply(undefined, [l].concat(ls));\n\t  return L(L.find(function (x) {\n\t    return L.view(lls, x) !== undefined;\n\t  }), lls);\n\t};\n\t\n\tL.index = function (i) {\n\t  return _ramda2.default.lens(function (xs) {\n\t    return xs && xs[i];\n\t  }, function (x, xs) {\n\t    if (x === undefined) {\n\t      if (xs === undefined) return undefined;\n\t      if (i < xs.length) return dropped(xs.slice(0, i).concat(xs.slice(i + 1)));\n\t      return xs;\n\t    } else {\n\t      if (xs === undefined) return Array(i).concat([x]);\n\t      if (xs.length <= i) return xs.concat(Array(i - xs.length), [x]);\n\t      if (_ramda2.default.equals(x, xs[i])) return xs;\n\t      return xs.slice(0, i).concat([x], xs.slice(i + 1));\n\t    }\n\t  });\n\t};\n\t\n\tL.append = _ramda2.default.lens(function () {}, function (x, xs) {\n\t  return x === undefined ? xs : xs === undefined ? [x] : xs.concat([x]);\n\t});\n\t\n\tL.filter = function (p) {\n\t  return _ramda2.default.lens(function (xs) {\n\t    return xs && xs.filter(p);\n\t  }, function (ys, xs) {\n\t    return conserve(xs, dropped(_ramda2.default.concat(ys || [], (xs || []).filter(_ramda2.default.complement(p)))));\n\t  });\n\t};\n\t\n\tL.augment = function (template) {\n\t  return _ramda2.default.lens(toPartial(function (x) {\n\t    var z = _extends({}, x);\n\t    for (var k in template) {\n\t      z[k] = template[k](x);\n\t    }return z;\n\t  }), toConserve(function (y, c) {\n\t    if (y === undefined) return undefined;\n\t    var z = undefined;\n\t    var set = function set(k, v) {\n\t      if (undefined === z) z = {};\n\t      z[k] = v;\n\t    };\n\t    for (var k in y) {\n\t      if (!(k in template)) set(k, y[k]);else if (k in c) set(k, c[k]);\n\t    }\n\t    return z;\n\t  }));\n\t};\n\t\n\texports.default = L;\n\t//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9wYXJ0aWFsLmxlbnNlcy5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUlBLElBQU0sWUFBWSxTQUFaLFNBQVksQ0FBQyxDQUFELEVBQUksQ0FBSixFQUFVO0FBQzFCLE1BQUksTUFBTSxTQUFOLElBQW1CLEVBQUUsS0FBSyxDQUFMLENBQUYsRUFDckIsT0FBTyxDQUFQLENBREY7QUFFQSxNQUFJLGFBQUosQ0FIMEI7QUFJMUIsT0FBSyxJQUFNLENBQU4sSUFBVyxDQUFoQixFQUFtQjtBQUNqQixRQUFJLE1BQU0sQ0FBTixFQUFTO0FBQ1gsVUFBSSxjQUFjLENBQWQsRUFDRixJQUFJLEVBQUosQ0FERjtBQUVBLFFBQUUsQ0FBRixJQUFPLEVBQUUsQ0FBRixDQUFQLENBSFc7S0FBYjtHQURGO0FBT0EsU0FBTyxDQUFQLENBWDBCO0NBQVY7O0FBY2xCLElBQU0sU0FBUyxTQUFULE1BQVMsQ0FBQyxDQUFELEVBQUksQ0FBSixFQUFPLENBQVAsRUFBYTtBQUMxQixNQUFJLE1BQU0sU0FBTixFQUNGLDJCQUFTLEdBQUksRUFBYixDQURGO0FBRUEsTUFBSSxLQUFLLENBQUwsSUFBVSxnQkFBRSxNQUFGLENBQVMsQ0FBVCxFQUFZLEVBQUUsQ0FBRixDQUFaLENBQVYsRUFDRixPQUFPLENBQVAsQ0FERjtBQUVBLE1BQU0sd0JBQU0sR0FBSSxFQUFWLENBTG9CO0FBTTFCLE9BQUssSUFBTSxDQUFOLElBQVcsQ0FBaEI7QUFDRSxRQUFJLE1BQU0sQ0FBTixFQUNGLEVBQUUsQ0FBRixJQUFPLEVBQUUsQ0FBRixDQUFQLENBREY7R0FERixPQUdPLENBQVAsQ0FUMEI7Q0FBYjs7OztBQWNmLElBQU0sVUFBVSxTQUFWLE9BQVU7U0FBTSxPQUFPLElBQVAsQ0FBWSxFQUFaLEVBQWdCLE1BQWhCLEtBQTJCLENBQTNCLEdBQStCLFNBQS9CLEdBQTJDLEVBQTNDO0NBQU47Ozs7QUFJaEIsSUFBTSxZQUFZLFNBQVosU0FB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QUFFQSxRQUFJLGFBQUosQ0FIbUI7QUFJbkIsUUFBTSxNQUFNLFNBQU4sR0FBTSxDQUFDLENBQUQsRUFBSSxDQUFKLEVBQVU7QUFDcEIsVUFBSSxjQUFjLENBQWQsRUFDRixJQUFJLEVBQUosQ0FERjtBQUVBLFFBQUUsQ0FBRixJQUFPLENBQVAsQ0FIb0I7S0FBVixDQUpPO0FBU25CLFNBQUssSUFBTSxDQUFOLElBQVcsQ0FBaEIsRUFBbUI7QUFDakIsVUFBSSxFQUFFLEtBQUssUUFBTCxDQUFGLEVBQ0YsSUFBSSxDQUFKLEVBQU8sRUFBRSxDQUFGLENBQVAsRUFERixLQUdFLElBQUksS0FBSyxDQUFMLEVBQ0YsSUFBSSxDQUFKLEVBQU8sRUFBRSxDQUFGLENBQVAsRUFERjtLQUpKO0FBT0EsV0FBTyxDQUFQLENBaEJtQjtHQUFWLENBUFc7Q0FBWjs7a0JBMEJHIiwiZmlsZSI6InBhcnRpYWwubGVuc2VzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFIgZnJvbSBcInJhbWRhXCJcblxuLy9cblxuY29uc3QgZGVsZXRlS2V5ID0gKGssIG8pID0+IHtcbiAgaWYgKG8gPT09IHVuZGVmaW5lZCB8fCAhKGsgaW4gbykpXG4gICAgcmV0dXJuIG9cbiAgbGV0IHJcbiAgZm9yIChjb25zdCBwIGluIG8pIHtcbiAgICBpZiAocCAhPT0gaykge1xuICAgICAgaWYgKHVuZGVmaW5lZCA9PT0gcilcbiAgICAgICAgciA9IHt9XG4gICAgICByW3BdID0gb1twXVxuICAgIH1cbiAgfVxuICByZXR1cm4gclxufVxuXG5jb25zdCBzZXRLZXkgPSAoaywgdiwgbykgPT4ge1xuICBpZiAobyA9PT0gdW5kZWZpbmVkKVxuICAgIHJldHVybiB7W2tdOiB2fVxuICBpZiAoayBpbiBvICYmIFIuZXF1YWxzKHYsIG9ba10pKVxuICAgIHJldHVybiBvXG4gIGNvbnN0IHIgPSB7W2tdOiB2fVxuICBmb3IgKGNvbnN0IHAgaW4gbylcbiAgICBpZiAocCAhPT0gaylcbiAgICAgIHJbcF0gPSBvW3BdXG4gIHJldHVybiByXG59XG5cbi8vXG5cbmNvbnN0IGRyb3BwZWQgPSB4cyA9PiBPYmplY3Qua2V5cyh4cykubGVuZ3RoID09PSAwID8gdW5kZWZpbmVkIDogeHNcblxuLy9cblxuY29uc3QgdG9QYXJ0aWFsID0gdHJhbnNmb3JtID0+IHggPT4gdW5kZWZpbmVkID09PSB4ID8geCA6IHRyYW5zZm9ybSh4KVxuXG4vL1xuXG5jb25zdCBjb25zZXJ2ZSA9IChjMCwgYzEpID0+IFIuZXF1YWxzKGMwLCBjMSkgPyBjMCA6IGMxXG5cbmNvbnN0IHRvQ29uc2VydmUgPSBmID0+ICh5LCBjMCkgPT4gY29uc2VydmUoYzAsIGYoeSwgYzApKVxuXG4vL1xuXG5leHBvcnQgY29uc3QgbGlmdCA9IGwgPT4ge1xuICBzd2l0Y2ggKHR5cGVvZiBsKSB7XG4gIGNhc2UgXCJzdHJpbmdcIjogcmV0dXJuIEwucHJvcChsKVxuICBjYXNlIFwibnVtYmVyXCI6IHJldHVybiBMLmluZGV4KGwpXG4gIGRlZmF1bHQ6ICAgICAgIHJldHVybiBsXG4gIH1cbn1cblxuY29uc3QgTCA9IChsLCAuLi5scykgPT5cbiAgbHMubGVuZ3RoID09PSAwID8gbGlmdChsKSA6IFIuY29tcG9zZShsaWZ0KGwpLCAuLi5scy5tYXAobGlmdCkpXG5cbkwuY29tcG9zZSA9IExcbkwuZGVsZXRlID0gUi5jdXJyeSgobCwgcykgPT4gUi5zZXQobGlmdChsKSwgdW5kZWZpbmVkLCBzKSlcbkwuZGVsZXRlQWxsID0gUi5jdXJyeSgobGVucywgZGF0YSkgPT4ge1xuICB3aGlsZSAoTC52aWV3KGxlbnMsIGRhdGEpICE9PSB1bmRlZmluZWQpXG4gICAgZGF0YSA9IEwuZGVsZXRlKGxlbnMsIGRhdGEpXG4gIHJldHVybiBkYXRhXG59KVxuTC5sZW5zID0gUi5sZW5zXG5MLm92ZXIgPSBSLmN1cnJ5KChsLCB4MngsIHMpID0+IFIub3ZlcihsaWZ0KGwpLCB4MngsIHMpKVxuTC5zZXQgPSBSLmN1cnJ5KChsLCB4LCBzKSA9PiBSLnNldChsaWZ0KGwpLCB4LCBzKSlcbkwudmlldyA9IFIuY3VycnkoKGwsIHMpID0+IFIudmlldyhsaWZ0KGwpLCBzKSlcblxuTC5jaG9vc2UgPSB4MnlMID0+IHRvRnVuY3RvciA9PiB0YXJnZXQgPT4ge1xuICBjb25zdCBsID0gbGlmdCh4MnlMKHRhcmdldCkpXG4gIHJldHVybiBSLm1hcChmb2N1cyA9PiBSLnNldChsLCBmb2N1cywgdGFyZ2V0KSwgdG9GdW5jdG9yKFIudmlldyhsLCB0YXJnZXQpKSlcbn1cblxuTC5maXJzdE9mID0gKGwsIC4uLmxzKSA9PiBMLmNob29zZSh4ID0+IHtcbiAgY29uc3QgbGxzID0gW2wsIC4uLmxzXVxuICByZXR1cm4gbGxzW01hdGgubWF4KDAsIGxscy5maW5kSW5kZXgobCA9PiBMLnZpZXcobCwgeCkgIT09IHVuZGVmaW5lZCkpXVxufSlcblxuTC5yZXBsYWNlID0gUi5jdXJyeSgoaW5uLCBvdXQpID0+XG4gIFIubGVucyh4ID0+IFIuZXF1YWxzKHgsIGlubikgPyBvdXQgOiB4LFxuICAgICAgICAgdG9Db25zZXJ2ZSh5ID0+IFIuZXF1YWxzKHksIG91dCkgPyBpbm4gOiB5KSkpXG5cbkwuZGVmYXVsdCA9IEwucmVwbGFjZSh1bmRlZmluZWQpXG5MLnJlcXVpcmVkID0gaW5uID0+IEwucmVwbGFjZShpbm4sIHVuZGVmaW5lZClcbkwuZGVmaW5lID0gdiA9PiBSLmNvbXBvc2UoTC5yZXF1aXJlZCh2KSwgTC5kZWZhdWx0KHYpKVxuXG5MLm5vcm1hbGl6ZSA9IHRyYW5zZm9ybSA9PlxuICBSLmxlbnModG9QYXJ0aWFsKHRyYW5zZm9ybSksIHRvQ29uc2VydmUodG9QYXJ0aWFsKHRyYW5zZm9ybSkpKVxuXG5MLnByb3AgPSBrID0+XG4gIFIubGVucyhvID0+IG8gJiYgb1trXSxcbiAgICAgICAgICh2LCBvKSA9PiB2ID09PSB1bmRlZmluZWQgPyBkZWxldGVLZXkoaywgbykgOiBzZXRLZXkoaywgdiwgbykpXG5cbkwuZmluZCA9IHByZWRpY2F0ZSA9PiBMLmNob29zZSh4cyA9PiB7XG4gIGlmICh4cyA9PT0gdW5kZWZpbmVkKVxuICAgIHJldHVybiBMLmFwcGVuZFxuICBjb25zdCBpID0geHMuZmluZEluZGV4KHByZWRpY2F0ZSlcbiAgcmV0dXJuIGkgPCAwID8gTC5hcHBlbmQgOiBpXG59KVxuXG5MLmZpbmRXaXRoID0gKGwsIC4uLmxzKSA9PiB7XG4gIGNvbnN0IGxscyA9IEwobCwgLi4ubHMpXG4gIHJldHVybiBMKEwuZmluZCh4ID0+IEwudmlldyhsbHMsIHgpICE9PSB1bmRlZmluZWQpLCBsbHMpXG59XG5cbkwuaW5kZXggPSBpID0+IFIubGVucyh4cyA9PiB4cyAmJiB4c1tpXSwgKHgsIHhzKSA9PiB7XG4gIGlmICh4ID09PSB1bmRlZmluZWQpIHtcbiAgICBpZiAoeHMgPT09IHVuZGVmaW5lZClcbiAgICAgIHJldHVybiB1bmRlZmluZWRcbiAgICBpZiAoaSA8IHhzLmxlbmd0aClcbiAgICAgIHJldHVybiBkcm9wcGVkKHhzLnNsaWNlKDAsIGkpLmNvbmNhdCh4cy5zbGljZShpKzEpKSlcbiAgICByZXR1cm4geHNcbiAgfSBlbHNlIHtcbiAgICBpZiAoeHMgPT09IHVuZGVmaW5lZClcbiAgICAgIHJldHVybiBBcnJheShpKS5jb25jYXQoW3hdKVxuICAgIGlmICh4cy5sZW5ndGggPD0gaSlcbiAgICAgIHJldHVybiB4cy5jb25jYXQoQXJyYXkoaSAtIHhzLmxlbmd0aCksIFt4XSlcbiAgICBpZiAoUi5lcXVhbHMoeCwgeHNbaV0pKVxuICAgICAgcmV0dXJuIHhzXG4gICAgcmV0dXJuIHhzLnNsaWNlKDAsIGkpLmNvbmNhdChbeF0sIHhzLnNsaWNlKGkrMSkpXG4gIH1cbn0pXG5cbkwuYXBwZW5kID0gUi5sZW5zKCgpID0+IHt9LCAoeCwgeHMpID0+XG4gIHggPT09IHVuZGVmaW5lZCA/IHhzIDogeHMgPT09IHVuZGVmaW5lZCA/IFt4XSA6IHhzLmNvbmNhdChbeF0pKVxuXG5MLmZpbHRlciA9IHAgPT4gUi5sZW5zKHhzID0+IHhzICYmIHhzLmZpbHRlcihwKSwgKHlzLCB4cykgPT5cbiAgY29uc2VydmUoeHMsIGRyb3BwZWQoUi5jb25jYXQoeXMgfHwgW10sICh4cyB8fCBbXSkuZmlsdGVyKFIuY29tcGxlbWVudChwKSkpKSkpXG5cbkwuYXVnbWVudCA9IHRlbXBsYXRlID0+IFIubGVucyhcbiAgdG9QYXJ0aWFsKHggPT4ge1xuICAgIGNvbnN0IHogPSB7Li4ueH1cbiAgICBmb3IgKGNvbnN0IGsgaW4gdGVtcGxhdGUpXG4gICAgICB6W2tdID0gdGVtcGxhdGVba10oeClcbiAgICByZXR1cm4gelxuICB9KSxcbiAgdG9Db25zZXJ2ZSgoeSwgYykgPT4ge1xuICAgIGlmICh5ID09PSB1bmRlZmluZWQpXG4gICAgICByZXR1cm4gdW5kZWZpbmVkXG4gICAgbGV0IHpcbiAgICBjb25zdCBzZXQgPSAoaywgdikgPT4ge1xuICAgICAgaWYgKHVuZGVmaW5lZCA9PT0geilcbiAgICAgICAgeiA9IHt9XG4gICAgICB6W2tdID0gdlxuICAgIH1cbiAgICBmb3IgKGNvbnN0IGsgaW4geSkge1xuICAgICAgaWYgKCEoayBpbiB0ZW1wbGF0ZSkpXG4gICAgICAgIHNldChrLCB5W2tdKVxuICAgICAgZWxzZVxuICAgICAgICBpZiAoayBpbiBjKVxuICAgICAgICAgIHNldChrLCBjW2tdKVxuICAgIH1cbiAgICByZXR1cm4gelxuICB9KSlcblxuZXhwb3J0IGRlZmF1bHQgTFxuIl19\n\n/***/ },\n/* 13 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\t(function () {\n\t  'use strict';\n\t\n\t  var ElementPrototype = Element.prototype;\n\t\n\t  /**\n\t   * Detect full support\n\t   */\n\t\n\t  var isSupported = ElementPrototype.after && ElementPrototype.append && ElementPrototype.before && ElementPrototype.prepend && ElementPrototype.remove && ElementPrototype.replace;\n\t\n\t  if (isSupported) {\n\t    return;\n\t  }\n\t\n\t  /**\n\t   * Apply mutation shims\n\t   */\n\t\n\t  function toNode(node) {\n\t    return typeof node === 'string' ? document.createTextNode(node) : node;\n\t  }\n\t\n\t  function mutationMacro(nodes) {\n\t    var fragment, i, len;\n\t    if (nodes) {\n\t      len = nodes.length;\n\t    }\n\t\n\t    if (!len) {\n\t      throw new Error('No node was specified (DOM Exception 8)');\n\t    }\n\t\n\t    if (len === 1) {\n\t      return toNode(nodes[0]);\n\t    } else {\n\t      fragment = document.createDocumentFragment();\n\t      for (i = 0; i < len; i++) {\n\t        fragment.appendChild(toNode(nodes[i]));\n\t      }\n\t      return fragment;\n\t    }\n\t  }\n\t\n\t  ElementPrototype.prepend = function prepend() {\n\t    this.insertBefore(mutationMacro(arguments), this.firstChild);\n\t  };\n\t\n\t  ElementPrototype.append = function append() {\n\t    this.appendChild(mutationMacro(arguments));\n\t  };\n\t\n\t  ElementPrototype.before = function before() {\n\t    var parentNode = this.parentNode;\n\t    if (parentNode) {\n\t      parentNode.insertBefore(mutationMacro(arguments), this);\n\t    }\n\t  };\n\t\n\t  ElementPrototype.after = function after() {\n\t    var parentNode = this.parentNode;\n\t    if (parentNode) {\n\t      parentNode.insertBefore(mutationMacro(arguments), this.nextSibling);\n\t    }\n\t  };\n\t\n\t  ElementPrototype.replace = function replace() {\n\t    var parentNode = this.parentNode;\n\t    if (parentNode) {\n\t      parentNode.replaceChild(mutationMacro(arguments), this);\n\t    }\n\t  };\n\t\n\t  /**\n\t   * This method is defined with bracket notation to avoid conflicting with the\n\t   * definition of HTMLSelectElement.\n\t   */\n\t  ElementPrototype['remove'] = function remove() {\n\t    var parentNode = this.parentNode;\n\t    if (parentNode) {\n\t      parentNode.removeChild(this);\n\t    }\n\t  };\n\t})();\n\n/***/ },\n/* 14 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// style-loader: Adds some css to the DOM by adding a <style> tag\n\t\n\t// load the styles\n\tvar content = __webpack_require__(15);\n\tif(typeof content === 'string') content = [[module.id, content, '']];\n\t// add the styles to the DOM\n\tvar update = __webpack_require__(17)(content, {});\n\tif(content.locals) module.exports = content.locals;\n\t// Hot Module Replacement\n\tif(false) {\n\t\t// When the styles change, update the <style> tags\n\t\tif(!content.locals) {\n\t\t\tmodule.hot.accept(\"!!./../node_modules/css-loader/index.js!./../node_modules/postcss-loader/index.js!./global.css\", function() {\n\t\t\t\tvar newContent = require(\"!!./../node_modules/css-loader/index.js!./../node_modules/postcss-loader/index.js!./global.css\");\n\t\t\t\tif(typeof newContent === 'string') newContent = [[module.id, newContent, '']];\n\t\t\t\tupdate(newContent);\n\t\t\t});\n\t\t}\n\t\t// When the module is disposed, remove the <style> tags\n\t\tmodule.hot.dispose(function() { update(); });\n\t}\n\n/***/ },\n/* 15 */\n/***/ function(module, exports, __webpack_require__) {\n\n\texports = module.exports = __webpack_require__(16)();\n\t// imports\n\t\n\t\n\t// module\n\texports.push([module.id, \"body,html{margin:0;background-color:#000;overflow:hidden;height:100%}canvas[resize]{width:100%;height:100%}video{width:100%}.draw{position:absolute;top:0;left:0}\", \"\"]);\n\t\n\t// exports\n\n\n/***/ }\n]);\n\n\n/** WEBPACK FOOTER **\n ** main.bundle.js\n **/","import paper from \"paper\"\nimport Story from \"./story\"\n\nimport {Kefir} from \"kefir\"\nimport Atom from \"kefir.atom\"\n\nimport R from \"ramda\"\n\nrequire(\"./Element.mutation.js\")\n\nwindow.R = R\nwindow.p = paper\n\nrequire(\"../css/global.css\")\n\nKefir.Observable.prototype.pluck = function(prop) {\n\treturn this.map(R.view(R.lensProp(prop)))\n}\n\n\nlet story = new Story()\n\nvar canvas = null\nvar container = null\n\n//var planet = null;\nvar graphene = null\nvar carbon = null\n\nvar video = null\n\nvar gobjects = []\n\nvar talk_text = null\n\nvar font_size = 22\n\n\nvar g_text = null\nvar c_text = null\n\nvar timeout_id = 0\n\nvar main_button = null\n\nvar volume = new Atom(0.5)\n\nstory.onBefore(\"end_true\",() => {\n\n\tstory.showDialogue = true\n\n\ttoggleCharacters(false)\n\tgraphene.visible = true\n\ttalk_text.visible = true\n\n\n\tgraphene.setPosition(paper.view.center)\n\ttalk_text.content = \"А ти какво научи от всико това?\"\t\n\tpaper.view.update(true)\n\n})\n\n//gala --replace\n\nstory.onBefore(\"test\",() => {\n\twindow.location.href = \"./test.html\"\n})\n\nvar resize = Kefir.fromEvents(window, \"resize\").toProperty(() => null)\n\t.map(() => {return {height: window.innerHeight, width: window.innerWidth}})\n\nvar center = resize.map(() => paper.view.center).toProperty(() => paper.view.center)\n\nfunction set(obj, prop){\n\treturn (val) => {\n\t\tobj[prop] = val\n\t}\n}\n\nwindow.createVolumeCtrl = () => {\n\tvar size = {\n\t\tx: 20,\n\t\ty: 20,\n\t\tw: 60\n\t}\n\tsize.h = 3*size.w\n\n\tvar path = {\n\t\tmw: 23, // margin width,x\n\t\tmh: 15 // margin height,y\n\t}\n\tvar volCtrlGroup = new paper.Group()\n\n\tlet rect_out_box = new paper.Rectangle(size.x,size.y, size.w, size.h)\n\tvar box = new paper.Shape.Rectangle(rect_out_box)\n\tbox.fillColor = \"black\"\n\n\tvolCtrlGroup.addChild(box)\n\n\tlet rect_blue_path = new paper.Rectangle(size.x + path.mw, size.y + path.mh, size.w - (path.mw*2), (size.h - 20) - (path.mh*2))\n\tvar path_blue = new paper.Shape.Rectangle(rect_blue_path)\n\tpath_blue.fillColor = \"#000080\"\n\n\tvolCtrlGroup.addChild(path_blue)\n\n\n\tvar vol = ((volume.get() * 100) | 0)\n\n\n\tlet rect_white_path = new paper.Rectangle(size.x + path.mw, size.y + path.mh, size.w - (path.mw*2), (((size.h - 20) - (path.mh*2)) * (1 - volume.get())) | 0)\n\tvar path_white = new paper.Shape.Rectangle(rect_white_path)\n\tpath_white.fillColor = \"white\"\n\n\tvolCtrlGroup.addChild(path_white)\n\n\n\tlet text = new paper.PointText({\n\t\tpoint: new paper.Point(size.x + (size.w/2), size.w + ((size.h - 25) - (path.mh*2))),\n\t\tcontent: vol + \"%\",\n\t\tfillColor: \"white\",\n\t\tfontFamily: \"Sans Serif\",\n\t\tfontWeight: \"bold\",\n\t\tfontSize: 13,\n\t\tjustification: \"center\"\n\t})\n\n\tvolCtrlGroup.addChild(text) \n\n\tvolCtrlGroup.visible = false\n\n\twindow.vcg = volCtrlGroup\n\n\tvar black_line = new paper.Shape.Rectangle(new paper.Rectangle(size.x + path.mw, size.y + path.mh, size.w - (path.mw*2), 1))\n\tblack_line.fillColor = \"black\"\n\t\n\tvolume.onValue((value) => {\n\t\tvolCtrlGroup.visible = true\n\t\tclearTimeout(window.vol_timout)\n\n\t\tlet vol = ((value * 100) | 0)\n\t\tlet bounds = new paper.Rectangle(size.x + path.mw, size.y + path.mh, size.w - (path.mw*2), (((size.h - 20) - (path.mh*2)) * (1 - value)) | 0)\n\n\t\tif(bounds.height < 1) {\n\t\t\tbounds.height = 1\n\t\t}\n\n\t\tpath_white.setBounds(bounds)\n\t\ttext.content = vol + \"%\"\n\t\tpaper.view.draw()\n\n\t\twindow.vol_timout = setTimeout(() => {\n\t\t\tvolCtrlGroup.visible = false\n\t\t\tpaper.view.draw()\n\t\t}, 500)\n\t})\n\n\n\tpaper.view.draw()\n}\n\nfunction toggleCharacters(val){\n\tgraphene.visible = val\n\tcarbon.visible = val\n\ttalk_text.visible = val\n\tg_text.visible = val\n\tc_text.visible = val\n\tpaper.view.draw()\n\tpaper.view.update(true)\n\n}\n\nfunction calculateButtonSize(rect){\n\tlet res_rect = R.clone(rect)\n\tlet margin = 10\n\tres_rect.x -= margin/2\n\tres_rect.y -= margin/2\n\tres_rect.width += margin\n\tres_rect.height += margin\n\n\treturn res_rect\n}\n\nfunction showDialogue(){\n\tlet choices = story.choices()\n\t\n\tif(R.isArrayLike(choices)){\n\t//\tconsole.log(choices)\n\t\tgobjects = []\n\n\t\tlet width = 0\n\t\tgobjects = choices.map((choice,n) => {\n\t\t\tlet group = new paper.Group()\n\n\t\t\tlet text = new paper.PointText({\n\t\t\t//\tpoint: point,\n\t\t\t\tcontent: choice,\n\t\t\t\tfillColor: \"#000080\",\n\t\t\t\tfontFamily: \"Courier New\",\n\t\t\t\tfontWeight: \"bold\",\n\t\t\t\tfontSize: font_size,\n\t\t\t\tjustification: \"left\"\n\t\t\t})\n\t\t\ttext.onClick = () => window.next(n)\n\n\t\t\tlet button = main_button.clone()\n\t\t\tbutton.visible = true\n\t\t\tbutton.setBounds(calculateButtonSize(text.bounds))\n\n\t\t\tgroup.addChild(button)\n\t\t\tgroup.addChild(text)\n\n\t\t\twidth += group.getBounds().width\n\n\t\t\treturn group\n\t\t})\n\n\t\tresize.onValue(size => {\n\t\t\tlet rem = size.width - width\n\t\t\tlet padding = rem/(gobjects.length + 1)\n\t\t\tlet cur = padding\n\t\t\tfor(let i = 0; i < gobjects.length; i++){\n\t\t\t\tlet group = gobjects[i]\n\t\t\t\tgroup.bounds.x = cur\n\t\t\t\tgroup.bounds.y = size.height - 75\n\t\t\t\t\n\t\t\t\tcur += group.bounds.width + padding\n\n\t\t\t}\n\n\t\t\tpaper.view.draw()\n\t\t})\n\n\t\tpaper.view.draw()\n\t}else{\n\n\t\ttalk_text.content = choices.who +\": \"+ choices.say\n\t\tlet len = choices.say.length\n\t\tlet t = 0\n\t\tif(len < 10) {\n\t\t\tt = 5000\n\t\t}else{\n\t\t\tt = len * 200 \n\t\t}\n\n\t\ttimeout_id = setTimeout(() => {\n\t\t\twindow.next()\n\t\t}, t)\n\t}\n\tpaper.view.draw()\n\n}\n\nfunction show(current){\n\tlet video = story.current.video\n\tif(video == current){\n\t\treturn video\n\t}else{\n\t\tif(current){\n\t\t\tconsole.log(\"Removeing: \", video)\n\t\t\tcurrent.remove()\n\t\t}\n\t}\n\n\tvideo.addEventListener(\"ended\", () => window.next())\n\n\tcontainer.appendChild(video)\n\tvideo.play()\n\treturn video\n\n}\n\nwindow.next = (arg) => {\n\tclearTimeout(timeout_id)\n\tif(story.hasChoices() && arg == null){\n\t\treturn\n\t}\n\n\tgobjects.forEach(o => o.remove())\n\n\tstory.next(arg)\n\n\tif(story.hasDialogue()){\n\t\t\n\t\tshowDialogue()\n\t\ttoggleCharacters(true)\n\t\n\t}else{\n\t\ttoggleCharacters(false)\n\t}\n\tpaper.view.update(true)\n\n\tvideo = show(video)\n\tvideo.volume = volume.get()\n\n\tconsole.log(video)\n}\n\nconst volumeModifier = 0.05\n\nwindow.addEventListener(\"load\", (event) => {\n\tconsole.log(\"Loading\")\n\n\tcanvas = document.getElementById(\"drawSurf\")\n\tcontainer = document.getElementById(\"container\")\n\n\tKefir.fromEvents(canvas, \"mousewheel\").map(e => e.wheelDelta < 0 ? -volumeModifier : volumeModifier).onValue(mod => {\n\t\tvolume.modify(old => {\n\t\t\tlet volume = old + mod\n\t\t\tif(volume < 0){\n\t\t\t\tvolume = 0\n\t\t\t}else if(volume > 1){\n\t\t\t\tvolume = 1\n\t\t\t}\n\t\t\treturn volume\n\t\t})\n\n\t})\n\n\tpaper.setup(canvas)\n\n\tvolume.onValue(vol => {\n\t\tif(video != null)\n\t\t\tvideo.volume = vol\n\t})\n\n\tresize.onValue(size => {\n\t\tcanvas.width = size.width\n\t\tcanvas.height = size.height\n\t\tpaper.view.setViewSize(size.width, size.height);\n\n\t\tpaper.view.draw();\n\t\tpaper.view.update(true)\n\t})\n\n\t//planet = new paper.Raster(\"./mercury.png\")\n\n\tgraphene = new paper.Raster(\"./Graphene.png\")\n\tcarbon = new paper.Raster(\"./Carbon1.png\")\n\tgraphene.scale(-1,1)\n\t\n\tresize.pluck(\"width\").toProperty().map(v => v - 100).onValue(set(graphene.position,\"x\"))\n\tcarbon.position.x = 100\n\n\tcarbon.scale(0.8,0.8)\n\tgraphene.scale(0.8,0.8)\n\n\ttalk_text = new paper.PointText({\n\t\tpoint: paper.view.center,\n\t//\tcontent: choices.who +\": \"+ choices.say,\n\t\tfillColor: 'white',\n\t\tfontFamily: 'Courier New',\n\t\tfontWeight: 'bold',\n\t\tfontSize: font_size,\n\t\tjustification: \"center\"\n\t});\n\n\tg_text = new paper.PointText({\n\t\tpoint: paper.view.center,\n\t\tcontent: \"Графен\",\n\t\tfillColor: 'white',\n\t\tfontFamily: 'Courier New',\n\t\tfontWeight: 'bold',\n\t\tfontSize: font_size,\n\t\tjustification: \"center\"\n\t});\n\n\tc_text = new paper.PointText({\n\t\tpoint: paper.view.center,\n\t\tcontent: \"Карбон\",\n\t\tfillColor: 'white',\n\t\tfontFamily: 'Courier New',\n\t\tfontWeight: 'bold',\n\t\tfontSize: font_size,\n\t\tjustification: \"center\"\n\t});\n\t\n\n\ttalk_text.importSVG(\"button.svg\", e => {\n\t\tmain_button = e\n\t\tmain_button.visible = false\n\t})\n\n\n\tresize.pluck(\"width\").toProperty().map(v => v - 100).onValue(set(g_text.position,\"x\"))\n\n\tc_text.position.x = 100\n\n\tcenter.onValue((center) => {\n\t\tcarbon.position.y = center.y - 100\n\t\tgraphene.position.y = center.y - 100\n\t\tg_text.position.y = center.y + 200\n\t\tc_text.position.y = center.y + 200\n\n\t});\n\n\tcenter.map(point => new paper.Point(point.x, (point.y * 2) - 100)).onValue(set(talk_text, \"point\"))\n\n\t\n\n\t//planet.position = paper.view.center;\n\t\n\tpaper.view.onMouseDown = () => {\n\t\twindow.next()\n\t}\n\t\n\t//center.onValue(set(planet, \"position\"))\n\n\tvideo = show()\n\ttoggleCharacters(false)\n\t\n\tcreateVolumeCtrl()\n\n\tconsole.log(\"Loaded\")\n}, false )\n\n\n\n\n/** WEBPACK FOOTER **\n ** ./js/main.js\n **/","/*!\n * Paper.js v0.9.25 - The Swiss Army Knife of Vector Graphics Scripting.\n * http://paperjs.org/\n *\n * Copyright (c) 2011 - 2014, Juerg Lehni & Jonathan Puckey\n * http://scratchdisk.com/ & http://jonathanpuckey.com/\n *\n * Distributed under the MIT license. See LICENSE file for details.\n *\n * All rights reserved.\n *\n * Date: Sun Oct 25 11:23:38 2015 +0100\n *\n ***\n *\n * Straps.js - Class inheritance library with support for bean-style accessors\n *\n * Copyright (c) 2006 - 2013 Juerg Lehni\n * http://scratchdisk.com/\n *\n * Distributed under the MIT license.\n *\n ***\n *\n * Acorn.js\n * http://marijnhaverbeke.nl/acorn/\n *\n * Acorn is a tiny, fast JavaScript parser written in JavaScript,\n * created by Marijn Haverbeke and released under an MIT license.\n *\n */\n\nvar paper = new function(undefined) {\n\nvar Base = new function() {\n\tvar hidden = /^(statics|enumerable|beans|preserve)$/,\n\n\t\tforEach = [].forEach || function(iter, bind) {\n\t\t\tfor (var i = 0, l = this.length; i < l; i++)\n\t\t\t\titer.call(bind, this[i], i, this);\n\t\t},\n\n\t\tforIn = function(iter, bind) {\n\t\t\tfor (var i in this)\n\t\t\t\tif (this.hasOwnProperty(i))\n\t\t\t\t\titer.call(bind, this[i], i, this);\n\t\t},\n\n\t\tcreate = Object.create || function(proto) {\n\t\t\treturn { __proto__: proto };\n\t\t},\n\n\t\tdescribe = Object.getOwnPropertyDescriptor || function(obj, name) {\n\t\t\tvar get = obj.__lookupGetter__ && obj.__lookupGetter__(name);\n\t\t\treturn get\n\t\t\t\t\t? { get: get, set: obj.__lookupSetter__(name),\n\t\t\t\t\t\tenumerable: true, configurable: true }\n\t\t\t\t\t: obj.hasOwnProperty(name)\n\t\t\t\t\t\t? { value: obj[name], enumerable: true,\n\t\t\t\t\t\t\tconfigurable: true, writable: true }\n\t\t\t\t\t\t: null;\n\t\t},\n\n\t\t_define = Object.defineProperty || function(obj, name, desc) {\n\t\t\tif ((desc.get || desc.set) && obj.__defineGetter__) {\n\t\t\t\tif (desc.get)\n\t\t\t\t\tobj.__defineGetter__(name, desc.get);\n\t\t\t\tif (desc.set)\n\t\t\t\t\tobj.__defineSetter__(name, desc.set);\n\t\t\t} else {\n\t\t\t\tobj[name] = desc.value;\n\t\t\t}\n\t\t\treturn obj;\n\t\t},\n\n\t\tdefine = function(obj, name, desc) {\n\t\t\tdelete obj[name];\n\t\t\treturn _define(obj, name, desc);\n\t\t};\n\n\tfunction inject(dest, src, enumerable, beans, preserve) {\n\t\tvar beansNames = {};\n\n\t\tfunction field(name, val) {\n\t\t\tval = val || (val = describe(src, name))\n\t\t\t\t\t&& (val.get ? val : val.value);\n\t\t\tif (typeof val === 'string' && val[0] === '#')\n\t\t\t\tval = dest[val.substring(1)] || val;\n\t\t\tvar isFunc = typeof val === 'function',\n\t\t\t\tres = val,\n\t\t\t\tprev = preserve || isFunc && !val.base\n\t\t\t\t\t\t? (val && val.get ? name in dest : dest[name])\n\t\t\t\t\t\t: null,\n\t\t\t\tbean;\n\t\t\tif (!preserve || !prev) {\n\t\t\t\tif (isFunc && prev)\n\t\t\t\t\tval.base = prev;\n\t\t\t\tif (isFunc && beans !== false\n\t\t\t\t\t\t&& (bean = name.match(/^([gs]et|is)(([A-Z])(.*))$/)))\n\t\t\t\t\tbeansNames[bean[3].toLowerCase() + bean[4]] = bean[2];\n\t\t\t\tif (!res || isFunc || !res.get || typeof res.get !== 'function'\n\t\t\t\t\t\t|| !Base.isPlainObject(res))\n\t\t\t\t\tres = { value: res, writable: true };\n\t\t\t\tif ((describe(dest, name)\n\t\t\t\t\t\t|| { configurable: true }).configurable) {\n\t\t\t\t\tres.configurable = true;\n\t\t\t\t\tres.enumerable = enumerable;\n\t\t\t\t}\n\t\t\t\tdefine(dest, name, res);\n\t\t\t}\n\t\t}\n\t\tif (src) {\n\t\t\tfor (var name in src) {\n\t\t\t\tif (src.hasOwnProperty(name) && !hidden.test(name))\n\t\t\t\t\tfield(name);\n\t\t\t}\n\t\t\tfor (var name in beansNames) {\n\t\t\t\tvar part = beansNames[name],\n\t\t\t\t\tset = dest['set' + part],\n\t\t\t\t\tget = dest['get' + part] || set && dest['is' + part];\n\t\t\t\tif (get && (beans === true || get.length === 0))\n\t\t\t\t\tfield(name, { get: get, set: set });\n\t\t\t}\n\t\t}\n\t\treturn dest;\n\t}\n\n\tfunction each(obj, iter, bind) {\n\t\tif (obj)\n\t\t\t('length' in obj && !obj.getLength\n\t\t\t\t\t&& typeof obj.length === 'number'\n\t\t\t\t? forEach\n\t\t\t\t: forIn).call(obj, iter, bind = bind || obj);\n\t\treturn bind;\n\t}\n\n\tfunction set(obj, props, exclude) {\n\t\tfor (var key in props)\n\t\t\tif (props.hasOwnProperty(key) && !(exclude && exclude[key]))\n\t\t\t\tobj[key] = props[key];\n\t\treturn obj;\n\t}\n\n\treturn inject(function Base() {\n\t\tfor (var i = 0, l = arguments.length; i < l; i++)\n\t\t\tset(this, arguments[i]);\n\t}, {\n\t\tinject: function(src) {\n\t\t\tif (src) {\n\t\t\t\tvar statics = src.statics === true ? src : src.statics,\n\t\t\t\t\tbeans = src.beans,\n\t\t\t\t\tpreserve = src.preserve;\n\t\t\t\tif (statics !== src)\n\t\t\t\t\tinject(this.prototype, src, src.enumerable, beans, preserve);\n\t\t\t\tinject(this, statics, true, beans, preserve);\n\t\t\t}\n\t\t\tfor (var i = 1, l = arguments.length; i < l; i++)\n\t\t\t\tthis.inject(arguments[i]);\n\t\t\treturn this;\n\t\t},\n\n\t\textend: function() {\n\t\t\tvar base = this,\n\t\t\t\tctor,\n\t\t\t\tproto;\n\t\t\tfor (var i = 0, l = arguments.length; i < l; i++)\n\t\t\t\tif (ctor = arguments[i].initialize)\n\t\t\t\t\tbreak;\n\t\t\tctor = ctor || function() {\n\t\t\t\tbase.apply(this, arguments);\n\t\t\t};\n\t\t\tproto = ctor.prototype = create(this.prototype);\n\t\t\tdefine(proto, 'constructor',\n\t\t\t\t\t{ value: ctor, writable: true, configurable: true });\n\t\t\tinject(ctor, this, true);\n\t\t\tif (arguments.length)\n\t\t\t\tthis.inject.apply(ctor, arguments);\n\t\t\tctor.base = base;\n\t\t\treturn ctor;\n\t\t}\n\t}, true).inject({\n\t\tinject: function() {\n\t\t\tfor (var i = 0, l = arguments.length; i < l; i++) {\n\t\t\t\tvar src = arguments[i];\n\t\t\t\tif (src)\n\t\t\t\t\tinject(this, src, src.enumerable, src.beans, src.preserve);\n\t\t\t}\n\t\t\treturn this;\n\t\t},\n\n\t\textend: function() {\n\t\t\tvar res = create(this);\n\t\t\treturn res.inject.apply(res, arguments);\n\t\t},\n\n\t\teach: function(iter, bind) {\n\t\t\treturn each(this, iter, bind);\n\t\t},\n\n\t\tset: function(props) {\n\t\t\treturn set(this, props);\n\t\t},\n\n\t\tclone: function() {\n\t\t\treturn new this.constructor(this);\n\t\t},\n\n\t\tstatics: {\n\t\t\teach: each,\n\t\t\tcreate: create,\n\t\t\tdefine: define,\n\t\t\tdescribe: describe,\n\t\t\tset: set,\n\n\t\t\tclone: function(obj) {\n\t\t\t\treturn set(new obj.constructor(), obj);\n\t\t\t},\n\n\t\t\tisPlainObject: function(obj) {\n\t\t\t\tvar ctor = obj != null && obj.constructor;\n\t\t\t\treturn ctor && (ctor === Object || ctor === Base\n\t\t\t\t\t\t|| ctor.name === 'Object');\n\t\t\t},\n\n\t\t\tpick: function(a, b) {\n\t\t\t\treturn a !== undefined ? a : b;\n\t\t\t}\n\t\t}\n\t});\n};\n\nif (typeof module !== 'undefined')\n\tmodule.exports = Base;\n\nBase.inject({\n\ttoString: function() {\n\t\treturn this._id != null\n\t\t\t?  (this._class || 'Object') + (this._name\n\t\t\t\t? \" '\" + this._name + \"'\"\n\t\t\t\t: ' @' + this._id)\n\t\t\t: '{ ' + Base.each(this, function(value, key) {\n\t\t\t\tif (!/^_/.test(key)) {\n\t\t\t\t\tvar type = typeof value;\n\t\t\t\t\tthis.push(key + ': ' + (type === 'number'\n\t\t\t\t\t\t\t? Formatter.instance.number(value)\n\t\t\t\t\t\t\t: type === 'string' ? \"'\" + value + \"'\" : value));\n\t\t\t\t}\n\t\t\t}, []).join(', ') + ' }';\n\t},\n\n\tgetClassName: function() {\n\t\treturn this._class || '';\n\t},\n\n\texportJSON: function(options) {\n\t\treturn Base.exportJSON(this, options);\n\t},\n\n\ttoJSON: function() {\n\t\treturn Base.serialize(this);\n\t},\n\n\t_set: function(props, exclude, dontCheck) {\n\t\tif (props && (dontCheck || Base.isPlainObject(props))) {\n\t\t\tvar keys = Object.keys(props._filtering || props);\n\t\t\tfor (var i = 0, l = keys.length; i < l; i++) {\n\t\t\t\tvar key = keys[i];\n\t\t\t\tif (!(exclude && exclude[key])) {\n\t\t\t\t\tvar value = props[key];\n\t\t\t\t\tif (value !== undefined)\n\t\t\t\t\t\tthis[key] = value;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t},\n\n\tstatics: {\n\n\t\texports: {\n\t\t\tenumerable: true\n\t\t},\n\n\t\textend: function extend() {\n\t\t\tvar res = extend.base.apply(this, arguments),\n\t\t\t\tname = res.prototype._class;\n\t\t\tif (name && !Base.exports[name])\n\t\t\t\tBase.exports[name] = res;\n\t\t\treturn res;\n\t\t},\n\n\t\tequals: function(obj1, obj2) {\n\t\t\tif (obj1 === obj2)\n\t\t\t\treturn true;\n\t\t\tif (obj1 && obj1.equals)\n\t\t\t\treturn obj1.equals(obj2);\n\t\t\tif (obj2 && obj2.equals)\n\t\t\t\treturn obj2.equals(obj1);\n\t\t\tif (obj1 && obj2\n\t\t\t\t\t&& typeof obj1 === 'object' && typeof obj2 === 'object') {\n\t\t\t\tif (Array.isArray(obj1) && Array.isArray(obj2)) {\n\t\t\t\t\tvar length = obj1.length;\n\t\t\t\t\tif (length !== obj2.length)\n\t\t\t\t\t\treturn false;\n\t\t\t\t\twhile (length--) {\n\t\t\t\t\t\tif (!Base.equals(obj1[length], obj2[length]))\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tvar keys = Object.keys(obj1),\n\t\t\t\t\t\tlength = keys.length;\n\t\t\t\t\tif (length !== Object.keys(obj2).length)\n\t\t\t\t\t\treturn false;\n\t\t\t\t\twhile (length--) {\n\t\t\t\t\t\tvar key = keys[length];\n\t\t\t\t\t\tif (!(obj2.hasOwnProperty(key)\n\t\t\t\t\t\t\t\t&& Base.equals(obj1[key], obj2[key])))\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\treturn false;\n\t\t},\n\n\t\tread: function(list, start, options, length) {\n\t\t\tif (this === Base) {\n\t\t\t\tvar value = this.peek(list, start);\n\t\t\t\tlist.__index++;\n\t\t\t\treturn value;\n\t\t\t}\n\t\t\tvar proto = this.prototype,\n\t\t\t\treadIndex = proto._readIndex,\n\t\t\t\tindex = start || readIndex && list.__index || 0;\n\t\t\tif (!length)\n\t\t\t\tlength = list.length - index;\n\t\t\tvar obj = list[index];\n\t\t\tif (obj instanceof this\n\t\t\t\t|| options && options.readNull && obj == null && length <= 1) {\n\t\t\t\tif (readIndex)\n\t\t\t\t\tlist.__index = index + 1;\n\t\t\t\treturn obj && options && options.clone ? obj.clone() : obj;\n\t\t\t}\n\t\t\tobj = Base.create(this.prototype);\n\t\t\tif (readIndex)\n\t\t\t\tobj.__read = true;\n\t\t\tobj = obj.initialize.apply(obj, index > 0 || length < list.length\n\t\t\t\t? Array.prototype.slice.call(list, index, index + length)\n\t\t\t\t: list) || obj;\n\t\t\tif (readIndex) {\n\t\t\t\tlist.__index = index + obj.__read;\n\t\t\t\tobj.__read = undefined;\n\t\t\t}\n\t\t\treturn obj;\n\t\t},\n\n\t\tpeek: function(list, start) {\n\t\t\treturn list[list.__index = start || list.__index || 0];\n\t\t},\n\n\t\tremain: function(list) {\n\t\t\treturn list.length - (list.__index || 0);\n\t\t},\n\n\t\treadAll: function(list, start, options) {\n\t\t\tvar res = [],\n\t\t\t\tentry;\n\t\t\tfor (var i = start || 0, l = list.length; i < l; i++) {\n\t\t\t\tres.push(Array.isArray(entry = list[i])\n\t\t\t\t\t\t? this.read(entry, 0, options)\n\t\t\t\t\t\t: this.read(list, i, options, 1));\n\t\t\t}\n\t\t\treturn res;\n\t\t},\n\n\t\treadNamed: function(list, name, start, options, length) {\n\t\t\tvar value = this.getNamed(list, name),\n\t\t\t\thasObject = value !== undefined;\n\t\t\tif (hasObject) {\n\t\t\t\tvar filtered = list._filtered;\n\t\t\t\tif (!filtered) {\n\t\t\t\t\tfiltered = list._filtered = Base.create(list[0]);\n\t\t\t\t\tfiltered._filtering = list[0];\n\t\t\t\t}\n\t\t\t\tfiltered[name] = undefined;\n\t\t\t}\n\t\t\treturn this.read(hasObject ? [value] : list, start, options, length);\n\t\t},\n\n\t\tgetNamed: function(list, name) {\n\t\t\tvar arg = list[0];\n\t\t\tif (list._hasObject === undefined)\n\t\t\t\tlist._hasObject = list.length === 1 && Base.isPlainObject(arg);\n\t\t\tif (list._hasObject)\n\t\t\t\treturn name ? arg[name] : list._filtered || arg;\n\t\t},\n\n\t\thasNamed: function(list, name) {\n\t\t\treturn !!this.getNamed(list, name);\n\t\t},\n\n\t\tisPlainValue: function(obj, asString) {\n\t\t\treturn this.isPlainObject(obj) || Array.isArray(obj)\n\t\t\t\t\t|| asString && typeof obj === 'string';\n\t\t},\n\n\t\tserialize: function(obj, options, compact, dictionary) {\n\t\t\toptions = options || {};\n\n\t\t\tvar root = !dictionary,\n\t\t\t\tres;\n\t\t\tif (root) {\n\t\t\t\toptions.formatter = new Formatter(options.precision);\n\t\t\t\tdictionary = {\n\t\t\t\t\tlength: 0,\n\t\t\t\t\tdefinitions: {},\n\t\t\t\t\treferences: {},\n\t\t\t\t\tadd: function(item, create) {\n\t\t\t\t\t\tvar id = '#' + item._id,\n\t\t\t\t\t\t\tref = this.references[id];\n\t\t\t\t\t\tif (!ref) {\n\t\t\t\t\t\t\tthis.length++;\n\t\t\t\t\t\t\tvar res = create.call(item),\n\t\t\t\t\t\t\t\tname = item._class;\n\t\t\t\t\t\t\tif (name && res[0] !== name)\n\t\t\t\t\t\t\t\tres.unshift(name);\n\t\t\t\t\t\t\tthis.definitions[id] = res;\n\t\t\t\t\t\t\tref = this.references[id] = [id];\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn ref;\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t}\n\t\t\tif (obj && obj._serialize) {\n\t\t\t\tres = obj._serialize(options, dictionary);\n\t\t\t\tvar name = obj._class;\n\t\t\t\tif (name && !compact && !res._compact && res[0] !== name)\n\t\t\t\t\tres.unshift(name);\n\t\t\t} else if (Array.isArray(obj)) {\n\t\t\t\tres = [];\n\t\t\t\tfor (var i = 0, l = obj.length; i < l; i++)\n\t\t\t\t\tres[i] = Base.serialize(obj[i], options, compact,\n\t\t\t\t\t\t\tdictionary);\n\t\t\t\tif (compact)\n\t\t\t\t\tres._compact = true;\n\t\t\t} else if (Base.isPlainObject(obj)) {\n\t\t\t\tres = {};\n\t\t\t\tvar keys = Object.keys(obj);\n\t\t\t\tfor (var i = 0, l = keys.length; i < l; i++) {\n\t\t\t\t\tvar key = keys[i];\n\t\t\t\t\tres[key] = Base.serialize(obj[key], options, compact,\n\t\t\t\t\t\t\tdictionary);\n\t\t\t\t}\n\t\t\t} else if (typeof obj === 'number') {\n\t\t\t\tres = options.formatter.number(obj, options.precision);\n\t\t\t} else {\n\t\t\t\tres = obj;\n\t\t\t}\n\t\t\treturn root && dictionary.length > 0\n\t\t\t\t\t? [['dictionary', dictionary.definitions], res]\n\t\t\t\t\t: res;\n\t\t},\n\n\t\tdeserialize: function(json, create, _data, _isDictionary) {\n\t\t\tvar res = json,\n\t\t\t\tisRoot = !_data;\n\t\t\t_data = _data || {};\n\t\t\tif (Array.isArray(json)) {\n\t\t\t\tvar type = json[0],\n\t\t\t\t\tisDictionary = type === 'dictionary';\n\t\t\t\tif (json.length == 1 && /^#/.test(type))\n\t\t\t\t\treturn _data.dictionary[type];\n\t\t\t\ttype = Base.exports[type];\n\t\t\t\tres = [];\n\t\t\t\tif (_isDictionary)\n\t\t\t\t\t_data.dictionary = res;\n\t\t\t\tfor (var i = type ? 1 : 0, l = json.length; i < l; i++)\n\t\t\t\t\tres.push(Base.deserialize(json[i], create, _data,\n\t\t\t\t\t\t\tisDictionary));\n\t\t\t\tif (type) {\n\t\t\t\t\tvar args = res;\n\t\t\t\t\tif (create) {\n\t\t\t\t\t\tres = create(type, args);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tres = Base.create(type.prototype);\n\t\t\t\t\t\ttype.apply(res, args);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (Base.isPlainObject(json)) {\n\t\t\t\tres = {};\n\t\t\t\tif (_isDictionary)\n\t\t\t\t\t_data.dictionary = res;\n\t\t\t\tfor (var key in json)\n\t\t\t\t\tres[key] = Base.deserialize(json[key], create, _data);\n\t\t\t}\n\t\t\treturn isRoot && json && json.length && json[0][0] === 'dictionary'\n\t\t\t\t\t? res[1]\n\t\t\t\t\t: res;\n\t\t},\n\n\t\texportJSON: function(obj, options) {\n\t\t\tvar json = Base.serialize(obj, options);\n\t\t\treturn options && options.asString === false\n\t\t\t\t\t? json\n\t\t\t\t\t: JSON.stringify(json);\n\t\t},\n\n\t\timportJSON: function(json, target) {\n\t\t\treturn Base.deserialize(\n\t\t\t\t\ttypeof json === 'string' ? JSON.parse(json) : json,\n\t\t\t\t\tfunction(type, args) {\n\t\t\t\t\t\tvar obj = target && target.constructor === type\n\t\t\t\t\t\t\t\t? target\n\t\t\t\t\t\t\t\t: Base.create(type.prototype),\n\t\t\t\t\t\t\tisTarget = obj === target;\n\t\t\t\t\t\tif (args.length === 1 && obj instanceof Item\n\t\t\t\t\t\t\t\t&& (isTarget || !(obj instanceof Layer))) {\n\t\t\t\t\t\t\tvar arg = args[0];\n\t\t\t\t\t\t\tif (Base.isPlainObject(arg))\n\t\t\t\t\t\t\t\targ.insert = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t\ttype.apply(obj, args);\n\t\t\t\t\t\tif (isTarget)\n\t\t\t\t\t\t\ttarget = null;\n\t\t\t\t\t\treturn obj;\n\t\t\t\t\t});\n\t\t},\n\n\t\tsplice: function(list, items, index, remove) {\n\t\t\tvar amount = items && items.length,\n\t\t\t\tappend = index === undefined;\n\t\t\tindex = append ? list.length : index;\n\t\t\tif (index > list.length)\n\t\t\t\tindex = list.length;\n\t\t\tfor (var i = 0; i < amount; i++)\n\t\t\t\titems[i]._index = index + i;\n\t\t\tif (append) {\n\t\t\t\tlist.push.apply(list, items);\n\t\t\t\treturn [];\n\t\t\t} else {\n\t\t\t\tvar args = [index, remove];\n\t\t\t\tif (items)\n\t\t\t\t\targs.push.apply(args, items);\n\t\t\t\tvar removed = list.splice.apply(list, args);\n\t\t\t\tfor (var i = 0, l = removed.length; i < l; i++)\n\t\t\t\t\tremoved[i]._index = undefined;\n\t\t\t\tfor (var i = index + amount, l = list.length; i < l; i++)\n\t\t\t\t\tlist[i]._index = i;\n\t\t\t\treturn removed;\n\t\t\t}\n\t\t},\n\n\t\tcapitalize: function(str) {\n\t\t\treturn str.replace(/\\b[a-z]/g, function(match) {\n\t\t\t\treturn match.toUpperCase();\n\t\t\t});\n\t\t},\n\n\t\tcamelize: function(str) {\n\t\t\treturn str.replace(/-(.)/g, function(all, chr) {\n\t\t\t\treturn chr.toUpperCase();\n\t\t\t});\n\t\t},\n\n\t\thyphenate: function(str) {\n\t\t\treturn str.replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase();\n\t\t}\n\t}\n});\n\nvar Emitter = {\n\ton: function(type, func) {\n\t\tif (typeof type !== 'string') {\n\t\t\tBase.each(type, function(value, key) {\n\t\t\t\tthis.on(key, value);\n\t\t\t}, this);\n\t\t} else {\n\t\t\tvar types = this._eventTypes,\n\t\t\t\tentry = types && types[type],\n\t\t\t\thandlers = this._callbacks = this._callbacks || {};\n\t\t\thandlers = handlers[type] = handlers[type] || [];\n\t\t\tif (handlers.indexOf(func) === -1) {\n\t\t\t\thandlers.push(func);\n\t\t\t\tif (entry && entry.install && handlers.length === 1)\n\t\t\t\t\tentry.install.call(this, type);\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t},\n\n\toff: function(type, func) {\n\t\tif (typeof type !== 'string') {\n\t\t\tBase.each(type, function(value, key) {\n\t\t\t\tthis.off(key, value);\n\t\t\t}, this);\n\t\t\treturn;\n\t\t}\n\t\tvar types = this._eventTypes,\n\t\t\tentry = types && types[type],\n\t\t\thandlers = this._callbacks && this._callbacks[type],\n\t\t\tindex;\n\t\tif (handlers) {\n\t\t\tif (!func || (index = handlers.indexOf(func)) !== -1\n\t\t\t\t\t&& handlers.length === 1) {\n\t\t\t\tif (entry && entry.uninstall)\n\t\t\t\t\tentry.uninstall.call(this, type);\n\t\t\t\tdelete this._callbacks[type];\n\t\t\t} else if (index !== -1) {\n\t\t\t\thandlers.splice(index, 1);\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t},\n\n\tonce: function(type, func) {\n\t\treturn this.on(type, function() {\n\t\t\tfunc.apply(this, arguments);\n\t\t\tthis.off(type, func);\n\t\t});\n\t},\n\n\temit: function(type, event) {\n\t\tvar handlers = this._callbacks && this._callbacks[type];\n\t\tif (!handlers)\n\t\t\treturn false;\n\t\tvar args = [].slice.call(arguments, 1);\n\t\thandlers = handlers.slice();\n\t\tfor (var i = 0, l = handlers.length; i < l; i++) {\n\t\t\tif (handlers[i].apply(this, args) === false) {\n\t\t\t\tif (event && event.stop)\n\t\t\t\t\tevent.stop();\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t},\n\n\tresponds: function(type) {\n\t\treturn !!(this._callbacks && this._callbacks[type]);\n\t},\n\n\tattach: '#on',\n\tdetach: '#off',\n\tfire: '#emit',\n\n\t_installEvents: function(install) {\n\t\tvar handlers = this._callbacks,\n\t\t\tkey = install ? 'install' : 'uninstall';\n\t\tfor (var type in handlers) {\n\t\t\tif (handlers[type].length > 0) {\n\t\t\t\tvar types = this._eventTypes,\n\t\t\t\t\tentry = types && types[type],\n\t\t\t\t\tfunc = entry && entry[key];\n\t\t\t\tif (func)\n\t\t\t\t\tfunc.call(this, type);\n\t\t\t}\n\t\t}\n\t},\n\n\tstatics: {\n\t\tinject: function inject(src) {\n\t\t\tvar events = src._events;\n\t\t\tif (events) {\n\t\t\t\tvar types = {};\n\t\t\t\tBase.each(events, function(entry, key) {\n\t\t\t\t\tvar isString = typeof entry === 'string',\n\t\t\t\t\t\tname = isString ? entry : key,\n\t\t\t\t\t\tpart = Base.capitalize(name),\n\t\t\t\t\t\ttype = name.substring(2).toLowerCase();\n\t\t\t\t\ttypes[type] = isString ? {} : entry;\n\t\t\t\t\tname = '_' + name;\n\t\t\t\t\tsrc['get' + part] = function() {\n\t\t\t\t\t\treturn this[name];\n\t\t\t\t\t};\n\t\t\t\t\tsrc['set' + part] = function(func) {\n\t\t\t\t\t\tvar prev = this[name];\n\t\t\t\t\t\tif (prev)\n\t\t\t\t\t\t\tthis.off(type, prev);\n\t\t\t\t\t\tif (func)\n\t\t\t\t\t\t\tthis.on(type, func);\n\t\t\t\t\t\tthis[name] = func;\n\t\t\t\t\t};\n\t\t\t\t});\n\t\t\t\tsrc._eventTypes = types;\n\t\t\t}\n\t\t\treturn inject.base.apply(this, arguments);\n\t\t}\n\t}\n};\n\nvar PaperScope = Base.extend({\n\t_class: 'PaperScope',\n\n\tinitialize: function PaperScope() {\n\t\tpaper = this;\n\t\tthis.settings = new Base({\n\t\t\tapplyMatrix: true,\n\t\t\thandleSize: 4,\n\t\t\thitTolerance: 0\n\t\t});\n\t\tthis.project = null;\n\t\tthis.projects = [];\n\t\tthis.tools = [];\n\t\tthis.palettes = [];\n\t\tthis._id = PaperScope._id++;\n\t\tPaperScope._scopes[this._id] = this;\n\t\tvar proto = PaperScope.prototype;\n\t\tif (!this.support) {\n\t\t\tvar ctx = CanvasProvider.getContext(1, 1);\n\t\t\tproto.support = {\n\t\t\t\tnativeDash: 'setLineDash' in ctx || 'mozDash' in ctx,\n\t\t\t\tnativeBlendModes: BlendMode.nativeModes\n\t\t\t};\n\t\t\tCanvasProvider.release(ctx);\n\t\t}\n\n\t\tif (!this.browser) {\n\t\t\tvar agent = navigator.userAgent.toLowerCase(),\n\t\t\t\tplatform = (/(win)/.exec(agent)\n\t\t\t\t\t\t|| /(mac)/.exec(agent)\n\t\t\t\t\t\t|| /(linux)/.exec(agent)\n\t\t\t\t\t\t|| [])[0],\n\t\t\t\tbrowser = proto.browser = { platform: platform };\n\t\t\tif (platform)\n\t\t\t\tbrowser[platform] = true;\n\t\t\tagent.replace(\n\t\t\t\t/(opera|chrome|safari|webkit|firefox|msie|trident|atom)\\/?\\s*([.\\d]+)(?:.*version\\/([.\\d]+))?(?:.*rv\\:([.\\d]+))?/g,\n\t\t\t\tfunction(all, n, v1, v2, rv) {\n\t\t\t\t\tif (!browser.chrome) {\n\t\t\t\t\t\tvar v = n === 'opera' ? v2 : v1;\n\t\t\t\t\t\tif (n === 'trident') {\n\t\t\t\t\t\t\tv = rv;\n\t\t\t\t\t\t\tn = 'msie';\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbrowser.version = v;\n\t\t\t\t\t\tbrowser.versionNumber = parseFloat(v);\n\t\t\t\t\t\tbrowser.name = n;\n\t\t\t\t\t\tbrowser[n] = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t);\n\t\t\tif (browser.chrome)\n\t\t\t\tdelete browser.webkit;\n\t\t\tif (browser.atom)\n\t\t\t\tdelete browser.chrome;\n\t\t}\n\t},\n\n\tversion: \"0.9.25\",\n\n\tgetView: function() {\n\t\treturn this.project && this.project.getView();\n\t},\n\n\tgetPaper: function() {\n\t\treturn this;\n\t},\n\n\texecute: function(code, url, options) {\n\t\tpaper.PaperScript.execute(code, this, url, options);\n\t\tView.updateFocus();\n\t},\n\n\tinstall: function(scope) {\n\t\tvar that = this;\n\t\tBase.each(['project', 'view', 'tool'], function(key) {\n\t\t\tBase.define(scope, key, {\n\t\t\t\tconfigurable: true,\n\t\t\t\tget: function() {\n\t\t\t\t\treturn that[key];\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t\tfor (var key in this)\n\t\t\tif (!/^_/.test(key) && this[key])\n\t\t\t\tscope[key] = this[key];\n\t},\n\n\tsetup: function(element) {\n\t\tpaper = this;\n\t\tthis.project = new Project(element);\n\t\treturn this;\n\t},\n\n\tactivate: function() {\n\t\tpaper = this;\n\t},\n\n\tclear: function() {\n\t\tfor (var i = this.projects.length - 1; i >= 0; i--)\n\t\t\tthis.projects[i].remove();\n\t\tfor (var i = this.tools.length - 1; i >= 0; i--)\n\t\t\tthis.tools[i].remove();\n\t\tfor (var i = this.palettes.length - 1; i >= 0; i--)\n\t\t\tthis.palettes[i].remove();\n\t},\n\n\tremove: function() {\n\t\tthis.clear();\n\t\tdelete PaperScope._scopes[this._id];\n\t},\n\n\tstatics: new function() {\n\t\tfunction handleAttribute(name) {\n\t\t\tname += 'Attribute';\n\t\t\treturn function(el, attr) {\n\t\t\t\treturn el[name](attr) || el[name]('data-paper-' + attr);\n\t\t\t};\n\t\t}\n\n\t\treturn {\n\t\t\t_scopes: {},\n\t\t\t_id: 0,\n\n\t\t\tget: function(id) {\n\t\t\t\treturn this._scopes[id] || null;\n\t\t\t},\n\n\t\t\tgetAttribute: handleAttribute('get'),\n\t\t\thasAttribute: handleAttribute('has')\n\t\t};\n\t}\n});\n\nvar PaperScopeItem = Base.extend(Emitter, {\n\n\tinitialize: function(activate) {\n\t\tthis._scope = paper;\n\t\tthis._index = this._scope[this._list].push(this) - 1;\n\t\tif (activate || !this._scope[this._reference])\n\t\t\tthis.activate();\n\t},\n\n\tactivate: function() {\n\t\tif (!this._scope)\n\t\t\treturn false;\n\t\tvar prev = this._scope[this._reference];\n\t\tif (prev && prev !== this)\n\t\t\tprev.emit('deactivate');\n\t\tthis._scope[this._reference] = this;\n\t\tthis.emit('activate', prev);\n\t\treturn true;\n\t},\n\n\tisActive: function() {\n\t\treturn this._scope[this._reference] === this;\n\t},\n\n\tremove: function() {\n\t\tif (this._index == null)\n\t\t\treturn false;\n\t\tBase.splice(this._scope[this._list], null, this._index, 1);\n\t\tif (this._scope[this._reference] == this)\n\t\t\tthis._scope[this._reference] = null;\n\t\tthis._scope = null;\n\t\treturn true;\n\t}\n});\n\nvar Formatter = Base.extend({\n\tinitialize: function(precision) {\n\t\tthis.precision = precision || 5;\n\t\tthis.multiplier = Math.pow(10, this.precision);\n\t},\n\n\tnumber: function(val) {\n\t\treturn Math.round(val * this.multiplier) / this.multiplier;\n\t},\n\n\tpair: function(val1, val2, separator) {\n\t\treturn this.number(val1) + (separator || ',') + this.number(val2);\n\t},\n\n\tpoint: function(val, separator) {\n\t\treturn this.number(val.x) + (separator || ',') + this.number(val.y);\n\t},\n\n\tsize: function(val, separator) {\n\t\treturn this.number(val.width) + (separator || ',')\n\t\t\t\t+ this.number(val.height);\n\t},\n\n\trectangle: function(val, separator) {\n\t\treturn this.point(val, separator) + (separator || ',')\n\t\t\t\t+ this.size(val, separator);\n\t}\n});\n\nFormatter.instance = new Formatter();\n\nvar Numerical = new function() {\n\n\tvar abscissas = [\n\t\t[  0.5773502691896257645091488],\n\t\t[0,0.7745966692414833770358531],\n\t\t[  0.3399810435848562648026658,0.8611363115940525752239465],\n\t\t[0,0.5384693101056830910363144,0.9061798459386639927976269],\n\t\t[  0.2386191860831969086305017,0.6612093864662645136613996,0.9324695142031520278123016],\n\t\t[0,0.4058451513773971669066064,0.7415311855993944398638648,0.9491079123427585245261897],\n\t\t[  0.1834346424956498049394761,0.5255324099163289858177390,0.7966664774136267395915539,0.9602898564975362316835609],\n\t\t[0,0.3242534234038089290385380,0.6133714327005903973087020,0.8360311073266357942994298,0.9681602395076260898355762],\n\t\t[  0.1488743389816312108848260,0.4333953941292471907992659,0.6794095682990244062343274,0.8650633666889845107320967,0.9739065285171717200779640],\n\t\t[0,0.2695431559523449723315320,0.5190961292068118159257257,0.7301520055740493240934163,0.8870625997680952990751578,0.9782286581460569928039380],\n\t\t[  0.1252334085114689154724414,0.3678314989981801937526915,0.5873179542866174472967024,0.7699026741943046870368938,0.9041172563704748566784659,0.9815606342467192506905491],\n\t\t[0,0.2304583159551347940655281,0.4484927510364468528779129,0.6423493394403402206439846,0.8015780907333099127942065,0.9175983992229779652065478,0.9841830547185881494728294],\n\t\t[  0.1080549487073436620662447,0.3191123689278897604356718,0.5152486363581540919652907,0.6872929048116854701480198,0.8272013150697649931897947,0.9284348836635735173363911,0.9862838086968123388415973],\n\t\t[0,0.2011940939974345223006283,0.3941513470775633698972074,0.5709721726085388475372267,0.7244177313601700474161861,0.8482065834104272162006483,0.9372733924007059043077589,0.9879925180204854284895657],\n\t\t[  0.0950125098376374401853193,0.2816035507792589132304605,0.4580167776572273863424194,0.6178762444026437484466718,0.7554044083550030338951012,0.8656312023878317438804679,0.9445750230732325760779884,0.9894009349916499325961542]\n\t];\n\n\tvar weights = [\n\t\t[1],\n\t\t[0.8888888888888888888888889,0.5555555555555555555555556],\n\t\t[0.6521451548625461426269361,0.3478548451374538573730639],\n\t\t[0.5688888888888888888888889,0.4786286704993664680412915,0.2369268850561890875142640],\n\t\t[0.4679139345726910473898703,0.3607615730481386075698335,0.1713244923791703450402961],\n\t\t[0.4179591836734693877551020,0.3818300505051189449503698,0.2797053914892766679014678,0.1294849661688696932706114],\n\t\t[0.3626837833783619829651504,0.3137066458778872873379622,0.2223810344533744705443560,0.1012285362903762591525314],\n\t\t[0.3302393550012597631645251,0.3123470770400028400686304,0.2606106964029354623187429,0.1806481606948574040584720,0.0812743883615744119718922],\n\t\t[0.2955242247147528701738930,0.2692667193099963550912269,0.2190863625159820439955349,0.1494513491505805931457763,0.0666713443086881375935688],\n\t\t[0.2729250867779006307144835,0.2628045445102466621806889,0.2331937645919904799185237,0.1862902109277342514260976,0.1255803694649046246346943,0.0556685671161736664827537],\n\t\t[0.2491470458134027850005624,0.2334925365383548087608499,0.2031674267230659217490645,0.1600783285433462263346525,0.1069393259953184309602547,0.0471753363865118271946160],\n\t\t[0.2325515532308739101945895,0.2262831802628972384120902,0.2078160475368885023125232,0.1781459807619457382800467,0.1388735102197872384636018,0.0921214998377284479144218,0.0404840047653158795200216],\n\t\t[0.2152638534631577901958764,0.2051984637212956039659241,0.1855383974779378137417166,0.1572031671581935345696019,0.1215185706879031846894148,0.0801580871597602098056333,0.0351194603317518630318329],\n\t\t[0.2025782419255612728806202,0.1984314853271115764561183,0.1861610000155622110268006,0.1662692058169939335532009,0.1395706779261543144478048,0.1071592204671719350118695,0.0703660474881081247092674,0.0307532419961172683546284],\n\t\t[0.1894506104550684962853967,0.1826034150449235888667637,0.1691565193950025381893121,0.1495959888165767320815017,0.1246289712555338720524763,0.0951585116824927848099251,0.0622535239386478928628438,0.0271524594117540948517806]\n\t];\n\n\tvar abs = Math.abs,\n\t\tsqrt = Math.sqrt,\n\t\tpow = Math.pow,\n\t\tEPSILON = 1e-12,\n\t\tMACHINE_EPSILON = 1.12e-16;\n\n\tfunction clip(value, min, max) {\n\t\treturn value < min ? min : value > max ? max : value;\n\t}\n\n\treturn {\n\t\tTOLERANCE: 1e-6,\n\t\tEPSILON: EPSILON,\n\t\tMACHINE_EPSILON: MACHINE_EPSILON,\n\t\tCURVETIME_EPSILON: 4e-7,\n\t\tGEOMETRIC_EPSILON: 2e-7,\n\t\tWINDING_EPSILON: 2e-7,\n\t\tTRIGONOMETRIC_EPSILON: 1e-7,\n\t\tCLIPPING_EPSILON: 1e-7,\n\t\tKAPPA: 4 * (sqrt(2) - 1) / 3,\n\n\t\tisZero: function(val) {\n\t\t\treturn val >= -EPSILON && val <= EPSILON;\n\t\t},\n\n\t\tintegrate: function(f, a, b, n) {\n\t\t\tvar x = abscissas[n - 2],\n\t\t\t\tw = weights[n - 2],\n\t\t\t\tA = (b - a) * 0.5,\n\t\t\t\tB = A + a,\n\t\t\t\ti = 0,\n\t\t\t\tm = (n + 1) >> 1,\n\t\t\t\tsum = n & 1 ? w[i++] * f(B) : 0;\n\t\t\twhile (i < m) {\n\t\t\t\tvar Ax = A * x[i];\n\t\t\t\tsum += w[i++] * (f(B + Ax) + f(B - Ax));\n\t\t\t}\n\t\t\treturn A * sum;\n\t\t},\n\n\t\tfindRoot: function(f, df, x, a, b, n, tolerance) {\n\t\t\tfor (var i = 0; i < n; i++) {\n\t\t\t\tvar fx = f(x),\n\t\t\t\t\tdx = fx / df(x),\n\t\t\t\t\tnx = x - dx;\n\t\t\t\tif (abs(dx) < tolerance)\n\t\t\t\t\treturn nx;\n\t\t\t\tif (fx > 0) {\n\t\t\t\t\tb = x;\n\t\t\t\t\tx = nx <= a ? (a + b) * 0.5 : nx;\n\t\t\t\t} else {\n\t\t\t\t\ta = x;\n\t\t\t\t\tx = nx >= b ? (a + b) * 0.5 : nx;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn x;\n\t\t},\n\n\t\tsolveQuadratic: function(a, b, c, roots, min, max) {\n\t\t\tvar count = 0,\n\t\t\t\teMin = min - EPSILON,\n\t\t\t\teMax = max + EPSILON,\n\t\t\t\tx1, x2 = Infinity,\n\t\t\t\tB = b,\n\t\t\t\tD;\n\t\t\tb /= -2;\n\t\t\tD = b * b - a * c;\n\t\t\tif (D !== 0 && abs(D) < MACHINE_EPSILON) {\n\t\t\t\tvar gmC = pow(abs(a * b * c), 1 / 3);\n\t\t\t\tif (gmC < 1e-8) {\n\t\t\t\t\tvar mult = pow(10,\n\t\t\t\t\t\t\tabs(Math.floor(Math.log(gmC) * Math.LOG10E)));\n\t\t\t\t\tif (!isFinite(mult))\n\t\t\t\t\t\tmult = 0;\n\t\t\t\t\ta *= mult;\n\t\t\t\t\tb *= mult;\n\t\t\t\t\tc *= mult;\n\t\t\t\t\tD = b * b - a * c;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (abs(a) < EPSILON) {\n\t\t\t\tif (abs(B) < EPSILON)\n\t\t\t\t\treturn abs(c) < EPSILON ? -1 : 0;\n\t\t\t\tx1 = -c / B;\n\t\t\t} else if (D >= -MACHINE_EPSILON) {\n\t\t\t\tvar Q = D < 0 ? 0 : sqrt(D),\n\t\t\t\t\tR = b + (b < 0 ? -Q : Q);\n\t\t\t\tif (R === 0) {\n\t\t\t\t\tx1 = c / a;\n\t\t\t\t\tx2 = -x1;\n\t\t\t\t} else {\n\t\t\t\t\tx1 = R / a;\n\t\t\t\t\tx2 = c / R;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (isFinite(x1) && (min == null || x1 > eMin && x1 < eMax))\n\t\t\t\troots[count++] = min == null ? x1 : clip(x1, min, max);\n\t\t\tif (x2 !== x1\n\t\t\t\t\t&& isFinite(x2) && (min == null || x2 > eMin && x2 < eMax))\n\t\t\t\troots[count++] = min == null ? x2 : clip(x2, min, max);\n\t\t\treturn count;\n\t\t},\n\n\t\tsolveCubic: function(a, b, c, d, roots, min, max) {\n\t\t\tvar count = 0,\n\t\t\t\tx, b1, c2;\n\t\t\tif (abs(a) < EPSILON) {\n\t\t\t\ta = b;\n\t\t\t\tb1 = c;\n\t\t\t\tc2 = d;\n\t\t\t\tx = Infinity;\n\t\t\t} else if (abs(d) < EPSILON) {\n\t\t\t\tb1 = b;\n\t\t\t\tc2 = c;\n\t\t\t\tx = 0;\n\t\t\t} else {\n\t\t\t\tvar ec = 1 + MACHINE_EPSILON,\n\t\t\t\t\tx0, q, qd, t, r, s, tmp;\n\t\t\t\tx = -(b / a) / 3;\n\t\t\t\ttmp = a * x,\n\t\t\t\tb1 = tmp + b,\n\t\t\t\tc2 = b1 * x + c,\n\t\t\t\tqd = (tmp + b1) * x + c2,\n\t\t\t\tq = c2 * x + d;\n\t\t\t\tt = q /a;\n\t\t\t\tr = pow(abs(t), 1/3);\n\t\t\t\ts = t < 0 ? -1 : 1;\n\t\t\t\tt = -qd / a;\n\t\t\t\tr = t > 0 ? 1.3247179572 * Math.max(r, sqrt(t)) : r;\n\t\t\t\tx0 = x - s * r;\n\t\t\t\tif (x0 !== x) {\n\t\t\t\t\tdo {\n\t\t\t\t\t\tx = x0;\n\t\t\t\t\t\ttmp = a * x,\n\t\t\t\t\t\tb1 = tmp + b,\n\t\t\t\t\t\tc2 = b1 * x + c,\n\t\t\t\t\t\tqd = (tmp + b1) * x + c2,\n\t\t\t\t\t\tq = c2 * x + d;\n\t\t\t\t\t\tx0 = qd === 0 ? x : x - q / qd / ec;\n\t\t\t\t\t\tif (x0 === x) {\n\t\t\t\t\t\t\tx = x0;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t} while (s * x0 > s * x);\n\t\t\t\t\tif (abs(a) * x * x > abs(d / x)) {\n\t\t\t\t\t\tc2 = -d / x;\n\t\t\t\t\t\tb1 = (c2 - c) / x;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tvar count = Numerical.solveQuadratic(a, b1, c2, roots, min, max);\n\t\t\tif (isFinite(x) && (count === 0 || x !== roots[count - 1])\n\t\t\t\t\t&& (min == null || x > min - EPSILON && x < max + EPSILON))\n\t\t\t\troots[count++] = min == null ? x : clip(x, min, max);\n\t\t\treturn count;\n\t\t}\n\t};\n};\n\nvar UID = {\n\t_id: 1,\n\t_pools: {},\n\n\tget: function(ctor) {\n\t\tif (ctor) {\n\t\t\tvar name = ctor._class,\n\t\t\t\tpool = this._pools[name];\n\t\t\tif (!pool)\n\t\t\t\tpool = this._pools[name] = { _id: 1 };\n\t\t\treturn pool._id++;\n\t\t} else {\n\t\t\treturn this._id++;\n\t\t}\n\t}\n};\n\nvar Point = Base.extend({\n\t_class: 'Point',\n\t_readIndex: true,\n\n\tinitialize: function Point(arg0, arg1) {\n\t\tvar type = typeof arg0;\n\t\tif (type === 'number') {\n\t\t\tvar hasY = typeof arg1 === 'number';\n\t\t\tthis.x = arg0;\n\t\t\tthis.y = hasY ? arg1 : arg0;\n\t\t\tif (this.__read)\n\t\t\t\tthis.__read = hasY ? 2 : 1;\n\t\t} else if (type === 'undefined' || arg0 === null) {\n\t\t\tthis.x = this.y = 0;\n\t\t\tif (this.__read)\n\t\t\t\tthis.__read = arg0 === null ? 1 : 0;\n\t\t} else {\n\t\t\tif (Array.isArray(arg0)) {\n\t\t\t\tthis.x = arg0[0];\n\t\t\t\tthis.y = arg0.length > 1 ? arg0[1] : arg0[0];\n\t\t\t} else if (arg0.x != null) {\n\t\t\t\tthis.x = arg0.x;\n\t\t\t\tthis.y = arg0.y;\n\t\t\t} else if (arg0.width != null) {\n\t\t\t\tthis.x = arg0.width;\n\t\t\t\tthis.y = arg0.height;\n\t\t\t} else if (arg0.angle != null) {\n\t\t\t\tthis.x = arg0.length;\n\t\t\t\tthis.y = 0;\n\t\t\t\tthis.setAngle(arg0.angle);\n\t\t\t} else {\n\t\t\t\tthis.x = this.y = 0;\n\t\t\t\tif (this.__read)\n\t\t\t\t\tthis.__read = 0;\n\t\t\t}\n\t\t\tif (this.__read)\n\t\t\t\tthis.__read = 1;\n\t\t}\n\t},\n\n\tset: function(x, y) {\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t\treturn this;\n\t},\n\n\tequals: function(point) {\n\t\treturn this === point || point\n\t\t\t\t&& (this.x === point.x && this.y === point.y\n\t\t\t\t\t|| Array.isArray(point)\n\t\t\t\t\t\t&& this.x === point[0] && this.y === point[1])\n\t\t\t\t|| false;\n\t},\n\n\tclone: function() {\n\t\treturn new Point(this.x, this.y);\n\t},\n\n\ttoString: function() {\n\t\tvar f = Formatter.instance;\n\t\treturn '{ x: ' + f.number(this.x) + ', y: ' + f.number(this.y) + ' }';\n\t},\n\n\t_serialize: function(options) {\n\t\tvar f = options.formatter;\n\t\treturn [f.number(this.x), f.number(this.y)];\n\t},\n\n\tgetLength: function() {\n\t\treturn Math.sqrt(this.x * this.x + this.y * this.y);\n\t},\n\n\tsetLength: function(length) {\n\t\tif (this.isZero()) {\n\t\t\tvar angle = this._angle || 0;\n\t\t\tthis.set(\n\t\t\t\tMath.cos(angle) * length,\n\t\t\t\tMath.sin(angle) * length\n\t\t\t);\n\t\t} else {\n\t\t\tvar scale = length / this.getLength();\n\t\t\tif (Numerical.isZero(scale))\n\t\t\t\tthis.getAngle();\n\t\t\tthis.set(\n\t\t\t\tthis.x * scale,\n\t\t\t\tthis.y * scale\n\t\t\t);\n\t\t}\n\t},\n\tgetAngle: function() {\n\t\treturn this.getAngleInRadians.apply(this, arguments) * 180 / Math.PI;\n\t},\n\n\tsetAngle: function(angle) {\n\t\tthis.setAngleInRadians.call(this, angle * Math.PI / 180);\n\t},\n\n\tgetAngleInDegrees: '#getAngle',\n\tsetAngleInDegrees: '#setAngle',\n\n\tgetAngleInRadians: function() {\n\t\tif (!arguments.length) {\n\t\t\treturn this.isZero()\n\t\t\t\t\t? this._angle || 0\n\t\t\t\t\t: this._angle = Math.atan2(this.y, this.x);\n\t\t} else {\n\t\t\tvar point = Point.read(arguments),\n\t\t\t\tdiv = this.getLength() * point.getLength();\n\t\t\tif (Numerical.isZero(div)) {\n\t\t\t\treturn NaN;\n\t\t\t} else {\n\t\t\t\tvar a = this.dot(point) / div;\n\t\t\t\treturn Math.acos(a < -1 ? -1 : a > 1 ? 1 : a);\n\t\t\t}\n\t\t}\n\t},\n\n\tsetAngleInRadians: function(angle) {\n\t\tthis._angle = angle;\n\t\tif (!this.isZero()) {\n\t\t\tvar length = this.getLength();\n\t\t\tthis.set(\n\t\t\t\tMath.cos(angle) * length,\n\t\t\t\tMath.sin(angle) * length\n\t\t\t);\n\t\t}\n\t},\n\n\tgetQuadrant: function() {\n\t\treturn this.x >= 0 ? this.y >= 0 ? 1 : 4 : this.y >= 0 ? 2 : 3;\n\t}\n}, {\n\tbeans: false,\n\n\tgetDirectedAngle: function() {\n\t\tvar point = Point.read(arguments);\n\t\treturn Math.atan2(this.cross(point), this.dot(point)) * 180 / Math.PI;\n\t},\n\n\tgetDistance: function() {\n\t\tvar point = Point.read(arguments),\n\t\t\tx = point.x - this.x,\n\t\t\ty = point.y - this.y,\n\t\t\td = x * x + y * y,\n\t\t\tsquared = Base.read(arguments);\n\t\treturn squared ? d : Math.sqrt(d);\n\t},\n\n\tnormalize: function(length) {\n\t\tif (length === undefined)\n\t\t\tlength = 1;\n\t\tvar current = this.getLength(),\n\t\t\tscale = current !== 0 ? length / current : 0,\n\t\t\tpoint = new Point(this.x * scale, this.y * scale);\n\t\tif (scale >= 0)\n\t\t\tpoint._angle = this._angle;\n\t\treturn point;\n\t},\n\n\trotate: function(angle, center) {\n\t\tif (angle === 0)\n\t\t\treturn this.clone();\n\t\tangle = angle * Math.PI / 180;\n\t\tvar point = center ? this.subtract(center) : this,\n\t\t\tsin = Math.sin(angle),\n\t\t\tcos = Math.cos(angle);\n\t\tpoint = new Point(\n\t\t\tpoint.x * cos - point.y * sin,\n\t\t\tpoint.x * sin + point.y * cos\n\t\t);\n\t\treturn center ? point.add(center) : point;\n\t},\n\n\ttransform: function(matrix) {\n\t\treturn matrix ? matrix._transformPoint(this) : this;\n\t},\n\n\tadd: function() {\n\t\tvar point = Point.read(arguments);\n\t\treturn new Point(this.x + point.x, this.y + point.y);\n\t},\n\n\tsubtract: function() {\n\t\tvar point = Point.read(arguments);\n\t\treturn new Point(this.x - point.x, this.y - point.y);\n\t},\n\n\tmultiply: function() {\n\t\tvar point = Point.read(arguments);\n\t\treturn new Point(this.x * point.x, this.y * point.y);\n\t},\n\n\tdivide: function() {\n\t\tvar point = Point.read(arguments);\n\t\treturn new Point(this.x / point.x, this.y / point.y);\n\t},\n\n\tmodulo: function() {\n\t\tvar point = Point.read(arguments);\n\t\treturn new Point(this.x % point.x, this.y % point.y);\n\t},\n\n\tnegate: function() {\n\t\treturn new Point(-this.x, -this.y);\n\t},\n\n\tisInside: function() {\n\t\treturn Rectangle.read(arguments).contains(this);\n\t},\n\n\tisClose: function() {\n\t\tvar point = Point.read(arguments),\n\t\t\ttolerance = Base.read(arguments);\n\t\treturn this.getDistance(point) < tolerance;\n\t},\n\n\tisCollinear: function() {\n\t\tvar point = Point.read(arguments);\n\t\treturn Point.isCollinear(this.x, this.y, point.x, point.y);\n\t},\n\n\tisColinear: '#isCollinear',\n\n\tisOrthogonal: function() {\n\t\tvar point = Point.read(arguments);\n\t\treturn Point.isOrthogonal(this.x, this.y, point.x, point.y);\n\t},\n\n\tisZero: function() {\n\t\treturn Numerical.isZero(this.x) && Numerical.isZero(this.y);\n\t},\n\n\tisNaN: function() {\n\t\treturn isNaN(this.x) || isNaN(this.y);\n\t},\n\n\tdot: function() {\n\t\tvar point = Point.read(arguments);\n\t\treturn this.x * point.x + this.y * point.y;\n\t},\n\n\tcross: function() {\n\t\tvar point = Point.read(arguments);\n\t\treturn this.x * point.y - this.y * point.x;\n\t},\n\n\tproject: function() {\n\t\tvar point = Point.read(arguments),\n\t\t\tscale = point.isZero() ? 0 : this.dot(point) / point.dot(point);\n\t\treturn new Point(\n\t\t\tpoint.x * scale,\n\t\t\tpoint.y * scale\n\t\t);\n\t},\n\n\tstatics: {\n\t\tmin: function() {\n\t\t\tvar point1 = Point.read(arguments),\n\t\t\t\tpoint2 = Point.read(arguments);\n\t\t\treturn new Point(\n\t\t\t\tMath.min(point1.x, point2.x),\n\t\t\t\tMath.min(point1.y, point2.y)\n\t\t\t);\n\t\t},\n\n\t\tmax: function() {\n\t\t\tvar point1 = Point.read(arguments),\n\t\t\t\tpoint2 = Point.read(arguments);\n\t\t\treturn new Point(\n\t\t\t\tMath.max(point1.x, point2.x),\n\t\t\t\tMath.max(point1.y, point2.y)\n\t\t\t);\n\t\t},\n\n\t\trandom: function() {\n\t\t\treturn new Point(Math.random(), Math.random());\n\t\t},\n\n\t\tisCollinear: function(x1, y1, x2, y2) {\n\t\t\treturn Math.abs(x1 * y2 - y1 * x2)\n\t\t\t\t\t<= Math.sqrt((x1 * x1 + y1 * y1) * (x2 * x2 + y2 * y2))\n\t\t\t\t\t\t* 1e-7;\n\t\t},\n\n\t\tisOrthogonal: function(x1, y1, x2, y2) {\n\t\t\treturn Math.abs(x1 * x2 + y1 * y2)\n\t\t\t\t\t<= Math.sqrt((x1 * x1 + y1 * y1) * (x2 * x2 + y2 * y2))\n\t\t\t\t\t\t* 1e-7;\n\t\t}\n\t}\n}, Base.each(['round', 'ceil', 'floor', 'abs'], function(name) {\n\tvar op = Math[name];\n\tthis[name] = function() {\n\t\treturn new Point(op(this.x), op(this.y));\n\t};\n}, {}));\n\nvar LinkedPoint = Point.extend({\n\tinitialize: function Point(x, y, owner, setter) {\n\t\tthis._x = x;\n\t\tthis._y = y;\n\t\tthis._owner = owner;\n\t\tthis._setter = setter;\n\t},\n\n\tset: function(x, y, _dontNotify) {\n\t\tthis._x = x;\n\t\tthis._y = y;\n\t\tif (!_dontNotify)\n\t\t\tthis._owner[this._setter](this);\n\t\treturn this;\n\t},\n\n\tgetX: function() {\n\t\treturn this._x;\n\t},\n\n\tsetX: function(x) {\n\t\tthis._x = x;\n\t\tthis._owner[this._setter](this);\n\t},\n\n\tgetY: function() {\n\t\treturn this._y;\n\t},\n\n\tsetY: function(y) {\n\t\tthis._y = y;\n\t\tthis._owner[this._setter](this);\n\t}\n});\n\nvar Size = Base.extend({\n\t_class: 'Size',\n\t_readIndex: true,\n\n\tinitialize: function Size(arg0, arg1) {\n\t\tvar type = typeof arg0;\n\t\tif (type === 'number') {\n\t\t\tvar hasHeight = typeof arg1 === 'number';\n\t\t\tthis.width = arg0;\n\t\t\tthis.height = hasHeight ? arg1 : arg0;\n\t\t\tif (this.__read)\n\t\t\t\tthis.__read = hasHeight ? 2 : 1;\n\t\t} else if (type === 'undefined' || arg0 === null) {\n\t\t\tthis.width = this.height = 0;\n\t\t\tif (this.__read)\n\t\t\t\tthis.__read = arg0 === null ? 1 : 0;\n\t\t} else {\n\t\t\tif (Array.isArray(arg0)) {\n\t\t\t\tthis.width = arg0[0];\n\t\t\t\tthis.height = arg0.length > 1 ? arg0[1] : arg0[0];\n\t\t\t} else if (arg0.width != null) {\n\t\t\t\tthis.width = arg0.width;\n\t\t\t\tthis.height = arg0.height;\n\t\t\t} else if (arg0.x != null) {\n\t\t\t\tthis.width = arg0.x;\n\t\t\t\tthis.height = arg0.y;\n\t\t\t} else {\n\t\t\t\tthis.width = this.height = 0;\n\t\t\t\tif (this.__read)\n\t\t\t\t\tthis.__read = 0;\n\t\t\t}\n\t\t\tif (this.__read)\n\t\t\t\tthis.__read = 1;\n\t\t}\n\t},\n\n\tset: function(width, height) {\n\t\tthis.width = width;\n\t\tthis.height = height;\n\t\treturn this;\n\t},\n\n\tequals: function(size) {\n\t\treturn size === this || size && (this.width === size.width\n\t\t\t\t&& this.height === size.height\n\t\t\t\t|| Array.isArray(size) && this.width === size[0]\n\t\t\t\t\t&& this.height === size[1]) || false;\n\t},\n\n\tclone: function() {\n\t\treturn new Size(this.width, this.height);\n\t},\n\n\ttoString: function() {\n\t\tvar f = Formatter.instance;\n\t\treturn '{ width: ' + f.number(this.width)\n\t\t\t\t+ ', height: ' + f.number(this.height) + ' }';\n\t},\n\n\t_serialize: function(options) {\n\t\tvar f = options.formatter;\n\t\treturn [f.number(this.width),\n\t\t\t\tf.number(this.height)];\n\t},\n\n\tadd: function() {\n\t\tvar size = Size.read(arguments);\n\t\treturn new Size(this.width + size.width, this.height + size.height);\n\t},\n\n\tsubtract: function() {\n\t\tvar size = Size.read(arguments);\n\t\treturn new Size(this.width - size.width, this.height - size.height);\n\t},\n\n\tmultiply: function() {\n\t\tvar size = Size.read(arguments);\n\t\treturn new Size(this.width * size.width, this.height * size.height);\n\t},\n\n\tdivide: function() {\n\t\tvar size = Size.read(arguments);\n\t\treturn new Size(this.width / size.width, this.height / size.height);\n\t},\n\n\tmodulo: function() {\n\t\tvar size = Size.read(arguments);\n\t\treturn new Size(this.width % size.width, this.height % size.height);\n\t},\n\n\tnegate: function() {\n\t\treturn new Size(-this.width, -this.height);\n\t},\n\n\tisZero: function() {\n\t\treturn Numerical.isZero(this.width) && Numerical.isZero(this.height);\n\t},\n\n\tisNaN: function() {\n\t\treturn isNaN(this.width) || isNaN(this.height);\n\t},\n\n\tstatics: {\n\t\tmin: function(size1, size2) {\n\t\t\treturn new Size(\n\t\t\t\tMath.min(size1.width, size2.width),\n\t\t\t\tMath.min(size1.height, size2.height));\n\t\t},\n\n\t\tmax: function(size1, size2) {\n\t\t\treturn new Size(\n\t\t\t\tMath.max(size1.width, size2.width),\n\t\t\t\tMath.max(size1.height, size2.height));\n\t\t},\n\n\t\trandom: function() {\n\t\t\treturn new Size(Math.random(), Math.random());\n\t\t}\n\t}\n}, Base.each(['round', 'ceil', 'floor', 'abs'], function(name) {\n\tvar op = Math[name];\n\tthis[name] = function() {\n\t\treturn new Size(op(this.width), op(this.height));\n\t};\n}, {}));\n\nvar LinkedSize = Size.extend({\n\tinitialize: function Size(width, height, owner, setter) {\n\t\tthis._width = width;\n\t\tthis._height = height;\n\t\tthis._owner = owner;\n\t\tthis._setter = setter;\n\t},\n\n\tset: function(width, height, _dontNotify) {\n\t\tthis._width = width;\n\t\tthis._height = height;\n\t\tif (!_dontNotify)\n\t\t\tthis._owner[this._setter](this);\n\t\treturn this;\n\t},\n\n\tgetWidth: function() {\n\t\treturn this._width;\n\t},\n\n\tsetWidth: function(width) {\n\t\tthis._width = width;\n\t\tthis._owner[this._setter](this);\n\t},\n\n\tgetHeight: function() {\n\t\treturn this._height;\n\t},\n\n\tsetHeight: function(height) {\n\t\tthis._height = height;\n\t\tthis._owner[this._setter](this);\n\t}\n});\n\nvar Rectangle = Base.extend({\n\t_class: 'Rectangle',\n\t_readIndex: true,\n\tbeans: true,\n\n\tinitialize: function Rectangle(arg0, arg1, arg2, arg3) {\n\t\tvar type = typeof arg0,\n\t\t\tread = 0;\n\t\tif (type === 'number') {\n\t\t\tthis.x = arg0;\n\t\t\tthis.y = arg1;\n\t\t\tthis.width = arg2;\n\t\t\tthis.height = arg3;\n\t\t\tread = 4;\n\t\t} else if (type === 'undefined' || arg0 === null) {\n\t\t\tthis.x = this.y = this.width = this.height = 0;\n\t\t\tread = arg0 === null ? 1 : 0;\n\t\t} else if (arguments.length === 1) {\n\t\t\tif (Array.isArray(arg0)) {\n\t\t\t\tthis.x = arg0[0];\n\t\t\t\tthis.y = arg0[1];\n\t\t\t\tthis.width = arg0[2];\n\t\t\t\tthis.height = arg0[3];\n\t\t\t\tread = 1;\n\t\t\t} else if (arg0.x !== undefined || arg0.width !== undefined) {\n\t\t\t\tthis.x = arg0.x || 0;\n\t\t\t\tthis.y = arg0.y || 0;\n\t\t\t\tthis.width = arg0.width || 0;\n\t\t\t\tthis.height = arg0.height || 0;\n\t\t\t\tread = 1;\n\t\t\t} else if (arg0.from === undefined && arg0.to === undefined) {\n\t\t\t\tthis.x = this.y = this.width = this.height = 0;\n\t\t\t\tthis._set(arg0);\n\t\t\t\tread = 1;\n\t\t\t}\n\t\t}\n\t\tif (!read) {\n\t\t\tvar point = Point.readNamed(arguments, 'from'),\n\t\t\t\tnext = Base.peek(arguments);\n\t\t\tthis.x = point.x;\n\t\t\tthis.y = point.y;\n\t\t\tif (next && next.x !== undefined || Base.hasNamed(arguments, 'to')) {\n\t\t\t\tvar to = Point.readNamed(arguments, 'to');\n\t\t\t\tthis.width = to.x - point.x;\n\t\t\t\tthis.height = to.y - point.y;\n\t\t\t\tif (this.width < 0) {\n\t\t\t\t\tthis.x = to.x;\n\t\t\t\t\tthis.width = -this.width;\n\t\t\t\t}\n\t\t\t\tif (this.height < 0) {\n\t\t\t\t\tthis.y = to.y;\n\t\t\t\t\tthis.height = -this.height;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tvar size = Size.read(arguments);\n\t\t\t\tthis.width = size.width;\n\t\t\t\tthis.height = size.height;\n\t\t\t}\n\t\t\tread = arguments.__index;\n\t\t}\n\t\tif (this.__read)\n\t\t\tthis.__read = read;\n\t},\n\n\tset: function(x, y, width, height) {\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t\tthis.width = width;\n\t\tthis.height = height;\n\t\treturn this;\n\t},\n\n\tclone: function() {\n\t\treturn new Rectangle(this.x, this.y, this.width, this.height);\n\t},\n\n\tequals: function(rect) {\n\t\tvar rt = Base.isPlainValue(rect)\n\t\t\t\t? Rectangle.read(arguments)\n\t\t\t\t: rect;\n\t\treturn rt === this\n\t\t\t\t|| rt && this.x === rt.x && this.y === rt.y\n\t\t\t\t\t&& this.width === rt.width && this.height === rt.height\n\t\t\t\t|| false;\n\t},\n\n\ttoString: function() {\n\t\tvar f = Formatter.instance;\n\t\treturn '{ x: ' + f.number(this.x)\n\t\t\t\t+ ', y: ' + f.number(this.y)\n\t\t\t\t+ ', width: ' + f.number(this.width)\n\t\t\t\t+ ', height: ' + f.number(this.height)\n\t\t\t\t+ ' }';\n\t},\n\n\t_serialize: function(options) {\n\t\tvar f = options.formatter;\n\t\treturn [f.number(this.x),\n\t\t\t\tf.number(this.y),\n\t\t\t\tf.number(this.width),\n\t\t\t\tf.number(this.height)];\n\t},\n\n\tgetPoint: function(_dontLink) {\n\t\tvar ctor = _dontLink ? Point : LinkedPoint;\n\t\treturn new ctor(this.x, this.y, this, 'setPoint');\n\t},\n\n\tsetPoint: function() {\n\t\tvar point = Point.read(arguments);\n\t\tthis.x = point.x;\n\t\tthis.y = point.y;\n\t},\n\n\tgetSize: function(_dontLink) {\n\t\tvar ctor = _dontLink ? Size : LinkedSize;\n\t\treturn new ctor(this.width, this.height, this, 'setSize');\n\t},\n\n\tsetSize: function() {\n\t\tvar size = Size.read(arguments);\n\t\tif (this._fixX)\n\t\t\tthis.x += (this.width - size.width) * this._fixX;\n\t\tif (this._fixY)\n\t\t\tthis.y += (this.height - size.height) * this._fixY;\n\t\tthis.width = size.width;\n\t\tthis.height = size.height;\n\t\tthis._fixW = 1;\n\t\tthis._fixH = 1;\n\t},\n\n\tgetLeft: function() {\n\t\treturn this.x;\n\t},\n\n\tsetLeft: function(left) {\n\t\tif (!this._fixW)\n\t\t\tthis.width -= left - this.x;\n\t\tthis.x = left;\n\t\tthis._fixX = 0;\n\t},\n\n\tgetTop: function() {\n\t\treturn this.y;\n\t},\n\n\tsetTop: function(top) {\n\t\tif (!this._fixH)\n\t\t\tthis.height -= top - this.y;\n\t\tthis.y = top;\n\t\tthis._fixY = 0;\n\t},\n\n\tgetRight: function() {\n\t\treturn this.x + this.width;\n\t},\n\n\tsetRight: function(right) {\n\t\tif (this._fixX !== undefined && this._fixX !== 1)\n\t\t\tthis._fixW = 0;\n\t\tif (this._fixW)\n\t\t\tthis.x = right - this.width;\n\t\telse\n\t\t\tthis.width = right - this.x;\n\t\tthis._fixX = 1;\n\t},\n\n\tgetBottom: function() {\n\t\treturn this.y + this.height;\n\t},\n\n\tsetBottom: function(bottom) {\n\t\tif (this._fixY !== undefined && this._fixY !== 1)\n\t\t\tthis._fixH = 0;\n\t\tif (this._fixH)\n\t\t\tthis.y = bottom - this.height;\n\t\telse\n\t\t\tthis.height = bottom - this.y;\n\t\tthis._fixY = 1;\n\t},\n\n\tgetCenterX: function() {\n\t\treturn this.x + this.width * 0.5;\n\t},\n\n\tsetCenterX: function(x) {\n\t\tthis.x = x - this.width * 0.5;\n\t\tthis._fixX = 0.5;\n\t},\n\n\tgetCenterY: function() {\n\t\treturn this.y + this.height * 0.5;\n\t},\n\n\tsetCenterY: function(y) {\n\t\tthis.y = y - this.height * 0.5;\n\t\tthis._fixY = 0.5;\n\t},\n\n\tgetCenter: function(_dontLink) {\n\t\tvar ctor = _dontLink ? Point : LinkedPoint;\n\t\treturn new ctor(this.getCenterX(), this.getCenterY(), this, 'setCenter');\n\t},\n\n\tsetCenter: function() {\n\t\tvar point = Point.read(arguments);\n\t\tthis.setCenterX(point.x);\n\t\tthis.setCenterY(point.y);\n\t\treturn this;\n\t},\n\n\tgetArea: function() {\n\t\treturn this.width * this.height;\n\t},\n\n\tisEmpty: function() {\n\t\treturn this.width === 0 || this.height === 0;\n\t},\n\n\tcontains: function(arg) {\n\t\treturn arg && arg.width !== undefined\n\t\t\t\t|| (Array.isArray(arg) ? arg : arguments).length == 4\n\t\t\t\t? this._containsRectangle(Rectangle.read(arguments))\n\t\t\t\t: this._containsPoint(Point.read(arguments));\n\t},\n\n\t_containsPoint: function(point) {\n\t\tvar x = point.x,\n\t\t\ty = point.y;\n\t\treturn x >= this.x && y >= this.y\n\t\t\t\t&& x <= this.x + this.width\n\t\t\t\t&& y <= this.y + this.height;\n\t},\n\n\t_containsRectangle: function(rect) {\n\t\tvar x = rect.x,\n\t\t\ty = rect.y;\n\t\treturn x >= this.x && y >= this.y\n\t\t\t\t&& x + rect.width <= this.x + this.width\n\t\t\t\t&& y + rect.height <= this.y + this.height;\n\t},\n\n\tintersects: function() {\n\t\tvar rect = Rectangle.read(arguments);\n\t\treturn rect.x + rect.width > this.x\n\t\t\t\t&& rect.y + rect.height > this.y\n\t\t\t\t&& rect.x < this.x + this.width\n\t\t\t\t&& rect.y < this.y + this.height;\n\t},\n\n\ttouches: function() {\n\t\tvar rect = Rectangle.read(arguments);\n\t\treturn rect.x + rect.width >= this.x\n\t\t\t\t&& rect.y + rect.height >= this.y\n\t\t\t\t&& rect.x <= this.x + this.width\n\t\t\t\t&& rect.y <= this.y + this.height;\n\t},\n\n\tintersect: function() {\n\t\tvar rect = Rectangle.read(arguments),\n\t\t\tx1 = Math.max(this.x, rect.x),\n\t\t\ty1 = Math.max(this.y, rect.y),\n\t\t\tx2 = Math.min(this.x + this.width, rect.x + rect.width),\n\t\t\ty2 = Math.min(this.y + this.height, rect.y + rect.height);\n\t\treturn new Rectangle(x1, y1, x2 - x1, y2 - y1);\n\t},\n\n\tunite: function() {\n\t\tvar rect = Rectangle.read(arguments),\n\t\t\tx1 = Math.min(this.x, rect.x),\n\t\t\ty1 = Math.min(this.y, rect.y),\n\t\t\tx2 = Math.max(this.x + this.width, rect.x + rect.width),\n\t\t\ty2 = Math.max(this.y + this.height, rect.y + rect.height);\n\t\treturn new Rectangle(x1, y1, x2 - x1, y2 - y1);\n\t},\n\n\tinclude: function() {\n\t\tvar point = Point.read(arguments);\n\t\tvar x1 = Math.min(this.x, point.x),\n\t\t\ty1 = Math.min(this.y, point.y),\n\t\t\tx2 = Math.max(this.x + this.width, point.x),\n\t\t\ty2 = Math.max(this.y + this.height, point.y);\n\t\treturn new Rectangle(x1, y1, x2 - x1, y2 - y1);\n\t},\n\n\texpand: function() {\n\t\tvar amount = Size.read(arguments),\n\t\t\thor = amount.width,\n\t\t\tver = amount.height;\n\t\treturn new Rectangle(this.x - hor / 2, this.y - ver / 2,\n\t\t\t\tthis.width + hor, this.height + ver);\n\t},\n\n\tscale: function(hor, ver) {\n\t\treturn this.expand(this.width * hor - this.width,\n\t\t\t\tthis.height * (ver === undefined ? hor : ver) - this.height);\n\t}\n}, Base.each([\n\t\t['Top', 'Left'], ['Top', 'Right'],\n\t\t['Bottom', 'Left'], ['Bottom', 'Right'],\n\t\t['Left', 'Center'], ['Top', 'Center'],\n\t\t['Right', 'Center'], ['Bottom', 'Center']\n\t],\n\tfunction(parts, index) {\n\t\tvar part = parts.join('');\n\t\tvar xFirst = /^[RL]/.test(part);\n\t\tif (index >= 4)\n\t\t\tparts[1] += xFirst ? 'Y' : 'X';\n\t\tvar x = parts[xFirst ? 0 : 1],\n\t\t\ty = parts[xFirst ? 1 : 0],\n\t\t\tgetX = 'get' + x,\n\t\t\tgetY = 'get' + y,\n\t\t\tsetX = 'set' + x,\n\t\t\tsetY = 'set' + y,\n\t\t\tget = 'get' + part,\n\t\t\tset = 'set' + part;\n\t\tthis[get] = function(_dontLink) {\n\t\t\tvar ctor = _dontLink ? Point : LinkedPoint;\n\t\t\treturn new ctor(this[getX](), this[getY](), this, set);\n\t\t};\n\t\tthis[set] = function() {\n\t\t\tvar point = Point.read(arguments);\n\t\t\tthis[setX](point.x);\n\t\t\tthis[setY](point.y);\n\t\t};\n\t}, {\n\t\tbeans: true\n\t}\n));\n\nvar LinkedRectangle = Rectangle.extend({\n\tinitialize: function Rectangle(x, y, width, height, owner, setter) {\n\t\tthis.set(x, y, width, height, true);\n\t\tthis._owner = owner;\n\t\tthis._setter = setter;\n\t},\n\n\tset: function(x, y, width, height, _dontNotify) {\n\t\tthis._x = x;\n\t\tthis._y = y;\n\t\tthis._width = width;\n\t\tthis._height = height;\n\t\tif (!_dontNotify)\n\t\t\tthis._owner[this._setter](this);\n\t\treturn this;\n\t}\n},\nnew function() {\n\tvar proto = Rectangle.prototype;\n\n\treturn Base.each(['x', 'y', 'width', 'height'], function(key) {\n\t\tvar part = Base.capitalize(key);\n\t\tvar internal = '_' + key;\n\t\tthis['get' + part] = function() {\n\t\t\treturn this[internal];\n\t\t};\n\n\t\tthis['set' + part] = function(value) {\n\t\t\tthis[internal] = value;\n\t\t\tif (!this._dontNotify)\n\t\t\t\tthis._owner[this._setter](this);\n\t\t};\n\t}, Base.each(['Point', 'Size', 'Center',\n\t\t\t'Left', 'Top', 'Right', 'Bottom', 'CenterX', 'CenterY',\n\t\t\t'TopLeft', 'TopRight', 'BottomLeft', 'BottomRight',\n\t\t\t'LeftCenter', 'TopCenter', 'RightCenter', 'BottomCenter'],\n\t\tfunction(key) {\n\t\t\tvar name = 'set' + key;\n\t\t\tthis[name] = function() {\n\t\t\t\tthis._dontNotify = true;\n\t\t\t\tproto[name].apply(this, arguments);\n\t\t\t\tthis._dontNotify = false;\n\t\t\t\tthis._owner[this._setter](this);\n\t\t\t};\n\t\t}, {\n\t\t\tisSelected: function() {\n\t\t\t\treturn this._owner._boundsSelected;\n\t\t\t},\n\n\t\t\tsetSelected: function(selected) {\n\t\t\t\tvar owner = this._owner;\n\t\t\t\tif (owner.setSelected) {\n\t\t\t\t\towner._boundsSelected = selected;\n\t\t\t\t\towner.setSelected(selected || owner._selectedSegmentState > 0);\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t);\n});\n\nvar Matrix = Base.extend({\n\t_class: 'Matrix',\n\n\tinitialize: function Matrix(arg) {\n\t\tvar count = arguments.length,\n\t\t\tok = true;\n\t\tif (count === 6) {\n\t\t\tthis.set.apply(this, arguments);\n\t\t} else if (count === 1) {\n\t\t\tif (arg instanceof Matrix) {\n\t\t\t\tthis.set(arg._a, arg._c, arg._b, arg._d, arg._tx, arg._ty);\n\t\t\t} else if (Array.isArray(arg)) {\n\t\t\t\tthis.set.apply(this, arg);\n\t\t\t} else {\n\t\t\t\tok = false;\n\t\t\t}\n\t\t} else if (count === 0) {\n\t\t\tthis.reset();\n\t\t} else {\n\t\t\tok = false;\n\t\t}\n\t\tif (!ok)\n\t\t\tthrow new Error('Unsupported matrix parameters');\n\t},\n\n\tset: function(a, c, b, d, tx, ty, _dontNotify) {\n\t\tthis._a = a;\n\t\tthis._c = c;\n\t\tthis._b = b;\n\t\tthis._d = d;\n\t\tthis._tx = tx;\n\t\tthis._ty = ty;\n\t\tif (!_dontNotify)\n\t\t\tthis._changed();\n\t\treturn this;\n\t},\n\n\t_serialize: function(options) {\n\t\treturn Base.serialize(this.getValues(), options);\n\t},\n\n\t_changed: function() {\n\t\tvar owner = this._owner;\n\t\tif (owner) {\n\t\t\tif (owner._applyMatrix) {\n\t\t\t\towner.transform(null, true);\n\t\t\t} else {\n\t\t\t\towner._changed(9);\n\t\t\t}\n\t\t}\n\t},\n\n\tclone: function() {\n\t\treturn new Matrix(this._a, this._c, this._b, this._d,\n\t\t\t\tthis._tx, this._ty);\n\t},\n\n\tequals: function(mx) {\n\t\treturn mx === this || mx && this._a === mx._a && this._b === mx._b\n\t\t\t\t&& this._c === mx._c && this._d === mx._d\n\t\t\t\t&& this._tx === mx._tx && this._ty === mx._ty\n\t\t\t\t|| false;\n\t},\n\n\ttoString: function() {\n\t\tvar f = Formatter.instance;\n\t\treturn '[[' + [f.number(this._a), f.number(this._b),\n\t\t\t\t\tf.number(this._tx)].join(', ') + '], ['\n\t\t\t\t+ [f.number(this._c), f.number(this._d),\n\t\t\t\t\tf.number(this._ty)].join(', ') + ']]';\n\t},\n\n\treset: function(_dontNotify) {\n\t\tthis._a = this._d = 1;\n\t\tthis._c = this._b = this._tx = this._ty = 0;\n\t\tif (!_dontNotify)\n\t\t\tthis._changed();\n\t\treturn this;\n\t},\n\n\tapply: function(recursively, _setApplyMatrix) {\n\t\tvar owner = this._owner;\n\t\tif (owner) {\n\t\t\towner.transform(null, true, Base.pick(recursively, true),\n\t\t\t\t\t_setApplyMatrix);\n\t\t\treturn this.isIdentity();\n\t\t}\n\t\treturn false;\n\t},\n\n\ttranslate: function() {\n\t\tvar point = Point.read(arguments),\n\t\t\tx = point.x,\n\t\t\ty = point.y;\n\t\tthis._tx += x * this._a + y * this._b;\n\t\tthis._ty += x * this._c + y * this._d;\n\t\tthis._changed();\n\t\treturn this;\n\t},\n\n\tscale: function() {\n\t\tvar scale = Point.read(arguments),\n\t\t\tcenter = Point.read(arguments, 0, { readNull: true });\n\t\tif (center)\n\t\t\tthis.translate(center);\n\t\tthis._a *= scale.x;\n\t\tthis._c *= scale.x;\n\t\tthis._b *= scale.y;\n\t\tthis._d *= scale.y;\n\t\tif (center)\n\t\t\tthis.translate(center.negate());\n\t\tthis._changed();\n\t\treturn this;\n\t},\n\n\trotate: function(angle ) {\n\t\tangle *= Math.PI / 180;\n\t\tvar center = Point.read(arguments, 1),\n\t\t\tx = center.x,\n\t\t\ty = center.y,\n\t\t\tcos = Math.cos(angle),\n\t\t\tsin = Math.sin(angle),\n\t\t\ttx = x - x * cos + y * sin,\n\t\t\tty = y - x * sin - y * cos,\n\t\t\ta = this._a,\n\t\t\tb = this._b,\n\t\t\tc = this._c,\n\t\t\td = this._d;\n\t\tthis._a = cos * a + sin * b;\n\t\tthis._b = -sin * a + cos * b;\n\t\tthis._c = cos * c + sin * d;\n\t\tthis._d = -sin * c + cos * d;\n\t\tthis._tx += tx * a + ty * b;\n\t\tthis._ty += tx * c + ty * d;\n\t\tthis._changed();\n\t\treturn this;\n\t},\n\n\tshear: function() {\n\t\tvar shear = Point.read(arguments),\n\t\t\tcenter = Point.read(arguments, 0, { readNull: true });\n\t\tif (center)\n\t\t\tthis.translate(center);\n\t\tvar a = this._a,\n\t\t\tc = this._c;\n\t\tthis._a += shear.y * this._b;\n\t\tthis._c += shear.y * this._d;\n\t\tthis._b += shear.x * a;\n\t\tthis._d += shear.x * c;\n\t\tif (center)\n\t\t\tthis.translate(center.negate());\n\t\tthis._changed();\n\t\treturn this;\n\t},\n\n\tskew: function() {\n\t\tvar skew = Point.read(arguments),\n\t\t\tcenter = Point.read(arguments, 0, { readNull: true }),\n\t\t\ttoRadians = Math.PI / 180,\n\t\t\tshear = new Point(Math.tan(skew.x * toRadians),\n\t\t\t\tMath.tan(skew.y * toRadians));\n\t\treturn this.shear(shear, center);\n\t},\n\n\tconcatenate: function(mx) {\n\t\tvar a1 = this._a,\n\t\t\tb1 = this._b,\n\t\t\tc1 = this._c,\n\t\t\td1 = this._d,\n\t\t\ta2 = mx._a,\n\t\t\tb2 = mx._b,\n\t\t\tc2 = mx._c,\n\t\t\td2 = mx._d,\n\t\t\ttx2 = mx._tx,\n\t\t\tty2 = mx._ty;\n\t\tthis._a = a2 * a1 + c2 * b1;\n\t\tthis._b = b2 * a1 + d2 * b1;\n\t\tthis._c = a2 * c1 + c2 * d1;\n\t\tthis._d = b2 * c1 + d2 * d1;\n\t\tthis._tx += tx2 * a1 + ty2 * b1;\n\t\tthis._ty += tx2 * c1 + ty2 * d1;\n\t\tthis._changed();\n\t\treturn this;\n\t},\n\n\tpreConcatenate: function(mx) {\n\t\tvar a1 = this._a,\n\t\t\tb1 = this._b,\n\t\t\tc1 = this._c,\n\t\t\td1 = this._d,\n\t\t\ttx1 = this._tx,\n\t\t\tty1 = this._ty,\n\t\t\ta2 = mx._a,\n\t\t\tb2 = mx._b,\n\t\t\tc2 = mx._c,\n\t\t\td2 = mx._d,\n\t\t\ttx2 = mx._tx,\n\t\t\tty2 = mx._ty;\n\t\tthis._a = a2 * a1 + b2 * c1;\n\t\tthis._b = a2 * b1 + b2 * d1;\n\t\tthis._c = c2 * a1 + d2 * c1;\n\t\tthis._d = c2 * b1 + d2 * d1;\n\t\tthis._tx = a2 * tx1 + b2 * ty1 + tx2;\n\t\tthis._ty = c2 * tx1 + d2 * ty1 + ty2;\n\t\tthis._changed();\n\t\treturn this;\n\t},\n\n\tchain: function(mx) {\n\t\tvar a1 = this._a,\n\t\t\tb1 = this._b,\n\t\t\tc1 = this._c,\n\t\t\td1 = this._d,\n\t\t\ttx1 = this._tx,\n\t\t\tty1 = this._ty,\n\t\t\ta2 = mx._a,\n\t\t\tb2 = mx._b,\n\t\t\tc2 = mx._c,\n\t\t\td2 = mx._d,\n\t\t\ttx2 = mx._tx,\n\t\t\tty2 = mx._ty;\n\t\treturn new Matrix(\n\t\t\t\ta2 * a1 + c2 * b1,\n\t\t\t\ta2 * c1 + c2 * d1,\n\t\t\t\tb2 * a1 + d2 * b1,\n\t\t\t\tb2 * c1 + d2 * d1,\n\t\t\t\ttx1 + tx2 * a1 + ty2 * b1,\n\t\t\t\tty1 + tx2 * c1 + ty2 * d1);\n\t},\n\n\tisIdentity: function() {\n\t\treturn this._a === 1 && this._c === 0 && this._b === 0 && this._d === 1\n\t\t\t\t&& this._tx === 0 && this._ty === 0;\n\t},\n\n\torNullIfIdentity: function() {\n\t\treturn this.isIdentity() ? null : this;\n\t},\n\n\tisInvertible: function() {\n\t\treturn !!this._getDeterminant();\n\t},\n\n\tisSingular: function() {\n\t\treturn !this._getDeterminant();\n\t},\n\n\ttransform: function( src, dst, count) {\n\t\treturn arguments.length < 3\n\t\t\t? this._transformPoint(Point.read(arguments))\n\t\t\t: this._transformCoordinates(src, dst, count);\n\t},\n\n\t_transformPoint: function(point, dest, _dontNotify) {\n\t\tvar x = point.x,\n\t\t\ty = point.y;\n\t\tif (!dest)\n\t\t\tdest = new Point();\n\t\treturn dest.set(\n\t\t\tx * this._a + y * this._b + this._tx,\n\t\t\tx * this._c + y * this._d + this._ty,\n\t\t\t_dontNotify\n\t\t);\n\t},\n\n\t_transformCoordinates: function(src, dst, count) {\n\t\tvar i = 0,\n\t\t\tj = 0,\n\t\t\tmax = 2 * count;\n\t\twhile (i < max) {\n\t\t\tvar x = src[i++],\n\t\t\t\ty = src[i++];\n\t\t\tdst[j++] = x * this._a + y * this._b + this._tx;\n\t\t\tdst[j++] = x * this._c + y * this._d + this._ty;\n\t\t}\n\t\treturn dst;\n\t},\n\n\t_transformCorners: function(rect) {\n\t\tvar x1 = rect.x,\n\t\t\ty1 = rect.y,\n\t\t\tx2 = x1 + rect.width,\n\t\t\ty2 = y1 + rect.height,\n\t\t\tcoords = [ x1, y1, x2, y1, x2, y2, x1, y2 ];\n\t\treturn this._transformCoordinates(coords, coords, 4);\n\t},\n\n\t_transformBounds: function(bounds, dest, _dontNotify) {\n\t\tvar coords = this._transformCorners(bounds),\n\t\t\tmin = coords.slice(0, 2),\n\t\t\tmax = min.slice();\n\t\tfor (var i = 2; i < 8; i++) {\n\t\t\tvar val = coords[i],\n\t\t\t\tj = i & 1;\n\t\t\tif (val < min[j])\n\t\t\t\tmin[j] = val;\n\t\t\telse if (val > max[j])\n\t\t\t\tmax[j] = val;\n\t\t}\n\t\tif (!dest)\n\t\t\tdest = new Rectangle();\n\t\treturn dest.set(min[0], min[1], max[0] - min[0], max[1] - min[1],\n\t\t\t\t_dontNotify);\n\t},\n\n\tinverseTransform: function() {\n\t\treturn this._inverseTransform(Point.read(arguments));\n\t},\n\n\t_getDeterminant: function() {\n\t\tvar det = this._a * this._d - this._b * this._c;\n\t\treturn isFinite(det) && !Numerical.isZero(det)\n\t\t\t\t&& isFinite(this._tx) && isFinite(this._ty)\n\t\t\t\t? det : null;\n\t},\n\n\t_inverseTransform: function(point, dest, _dontNotify) {\n\t\tvar det = this._getDeterminant();\n\t\tif (!det)\n\t\t\treturn null;\n\t\tvar x = point.x - this._tx,\n\t\t\ty = point.y - this._ty;\n\t\tif (!dest)\n\t\t\tdest = new Point();\n\t\treturn dest.set(\n\t\t\t(x * this._d - y * this._b) / det,\n\t\t\t(y * this._a - x * this._c) / det,\n\t\t\t_dontNotify\n\t\t);\n\t},\n\n\tdecompose: function() {\n\t\tvar a = this._a, b = this._b, c = this._c, d = this._d;\n\t\tif (Numerical.isZero(a * d - b * c))\n\t\t\treturn null;\n\n\t\tvar scaleX = Math.sqrt(a * a + b * b);\n\t\ta /= scaleX;\n\t\tb /= scaleX;\n\n\t\tvar shear = a * c + b * d;\n\t\tc -= a * shear;\n\t\td -= b * shear;\n\n\t\tvar scaleY = Math.sqrt(c * c + d * d);\n\t\tc /= scaleY;\n\t\td /= scaleY;\n\t\tshear /= scaleY;\n\n\t\tif (a * d < b * c) {\n\t\t\ta = -a;\n\t\t\tb = -b;\n\t\t\tshear = -shear;\n\t\t\tscaleX = -scaleX;\n\t\t}\n\n\t\treturn {\n\t\t\tscaling: new Point(scaleX, scaleY),\n\t\t\trotation: -Math.atan2(b, a) * 180 / Math.PI,\n\t\t\tshearing: shear\n\t\t};\n\t},\n\n\tgetValues: function() {\n\t\treturn [ this._a, this._c, this._b, this._d, this._tx, this._ty ];\n\t},\n\n\tgetTranslation: function() {\n\t\treturn new Point(this._tx, this._ty);\n\t},\n\n\tgetScaling: function() {\n\t\treturn (this.decompose() || {}).scaling;\n\t},\n\n\tgetRotation: function() {\n\t\treturn (this.decompose() || {}).rotation;\n\t},\n\n\tinverted: function() {\n\t\tvar det = this._getDeterminant();\n\t\treturn det && new Matrix(\n\t\t\t\tthis._d / det,\n\t\t\t\t-this._c / det,\n\t\t\t\t-this._b / det,\n\t\t\t\tthis._a / det,\n\t\t\t\t(this._b * this._ty - this._d * this._tx) / det,\n\t\t\t\t(this._c * this._tx - this._a * this._ty) / det);\n\t},\n\n\tshiftless: function() {\n\t\treturn new Matrix(this._a, this._c, this._b, this._d, 0, 0);\n\t},\n\n\tapplyToContext: function(ctx) {\n\t\tctx.transform(this._a, this._c, this._b, this._d, this._tx, this._ty);\n\t}\n}, Base.each(['a', 'c', 'b', 'd', 'tx', 'ty'], function(name) {\n\tvar part = Base.capitalize(name),\n\t\tprop = '_' + name;\n\tthis['get' + part] = function() {\n\t\treturn this[prop];\n\t};\n\tthis['set' + part] = function(value) {\n\t\tthis[prop] = value;\n\t\tthis._changed();\n\t};\n}, {}));\n\nvar Line = Base.extend({\n\t_class: 'Line',\n\n\tinitialize: function Line(arg0, arg1, arg2, arg3, arg4) {\n\t\tvar asVector = false;\n\t\tif (arguments.length >= 4) {\n\t\t\tthis._px = arg0;\n\t\t\tthis._py = arg1;\n\t\t\tthis._vx = arg2;\n\t\t\tthis._vy = arg3;\n\t\t\tasVector = arg4;\n\t\t} else {\n\t\t\tthis._px = arg0.x;\n\t\t\tthis._py = arg0.y;\n\t\t\tthis._vx = arg1.x;\n\t\t\tthis._vy = arg1.y;\n\t\t\tasVector = arg2;\n\t\t}\n\t\tif (!asVector) {\n\t\t\tthis._vx -= this._px;\n\t\t\tthis._vy -= this._py;\n\t\t}\n\t},\n\n\tgetPoint: function() {\n\t\treturn new Point(this._px, this._py);\n\t},\n\n\tgetVector: function() {\n\t\treturn new Point(this._vx, this._vy);\n\t},\n\n\tgetLength: function() {\n\t\treturn this.getVector().getLength();\n\t},\n\n\tintersect: function(line, isInfinite) {\n\t\treturn Line.intersect(\n\t\t\t\tthis._px, this._py, this._vx, this._vy,\n\t\t\t\tline._px, line._py, line._vx, line._vy,\n\t\t\t\ttrue, isInfinite);\n\t},\n\n\tgetSide: function(point, isInfinite) {\n\t\treturn Line.getSide(\n\t\t\t\tthis._px, this._py, this._vx, this._vy,\n\t\t\t\tpoint.x, point.y, true, isInfinite);\n\t},\n\n\tgetDistance: function(point) {\n\t\treturn Math.abs(Line.getSignedDistance(\n\t\t\t\tthis._px, this._py, this._vx, this._vy,\n\t\t\t\tpoint.x, point.y, true));\n\t},\n\n\tisCollinear: function(line) {\n\t\treturn Point.isCollinear(this._vx, this._vy, line._vx, line._vy);\n\t},\n\n\tisOrthogonal: function(line) {\n\t\treturn Point.isOrthogonal(this._vx, this._vy, line._vx, line._vy);\n\t},\n\n\tstatics: {\n\t\tintersect: function(p1x, p1y, v1x, v1y, p2x, p2y, v2x, v2y, asVector,\n\t\t\t\tisInfinite) {\n\t\t\tif (!asVector) {\n\t\t\t\tv1x -= p1x;\n\t\t\t\tv1y -= p1y;\n\t\t\t\tv2x -= p2x;\n\t\t\t\tv2y -= p2y;\n\t\t\t}\n\t\t\tvar cross = v1x * v2y - v1y * v2x;\n\t\t\tif (!Numerical.isZero(cross)) {\n\t\t\t\tvar dx = p1x - p2x,\n\t\t\t\t\tdy = p1y - p2y,\n\t\t\t\t\tu1 = (v2x * dy - v2y * dx) / cross,\n\t\t\t\t\tu2 = (v1x * dy - v1y * dx) / cross,\n\t\t\t\t\tepsilon = 1e-12,\n\t\t\t\t\tuMin = -epsilon,\n\t\t\t\t\tuMax = 1 + epsilon;\n\t\t\t\tif (isInfinite\n\t\t\t\t\t\t|| uMin < u1 && u1 < uMax && uMin < u2 && u2 < uMax) {\n\t\t\t\t\tif (!isInfinite) {\n\t\t\t\t\t\tu1 = u1 <= 0 ? 0 : u1 >= 1 ? 1 : u1;\n\t\t\t\t\t}\n\t\t\t\t\treturn new Point(\n\t\t\t\t\t\t\tp1x + u1 * v1x,\n\t\t\t\t\t\t\tp1y + u1 * v1y);\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\tgetSide: function(px, py, vx, vy, x, y, asVector, isInfinite) {\n\t\t\tif (!asVector) {\n\t\t\t\tvx -= px;\n\t\t\t\tvy -= py;\n\t\t\t}\n\t\t\tvar v2x = x - px,\n\t\t\t\tv2y = y - py,\n\t\t\t\tccw = v2x * vy - v2y * vx;\n\t\t\tif (ccw === 0 && !isInfinite) {\n\t\t\t\tccw = (v2x * vx + v2x * vx) / (vx * vx + vy * vy);\n\t\t\t\tif (ccw >= 0 && ccw <= 1)\n\t\t\t\t\tccw = 0;\n\t\t\t}\n\t\t\treturn ccw < 0 ? -1 : ccw > 0 ? 1 : 0;\n\t\t},\n\n\t\tgetSignedDistance: function(px, py, vx, vy, x, y, asVector) {\n\t\t\tif (!asVector) {\n\t\t\t\tvx -= px;\n\t\t\t\tvy -= py;\n\t\t\t}\n\t\t\treturn vx === 0 ? vy > 0 ? x - px : px - x\n\t\t\t\t : vy === 0 ? vx < 0 ? y - py : py - y\n\t\t\t\t : ((x-px) * vy - (y-py) * vx) / Math.sqrt(vx * vx + vy * vy);\n\t\t}\n\t}\n});\n\nvar Project = PaperScopeItem.extend({\n\t_class: 'Project',\n\t_list: 'projects',\n\t_reference: 'project',\n\n\tinitialize: function Project(element) {\n\t\tPaperScopeItem.call(this, true);\n\t\tthis.layers = [];\n\t\tthis._activeLayer = null;\n\t\tthis.symbols = [];\n\t\tthis._currentStyle = new Style(null, null, this);\n\t\tthis._view = View.create(this,\n\t\t\t\telement || CanvasProvider.getCanvas(1, 1));\n\t\tthis._selectedItems = {};\n\t\tthis._selectedItemCount = 0;\n\t\tthis._updateVersion = 0;\n\t},\n\n\t_serialize: function(options, dictionary) {\n\t\treturn Base.serialize(this.layers, options, true, dictionary);\n\t},\n\n\tclear: function() {\n\t\tfor (var i = this.layers.length - 1; i >= 0; i--)\n\t\t\tthis.layers[i].remove();\n\t\tthis.symbols = [];\n\t},\n\n\tisEmpty: function() {\n\t\treturn this.layers.length === 0;\n\t},\n\n\tremove: function remove() {\n\t\tif (!remove.base.call(this))\n\t\t\treturn false;\n\t\tif (this._view)\n\t\t\tthis._view.remove();\n\t\treturn true;\n\t},\n\n\tgetView: function() {\n\t\treturn this._view;\n\t},\n\n\tgetCurrentStyle: function() {\n\t\treturn this._currentStyle;\n\t},\n\n\tsetCurrentStyle: function(style) {\n\t\tthis._currentStyle.initialize(style);\n\t},\n\n\tgetIndex: function() {\n\t\treturn this._index;\n\t},\n\n\tgetOptions: function() {\n\t\treturn this._scope.settings;\n\t},\n\n\tgetActiveLayer: function() {\n\t\treturn this._activeLayer || new Layer({ project: this });\n\t},\n\n\tgetSelectedItems: function() {\n\t\tvar items = [];\n\t\tfor (var id in this._selectedItems) {\n\t\t\tvar item = this._selectedItems[id];\n\t\t\tif (item.isInserted())\n\t\t\t\titems.push(item);\n\t\t}\n\t\treturn items;\n\t},\n\n\tinsertChild: function(index, item, _preserve) {\n\t\tif (item instanceof Layer) {\n\t\t\titem._remove(false, true);\n\t\t\tBase.splice(this.layers, [item], index, 0);\n\t\t\titem._setProject(this, true);\n\t\t\tif (this._changes)\n\t\t\t\titem._changed(5);\n\t\t\tif (!this._activeLayer)\n\t\t\t\tthis._activeLayer = item;\n\t\t} else if (item instanceof Item) {\n\t\t\t(this._activeLayer\n\t\t\t\t|| this.insertChild(index, new Layer(Item.NO_INSERT)))\n\t\t\t\t\t.insertChild(index, item, _preserve);\n\t\t} else {\n\t\t\titem = null;\n\t\t}\n\t\treturn item;\n\t},\n\n\taddChild: function(item, _preserve) {\n\t\treturn this.insertChild(undefined, item, _preserve);\n\t},\n\n\t_updateSelection: function(item) {\n\t\tvar id = item._id,\n\t\t\tselectedItems = this._selectedItems;\n\t\tif (item._selected) {\n\t\t\tif (selectedItems[id] !== item) {\n\t\t\t\tthis._selectedItemCount++;\n\t\t\t\tselectedItems[id] = item;\n\t\t\t}\n\t\t} else if (selectedItems[id] === item) {\n\t\t\tthis._selectedItemCount--;\n\t\t\tdelete selectedItems[id];\n\t\t}\n\t},\n\n\tselectAll: function() {\n\t\tvar layers = this.layers;\n\t\tfor (var i = 0, l = layers.length; i < l; i++)\n\t\t\tlayers[i].setFullySelected(true);\n\t},\n\n\tdeselectAll: function() {\n\t\tvar selectedItems = this._selectedItems;\n\t\tfor (var i in selectedItems)\n\t\t\tselectedItems[i].setFullySelected(false);\n\t},\n\n\thitTest: function() {\n\t\tvar point = Point.read(arguments),\n\t\t\toptions = HitResult.getOptions(Base.read(arguments));\n\t\tfor (var i = this.layers.length - 1; i >= 0; i--) {\n\t\t\tvar res = this.layers[i]._hitTest(point, options);\n\t\t\tif (res) return res;\n\t\t}\n\t\treturn null;\n\t},\n\n\tgetItems: function(match) {\n\t\treturn Item._getItems(this.layers, match);\n\t},\n\n\tgetItem: function(match) {\n\t\treturn Item._getItems(this.layers, match, null, null, true)[0] || null;\n\t},\n\n\timportJSON: function(json) {\n\t\tthis.activate();\n\t\tvar layer = this._activeLayer;\n\t\treturn Base.importJSON(json, layer && layer.isEmpty() && layer);\n\t},\n\n\tdraw: function(ctx, matrix, pixelRatio) {\n\t\tthis._updateVersion++;\n\t\tctx.save();\n\t\tmatrix.applyToContext(ctx);\n\t\tvar param = new Base({\n\t\t\toffset: new Point(0, 0),\n\t\t\tpixelRatio: pixelRatio,\n\t\t\tviewMatrix: matrix.isIdentity() ? null : matrix,\n\t\t\tmatrices: [new Matrix()],\n\t\t\tupdateMatrix: true\n\t\t});\n\t\tfor (var i = 0, layers = this.layers, l = layers.length; i < l; i++)\n\t\t\tlayers[i].draw(ctx, param);\n\t\tctx.restore();\n\n\t\tif (this._selectedItemCount > 0) {\n\t\t\tctx.save();\n\t\t\tctx.strokeWidth = 1;\n\t\t\tvar items = this._selectedItems,\n\t\t\t\tsize = this._scope.settings.handleSize,\n\t\t\t\tversion = this._updateVersion;\n\t\t\tfor (var id in items)\n\t\t\t\titems[id]._drawSelection(ctx, matrix, size, items, version);\n\t\t\tctx.restore();\n\t\t}\n\t}\n});\n\nvar Symbol = Base.extend({\n\t_class: 'Symbol',\n\n\tinitialize: function Symbol(item, dontCenter) {\n\t\tthis._id = UID.get();\n\t\tthis.project = paper.project;\n\t\tthis.project.symbols.push(this);\n\t\tif (item)\n\t\t\tthis.setDefinition(item, dontCenter);\n\t},\n\n\t_serialize: function(options, dictionary) {\n\t\treturn dictionary.add(this, function() {\n\t\t\treturn Base.serialize([this._class, this._definition],\n\t\t\t\t\toptions, false, dictionary);\n\t\t});\n\t},\n\n\t_changed: function(flags) {\n\t\tif (flags & 8) {\n\t\t\tItem._clearBoundsCache(this);\n\t\t}\n\t\tif (flags & 1) {\n\t\t\tthis.project._needsUpdate = true;\n\t\t}\n\t},\n\n\tgetDefinition: function() {\n\t\treturn this._definition;\n\t},\n\n\tsetDefinition: function(item, _dontCenter) {\n\t\tif (item._parentSymbol)\n\t\t\titem = item.clone();\n\t\tif (this._definition)\n\t\t\tthis._definition._parentSymbol = null;\n\t\tthis._definition = item;\n\t\titem.remove();\n\t\titem.setSelected(false);\n\t\tif (!_dontCenter)\n\t\t\titem.setPosition(new Point());\n\t\titem._parentSymbol = this;\n\t\tthis._changed(9);\n\t},\n\n\tplace: function(position) {\n\t\treturn new PlacedSymbol(this, position);\n\t},\n\n\tclone: function() {\n\t\treturn new Symbol(this._definition.clone(false));\n\t},\n\n\tequals: function(symbol) {\n\t\treturn symbol === this\n\t\t\t\t|| symbol && this.definition.equals(symbol.definition)\n\t\t\t\t|| false;\n\t}\n});\n\nvar Item = Base.extend(Emitter, {\n\tstatics: {\n\t\textend: function extend(src) {\n\t\t\tif (src._serializeFields)\n\t\t\t\tsrc._serializeFields = new Base(\n\t\t\t\t\t\tthis.prototype._serializeFields, src._serializeFields);\n\t\t\treturn extend.base.apply(this, arguments);\n\t\t},\n\n\t\tNO_INSERT: { insert: false }\n\t},\n\n\t_class: 'Item',\n\t_applyMatrix: true,\n\t_canApplyMatrix: true,\n\t_boundsSelected: false,\n\t_selectChildren: false,\n\t_serializeFields: {\n\t\tname: null,\n\t\tapplyMatrix: null,\n\t\tmatrix: new Matrix(),\n\t\tpivot: null,\n\t\tlocked: false,\n\t\tvisible: true,\n\t\tblendMode: 'normal',\n\t\topacity: 1,\n\t\tguide: false,\n\t\tselected: false,\n\t\tclipMask: false,\n\t\tdata: {}\n\t},\n\n\tinitialize: function Item() {\n\t},\n\n\t_initialize: function(props, point) {\n\t\tvar hasProps = props && Base.isPlainObject(props),\n\t\t\tinternal = hasProps && props.internal === true,\n\t\t\tmatrix = this._matrix = new Matrix(),\n\t\t\tproject = hasProps && props.project || paper.project;\n\t\tif (!internal)\n\t\t\tthis._id = UID.get();\n\t\tthis._applyMatrix = this._canApplyMatrix && paper.settings.applyMatrix;\n\t\tif (point)\n\t\t\tmatrix.translate(point);\n\t\tmatrix._owner = this;\n\t\tthis._style = new Style(project._currentStyle, this, project);\n\t\tif (!this._project) {\n\t\t\tif (internal || hasProps && props.insert === false) {\n\t\t\t\tthis._setProject(project);\n\t\t\t} else if (hasProps && props.parent) {\n\t\t\t\tthis.setParent(props.parent);\n\t\t\t} else {\n\t\t\t\t(project._activeLayer || new Layer()).addChild(this);\n\t\t\t}\n\t\t}\n\t\tif (hasProps && props !== Item.NO_INSERT)\n\t\t\tthis._set(props, { insert: true, project: true, parent: true },\n\t\t\t\t\ttrue);\n\t\treturn hasProps;\n\t},\n\n\t_events: Base.each(['onMouseDown', 'onMouseUp', 'onMouseDrag', 'onClick',\n\t\t\t'onDoubleClick', 'onMouseMove', 'onMouseEnter', 'onMouseLeave'],\n\t\tfunction(name) {\n\t\t\tthis[name] = {\n\t\t\t\tinstall: function(type) {\n\t\t\t\t\tthis.getView()._installEvent(type);\n\t\t\t\t},\n\n\t\t\t\tuninstall: function(type) {\n\t\t\t\t\tthis.getView()._uninstallEvent(type);\n\t\t\t\t}\n\t\t\t};\n\t\t}, {\n\t\t\tonFrame: {\n\t\t\t\tinstall: function() {\n\t\t\t\t\tthis.getView()._animateItem(this, true);\n\t\t\t\t},\n\n\t\t\t\tuninstall: function() {\n\t\t\t\t\tthis.getView()._animateItem(this, false);\n\t\t\t\t}\n\t\t\t},\n\n\t\t\tonLoad: {}\n\t\t}\n\t),\n\n\t_serialize: function(options, dictionary) {\n\t\tvar props = {},\n\t\t\tthat = this;\n\n\t\tfunction serialize(fields) {\n\t\t\tfor (var key in fields) {\n\t\t\t\tvar value = that[key];\n\t\t\t\tif (!Base.equals(value, key === 'leading'\n\t\t\t\t\t\t? fields.fontSize * 1.2 : fields[key])) {\n\t\t\t\t\tprops[key] = Base.serialize(value, options,\n\t\t\t\t\t\t\tkey !== 'data', dictionary);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tserialize(this._serializeFields);\n\t\tif (!(this instanceof Group))\n\t\t\tserialize(this._style._defaults);\n\t\treturn [ this._class, props ];\n\t},\n\n\t_changed: function(flags) {\n\t\tvar symbol = this._parentSymbol,\n\t\t\tcacheParent = this._parent || symbol,\n\t\t\tproject = this._project;\n\t\tif (flags & 8) {\n\t\t\tthis._bounds = this._position = this._decomposed =\n\t\t\t\t\tthis._globalMatrix = this._currentPath = undefined;\n\t\t}\n\t\tif (cacheParent\n\t\t\t\t&& (flags & 40)) {\n\t\t\tItem._clearBoundsCache(cacheParent);\n\t\t}\n\t\tif (flags & 2) {\n\t\t\tItem._clearBoundsCache(this);\n\t\t}\n\t\tif (project) {\n\t\t\tif (flags & 1) {\n\t\t\t\tproject._needsUpdate = true;\n\t\t\t}\n\t\t\tif (project._changes) {\n\t\t\t\tvar entry = project._changesById[this._id];\n\t\t\t\tif (entry) {\n\t\t\t\t\tentry.flags |= flags;\n\t\t\t\t} else {\n\t\t\t\t\tentry = { item: this, flags: flags };\n\t\t\t\t\tproject._changesById[this._id] = entry;\n\t\t\t\t\tproject._changes.push(entry);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (symbol)\n\t\t\tsymbol._changed(flags);\n\t},\n\n\tset: function(props) {\n\t\tif (props)\n\t\t\tthis._set(props);\n\t\treturn this;\n\t},\n\n\tgetId: function() {\n\t\treturn this._id;\n\t},\n\n\tgetName: function() {\n\t\treturn this._name;\n\t},\n\n\tsetName: function(name, unique) {\n\n\t\tif (this._name)\n\t\t\tthis._removeNamed();\n\t\tif (name === (+name) + '')\n\t\t\tthrow new Error(\n\t\t\t\t\t'Names consisting only of numbers are not supported.');\n\t\tvar parent = this._parent;\n\t\tif (name && parent) {\n\t\t\tvar children = parent._children,\n\t\t\t\tnamedChildren = parent._namedChildren,\n\t\t\t\torig = name,\n\t\t\t\ti = 1;\n\t\t\twhile (unique && children[name])\n\t\t\t\tname = orig + ' ' + (i++);\n\t\t\t(namedChildren[name] = namedChildren[name] || []).push(this);\n\t\t\tchildren[name] = this;\n\t\t}\n\t\tthis._name = name || undefined;\n\t\tthis._changed(128);\n\t},\n\n\tgetStyle: function() {\n\t\treturn this._style;\n\t},\n\n\tsetStyle: function(style) {\n\t\tthis.getStyle().set(style);\n\t}\n}, Base.each(['locked', 'visible', 'blendMode', 'opacity', 'guide'],\n\tfunction(name) {\n\t\tvar part = Base.capitalize(name),\n\t\t\tname = '_' + name;\n\t\tthis['get' + part] = function() {\n\t\t\treturn this[name];\n\t\t};\n\t\tthis['set' + part] = function(value) {\n\t\t\tif (value != this[name]) {\n\t\t\t\tthis[name] = value;\n\t\t\t\tthis._changed(name === '_locked'\n\t\t\t\t\t\t? 128 : 129);\n\t\t\t}\n\t\t};\n\t},\n{}), {\n\tbeans: true,\n\n\t_locked: false,\n\n\t_visible: true,\n\n\t_blendMode: 'normal',\n\n\t_opacity: 1,\n\n\t_guide: false,\n\n\tisSelected: function() {\n\t\tif (this._selectChildren) {\n\t\t\tvar children = this._children;\n\t\t\tfor (var i = 0, l = children.length; i < l; i++)\n\t\t\t\tif (children[i].isSelected())\n\t\t\t\t\treturn true;\n\t\t}\n\t\treturn this._selected;\n\t},\n\n\tsetSelected: function(selected, noChildren) {\n\t\tif (!noChildren && this._selectChildren) {\n\t\t\tvar children = this._children;\n\t\t\tfor (var i = 0, l = children.length; i < l; i++)\n\t\t\t\tchildren[i].setSelected(selected);\n\t\t}\n\t\tif ((selected = !!selected) ^ this._selected) {\n\t\t\tthis._selected = selected;\n\t\t\tthis._project._updateSelection(this);\n\t\t\tthis._changed(129);\n\t\t}\n\t},\n\n\t_selected: false,\n\n\tisFullySelected: function() {\n\t\tvar children = this._children;\n\t\tif (children && this._selected) {\n\t\t\tfor (var i = 0, l = children.length; i < l; i++)\n\t\t\t\tif (!children[i].isFullySelected())\n\t\t\t\t\treturn false;\n\t\t\treturn true;\n\t\t}\n\t\treturn this._selected;\n\t},\n\n\tsetFullySelected: function(selected) {\n\t\tvar children = this._children;\n\t\tif (children) {\n\t\t\tfor (var i = 0, l = children.length; i < l; i++)\n\t\t\t\tchildren[i].setFullySelected(selected);\n\t\t}\n\t\tthis.setSelected(selected, true);\n\t},\n\n\tisClipMask: function() {\n\t\treturn this._clipMask;\n\t},\n\n\tsetClipMask: function(clipMask) {\n\t\tif (this._clipMask != (clipMask = !!clipMask)) {\n\t\t\tthis._clipMask = clipMask;\n\t\t\tif (clipMask) {\n\t\t\t\tthis.setFillColor(null);\n\t\t\t\tthis.setStrokeColor(null);\n\t\t\t}\n\t\t\tthis._changed(129);\n\t\t\tif (this._parent)\n\t\t\t\tthis._parent._changed(1024);\n\t\t}\n\t},\n\n\t_clipMask: false,\n\n\tgetData: function() {\n\t\tif (!this._data)\n\t\t\tthis._data = {};\n\t\treturn this._data;\n\t},\n\n\tsetData: function(data) {\n\t\tthis._data = data;\n\t},\n\n\tgetPosition: function(_dontLink) {\n\t\tvar position = this._position,\n\t\t\tctor = _dontLink ? Point : LinkedPoint;\n\t\tif (!position) {\n\t\t\tvar pivot = this._pivot;\n\t\t\tposition = this._position = pivot\n\t\t\t\t\t? this._matrix._transformPoint(pivot)\n\t\t\t\t\t: this.getBounds().getCenter(true);\n\t\t}\n\t\treturn new ctor(position.x, position.y, this, 'setPosition');\n\t},\n\n\tsetPosition: function() {\n\t\tthis.translate(Point.read(arguments).subtract(this.getPosition(true)));\n\t},\n\n\tgetPivot: function(_dontLink) {\n\t\tvar pivot = this._pivot;\n\t\tif (pivot) {\n\t\t\tvar ctor = _dontLink ? Point : LinkedPoint;\n\t\t\tpivot = new ctor(pivot.x, pivot.y, this, 'setPivot');\n\t\t}\n\t\treturn pivot;\n\t},\n\n\tsetPivot: function() {\n\t\tthis._pivot = Point.read(arguments, 0, { clone: true, readNull: true });\n\t\tthis._position = undefined;\n\t},\n\n\t_pivot: null,\n}, Base.each(['bounds', 'strokeBounds', 'handleBounds', 'roughBounds',\n\t\t'internalBounds', 'internalRoughBounds'],\n\tfunction(key) {\n\t\tvar getter = 'get' + Base.capitalize(key),\n\t\t\tmatch = key.match(/^internal(.*)$/),\n\t\t\tinternalGetter = match ? 'get' + match[1] : null;\n\t\tthis[getter] = function(_matrix) {\n\t\t\tvar boundsGetter = this._boundsGetter,\n\t\t\t\tname = !internalGetter && (typeof boundsGetter === 'string'\n\t\t\t\t\t\t? boundsGetter : boundsGetter && boundsGetter[getter])\n\t\t\t\t\t\t|| getter,\n\t\t\t\tbounds = this._getCachedBounds(name, _matrix, this,\n\t\t\t\t\t\tinternalGetter);\n\t\t\treturn key === 'bounds'\n\t\t\t\t\t? new LinkedRectangle(bounds.x, bounds.y, bounds.width,\n\t\t\t\t\t\t\tbounds.height, this, 'setBounds')\n\t\t\t\t\t: bounds;\n\t\t};\n\t},\n{\n\tbeans: true,\n\n\t_getBounds: function(getter, matrix, cacheItem) {\n\t\tvar children = this._children;\n\t\tif (!children || children.length == 0)\n\t\t\treturn new Rectangle();\n\t\tItem._updateBoundsCache(this, cacheItem);\n\t\tvar x1 = Infinity,\n\t\t\tx2 = -x1,\n\t\t\ty1 = x1,\n\t\t\ty2 = x2;\n\t\tfor (var i = 0, l = children.length; i < l; i++) {\n\t\t\tvar child = children[i];\n\t\t\tif (child._visible && !child.isEmpty()) {\n\t\t\t\tvar rect = child._getCachedBounds(getter,\n\t\t\t\t\t\tmatrix && matrix.chain(child._matrix), cacheItem);\n\t\t\t\tx1 = Math.min(rect.x, x1);\n\t\t\t\ty1 = Math.min(rect.y, y1);\n\t\t\t\tx2 = Math.max(rect.x + rect.width, x2);\n\t\t\t\ty2 = Math.max(rect.y + rect.height, y2);\n\t\t\t}\n\t\t}\n\t\treturn isFinite(x1)\n\t\t\t\t? new Rectangle(x1, y1, x2 - x1, y2 - y1)\n\t\t\t\t: new Rectangle();\n\t},\n\n\tsetBounds: function() {\n\t\tvar rect = Rectangle.read(arguments),\n\t\t\tbounds = this.getBounds(),\n\t\t\tmatrix = new Matrix(),\n\t\t\tcenter = rect.getCenter();\n\t\tmatrix.translate(center);\n\t\tif (rect.width != bounds.width || rect.height != bounds.height) {\n\t\t\tmatrix.scale(\n\t\t\t\t\tbounds.width != 0 ? rect.width / bounds.width : 1,\n\t\t\t\t\tbounds.height != 0 ? rect.height / bounds.height : 1);\n\t\t}\n\t\tcenter = bounds.getCenter();\n\t\tmatrix.translate(-center.x, -center.y);\n\t\tthis.transform(matrix);\n\t},\n\n\t_getCachedBounds: function(getter, matrix, cacheItem, internalGetter) {\n\t\tmatrix = matrix && matrix.orNullIfIdentity();\n\t\tvar _matrix = internalGetter ? null : this._matrix.orNullIfIdentity(),\n\t\t\tcache = (!matrix || matrix.equals(_matrix)) && getter;\n\t\tItem._updateBoundsCache(this._parent || this._parentSymbol, cacheItem);\n\t\tif (cache && this._bounds && this._bounds[cache])\n\t\t\treturn this._bounds[cache].clone();\n\t\tvar bounds = this._getBounds(internalGetter || getter,\n\t\t\t\tmatrix || _matrix, cacheItem);\n\t\tif (cache) {\n\t\t\tif (!this._bounds)\n\t\t\t\tthis._bounds = {};\n\t\t\tvar cached = this._bounds[cache] = bounds.clone();\n\t\t\tcached._internal = !!internalGetter;\n\t\t}\n\t\treturn bounds;\n\t},\n\n\tstatics: {\n\t\t_updateBoundsCache: function(parent, item) {\n\t\t\tif (parent) {\n\t\t\t\tvar id = item._id,\n\t\t\t\t\tref = parent._boundsCache = parent._boundsCache || {\n\t\t\t\t\t\tids: {},\n\t\t\t\t\t\tlist: []\n\t\t\t\t\t};\n\t\t\t\tif (!ref.ids[id]) {\n\t\t\t\t\tref.list.push(item);\n\t\t\t\t\tref.ids[id] = item;\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\t_clearBoundsCache: function(item) {\n\t\t\tvar cache = item._boundsCache;\n\t\t\tif (cache) {\n\t\t\t\titem._bounds = item._position = item._boundsCache = undefined;\n\t\t\t\tfor (var i = 0, list = cache.list, l = list.length; i < l; i++){\n\t\t\t\t\tvar other = list[i];\n\t\t\t\t\tif (other !== item) {\n\t\t\t\t\t\tother._bounds = other._position = undefined;\n\t\t\t\t\t\tif (other._boundsCache)\n\t\t\t\t\t\t\tItem._clearBoundsCache(other);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n}), {\n\tbeans: true,\n\n\t_decompose: function() {\n\t\treturn this._decomposed = this._matrix.decompose();\n\t},\n\n\tgetRotation: function() {\n\t\tvar decomposed = this._decomposed || this._decompose();\n\t\treturn decomposed && decomposed.rotation;\n\t},\n\n\tsetRotation: function(rotation) {\n\t\tvar current = this.getRotation();\n\t\tif (current != null && rotation != null) {\n\t\t\tvar decomposed = this._decomposed;\n\t\t\tthis.rotate(rotation - current);\n\t\t\tdecomposed.rotation = rotation;\n\t\t\tthis._decomposed = decomposed;\n\t\t}\n\t},\n\n\tgetScaling: function(_dontLink) {\n\t\tvar decomposed = this._decomposed || this._decompose(),\n\t\t\tscaling = decomposed && decomposed.scaling,\n\t\t\tctor = _dontLink ? Point : LinkedPoint;\n\t\treturn scaling && new ctor(scaling.x, scaling.y, this, 'setScaling');\n\t},\n\n\tsetScaling: function() {\n\t\tvar current = this.getScaling();\n\t\tif (current) {\n\t\t\tvar scaling = Point.read(arguments, 0, { clone: true }),\n\t\t\t\tdecomposed = this._decomposed;\n\t\t\tthis.scale(scaling.x / current.x, scaling.y / current.y);\n\t\t\tdecomposed.scaling = scaling;\n\t\t\tthis._decomposed = decomposed;\n\t\t}\n\t},\n\n\tgetMatrix: function() {\n\t\treturn this._matrix;\n\t},\n\n\tsetMatrix: function() {\n\t\tvar matrix = this._matrix;\n\t\tmatrix.initialize.apply(matrix, arguments);\n\t\tif (this._applyMatrix) {\n\t\t\tthis.transform(null, true);\n\t\t} else {\n\t\t\tthis._changed(9);\n\t\t}\n\t},\n\n\tgetGlobalMatrix: function(_dontClone) {\n\t\tvar matrix = this._globalMatrix,\n\t\t\tupdateVersion = this._project._updateVersion;\n\t\tif (matrix && matrix._updateVersion !== updateVersion)\n\t\t\tmatrix = null;\n\t\tif (!matrix) {\n\t\t\tmatrix = this._globalMatrix = this._matrix.clone();\n\t\t\tvar parent = this._parent;\n\t\t\tif (parent)\n\t\t\t\tmatrix.preConcatenate(parent.getGlobalMatrix(true));\n\t\t\tmatrix._updateVersion = updateVersion;\n\t\t}\n\t\treturn _dontClone ? matrix : matrix.clone();\n\t},\n\n\tgetApplyMatrix: function() {\n\t\treturn this._applyMatrix;\n\t},\n\n\tsetApplyMatrix: function(apply) {\n\t\tif (this._applyMatrix = this._canApplyMatrix && !!apply)\n\t\t\tthis.transform(null, true);\n\t},\n\n\tgetTransformContent: '#getApplyMatrix',\n\tsetTransformContent: '#setApplyMatrix',\n}, {\n\tgetProject: function() {\n\t\treturn this._project;\n\t},\n\n\t_setProject: function(project, installEvents) {\n\t\tif (this._project !== project) {\n\t\t\tif (this._project)\n\t\t\t\tthis._installEvents(false);\n\t\t\tthis._project = project;\n\t\t\tvar children = this._children;\n\t\t\tfor (var i = 0, l = children && children.length; i < l; i++)\n\t\t\t\tchildren[i]._setProject(project);\n\t\t\tinstallEvents = true;\n\t\t}\n\t\tif (installEvents)\n\t\t\tthis._installEvents(true);\n\t},\n\n\tgetView: function() {\n\t\treturn this._project.getView();\n\t},\n\n\t_installEvents: function _installEvents(install) {\n\t\t_installEvents.base.call(this, install);\n\t\tvar children = this._children;\n\t\tfor (var i = 0, l = children && children.length; i < l; i++)\n\t\t\tchildren[i]._installEvents(install);\n\t},\n\n\tgetLayer: function() {\n\t\tvar parent = this;\n\t\twhile (parent = parent._parent) {\n\t\t\tif (parent instanceof Layer)\n\t\t\t\treturn parent;\n\t\t}\n\t\treturn null;\n\t},\n\n\tgetParent: function() {\n\t\treturn this._parent;\n\t},\n\n\tsetParent: function(item) {\n\t\treturn item.addChild(this);\n\t},\n\n\tgetChildren: function() {\n\t\treturn this._children;\n\t},\n\n\tsetChildren: function(items) {\n\t\tthis.removeChildren();\n\t\tthis.addChildren(items);\n\t},\n\n\tgetFirstChild: function() {\n\t\treturn this._children && this._children[0] || null;\n\t},\n\n\tgetLastChild: function() {\n\t\treturn this._children && this._children[this._children.length - 1]\n\t\t\t\t|| null;\n\t},\n\n\tgetNextSibling: function() {\n\t\treturn this._parent && this._parent._children[this._index + 1] || null;\n\t},\n\n\tgetPreviousSibling: function() {\n\t\treturn this._parent && this._parent._children[this._index - 1] || null;\n\t},\n\n\tgetIndex: function() {\n\t\treturn this._index;\n\t},\n\n\tequals: function(item) {\n\t\treturn item === this || item && this._class === item._class\n\t\t\t\t&& this._style.equals(item._style)\n\t\t\t\t&& this._matrix.equals(item._matrix)\n\t\t\t\t&& this._locked === item._locked\n\t\t\t\t&& this._visible === item._visible\n\t\t\t\t&& this._blendMode === item._blendMode\n\t\t\t\t&& this._opacity === item._opacity\n\t\t\t\t&& this._clipMask === item._clipMask\n\t\t\t\t&& this._guide === item._guide\n\t\t\t\t&& this._equals(item)\n\t\t\t\t|| false;\n\t},\n\n\t_equals: function(item) {\n\t\treturn Base.equals(this._children, item._children);\n\t},\n\n\tclone: function(insert) {\n\t\treturn this._clone(new this.constructor(Item.NO_INSERT), insert);\n\t},\n\n\t_clone: function(copy, insert, includeMatrix) {\n\t\tvar keys = ['_locked', '_visible', '_blendMode', '_opacity',\n\t\t\t\t'_clipMask', '_guide'],\n\t\t\tchildren = this._children;\n\t\tcopy.setStyle(this._style);\n\t\tfor (var i = 0, l = children && children.length; i < l; i++) {\n\t\t\tcopy.addChild(children[i].clone(false), true);\n\t\t}\n\t\tfor (var i = 0, l = keys.length; i < l; i++) {\n\t\t\tvar key = keys[i];\n\t\t\tif (this.hasOwnProperty(key))\n\t\t\t\tcopy[key] = this[key];\n\t\t}\n\t\tif (includeMatrix !== false)\n\t\t\tcopy._matrix.initialize(this._matrix);\n\t\tcopy.setApplyMatrix(this._applyMatrix);\n\t\tcopy.setPivot(this._pivot);\n\t\tcopy.setSelected(this._selected);\n\t\tcopy._data = this._data ? Base.clone(this._data) : null;\n\t\tif (insert || insert === undefined)\n\t\t\tcopy.insertAbove(this);\n\t\tif (this._name)\n\t\t\tcopy.setName(this._name, true);\n\t\treturn copy;\n\t},\n\n\tcopyTo: function(itemOrProject) {\n\t\treturn itemOrProject.addChild(this.clone(false));\n\t},\n\n\trasterize: function(resolution) {\n\t\tvar bounds = this.getStrokeBounds(),\n\t\t\tscale = (resolution || this.getView().getResolution()) / 72,\n\t\t\ttopLeft = bounds.getTopLeft().floor(),\n\t\t\tbottomRight = bounds.getBottomRight().ceil(),\n\t\t\tsize = new Size(bottomRight.subtract(topLeft)),\n\t\t\tcanvas = CanvasProvider.getCanvas(size.multiply(scale)),\n\t\t\tctx = canvas.getContext('2d'),\n\t\t\tmatrix = new Matrix().scale(scale).translate(topLeft.negate());\n\t\tctx.save();\n\t\tmatrix.applyToContext(ctx);\n\t\tthis.draw(ctx, new Base({ matrices: [matrix] }));\n\t\tctx.restore();\n\t\tvar raster = new Raster(Item.NO_INSERT);\n\t\traster.setCanvas(canvas);\n\t\traster.transform(new Matrix().translate(topLeft.add(size.divide(2)))\n\t\t\t\t.scale(1 / scale));\n\t\traster.insertAbove(this);\n\t\treturn raster;\n\t},\n\n\tcontains: function() {\n\t\treturn !!this._contains(\n\t\t\t\tthis._matrix._inverseTransform(Point.read(arguments)));\n\t},\n\n\t_contains: function(point) {\n\t\tif (this._children) {\n\t\t\tfor (var i = this._children.length - 1; i >= 0; i--) {\n\t\t\t\tif (this._children[i].contains(point))\n\t\t\t\t\treturn true;\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t\treturn point.isInside(this.getInternalBounds());\n\t},\n\n\tisInside: function() {\n\t\treturn Rectangle.read(arguments).contains(this.getBounds());\n\t},\n\n\t_asPathItem: function() {\n\t\treturn new Path.Rectangle({\n\t\t\trectangle: this.getInternalBounds(),\n\t\t\tmatrix: this._matrix,\n\t\t\tinsert: false,\n\t\t});\n\t},\n\n\tintersects: function(item, _matrix) {\n\t\tif (!(item instanceof Item))\n\t\t\treturn false;\n\t\treturn this._asPathItem().getIntersections(item._asPathItem(), null,\n\t\t\t\t_matrix || item._matrix, true).length > 0;\n\t},\n\n\thitTest: function() {\n\t\treturn this._hitTest(\n\t\t\t\tPoint.read(arguments),\n\t\t\t\tHitResult.getOptions(Base.read(arguments)));\n\t},\n\n\t_hitTest: function(point, options) {\n\t\tif (this._locked || !this._visible || this._guide && !options.guides\n\t\t\t\t|| this.isEmpty())\n\t\t\treturn null;\n\n\t\tvar matrix = this._matrix,\n\t\t\tparentTotalMatrix = options._totalMatrix,\n\t\t\tview = this.getView(),\n\t\t\ttotalMatrix = options._totalMatrix = parentTotalMatrix\n\t\t\t\t\t? parentTotalMatrix.chain(matrix)\n\t\t\t\t\t: this.getGlobalMatrix().preConcatenate(view._matrix),\n\t\t\ttolerancePadding = options._tolerancePadding = new Size(\n\t\t\t\t\t\tPath._getPenPadding(1, totalMatrix.inverted())\n\t\t\t\t\t).multiply(\n\t\t\t\t\t\tMath.max(options.tolerance, 1e-6)\n\t\t\t\t\t);\n\t\tpoint = matrix._inverseTransform(point);\n\n\t\tif (!this._children && !this.getInternalRoughBounds()\n\t\t\t\t.expand(tolerancePadding.multiply(2))._containsPoint(point))\n\t\t\treturn null;\n\t\tvar checkSelf = !(options.guides && !this._guide\n\t\t\t\t|| options.selected && !this._selected\n\t\t\t\t|| options.type && options.type !== Base.hyphenate(this._class)\n\t\t\t\t|| options.class && !(this instanceof options.class)),\n\t\t\tthat = this,\n\t\t\tres;\n\n\t\tfunction checkBounds(type, part) {\n\t\t\tvar pt = bounds['get' + part]();\n\t\t\tif (point.subtract(pt).divide(tolerancePadding).length <= 1)\n\t\t\t\treturn new HitResult(type, that,\n\t\t\t\t\t\t{ name: Base.hyphenate(part), point: pt });\n\t\t}\n\n\t\tif (checkSelf && (options.center || options.bounds) && this._parent) {\n\t\t\tvar bounds = this.getInternalBounds();\n\t\t\tif (options.center)\n\t\t\t\tres = checkBounds('center', 'Center');\n\t\t\tif (!res && options.bounds) {\n\t\t\t\tvar points = [\n\t\t\t\t\t'TopLeft', 'TopRight', 'BottomLeft', 'BottomRight',\n\t\t\t\t\t'LeftCenter', 'TopCenter', 'RightCenter', 'BottomCenter'\n\t\t\t\t];\n\t\t\t\tfor (var i = 0; i < 8 && !res; i++)\n\t\t\t\t\tres = checkBounds('bounds', points[i]);\n\t\t\t}\n\t\t}\n\n\t\tvar children = !res && this._children;\n\t\tif (children) {\n\t\t\tvar opts = this._getChildHitTestOptions(options);\n\t\t\tfor (var i = children.length - 1; i >= 0 && !res; i--)\n\t\t\t\tres = children[i]._hitTest(point, opts);\n\t\t}\n\t\tif (!res && checkSelf)\n\t\t\tres = this._hitTestSelf(point, options);\n\t\tif (res && res.point)\n\t\t\tres.point = matrix.transform(res.point);\n\t\toptions._totalMatrix = parentTotalMatrix;\n\t\treturn res;\n\t},\n\n\t_getChildHitTestOptions: function(options) {\n\t\treturn options;\n\t},\n\n\t_hitTestSelf: function(point, options) {\n\t\tif (options.fill && this.hasFill() && this._contains(point))\n\t\t\treturn new HitResult('fill', this);\n\t},\n\n\tmatches: function(name, compare) {\n\t\tfunction matchObject(obj1, obj2) {\n\t\t\tfor (var i in obj1) {\n\t\t\t\tif (obj1.hasOwnProperty(i)) {\n\t\t\t\t\tvar val1 = obj1[i],\n\t\t\t\t\t\tval2 = obj2[i];\n\t\t\t\t\tif (Base.isPlainObject(val1) && Base.isPlainObject(val2)) {\n\t\t\t\t\t\tif (!matchObject(val1, val2))\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t} else if (!Base.equals(val1, val2)) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t\tvar type = typeof name;\n\t\tif (type === 'object') {\n\t\t\tfor (var key in name) {\n\t\t\t\tif (name.hasOwnProperty(key) && !this.matches(key, name[key]))\n\t\t\t\t\treturn false;\n\t\t\t}\n\t\t} else if (type === 'function') {\n\t\t\treturn name(this);\n\t\t} else {\n\t\t\tvar value = /^(empty|editable)$/.test(name)\n\t\t\t\t\t? this['is' + Base.capitalize(name)]()\n\t\t\t\t\t: name === 'type'\n\t\t\t\t\t\t? Base.hyphenate(this._class)\n\t\t\t\t\t\t: this[name];\n\t\t\tif (/^(constructor|class)$/.test(name)) {\n\t\t\t\tif (!(this instanceof compare))\n\t\t\t\t\treturn false;\n\t\t\t} else if (compare instanceof RegExp) {\n\t\t\t\tif (!compare.test(value))\n\t\t\t\t\treturn false;\n\t\t\t} else if (typeof compare === 'function') {\n\t\t\t\tif (!compare(value))\n\t\t\t\t\treturn false;\n\t\t\t} else if (Base.isPlainObject(compare)) {\n\t\t\t\tif (!matchObject(compare, value))\n\t\t\t\t\treturn false;\n\t\t\t} else if (!Base.equals(value, compare)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t},\n\n\tgetItems: function(match) {\n\t\treturn Item._getItems(this._children, match, this._matrix);\n\t},\n\n\tgetItem: function(match) {\n\t\treturn Item._getItems(this._children, match, this._matrix, null, true)\n\t\t\t\t[0] || null;\n\t},\n\n\tstatics: {\n\t\t_getItems: function _getItems(children, match, matrix, param,\n\t\t\t\tfirstOnly) {\n\t\t\tif (!param && typeof match === 'object') {\n\t\t\t\tvar overlapping = match.overlapping,\n\t\t\t\t\tinside = match.inside,\n\t\t\t\t\tbounds = overlapping || inside,\n\t\t\t\t\trect = bounds && Rectangle.read([bounds]);\n\t\t\t\tparam = {\n\t\t\t\t\titems: [],\n\t\t\t\t\tinside: !!inside,\n\t\t\t\t\toverlapping: !!overlapping,\n\t\t\t\t\trect: rect,\n\t\t\t\t\tpath: overlapping && new Path.Rectangle({\n\t\t\t\t\t\trectangle: rect,\n\t\t\t\t\t\tinsert: false\n\t\t\t\t\t})\n\t\t\t\t};\n\t\t\t\tif (bounds)\n\t\t\t\t\tmatch = Base.set({}, match,\n\t\t\t\t\t\t\t{ inside: true, overlapping: true });\n\t\t\t}\n\t\t\tvar items = param && param.items,\n\t\t\t\trect = param && param.rect;\n\t\t\tmatrix = rect && (matrix || new Matrix());\n\t\t\tfor (var i = 0, l = children && children.length; i < l; i++) {\n\t\t\t\tvar child = children[i],\n\t\t\t\t\tchildMatrix = matrix && matrix.chain(child._matrix),\n\t\t\t\t\tadd = true;\n\t\t\t\tif (rect) {\n\t\t\t\t\tvar bounds = child.getBounds(childMatrix);\n\t\t\t\t\tif (!rect.intersects(bounds))\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tif (!(param.inside && rect.contains(bounds))\n\t\t\t\t\t\t\t&& !(param.overlapping && (bounds.contains(rect)\n\t\t\t\t\t\t\t\t|| param.path.intersects(child, childMatrix))))\n\t\t\t\t\t\tadd = false;\n\t\t\t\t}\n\t\t\t\tif (add && child.matches(match)) {\n\t\t\t\t\titems.push(child);\n\t\t\t\t\tif (firstOnly)\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t_getItems(child._children, match,\n\t\t\t\t\t\tchildMatrix, param,\n\t\t\t\t\t\tfirstOnly);\n\t\t\t\tif (firstOnly && items.length > 0)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\treturn items;\n\t\t}\n\t}\n}, {\n\n\timportJSON: function(json) {\n\t\tvar res = Base.importJSON(json, this);\n\t\treturn res !== this\n\t\t\t\t? this.addChild(res)\n\t\t\t\t: res;\n\t},\n\n\taddChild: function(item, _preserve) {\n\t\treturn this.insertChild(undefined, item, _preserve);\n\t},\n\n\tinsertChild: function(index, item, _preserve) {\n\t\tvar res = item ? this.insertChildren(index, [item], _preserve) : null;\n\t\treturn res && res[0];\n\t},\n\n\taddChildren: function(items, _preserve) {\n\t\treturn this.insertChildren(this._children.length, items, _preserve);\n\t},\n\n\tinsertChildren: function(index, items, _preserve, _proto) {\n\t\tvar children = this._children;\n\t\tif (children && items && items.length > 0) {\n\t\t\titems = Array.prototype.slice.apply(items);\n\t\t\tfor (var i = items.length - 1; i >= 0; i--) {\n\t\t\t\tvar item = items[i];\n\t\t\t\tif (_proto && !(item instanceof _proto)) {\n\t\t\t\t\titems.splice(i, 1);\n\t\t\t\t} else {\n\t\t\t\t\tvar shift = item._parent === this && item._index < index;\n\t\t\t\t\tif (item._remove(false, true) && shift)\n\t\t\t\t\t\tindex--;\n\t\t\t\t}\n\t\t\t}\n\t\t\tBase.splice(children, items, index, 0);\n\t\t\tvar project = this._project,\n\t\t\t\tnotifySelf = project && project._changes;\n\t\t\tfor (var i = 0, l = items.length; i < l; i++) {\n\t\t\t\tvar item = items[i];\n\t\t\t\titem._parent = this;\n\t\t\t\titem._setProject(this._project, true);\n\t\t\t\tif (item._name)\n\t\t\t\t\titem.setName(item._name);\n\t\t\t\tif (notifySelf)\n\t\t\t\t\tthis._changed(5);\n\t\t\t}\n\t\t\tthis._changed(11);\n\t\t} else {\n\t\t\titems = null;\n\t\t}\n\t\treturn items;\n\t},\n\n\t_insertSibling: function(index, item, _preserve) {\n\t\treturn this._parent\n\t\t\t\t? this._parent.insertChild(index, item, _preserve)\n\t\t\t\t: null;\n\t},\n\n\tinsertAbove: function(item, _preserve) {\n\t\treturn item._insertSibling(item._index + 1, this, _preserve);\n\t},\n\n\tinsertBelow: function(item, _preserve) {\n\t\treturn item._insertSibling(item._index, this, _preserve);\n\t},\n\n\tsendToBack: function() {\n\t\treturn (this._parent || this instanceof Layer && this._project)\n\t\t\t\t.insertChild(0, this);\n\t},\n\n\tbringToFront: function() {\n\t\treturn (this._parent || this instanceof Layer && this._project)\n\t\t\t\t.addChild(this);\n\t},\n\n\tappendTop: '#addChild',\n\n\tappendBottom: function(item) {\n\t\treturn this.insertChild(0, item);\n\t},\n\n\tmoveAbove: '#insertAbove',\n\n\tmoveBelow: '#insertBelow',\n\n\treduce: function() {\n\t\tif (this._children && this._children.length === 1) {\n\t\t\tvar child = this._children[0].reduce();\n\t\t\tchild.insertAbove(this);\n\t\t\tchild.setStyle(this._style);\n\t\t\tthis.remove();\n\t\t\treturn child;\n\t\t}\n\t\treturn this;\n\t},\n\n\t_removeNamed: function() {\n\t\tvar parent = this._parent;\n\t\tif (parent) {\n\t\t\tvar children = parent._children,\n\t\t\t\tnamedChildren = parent._namedChildren,\n\t\t\t\tname = this._name,\n\t\t\t\tnamedArray = namedChildren[name],\n\t\t\t\tindex = namedArray ? namedArray.indexOf(this) : -1;\n\t\t\tif (index !== -1) {\n\t\t\t\tif (children[name] == this)\n\t\t\t\t\tdelete children[name];\n\t\t\t\tnamedArray.splice(index, 1);\n\t\t\t\tif (namedArray.length) {\n\t\t\t\t\tchildren[name] = namedArray[namedArray.length - 1];\n\t\t\t\t} else {\n\t\t\t\t\tdelete namedChildren[name];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t},\n\n\t_remove: function(notifySelf, notifyParent) {\n\t\tvar parent = this._parent;\n\t\tif (parent) {\n\t\t\tif (this._name)\n\t\t\t\tthis._removeNamed();\n\t\t\tif (this._index != null)\n\t\t\t\tBase.splice(parent._children, null, this._index, 1);\n\t\t\tthis._installEvents(false);\n\t\t\tif (notifySelf) {\n\t\t\t\tvar project = this._project;\n\t\t\t\tif (project && project._changes)\n\t\t\t\t\tthis._changed(5);\n\t\t\t}\n\t\t\tif (notifyParent)\n\t\t\t\tparent._changed(11);\n\t\t\tthis._parent = null;\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t},\n\n\tremove: function() {\n\t\treturn this._remove(true, true);\n\t},\n\n\treplaceWith: function(item) {\n\t\tvar ok = item && item.insertBelow(this);\n\t\tif (ok)\n\t\t\tthis.remove();\n\t\treturn ok;\n\t},\n\n\tremoveChildren: function(from, to) {\n\t\tif (!this._children)\n\t\t\treturn null;\n\t\tfrom = from || 0;\n\t\tto = Base.pick(to, this._children.length);\n\t\tvar removed = Base.splice(this._children, null, from, to - from);\n\t\tfor (var i = removed.length - 1; i >= 0; i--) {\n\t\t\tremoved[i]._remove(true, false);\n\t\t}\n\t\tif (removed.length > 0)\n\t\t\tthis._changed(11);\n\t\treturn removed;\n\t},\n\n\tclear: '#removeChildren',\n\n\treverseChildren: function() {\n\t\tif (this._children) {\n\t\t\tthis._children.reverse();\n\t\t\tfor (var i = 0, l = this._children.length; i < l; i++)\n\t\t\t\tthis._children[i]._index = i;\n\t\t\tthis._changed(11);\n\t\t}\n\t},\n\n\tisEmpty: function() {\n\t\treturn !this._children || this._children.length === 0;\n\t},\n\n\tisEditable: function() {\n\t\tvar item = this;\n\t\twhile (item) {\n\t\t\tif (!item._visible || item._locked)\n\t\t\t\treturn false;\n\t\t\titem = item._parent;\n\t\t}\n\t\treturn true;\n\t},\n\n\thasFill: function() {\n\t\treturn this.getStyle().hasFill();\n\t},\n\n\thasStroke: function() {\n\t\treturn this.getStyle().hasStroke();\n\t},\n\n\thasShadow: function() {\n\t\treturn this.getStyle().hasShadow();\n\t},\n\n\t_getOrder: function(item) {\n\t\tfunction getList(item) {\n\t\t\tvar list = [];\n\t\t\tdo {\n\t\t\t\tlist.unshift(item);\n\t\t\t} while (item = item._parent);\n\t\t\treturn list;\n\t\t}\n\t\tvar list1 = getList(this),\n\t\t\tlist2 = getList(item);\n\t\tfor (var i = 0, l = Math.min(list1.length, list2.length); i < l; i++) {\n\t\t\tif (list1[i] != list2[i]) {\n\t\t\t\treturn list1[i]._index < list2[i]._index ? 1 : -1;\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t},\n\n\thasChildren: function() {\n\t\treturn this._children && this._children.length > 0;\n\t},\n\n\tisInserted: function() {\n\t\treturn this._parent ? this._parent.isInserted() : false;\n\t},\n\n\tisAbove: function(item) {\n\t\treturn this._getOrder(item) === -1;\n\t},\n\n\tisBelow: function(item) {\n\t\treturn this._getOrder(item) === 1;\n\t},\n\n\tisParent: function(item) {\n\t\treturn this._parent === item;\n\t},\n\n\tisChild: function(item) {\n\t\treturn item && item._parent === this;\n\t},\n\n\tisDescendant: function(item) {\n\t\tvar parent = this;\n\t\twhile (parent = parent._parent) {\n\t\t\tif (parent == item)\n\t\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t},\n\n\tisAncestor: function(item) {\n\t\treturn item ? item.isDescendant(this) : false;\n\t},\n\n\tisSibling: function(item) {\n\t\treturn this._parent === item._parent;\n\t},\n\n\tisGroupedWith: function(item) {\n\t\tvar parent = this._parent;\n\t\twhile (parent) {\n\t\t\tif (parent._parent\n\t\t\t\t&& /^(Group|Layer|CompoundPath)$/.test(parent._class)\n\t\t\t\t&& item.isDescendant(parent))\n\t\t\t\t\treturn true;\n\t\t\tparent = parent._parent;\n\t\t}\n\t\treturn false;\n\t},\n\n\ttranslate: function() {\n\t\tvar mx = new Matrix();\n\t\treturn this.transform(mx.translate.apply(mx, arguments));\n\t},\n\n\trotate: function(angle ) {\n\t\treturn this.transform(new Matrix().rotate(angle,\n\t\t\t\tPoint.read(arguments, 1, { readNull: true })\n\t\t\t\t\t|| this.getPosition(true)));\n\t}\n}, Base.each(['scale', 'shear', 'skew'], function(name) {\n\tthis[name] = function() {\n\t\tvar point = Point.read(arguments),\n\t\t\tcenter = Point.read(arguments, 0, { readNull: true });\n\t\treturn this.transform(new Matrix()[name](point,\n\t\t\t\tcenter || this.getPosition(true)));\n\t};\n}, {\n\n}), {\n\ttransform: function(matrix, _applyMatrix, _applyRecursively,\n\t\t\t_setApplyMatrix) {\n\t\tif (matrix && matrix.isIdentity())\n\t\t\tmatrix = null;\n\t\tvar _matrix = this._matrix,\n\t\t\tapplyMatrix = (_applyMatrix || this._applyMatrix)\n\t\t\t\t\t&& ((!_matrix.isIdentity() || matrix)\n\t\t\t\t\t\t|| _applyMatrix && _applyRecursively && this._children);\n\t\tif (!matrix && !applyMatrix)\n\t\t\treturn this;\n\t\tif (matrix)\n\t\t\t_matrix.preConcatenate(matrix);\n\t\tif (applyMatrix = applyMatrix && this._transformContent(_matrix,\n\t\t\t\t\t_applyRecursively, _setApplyMatrix)) {\n\t\t\tvar pivot = this._pivot,\n\t\t\t\tstyle = this._style,\n\t\t\t\tfillColor = style.getFillColor(true),\n\t\t\t\tstrokeColor = style.getStrokeColor(true);\n\t\t\tif (pivot)\n\t\t\t\t_matrix._transformPoint(pivot, pivot, true);\n\t\t\tif (fillColor)\n\t\t\t\tfillColor.transform(_matrix);\n\t\t\tif (strokeColor)\n\t\t\t\tstrokeColor.transform(_matrix);\n\t\t\t_matrix.reset(true);\n\t\t\tif (_setApplyMatrix && this._canApplyMatrix)\n\t\t\t\tthis._applyMatrix = true;\n\t\t}\n\t\tvar bounds = this._bounds,\n\t\t\tposition = this._position;\n\t\tthis._changed(9);\n\t\tvar decomp = bounds && matrix && matrix.decompose();\n\t\tif (decomp && !decomp.shearing && decomp.rotation % 90 === 0) {\n\t\t\tfor (var key in bounds) {\n\t\t\t\tvar rect = bounds[key];\n\t\t\t\tif (applyMatrix || !rect._internal)\n\t\t\t\t\tmatrix._transformBounds(rect, rect);\n\t\t\t}\n\t\t\tvar getter = this._boundsGetter,\n\t\t\t\trect = bounds[getter && getter.getBounds || getter || 'getBounds'];\n\t\t\tif (rect)\n\t\t\t\tthis._position = rect.getCenter(true);\n\t\t\tthis._bounds = bounds;\n\t\t} else if (matrix && position) {\n\t\t\tthis._position = matrix._transformPoint(position, position);\n\t\t}\n\t\treturn this;\n\t},\n\n\t_transformContent: function(matrix, applyRecursively, setApplyMatrix) {\n\t\tvar children = this._children;\n\t\tif (children) {\n\t\t\tfor (var i = 0, l = children.length; i < l; i++)\n\t\t\t\tchildren[i].transform(matrix, true, applyRecursively,\n\t\t\t\t\t\tsetApplyMatrix);\n\t\t\treturn true;\n\t\t}\n\t},\n\n\tglobalToLocal: function() {\n\t\treturn this.getGlobalMatrix(true)._inverseTransform(\n\t\t\t\tPoint.read(arguments));\n\t},\n\n\tlocalToGlobal: function() {\n\t\treturn this.getGlobalMatrix(true)._transformPoint(\n\t\t\t\tPoint.read(arguments));\n\t},\n\n\tparentToLocal: function() {\n\t\treturn this._matrix._inverseTransform(Point.read(arguments));\n\t},\n\n\tlocalToParent: function() {\n\t\treturn this._matrix._transformPoint(Point.read(arguments));\n\t},\n\n\tfitBounds: function(rectangle, fill) {\n\t\trectangle = Rectangle.read(arguments);\n\t\tvar bounds = this.getBounds(),\n\t\t\titemRatio = bounds.height / bounds.width,\n\t\t\trectRatio = rectangle.height / rectangle.width,\n\t\t\tscale = (fill ? itemRatio > rectRatio : itemRatio < rectRatio)\n\t\t\t\t\t? rectangle.width / bounds.width\n\t\t\t\t\t: rectangle.height / bounds.height,\n\t\t\tnewBounds = new Rectangle(new Point(),\n\t\t\t\t\tnew Size(bounds.width * scale, bounds.height * scale));\n\t\tnewBounds.setCenter(rectangle.getCenter());\n\t\tthis.setBounds(newBounds);\n\t},\n\n\t_setStyles: function(ctx) {\n\t\tvar style = this._style,\n\t\t\tfillColor = style.getFillColor(),\n\t\t\tstrokeColor = style.getStrokeColor(),\n\t\t\tshadowColor = style.getShadowColor();\n\t\tif (fillColor)\n\t\t\tctx.fillStyle = fillColor.toCanvasStyle(ctx);\n\t\tif (strokeColor) {\n\t\t\tvar strokeWidth = style.getStrokeWidth();\n\t\t\tif (strokeWidth > 0) {\n\t\t\t\tctx.strokeStyle = strokeColor.toCanvasStyle(ctx);\n\t\t\t\tctx.lineWidth = strokeWidth;\n\t\t\t\tvar strokeJoin = style.getStrokeJoin(),\n\t\t\t\t\tstrokeCap = style.getStrokeCap(),\n\t\t\t\t\tmiterLimit = style.getMiterLimit();\n\t\t\t\tif (strokeJoin)\n\t\t\t\t\tctx.lineJoin = strokeJoin;\n\t\t\t\tif (strokeCap)\n\t\t\t\t\tctx.lineCap = strokeCap;\n\t\t\t\tif (miterLimit)\n\t\t\t\t\tctx.miterLimit = miterLimit;\n\t\t\t\tif (paper.support.nativeDash) {\n\t\t\t\t\tvar dashArray = style.getDashArray(),\n\t\t\t\t\t\tdashOffset = style.getDashOffset();\n\t\t\t\t\tif (dashArray && dashArray.length) {\n\t\t\t\t\t\tif ('setLineDash' in ctx) {\n\t\t\t\t\t\t\tctx.setLineDash(dashArray);\n\t\t\t\t\t\t\tctx.lineDashOffset = dashOffset;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tctx.mozDash = dashArray;\n\t\t\t\t\t\t\tctx.mozDashOffset = dashOffset;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (shadowColor) {\n\t\t\tvar shadowBlur = style.getShadowBlur();\n\t\t\tif (shadowBlur > 0) {\n\t\t\t\tctx.shadowColor = shadowColor.toCanvasStyle(ctx);\n\t\t\t\tctx.shadowBlur = shadowBlur;\n\t\t\t\tvar offset = this.getShadowOffset();\n\t\t\t\tctx.shadowOffsetX = offset.x;\n\t\t\t\tctx.shadowOffsetY = offset.y;\n\t\t\t}\n\t\t}\n\t},\n\n\tdraw: function(ctx, param, parentStrokeMatrix) {\n\t\tvar updateVersion = this._updateVersion = this._project._updateVersion;\n\t\tif (!this._visible || this._opacity === 0)\n\t\t\treturn;\n\t\tvar matrices = param.matrices,\n\t\t\tviewMatrix = param.viewMatrix,\n\t\t\tmatrix = this._matrix,\n\t\t\tglobalMatrix = matrices[matrices.length - 1].chain(matrix);\n\t\tif (!globalMatrix.isInvertible())\n\t\t\treturn;\n\n\t\tfunction getViewMatrix(matrix) {\n\t\t\treturn viewMatrix ? viewMatrix.chain(matrix) : matrix;\n\t\t}\n\n\t\tmatrices.push(globalMatrix);\n\t\tif (param.updateMatrix) {\n\t\t\tglobalMatrix._updateVersion = updateVersion;\n\t\t\tthis._globalMatrix = globalMatrix;\n\t\t}\n\n\t\tvar blendMode = this._blendMode,\n\t\t\topacity = this._opacity,\n\t\t\tnormalBlend = blendMode === 'normal',\n\t\t\tnativeBlend = BlendMode.nativeModes[blendMode],\n\t\t\tdirect = normalBlend && opacity === 1\n\t\t\t\t\t|| param.dontStart\n\t\t\t\t\t|| param.clip\n\t\t\t\t\t|| (nativeBlend || normalBlend && opacity < 1)\n\t\t\t\t\t\t&& this._canComposite(),\n\t\t\tpixelRatio = param.pixelRatio || 1,\n\t\t\tmainCtx, itemOffset, prevOffset;\n\t\tif (!direct) {\n\t\t\tvar bounds = this.getStrokeBounds(getViewMatrix(globalMatrix));\n\t\t\tif (!bounds.width || !bounds.height)\n\t\t\t\treturn;\n\t\t\tprevOffset = param.offset;\n\t\t\titemOffset = param.offset = bounds.getTopLeft().floor();\n\t\t\tmainCtx = ctx;\n\t\t\tctx = CanvasProvider.getContext(bounds.getSize().ceil().add(1)\n\t\t\t\t\t.multiply(pixelRatio));\n\t\t\tif (pixelRatio !== 1)\n\t\t\t\tctx.scale(pixelRatio, pixelRatio);\n\t\t}\n\t\tctx.save();\n\t\tvar strokeMatrix = parentStrokeMatrix\n\t\t\t\t? parentStrokeMatrix.chain(matrix)\n\t\t\t\t: !this.getStrokeScaling(true) && getViewMatrix(globalMatrix),\n\t\t\tclip = !direct && param.clipItem,\n\t\t\ttransform = !strokeMatrix || clip;\n\t\tif (direct) {\n\t\t\tctx.globalAlpha = opacity;\n\t\t\tif (nativeBlend)\n\t\t\t\tctx.globalCompositeOperation = blendMode;\n\t\t} else if (transform) {\n\t\t\tctx.translate(-itemOffset.x, -itemOffset.y);\n\t\t}\n\t\tif (transform)\n\t\t\t(direct ? matrix : getViewMatrix(globalMatrix)).applyToContext(ctx);\n\t\tif (clip)\n\t\t\tparam.clipItem.draw(ctx, param.extend({ clip: true }));\n\t\tif (strokeMatrix) {\n\t\t\tctx.setTransform(pixelRatio, 0, 0, pixelRatio, 0, 0);\n\t\t\tvar offset = param.offset;\n\t\t\tif (offset)\n\t\t\t\tctx.translate(-offset.x, -offset.y);\n\t\t}\n\t\tthis._draw(ctx, param, strokeMatrix);\n\t\tctx.restore();\n\t\tmatrices.pop();\n\t\tif (param.clip && !param.dontFinish)\n\t\t\tctx.clip();\n\t\tif (!direct) {\n\t\t\tBlendMode.process(blendMode, ctx, mainCtx, opacity,\n\t\t\t\t\titemOffset.subtract(prevOffset).multiply(pixelRatio));\n\t\t\tCanvasProvider.release(ctx);\n\t\t\tparam.offset = prevOffset;\n\t\t}\n\t},\n\n\t_isUpdated: function(updateVersion) {\n\t\tvar parent = this._parent;\n\t\tif (parent instanceof CompoundPath)\n\t\t\treturn parent._isUpdated(updateVersion);\n\t\tvar updated = this._updateVersion === updateVersion;\n\t\tif (!updated && parent && parent._visible\n\t\t\t\t&& parent._isUpdated(updateVersion)) {\n\t\t\tthis._updateVersion = updateVersion;\n\t\t\tupdated = true;\n\t\t}\n\t\treturn updated;\n\t},\n\n\t_drawSelection: function(ctx, matrix, size, selectedItems, updateVersion) {\n\t\tif ((this._drawSelected || this._boundsSelected)\n\t\t\t\t&& this._isUpdated(updateVersion)) {\n\t\t\tvar color = this.getSelectedColor(true)\n\t\t\t\t\t|| this.getLayer().getSelectedColor(true),\n\t\t\t\tmx = matrix.chain(this.getGlobalMatrix(true));\n\t\t\tctx.strokeStyle = ctx.fillStyle = color\n\t\t\t\t\t? color.toCanvasStyle(ctx) : '#009dec';\n\t\t\tif (this._drawSelected)\n\t\t\t\tthis._drawSelected(ctx, mx, selectedItems);\n\t\t\tif (this._boundsSelected) {\n\t\t\t\tvar half = size / 2,\n\t\t\t\t\tcoords = mx._transformCorners(this.getInternalBounds());\n\t\t\t\tctx.beginPath();\n\t\t\t\tfor (var i = 0; i < 8; i++)\n\t\t\t\t\tctx[i === 0 ? 'moveTo' : 'lineTo'](coords[i], coords[++i]);\n\t\t\t\tctx.closePath();\n\t\t\t\tctx.stroke();\n\t\t\t\tfor (var i = 0; i < 8; i++)\n\t\t\t\t\tctx.fillRect(coords[i] - half, coords[++i] - half,\n\t\t\t\t\t\t\tsize, size);\n\t\t\t}\n\t\t}\n\t},\n\n\t_canComposite: function() {\n\t\treturn false;\n\t}\n}, Base.each(['down', 'drag', 'up', 'move'], function(name) {\n\tthis['removeOn' + Base.capitalize(name)] = function() {\n\t\tvar hash = {};\n\t\thash[name] = true;\n\t\treturn this.removeOn(hash);\n\t};\n}, {\n\n\tremoveOn: function(obj) {\n\t\tfor (var name in obj) {\n\t\t\tif (obj[name]) {\n\t\t\t\tvar key = 'mouse' + name,\n\t\t\t\t\tproject = this._project,\n\t\t\t\t\tsets = project._removeSets = project._removeSets || {};\n\t\t\t\tsets[key] = sets[key] || {};\n\t\t\t\tsets[key][this._id] = this;\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t}\n}));\n\nvar Group = Item.extend({\n\t_class: 'Group',\n\t_selectChildren: true,\n\t_serializeFields: {\n\t\tchildren: []\n\t},\n\n\tinitialize: function Group(arg) {\n\t\tthis._children = [];\n\t\tthis._namedChildren = {};\n\t\tif (!this._initialize(arg))\n\t\t\tthis.addChildren(Array.isArray(arg) ? arg : arguments);\n\t},\n\n\t_changed: function _changed(flags) {\n\t\t_changed.base.call(this, flags);\n\t\tif (flags & 1026) {\n\t\t\tthis._clipItem = undefined;\n\t\t}\n\t},\n\n\t_getClipItem: function() {\n\t\tvar clipItem = this._clipItem;\n\t\tif (clipItem === undefined) {\n\t\t\tclipItem = null;\n\t\t\tfor (var i = 0, l = this._children.length; i < l; i++) {\n\t\t\t\tvar child = this._children[i];\n\t\t\t\tif (child._clipMask) {\n\t\t\t\t\tclipItem = child;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis._clipItem = clipItem;\n\t\t}\n\t\treturn clipItem;\n\t},\n\n\tisClipped: function() {\n\t\treturn !!this._getClipItem();\n\t},\n\n\tsetClipped: function(clipped) {\n\t\tvar child = this.getFirstChild();\n\t\tif (child)\n\t\t\tchild.setClipMask(clipped);\n\t},\n\n\t_draw: function(ctx, param) {\n\t\tvar clip = param.clip,\n\t\t\tclipItem = !clip && this._getClipItem(),\n\t\t\tdraw = true;\n\t\tparam = param.extend({ clipItem: clipItem, clip: false });\n\t\tif (clip) {\n\t\t\tif (this._currentPath) {\n\t\t\t\tctx.currentPath = this._currentPath;\n\t\t\t\tdraw = false;\n\t\t\t} else {\n\t\t\t\tctx.beginPath();\n\t\t\t\tparam.dontStart = param.dontFinish = true;\n\t\t\t}\n\t\t} else if (clipItem) {\n\t\t\tclipItem.draw(ctx, param.extend({ clip: true }));\n\t\t}\n\t\tif (draw) {\n\t\t\tfor (var i = 0, l = this._children.length; i < l; i++) {\n\t\t\t\tvar item = this._children[i];\n\t\t\t\tif (item !== clipItem)\n\t\t\t\t\titem.draw(ctx, param);\n\t\t\t}\n\t\t}\n\t\tif (clip) {\n\t\t\tthis._currentPath = ctx.currentPath;\n\t\t}\n\t}\n});\n\nvar Layer = Group.extend({\n\t_class: 'Layer',\n\n\tinitialize: function Layer(arg) {\n\t\tvar props = Base.isPlainObject(arg)\n\t\t\t\t? new Base(arg)\n\t\t\t\t: { children: Array.isArray(arg) ? arg : arguments },\n\t\t\tinsert = props.insert;\n\t\tprops.insert = false;\n\t\tGroup.call(this, props);\n\t\tif (insert || insert === undefined) {\n\t\t\tthis._project.addChild(this);\n\t\t\tthis.activate();\n\t\t}\n\t},\n\n\t_remove: function _remove(notifySelf, notifyParent) {\n\t\tif (this._parent)\n\t\t\treturn _remove.base.call(this, notifySelf, notifyParent);\n\t\tif (this._index != null) {\n\t\t\tvar project = this._project;\n\t\t\tif (project._activeLayer === this)\n\t\t\t\tproject._activeLayer = this.getNextSibling()\n\t\t\t\t\t\t|| this.getPreviousSibling();\n\t\t\tBase.splice(project.layers, null, this._index, 1);\n\t\t\tthis._installEvents(false);\n\t\t\tif (notifySelf && project._changes)\n\t\t\t\tthis._changed(5);\n\t\t\tif (notifyParent) {\n\t\t\t\tproject._needsUpdate = true;\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t},\n\n\tgetNextSibling: function getNextSibling() {\n\t\treturn this._parent ? getNextSibling.base.call(this)\n\t\t\t\t: this._project.layers[this._index + 1] || null;\n\t},\n\n\tgetPreviousSibling: function getPreviousSibling() {\n\t\treturn this._parent ? getPreviousSibling.base.call(this)\n\t\t\t\t: this._project.layers[this._index - 1] || null;\n\t},\n\n\tisInserted: function isInserted() {\n\t\treturn this._parent ? isInserted.base.call(this) : this._index != null;\n\t},\n\n\tactivate: function() {\n\t\tthis._project._activeLayer = this;\n\t},\n\n\t_insertSibling: function _insertSibling(index, item, _preserve) {\n\t\treturn !this._parent\n\t\t\t\t? this._project.insertChild(index, item, _preserve)\n\t\t\t\t: _insertSibling.base.call(this, index, item, _preserve);\n\t}\n});\n\nvar Shape = Item.extend({\n\t_class: 'Shape',\n\t_applyMatrix: false,\n\t_canApplyMatrix: false,\n\t_boundsSelected: true,\n\t_serializeFields: {\n\t\ttype: null,\n\t\tsize: null,\n\t\tradius: null\n\t},\n\n\tinitialize: function Shape(props) {\n\t\tthis._initialize(props);\n\t},\n\n\t_equals: function(item) {\n\t\treturn this._type === item._type\n\t\t\t&& this._size.equals(item._size)\n\t\t\t&& Base.equals(this._radius, item._radius);\n\t},\n\n\tclone: function(insert) {\n\t\tvar copy = new Shape(Item.NO_INSERT);\n\t\tcopy.setType(this._type);\n\t\tcopy.setSize(this._size);\n\t\tcopy.setRadius(this._radius);\n\t\treturn this._clone(copy, insert);\n\t},\n\n\tgetType: function() {\n\t\treturn this._type;\n\t},\n\n\tsetType: function(type) {\n\t\tthis._type = type;\n\t},\n\n\tgetShape: '#getType',\n\tsetShape: '#setType',\n\n\tgetSize: function() {\n\t\tvar size = this._size;\n\t\treturn new LinkedSize(size.width, size.height, this, 'setSize');\n\t},\n\n\tsetSize: function() {\n\t\tvar size = Size.read(arguments);\n\t\tif (!this._size) {\n\t\t\tthis._size = size.clone();\n\t\t} else if (!this._size.equals(size)) {\n\t\t\tvar type = this._type,\n\t\t\t\twidth = size.width,\n\t\t\t\theight = size.height;\n\t\t\tif (type === 'rectangle') {\n\t\t\t\tvar radius = Size.min(this._radius, size.divide(2));\n\t\t\t\tthis._radius.set(radius.width, radius.height);\n\t\t\t} else if (type === 'circle') {\n\t\t\t\twidth = height = (width + height) / 2;\n\t\t\t\tthis._radius = width / 2;\n\t\t\t} else if (type === 'ellipse') {\n\t\t\t\tthis._radius.set(width / 2, height / 2);\n\t\t\t}\n\t\t\tthis._size.set(width, height);\n\t\t\tthis._changed(9);\n\t\t}\n\t},\n\n\tgetRadius: function() {\n\t\tvar rad = this._radius;\n\t\treturn this._type === 'circle'\n\t\t\t\t? rad\n\t\t\t\t: new LinkedSize(rad.width, rad.height, this, 'setRadius');\n\t},\n\n\tsetRadius: function(radius) {\n\t\tvar type = this._type;\n\t\tif (type === 'circle') {\n\t\t\tif (radius === this._radius)\n\t\t\t\treturn;\n\t\t\tvar size = radius * 2;\n\t\t\tthis._radius = radius;\n\t\t\tthis._size.set(size, size);\n\t\t} else {\n\t\t\tradius = Size.read(arguments);\n\t\t\tif (!this._radius) {\n\t\t\t\tthis._radius = radius.clone();\n\t\t\t} else {\n\t\t\t\tif (this._radius.equals(radius))\n\t\t\t\t\treturn;\n\t\t\t\tthis._radius.set(radius.width, radius.height);\n\t\t\t\tif (type === 'rectangle') {\n\t\t\t\t\tvar size = Size.max(this._size, radius.multiply(2));\n\t\t\t\t\tthis._size.set(size.width, size.height);\n\t\t\t\t} else if (type === 'ellipse') {\n\t\t\t\t\tthis._size.set(radius.width * 2, radius.height * 2);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tthis._changed(9);\n\t},\n\n\tisEmpty: function() {\n\t\treturn false;\n\t},\n\n\ttoPath: function(insert) {\n\t\tvar path = this._clone(new Path[Base.capitalize(this._type)]({\n\t\t\tcenter: new Point(),\n\t\t\tsize: this._size,\n\t\t\tradius: this._radius,\n\t\t\tinsert: false\n\t\t}), insert);\n\t\tif (paper.settings.applyMatrix)\n\t\t\tpath.setApplyMatrix(true);\n\t\treturn path;\n\t},\n\n\t_draw: function(ctx, param, strokeMatrix) {\n\t\tvar style = this._style,\n\t\t\thasFill = style.hasFill(),\n\t\t\thasStroke = style.hasStroke(),\n\t\t\tdontPaint = param.dontFinish || param.clip,\n\t\t\tuntransformed = !strokeMatrix;\n\t\tif (hasFill || hasStroke || dontPaint) {\n\t\t\tvar type = this._type,\n\t\t\t\tradius = this._radius,\n\t\t\t\tisCircle = type === 'circle';\n\t\t\tif (!param.dontStart)\n\t\t\t\tctx.beginPath();\n\t\t\tif (untransformed && isCircle) {\n\t\t\t\tctx.arc(0, 0, radius, 0, Math.PI * 2, true);\n\t\t\t} else {\n\t\t\t\tvar rx = isCircle ? radius : radius.width,\n\t\t\t\t\try = isCircle ? radius : radius.height,\n\t\t\t\t\tsize = this._size,\n\t\t\t\t\twidth = size.width,\n\t\t\t\t\theight = size.height;\n\t\t\t\tif (untransformed && type === 'rectangle' && rx === 0 && ry === 0) {\n\t\t\t\t\tctx.rect(-width / 2, -height / 2, width, height);\n\t\t\t\t} else {\n\t\t\t\t\tvar x = width / 2,\n\t\t\t\t\t\ty = height / 2,\n\t\t\t\t\t\tkappa = 1 - 0.5522847498307936,\n\t\t\t\t\t\tcx = rx * kappa,\n\t\t\t\t\t\tcy = ry * kappa,\n\t\t\t\t\t\tc = [\n\t\t\t\t\t\t\t-x, -y + ry,\n\t\t\t\t\t\t\t-x, -y + cy,\n\t\t\t\t\t\t\t-x + cx, -y,\n\t\t\t\t\t\t\t-x + rx, -y,\n\t\t\t\t\t\t\tx - rx, -y,\n\t\t\t\t\t\t\tx - cx, -y,\n\t\t\t\t\t\t\tx, -y + cy,\n\t\t\t\t\t\t\tx, -y + ry,\n\t\t\t\t\t\t\tx, y - ry,\n\t\t\t\t\t\t\tx, y - cy,\n\t\t\t\t\t\t\tx - cx, y,\n\t\t\t\t\t\t\tx - rx, y,\n\t\t\t\t\t\t\t-x + rx, y,\n\t\t\t\t\t\t\t-x + cx, y,\n\t\t\t\t\t\t\t-x, y - cy,\n\t\t\t\t\t\t\t-x, y - ry\n\t\t\t\t\t\t];\n\t\t\t\t\tif (strokeMatrix)\n\t\t\t\t\t\tstrokeMatrix.transform(c, c, 32);\n\t\t\t\t\tctx.moveTo(c[0], c[1]);\n\t\t\t\t\tctx.bezierCurveTo(c[2], c[3], c[4], c[5], c[6], c[7]);\n\t\t\t\t\tif (x !== rx)\n\t\t\t\t\t\tctx.lineTo(c[8], c[9]);\n\t\t\t\t\tctx.bezierCurveTo(c[10], c[11], c[12], c[13], c[14], c[15]);\n\t\t\t\t\tif (y !== ry)\n\t\t\t\t\t\tctx.lineTo(c[16], c[17]);\n\t\t\t\t\tctx.bezierCurveTo(c[18], c[19], c[20], c[21], c[22], c[23]);\n\t\t\t\t\tif (x !== rx)\n\t\t\t\t\t\tctx.lineTo(c[24], c[25]);\n\t\t\t\t\tctx.bezierCurveTo(c[26], c[27], c[28], c[29], c[30], c[31]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tctx.closePath();\n\t\t}\n\t\tif (!dontPaint && (hasFill || hasStroke)) {\n\t\t\tthis._setStyles(ctx);\n\t\t\tif (hasFill) {\n\t\t\t\tctx.fill(style.getWindingRule());\n\t\t\t\tctx.shadowColor = 'rgba(0,0,0,0)';\n\t\t\t}\n\t\t\tif (hasStroke)\n\t\t\t\tctx.stroke();\n\t\t}\n\t},\n\n\t_canComposite: function() {\n\t\treturn !(this.hasFill() && this.hasStroke());\n\t},\n\n\t_getBounds: function(getter, matrix) {\n\t\tvar rect = new Rectangle(this._size).setCenter(0, 0);\n\t\tif (getter !== 'getBounds' && this.hasStroke())\n\t\t\trect = rect.expand(this.getStrokeWidth());\n\t\treturn matrix ? matrix._transformBounds(rect) : rect;\n\t}\n},\nnew function() {\n\tfunction getCornerCenter(that, point, expand) {\n\t\tvar radius = that._radius;\n\t\tif (!radius.isZero()) {\n\t\t\tvar halfSize = that._size.divide(2);\n\t\t\tfor (var i = 0; i < 4; i++) {\n\t\t\t\tvar dir = new Point(i & 1 ? 1 : -1, i > 1 ? 1 : -1),\n\t\t\t\t\tcorner = dir.multiply(halfSize),\n\t\t\t\t\tcenter = corner.subtract(dir.multiply(radius)),\n\t\t\t\t\trect = new Rectangle(corner, center);\n\t\t\t\tif ((expand ? rect.expand(expand) : rect).contains(point))\n\t\t\t\t\treturn center;\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction getEllipseRadius(point, radius) {\n\t\tvar angle = point.getAngleInRadians(),\n\t\t\twidth = radius.width * 2,\n\t\t\theight = radius.height * 2,\n\t\t\tx = width * Math.sin(angle),\n\t\t\ty = height * Math.cos(angle);\n\t\treturn width * height / (2 * Math.sqrt(x * x + y * y));\n\t}\n\n\treturn {\n\t\t_contains: function _contains(point) {\n\t\t\tif (this._type === 'rectangle') {\n\t\t\t\tvar center = getCornerCenter(this, point);\n\t\t\t\treturn center\n\t\t\t\t\t\t? point.subtract(center).divide(this._radius)\n\t\t\t\t\t\t\t.getLength() <= 1\n\t\t\t\t\t\t: _contains.base.call(this, point);\n\t\t\t} else {\n\t\t\t\treturn point.divide(this.size).getLength() <= 0.5;\n\t\t\t}\n\t\t},\n\n\t\t_hitTestSelf: function _hitTestSelf(point, options) {\n\t\t\tvar hit = false;\n\t\t\tif (this.hasStroke()) {\n\t\t\t\tvar type = this._type,\n\t\t\t\t\tradius = this._radius,\n\t\t\t\t\tstrokeWidth = this.getStrokeWidth() + 2 * options.tolerance;\n\t\t\t\tif (type === 'rectangle') {\n\t\t\t\t\tvar center = getCornerCenter(this, point, strokeWidth);\n\t\t\t\t\tif (center) {\n\t\t\t\t\t\tvar pt = point.subtract(center);\n\t\t\t\t\t\thit = 2 * Math.abs(pt.getLength()\n\t\t\t\t\t\t\t\t- getEllipseRadius(pt, radius)) <= strokeWidth;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tvar rect = new Rectangle(this._size).setCenter(0, 0),\n\t\t\t\t\t\t\touter = rect.expand(strokeWidth),\n\t\t\t\t\t\t\tinner = rect.expand(-strokeWidth);\n\t\t\t\t\t\thit = outer._containsPoint(point)\n\t\t\t\t\t\t\t\t&& !inner._containsPoint(point);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (type === 'ellipse')\n\t\t\t\t\t\tradius = getEllipseRadius(point, radius);\n\t\t\t\t\thit = 2 * Math.abs(point.getLength() - radius)\n\t\t\t\t\t\t\t<= strokeWidth;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn hit\n\t\t\t\t\t? new HitResult('stroke', this)\n\t\t\t\t\t: _hitTestSelf.base.apply(this, arguments);\n\t\t}\n\t};\n}, {\n\nstatics: new function() {\n\tfunction createShape(type, point, size, radius, args) {\n\t\tvar item = new Shape(Base.getNamed(args));\n\t\titem._type = type;\n\t\titem._size = size;\n\t\titem._radius = radius;\n\t\treturn item.translate(point);\n\t}\n\n\treturn {\n\t\tCircle: function() {\n\t\t\tvar center = Point.readNamed(arguments, 'center'),\n\t\t\t\tradius = Base.readNamed(arguments, 'radius');\n\t\t\treturn createShape('circle', center, new Size(radius * 2), radius,\n\t\t\t\t\targuments);\n\t\t},\n\n\t\tRectangle: function() {\n\t\t\tvar rect = Rectangle.readNamed(arguments, 'rectangle'),\n\t\t\t\tradius = Size.min(Size.readNamed(arguments, 'radius'),\n\t\t\t\t\t\trect.getSize(true).divide(2));\n\t\t\treturn createShape('rectangle', rect.getCenter(true),\n\t\t\t\t\trect.getSize(true), radius, arguments);\n\t\t},\n\n\t\tEllipse: function() {\n\t\t\tvar ellipse = Shape._readEllipse(arguments),\n\t\t\t\tradius = ellipse.radius;\n\t\t\treturn createShape('ellipse', ellipse.center, radius.multiply(2),\n\t\t\t\t\tradius, arguments);\n\t\t},\n\n\t\t_readEllipse: function(args) {\n\t\t\tvar center,\n\t\t\t\tradius;\n\t\t\tif (Base.hasNamed(args, 'radius')) {\n\t\t\t\tcenter = Point.readNamed(args, 'center');\n\t\t\t\tradius = Size.readNamed(args, 'radius');\n\t\t\t} else {\n\t\t\t\tvar rect = Rectangle.readNamed(args, 'rectangle');\n\t\t\t\tcenter = rect.getCenter(true);\n\t\t\t\tradius = rect.getSize(true).divide(2);\n\t\t\t}\n\t\t\treturn { center: center, radius: radius };\n\t\t}\n\t};\n}});\n\nvar Raster = Item.extend({\n\t_class: 'Raster',\n\t_applyMatrix: false,\n\t_canApplyMatrix: false,\n\t_boundsGetter: 'getBounds',\n\t_boundsSelected: true,\n\t_serializeFields: {\n\t\tcrossOrigin: null,\n\t\tsource: null\n\t},\n\n\tinitialize: function Raster(object, position) {\n\t\tif (!this._initialize(object,\n\t\t\t\tposition !== undefined && Point.read(arguments, 1))) {\n\t\t\tif (typeof object === 'string') {\n\t\t\t\tthis.setSource(object);\n\t\t\t} else {\n\t\t\t\tthis.setImage(object);\n\t\t\t}\n\t\t}\n\t\tif (!this._size) {\n\t\t\tthis._size = new Size();\n\t\t\tthis._loaded = false;\n\t\t}\n\t},\n\n\t_equals: function(item) {\n\t\treturn this.getSource() === item.getSource();\n\t},\n\n\tclone: function(insert) {\n\t\tvar copy = new Raster(Item.NO_INSERT),\n\t\t\timage = this._image,\n\t\t\tcanvas = this._canvas;\n\t\tif (image) {\n\t\t\tcopy.setImage(image);\n\t\t} else if (canvas) {\n\t\t\tvar copyCanvas = CanvasProvider.getCanvas(this._size);\n\t\t\tcopyCanvas.getContext('2d').drawImage(canvas, 0, 0);\n\t\t\tcopy.setImage(copyCanvas);\n\t\t}\n\t\tcopy._crossOrigin = this._crossOrigin;\n\t\treturn this._clone(copy, insert);\n\t},\n\n\tgetSize: function() {\n\t\tvar size = this._size;\n\t\treturn new LinkedSize(size ? size.width : 0, size ? size.height : 0,\n\t\t\t\tthis, 'setSize');\n\t},\n\n\tsetSize: function() {\n\t\tvar size = Size.read(arguments);\n\t\tif (!size.equals(this._size)) {\n\t\t\tif (size.width > 0 && size.height > 0) {\n\t\t\t\tvar element = this.getElement();\n\t\t\t\tthis.setImage(CanvasProvider.getCanvas(size));\n\t\t\t\tif (element)\n\t\t\t\t\tthis.getContext(true).drawImage(element, 0, 0,\n\t\t\t\t\t\t\tsize.width, size.height);\n\t\t\t} else {\n\t\t\t\tif (this._canvas)\n\t\t\t\t\tCanvasProvider.release(this._canvas);\n\t\t\t\tthis._size = size.clone();\n\t\t\t}\n\t\t}\n\t},\n\n\tgetWidth: function() {\n\t\treturn this._size ? this._size.width : 0;\n\t},\n\n\tsetWidth: function(width) {\n\t\tthis.setSize(width, this.getHeight());\n\t},\n\n\tgetHeight: function() {\n\t\treturn this._size ? this._size.height : 0;\n\t},\n\n\tsetHeight: function(height) {\n\t\tthis.setSize(this.getWidth(), height);\n\t},\n\n\tisEmpty: function() {\n\t\tvar size = this._size;\n\t\treturn !size || size.width === 0 && size.height === 0;\n\t},\n\n\tgetResolution: function() {\n\t\tvar matrix = this._matrix,\n\t\t\torig = new Point(0, 0).transform(matrix),\n\t\t\tu = new Point(1, 0).transform(matrix).subtract(orig),\n\t\t\tv = new Point(0, 1).transform(matrix).subtract(orig);\n\t\treturn new Size(\n\t\t\t72 / u.getLength(),\n\t\t\t72 / v.getLength()\n\t\t);\n\t},\n\n\tgetPpi: '#getResolution',\n\n\tgetImage: function() {\n\t\treturn this._image;\n\t},\n\n\tsetImage: function(image) {\n\t\tif (this._canvas)\n\t\t\tCanvasProvider.release(this._canvas);\n\t\tif (image && image.getContext) {\n\t\t\tthis._image = null;\n\t\t\tthis._canvas = image;\n\t\t\tthis._loaded = true;\n\t\t} else {\n\t\t\tthis._image = image;\n\t\t\tthis._canvas = null;\n\t\t\tthis._loaded = image && image.complete;\n\t\t}\n\t\tthis._size = new Size(\n\t\t\t\timage ? image.naturalWidth || image.width : 0,\n\t\t\t\timage ? image.naturalHeight || image.height : 0);\n\t\tthis._context = null;\n\t\tthis._changed(521);\n\t},\n\n\tgetCanvas: function() {\n\t\tif (!this._canvas) {\n\t\t\tvar ctx = CanvasProvider.getContext(this._size);\n\t\t\ttry {\n\t\t\t\tif (this._image)\n\t\t\t\t\tctx.drawImage(this._image, 0, 0);\n\t\t\t\tthis._canvas = ctx.canvas;\n\t\t\t} catch (e) {\n\t\t\t\tCanvasProvider.release(ctx);\n\t\t\t}\n\t\t}\n\t\treturn this._canvas;\n\t},\n\n\tsetCanvas: '#setImage',\n\n\tgetContext: function(modify) {\n\t\tif (!this._context)\n\t\t\tthis._context = this.getCanvas().getContext('2d');\n\t\tif (modify) {\n\t\t\tthis._image = null;\n\t\t\tthis._changed(513);\n\t\t}\n\t\treturn this._context;\n\t},\n\n\tsetContext: function(context) {\n\t\tthis._context = context;\n\t},\n\n\tgetSource: function() {\n\t\treturn this._image && this._image.src || this.toDataURL();\n\t},\n\n\tsetSource: function(src) {\n\t\tvar that = this,\n\t\t\tcrossOrigin = this._crossOrigin,\n\t\t\timage;\n\n\t\tfunction loaded() {\n\t\t\tvar view = that.getView();\n\t\t\tif (view) {\n\t\t\t\tpaper = view._scope;\n\t\t\t\tthat.setImage(image);\n\t\t\t\tthat.emit('load');\n\t\t\t\tview.update();\n\t\t\t}\n\t\t}\n\n\t\timage = document.getElementById(src) || new Image();\n\t\tif (crossOrigin)\n\t\t\timage.crossOrigin = crossOrigin;\n\t\tif (image.naturalWidth && image.naturalHeight) {\n\t\t\tsetTimeout(loaded, 0);\n\t\t} else {\n\t\t\tDomEvent.add(image, { load: loaded });\n\t\t\tif (!image.src)\n\t\t\t\timage.src = src;\n\t\t}\n\t\tthis.setImage(image);\n\t},\n\n\tgetCrossOrigin: function() {\n\t\treturn this._image && this._image.crossOrigin || this._crossOrigin || '';\n\t},\n\n\tsetCrossOrigin: function(crossOrigin) {\n\t\tthis._crossOrigin = crossOrigin;\n\t\tif (this._image)\n\t\t\tthis._image.crossOrigin = crossOrigin;\n\t},\n\n\tgetElement: function() {\n\t\treturn this._canvas || this._loaded && this._image;\n\t}\n}, {\n\tbeans: false,\n\n\tgetSubCanvas: function() {\n\t\tvar rect = Rectangle.read(arguments),\n\t\t\tctx = CanvasProvider.getContext(rect.getSize());\n\t\tctx.drawImage(this.getCanvas(), rect.x, rect.y,\n\t\t\t\trect.width, rect.height, 0, 0, rect.width, rect.height);\n\t\treturn ctx.canvas;\n\t},\n\n\tgetSubRaster: function() {\n\t\tvar rect = Rectangle.read(arguments),\n\t\t\traster = new Raster(Item.NO_INSERT);\n\t\traster.setImage(this.getSubCanvas(rect));\n\t\traster.translate(rect.getCenter().subtract(this.getSize().divide(2)));\n\t\traster._matrix.preConcatenate(this._matrix);\n\t\traster.insertAbove(this);\n\t\treturn raster;\n\t},\n\n\ttoDataURL: function() {\n\t\tvar src = this._image && this._image.src;\n\t\tif (/^data:/.test(src))\n\t\t\treturn src;\n\t\tvar canvas = this.getCanvas();\n\t\treturn canvas ? canvas.toDataURL.apply(canvas, arguments) : null;\n\t},\n\n\tdrawImage: function(image ) {\n\t\tvar point = Point.read(arguments, 1);\n\t\tthis.getContext(true).drawImage(image, point.x, point.y);\n\t},\n\n\tgetAverageColor: function(object) {\n\t\tvar bounds, path;\n\t\tif (!object) {\n\t\t\tbounds = this.getBounds();\n\t\t} else if (object instanceof PathItem) {\n\t\t\tpath = object;\n\t\t\tbounds = object.getBounds();\n\t\t} else if (object.width) {\n\t\t\tbounds = new Rectangle(object);\n\t\t} else if (object.x) {\n\t\t\tbounds = new Rectangle(object.x - 0.5, object.y - 0.5, 1, 1);\n\t\t}\n\t\tvar sampleSize = 32,\n\t\t\twidth = Math.min(bounds.width, sampleSize),\n\t\t\theight = Math.min(bounds.height, sampleSize);\n\t\tvar ctx = Raster._sampleContext;\n\t\tif (!ctx) {\n\t\t\tctx = Raster._sampleContext = CanvasProvider.getContext(\n\t\t\t\t\tnew Size(sampleSize));\n\t\t} else {\n\t\t\tctx.clearRect(0, 0, sampleSize + 1, sampleSize + 1);\n\t\t}\n\t\tctx.save();\n\t\tvar matrix = new Matrix()\n\t\t\t\t.scale(width / bounds.width, height / bounds.height)\n\t\t\t\t.translate(-bounds.x, -bounds.y);\n\t\tmatrix.applyToContext(ctx);\n\t\tif (path)\n\t\t\tpath.draw(ctx, new Base({ clip: true, matrices: [matrix] }));\n\t\tthis._matrix.applyToContext(ctx);\n\t\tvar element = this.getElement(),\n\t\t\tsize = this._size;\n\t\tif (element)\n\t\t\tctx.drawImage(element, -size.width / 2, -size.height / 2);\n\t\tctx.restore();\n\t\tvar pixels = ctx.getImageData(0.5, 0.5, Math.ceil(width),\n\t\t\t\tMath.ceil(height)).data,\n\t\t\tchannels = [0, 0, 0],\n\t\t\ttotal = 0;\n\t\tfor (var i = 0, l = pixels.length; i < l; i += 4) {\n\t\t\tvar alpha = pixels[i + 3];\n\t\t\ttotal += alpha;\n\t\t\talpha /= 255;\n\t\t\tchannels[0] += pixels[i] * alpha;\n\t\t\tchannels[1] += pixels[i + 1] * alpha;\n\t\t\tchannels[2] += pixels[i + 2] * alpha;\n\t\t}\n\t\tfor (var i = 0; i < 3; i++)\n\t\t\tchannels[i] /= total;\n\t\treturn total ? Color.read(channels) : null;\n\t},\n\n\tgetPixel: function() {\n\t\tvar point = Point.read(arguments);\n\t\tvar data = this.getContext().getImageData(point.x, point.y, 1, 1).data;\n\t\treturn new Color('rgb', [data[0] / 255, data[1] / 255, data[2] / 255],\n\t\t\t\tdata[3] / 255);\n\t},\n\n\tsetPixel: function() {\n\t\tvar point = Point.read(arguments),\n\t\t\tcolor = Color.read(arguments),\n\t\t\tcomponents = color._convert('rgb'),\n\t\t\talpha = color._alpha,\n\t\t\tctx = this.getContext(true),\n\t\t\timageData = ctx.createImageData(1, 1),\n\t\t\tdata = imageData.data;\n\t\tdata[0] = components[0] * 255;\n\t\tdata[1] = components[1] * 255;\n\t\tdata[2] = components[2] * 255;\n\t\tdata[3] = alpha != null ? alpha * 255 : 255;\n\t\tctx.putImageData(imageData, point.x, point.y);\n\t},\n\n\tcreateImageData: function() {\n\t\tvar size = Size.read(arguments);\n\t\treturn this.getContext().createImageData(size.width, size.height);\n\t},\n\n\tgetImageData: function() {\n\t\tvar rect = Rectangle.read(arguments);\n\t\tif (rect.isEmpty())\n\t\t\trect = new Rectangle(this._size);\n\t\treturn this.getContext().getImageData(rect.x, rect.y,\n\t\t\t\trect.width, rect.height);\n\t},\n\n\tsetImageData: function(data ) {\n\t\tvar point = Point.read(arguments, 1);\n\t\tthis.getContext(true).putImageData(data, point.x, point.y);\n\t},\n\n\t_getBounds: function(getter, matrix) {\n\t\tvar rect = new Rectangle(this._size).setCenter(0, 0);\n\t\treturn matrix ? matrix._transformBounds(rect) : rect;\n\t},\n\n\t_hitTestSelf: function(point) {\n\t\tif (this._contains(point)) {\n\t\t\tvar that = this;\n\t\t\treturn new HitResult('pixel', that, {\n\t\t\t\toffset: point.add(that._size.divide(2)).round(),\n\t\t\t\tcolor: {\n\t\t\t\t\tget: function() {\n\t\t\t\t\t\treturn that.getPixel(this.offset);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t},\n\n\t_draw: function(ctx) {\n\t\tvar element = this.getElement();\n\t\tif (element) {\n\t\t\tctx.globalAlpha = this._opacity;\n\t\t\tctx.drawImage(element,\n\t\t\t\t\t-this._size.width / 2, -this._size.height / 2);\n\t\t}\n\t},\n\n\t_canComposite: function() {\n\t\treturn true;\n\t}\n});\n\nvar PlacedSymbol = Item.extend({\n\t_class: 'PlacedSymbol',\n\t_applyMatrix: false,\n\t_canApplyMatrix: false,\n\t_boundsGetter: { getBounds: 'getStrokeBounds' },\n\t_boundsSelected: true,\n\t_serializeFields: {\n\t\tsymbol: null\n\t},\n\n\tinitialize: function PlacedSymbol(arg0, arg1) {\n\t\tif (!this._initialize(arg0,\n\t\t\t\targ1 !== undefined && Point.read(arguments, 1)))\n\t\t\tthis.setSymbol(arg0 instanceof Symbol ? arg0 : new Symbol(arg0));\n\t},\n\n\t_equals: function(item) {\n\t\treturn this._symbol === item._symbol;\n\t},\n\n\tgetSymbol: function() {\n\t\treturn this._symbol;\n\t},\n\n\tsetSymbol: function(symbol) {\n\t\tthis._symbol = symbol;\n\t\tthis._changed(9);\n\t},\n\n\tclone: function(insert) {\n\t\tvar copy = new PlacedSymbol(Item.NO_INSERT);\n\t\tcopy.setSymbol(this._symbol);\n\t\treturn this._clone(copy, insert);\n\t},\n\n\tisEmpty: function() {\n\t\treturn this._symbol._definition.isEmpty();\n\t},\n\n\t_getBounds: function(getter, matrix, cacheItem) {\n\t\tvar definition = this.symbol._definition;\n\t\treturn definition._getCachedBounds(getter,\n\t\t\t\tmatrix && matrix.chain(definition._matrix), cacheItem);\n\t},\n\n\t_hitTestSelf: function(point, options) {\n\t\tvar res = this._symbol._definition._hitTest(point, options);\n\t\tif (res)\n\t\t\tres.item = this;\n\t\treturn res;\n\t},\n\n\t_draw: function(ctx, param) {\n\t\tthis.symbol._definition.draw(ctx, param);\n\t}\n\n});\n\nvar HitResult = Base.extend({\n\t_class: 'HitResult',\n\n\tinitialize: function HitResult(type, item, values) {\n\t\tthis.type = type;\n\t\tthis.item = item;\n\t\tif (values) {\n\t\t\tvalues.enumerable = true;\n\t\t\tthis.inject(values);\n\t\t}\n\t},\n\n\tstatics: {\n\t\tgetOptions: function(options) {\n\t\t\treturn new Base({\n\t\t\t\ttype: null,\n\t\t\t\ttolerance: paper.settings.hitTolerance,\n\t\t\t\tfill: !options,\n\t\t\t\tstroke: !options,\n\t\t\t\tsegments: !options,\n\t\t\t\thandles: false,\n\t\t\t\tends: false,\n\t\t\t\tcenter: false,\n\t\t\t\tbounds: false,\n\t\t\t\tguides: false,\n\t\t\t\tselected: false\n\t\t\t}, options);\n\t\t}\n\t}\n});\n\nvar Segment = Base.extend({\n\t_class: 'Segment',\n\tbeans: true,\n\n\tinitialize: function Segment(arg0, arg1, arg2, arg3, arg4, arg5) {\n\t\tvar count = arguments.length,\n\t\t\tpoint, handleIn, handleOut;\n\t\tif (count === 0) {\n\t\t} else if (count === 1) {\n\t\t\tif ('point' in arg0) {\n\t\t\t\tpoint = arg0.point;\n\t\t\t\thandleIn = arg0.handleIn;\n\t\t\t\thandleOut = arg0.handleOut;\n\t\t\t} else {\n\t\t\t\tpoint = arg0;\n\t\t\t}\n\t\t} else if (count === 2 && typeof arg0 === 'number') {\n\t\t\tpoint = arguments;\n\t\t} else if (count <= 3) {\n\t\t\tpoint = arg0;\n\t\t\thandleIn = arg1;\n\t\t\thandleOut = arg2;\n\t\t} else {\n\t\t\tpoint = arg0 !== undefined ? [ arg0, arg1 ] : null;\n\t\t\thandleIn = arg2 !== undefined ? [ arg2, arg3 ] : null;\n\t\t\thandleOut = arg4 !== undefined ? [ arg4, arg5 ] : null;\n\t\t}\n\t\tnew SegmentPoint(point, this, '_point');\n\t\tnew SegmentPoint(handleIn, this, '_handleIn');\n\t\tnew SegmentPoint(handleOut, this, '_handleOut');\n\t},\n\n\t_serialize: function(options) {\n\t\treturn Base.serialize(this.hasHandles()\n\t\t\t\t? [this._point, this._handleIn, this._handleOut]\n\t\t\t\t: this._point,\n\t\t\t\toptions, true);\n\t},\n\n\t_changed: function(point) {\n\t\tvar path = this._path;\n\t\tif (!path)\n\t\t\treturn;\n\t\tvar curves = path._curves,\n\t\t\tindex = this._index,\n\t\t\tcurve;\n\t\tif (curves) {\n\t\t\tif ((!point || point === this._point || point === this._handleIn)\n\t\t\t\t\t&& (curve = index > 0 ? curves[index - 1] : path._closed\n\t\t\t\t\t\t? curves[curves.length - 1] : null))\n\t\t\t\tcurve._changed();\n\t\t\tif ((!point || point === this._point || point === this._handleOut)\n\t\t\t\t\t&& (curve = curves[index]))\n\t\t\t\tcurve._changed();\n\t\t}\n\t\tpath._changed(25);\n\t},\n\n\tgetPoint: function() {\n\t\treturn this._point;\n\t},\n\n\tsetPoint: function() {\n\t\tvar point = Point.read(arguments);\n\t\tthis._point.set(point.x, point.y);\n\t},\n\n\tgetHandleIn: function() {\n\t\treturn this._handleIn;\n\t},\n\n\tsetHandleIn: function() {\n\t\tvar point = Point.read(arguments);\n\t\tthis._handleIn.set(point.x, point.y);\n\t},\n\n\tgetHandleOut: function() {\n\t\treturn this._handleOut;\n\t},\n\n\tsetHandleOut: function() {\n\t\tvar point = Point.read(arguments);\n\t\tthis._handleOut.set(point.x, point.y);\n\t},\n\n\thasHandles: function() {\n\t\treturn !this._handleIn.isZero() || !this._handleOut.isZero();\n\t},\n\n\tclearHandles: function() {\n\t\tthis._handleIn.set(0, 0);\n\t\tthis._handleOut.set(0, 0);\n\t},\n\n\t_selectionState: 0,\n\n\tisSelected: function(_point) {\n\t\tvar state = this._selectionState;\n\t\treturn !_point ? !!(state & 7)\n\t\t\t: _point === this._point ? !!(state & 4)\n\t\t\t: _point === this._handleIn ? !!(state & 1)\n\t\t\t: _point === this._handleOut ? !!(state & 2)\n\t\t\t: false;\n\t},\n\n\tsetSelected: function(selected, _point) {\n\t\tvar path = this._path,\n\t\t\tselected = !!selected,\n\t\t\tstate = this._selectionState,\n\t\t\toldState = state,\n\t\t\tflag = !_point ? 7\n\t\t\t\t\t: _point === this._point ? 4\n\t\t\t\t\t: _point === this._handleIn ? 1\n\t\t\t\t\t: _point === this._handleOut ? 2\n\t\t\t\t\t: 0;\n\t\tif (selected) {\n\t\t\tstate |= flag;\n\t\t} else {\n\t\t\tstate &= ~flag;\n\t\t}\n\t\tthis._selectionState = state;\n\t\tif (path && state !== oldState) {\n\t\t\tpath._updateSelection(this, oldState, state);\n\t\t\tpath._changed(129);\n\t\t}\n\t},\n\n\tgetIndex: function() {\n\t\treturn this._index !== undefined ? this._index : null;\n\t},\n\n\tgetPath: function() {\n\t\treturn this._path || null;\n\t},\n\n\tgetCurve: function() {\n\t\tvar path = this._path,\n\t\t\tindex = this._index;\n\t\tif (path) {\n\t\t\tif (index > 0 && !path._closed\n\t\t\t\t\t&& index === path._segments.length - 1)\n\t\t\t\tindex--;\n\t\t\treturn path.getCurves()[index] || null;\n\t\t}\n\t\treturn null;\n\t},\n\n\tgetLocation: function() {\n\t\tvar curve = this.getCurve();\n\t\treturn curve\n\t\t\t\t? new CurveLocation(curve, this === curve._segment1 ? 0 : 1)\n\t\t\t\t: null;\n\t},\n\n\tgetNext: function() {\n\t\tvar segments = this._path && this._path._segments;\n\t\treturn segments && (segments[this._index + 1]\n\t\t\t\t|| this._path._closed && segments[0]) || null;\n\t},\n\n\tgetPrevious: function() {\n\t\tvar segments = this._path && this._path._segments;\n\t\treturn segments && (segments[this._index - 1]\n\t\t\t\t|| this._path._closed && segments[segments.length - 1]) || null;\n\t},\n\n\tisFirst: function() {\n\t\treturn this._index === 0;\n\t},\n\n\tisLast: function() {\n\t\tvar path = this._path;\n\t\treturn path && this._index === path._segments.length - 1 || false;\n\t},\n\n\treverse: function() {\n\t\tvar handleIn = this._handleIn,\n\t\t\thandleOut = this._handleOut,\n\t\t\tinX = handleIn._x,\n\t\t\tinY = handleIn._y;\n\t\thandleIn.set(handleOut._x, handleOut._y);\n\t\thandleOut.set(inX, inY);\n\t},\n\n\treversed: function() {\n\t\treturn new Segment(this._point, this._handleOut, this._handleIn);\n\t},\n\n\tremove: function() {\n\t\treturn this._path ? !!this._path.removeSegment(this._index) : false;\n\t},\n\n\tclone: function() {\n\t\treturn new Segment(this._point, this._handleIn, this._handleOut);\n\t},\n\n\tequals: function(segment) {\n\t\treturn segment === this || segment && this._class === segment._class\n\t\t\t\t&& this._point.equals(segment._point)\n\t\t\t\t&& this._handleIn.equals(segment._handleIn)\n\t\t\t\t&& this._handleOut.equals(segment._handleOut)\n\t\t\t\t|| false;\n\t},\n\n\ttoString: function() {\n\t\tvar parts = [ 'point: ' + this._point ];\n\t\tif (!this._handleIn.isZero())\n\t\t\tparts.push('handleIn: ' + this._handleIn);\n\t\tif (!this._handleOut.isZero())\n\t\t\tparts.push('handleOut: ' + this._handleOut);\n\t\treturn '{ ' + parts.join(', ') + ' }';\n\t},\n\n\ttransform: function(matrix) {\n\t\tthis._transformCoordinates(matrix, new Array(6), true);\n\t\tthis._changed();\n\t},\n\n\t_transformCoordinates: function(matrix, coords, change) {\n\t\tvar point = this._point,\n\t\t\thandleIn = !change || !this._handleIn.isZero()\n\t\t\t\t\t? this._handleIn : null,\n\t\t\thandleOut = !change || !this._handleOut.isZero()\n\t\t\t\t\t? this._handleOut : null,\n\t\t\tx = point._x,\n\t\t\ty = point._y,\n\t\t\ti = 2;\n\t\tcoords[0] = x;\n\t\tcoords[1] = y;\n\t\tif (handleIn) {\n\t\t\tcoords[i++] = handleIn._x + x;\n\t\t\tcoords[i++] = handleIn._y + y;\n\t\t}\n\t\tif (handleOut) {\n\t\t\tcoords[i++] = handleOut._x + x;\n\t\t\tcoords[i++] = handleOut._y + y;\n\t\t}\n\t\tif (matrix) {\n\t\t\tmatrix._transformCoordinates(coords, coords, i / 2);\n\t\t\tx = coords[0];\n\t\t\ty = coords[1];\n\t\t\tif (change) {\n\t\t\t\tpoint._x = x;\n\t\t\t\tpoint._y = y;\n\t\t\t\ti  = 2;\n\t\t\t\tif (handleIn) {\n\t\t\t\t\thandleIn._x = coords[i++] - x;\n\t\t\t\t\thandleIn._y = coords[i++] - y;\n\t\t\t\t}\n\t\t\t\tif (handleOut) {\n\t\t\t\t\thandleOut._x = coords[i++] - x;\n\t\t\t\t\thandleOut._y = coords[i++] - y;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (!handleIn) {\n\t\t\t\t\tcoords[i++] = x;\n\t\t\t\t\tcoords[i++] = y;\n\t\t\t\t}\n\t\t\t\tif (!handleOut) {\n\t\t\t\t\tcoords[i++] = x;\n\t\t\t\t\tcoords[i++] = y;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn coords;\n\t}\n});\n\nvar SegmentPoint = Point.extend({\n\tinitialize: function SegmentPoint(point, owner, key) {\n\t\tvar x, y, selected;\n\t\tif (!point) {\n\t\t\tx = y = 0;\n\t\t} else if ((x = point[0]) !== undefined) {\n\t\t\ty = point[1];\n\t\t} else {\n\t\t\tvar pt = point;\n\t\t\tif ((x = pt.x) === undefined) {\n\t\t\t\tpt = Point.read(arguments);\n\t\t\t\tx = pt.x;\n\t\t\t}\n\t\t\ty = pt.y;\n\t\t\tselected = pt.selected;\n\t\t}\n\t\tthis._x = x;\n\t\tthis._y = y;\n\t\tthis._owner = owner;\n\t\towner[key] = this;\n\t\tif (selected)\n\t\t\tthis.setSelected(true);\n\t},\n\n\tset: function(x, y) {\n\t\tthis._x = x;\n\t\tthis._y = y;\n\t\tthis._owner._changed(this);\n\t\treturn this;\n\t},\n\n\t_serialize: function(options) {\n\t\tvar f = options.formatter,\n\t\t\tx = f.number(this._x),\n\t\t\ty = f.number(this._y);\n\t\treturn this.isSelected()\n\t\t\t\t? { x: x, y: y, selected: true }\n\t\t\t\t: [x, y];\n\t},\n\n\tgetX: function() {\n\t\treturn this._x;\n\t},\n\n\tsetX: function(x) {\n\t\tthis._x = x;\n\t\tthis._owner._changed(this);\n\t},\n\n\tgetY: function() {\n\t\treturn this._y;\n\t},\n\n\tsetY: function(y) {\n\t\tthis._y = y;\n\t\tthis._owner._changed(this);\n\t},\n\n\tisZero: function() {\n\t\treturn Numerical.isZero(this._x) && Numerical.isZero(this._y);\n\t},\n\n\tsetSelected: function(selected) {\n\t\tthis._owner.setSelected(selected, this);\n\t},\n\n\tisSelected: function() {\n\t\treturn this._owner.isSelected(this);\n\t}\n});\n\nvar Curve = Base.extend({\n\t_class: 'Curve',\n\n\tinitialize: function Curve(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7) {\n\t\tvar count = arguments.length,\n\t\t\tseg1, seg2,\n\t\t\tpoint1, point2,\n\t\t\thandle1, handle2;\n\t\tif (count === 3) {\n\t\t\tthis._path = arg0;\n\t\t\tseg1 = arg1;\n\t\t\tseg2 = arg2;\n\t\t} else if (count === 0) {\n\t\t\tseg1 = new Segment();\n\t\t\tseg2 = new Segment();\n\t\t} else if (count === 1) {\n\t\t\tif ('segment1' in arg0) {\n\t\t\t\tseg1 = new Segment(arg0.segment1);\n\t\t\t\tseg2 = new Segment(arg0.segment2);\n\t\t\t} else if ('point1' in arg0) {\n\t\t\t\tpoint1 = arg0.point1;\n\t\t\t\thandle1 = arg0.handle1;\n\t\t\t\thandle2 = arg0.handle2;\n\t\t\t\tpoint2 = arg0.point2;\n\t\t\t} else if (Array.isArray(arg0)) {\n\t\t\t\tpoint1 = [arg0[0], arg0[1]];\n\t\t\t\tpoint2 = [arg0[6], arg0[7]];\n\t\t\t\thandle1 = [arg0[2] - arg0[0], arg0[3] - arg0[1]];\n\t\t\t\thandle2 = [arg0[4] - arg0[6], arg0[5] - arg0[7]];\n\t\t\t}\n\t\t} else if (count === 2) {\n\t\t\tseg1 = new Segment(arg0);\n\t\t\tseg2 = new Segment(arg1);\n\t\t} else if (count === 4) {\n\t\t\tpoint1 = arg0;\n\t\t\thandle1 = arg1;\n\t\t\thandle2 = arg2;\n\t\t\tpoint2 = arg3;\n\t\t} else if (count === 8) {\n\t\t\tpoint1 = [arg0, arg1];\n\t\t\tpoint2 = [arg6, arg7];\n\t\t\thandle1 = [arg2 - arg0, arg3 - arg1];\n\t\t\thandle2 = [arg4 - arg6, arg5 - arg7];\n\t\t}\n\t\tthis._segment1 = seg1 || new Segment(point1, null, handle1);\n\t\tthis._segment2 = seg2 || new Segment(point2, handle2, null);\n\t},\n\n\t_serialize: function(options) {\n\t\treturn Base.serialize(this.hasHandles()\n\t\t\t\t? [this.getPoint1(), this.getHandle1(), this.getHandle2(),\n\t\t\t\t\tthis.getPoint2()]\n\t\t\t\t: [this.getPoint1(), this.getPoint2()],\n\t\t\t\toptions, true);\n\t},\n\n\t_changed: function() {\n\t\tthis._length = this._bounds = undefined;\n\t},\n\n\tclone: function() {\n\t\treturn new Curve(this._segment1, this._segment2);\n\t},\n\n\ttoString: function() {\n\t\tvar parts = [ 'point1: ' + this._segment1._point ];\n\t\tif (!this._segment1._handleOut.isZero())\n\t\t\tparts.push('handle1: ' + this._segment1._handleOut);\n\t\tif (!this._segment2._handleIn.isZero())\n\t\t\tparts.push('handle2: ' + this._segment2._handleIn);\n\t\tparts.push('point2: ' + this._segment2._point);\n\t\treturn '{ ' + parts.join(', ') + ' }';\n\t},\n\n\tremove: function() {\n\t\tvar removed = false;\n\t\tif (this._path) {\n\t\t\tvar segment2 = this._segment2,\n\t\t\t\thandleOut = segment2._handleOut;\n\t\t\tremoved = segment2.remove();\n\t\t\tif (removed)\n\t\t\t\tthis._segment1._handleOut.set(handleOut.x, handleOut.y);\n\t\t}\n\t\treturn removed;\n\t},\n\n\tgetPoint1: function() {\n\t\treturn this._segment1._point;\n\t},\n\n\tsetPoint1: function() {\n\t\tvar point = Point.read(arguments);\n\t\tthis._segment1._point.set(point.x, point.y);\n\t},\n\n\tgetPoint2: function() {\n\t\treturn this._segment2._point;\n\t},\n\n\tsetPoint2: function() {\n\t\tvar point = Point.read(arguments);\n\t\tthis._segment2._point.set(point.x, point.y);\n\t},\n\n\tgetHandle1: function() {\n\t\treturn this._segment1._handleOut;\n\t},\n\n\tsetHandle1: function() {\n\t\tvar point = Point.read(arguments);\n\t\tthis._segment1._handleOut.set(point.x, point.y);\n\t},\n\n\tgetHandle2: function() {\n\t\treturn this._segment2._handleIn;\n\t},\n\n\tsetHandle2: function() {\n\t\tvar point = Point.read(arguments);\n\t\tthis._segment2._handleIn.set(point.x, point.y);\n\t},\n\n\tgetSegment1: function() {\n\t\treturn this._segment1;\n\t},\n\n\tgetSegment2: function() {\n\t\treturn this._segment2;\n\t},\n\n\tgetPath: function() {\n\t\treturn this._path;\n\t},\n\n\tgetIndex: function() {\n\t\treturn this._segment1._index;\n\t},\n\n\tgetNext: function() {\n\t\tvar curves = this._path && this._path._curves;\n\t\treturn curves && (curves[this._segment1._index + 1]\n\t\t\t\t|| this._path._closed && curves[0]) || null;\n\t},\n\n\tgetPrevious: function() {\n\t\tvar curves = this._path && this._path._curves;\n\t\treturn curves && (curves[this._segment1._index - 1]\n\t\t\t\t|| this._path._closed && curves[curves.length - 1]) || null;\n\t},\n\n\tisFirst: function() {\n\t\treturn this._segment1._index === 0;\n\t},\n\n\tisLast: function() {\n\t\tvar path = this._path;\n\t\treturn path && this._segment1._index === path._curves.length - 1\n\t\t\t\t|| false;\n\t},\n\n\tisSelected: function() {\n\t\treturn this.getPoint1().isSelected()\n\t\t\t\t&& this.getHandle2().isSelected()\n\t\t\t\t&& this.getHandle2().isSelected()\n\t\t\t\t&& this.getPoint2().isSelected();\n\t},\n\n\tsetSelected: function(selected) {\n\t\tthis.getPoint1().setSelected(selected);\n\t\tthis.getHandle1().setSelected(selected);\n\t\tthis.getHandle2().setSelected(selected);\n\t\tthis.getPoint2().setSelected(selected);\n\t},\n\n\tgetValues: function(matrix) {\n\t\treturn Curve.getValues(this._segment1, this._segment2, matrix);\n\t},\n\n\tgetPoints: function() {\n\t\tvar coords = this.getValues(),\n\t\t\tpoints = [];\n\t\tfor (var i = 0; i < 8; i += 2)\n\t\t\tpoints.push(new Point(coords[i], coords[i + 1]));\n\t\treturn points;\n\t},\n\n\tgetLength: function() {\n\t\tif (this._length == null)\n\t\t\tthis._length = Curve.getLength(this.getValues(), 0, 1);\n\t\treturn this._length;\n\t},\n\n\tgetArea: function() {\n\t\treturn Curve.getArea(this.getValues());\n\t},\n\n\tgetLine: function() {\n\t\treturn new Line(this._segment1._point, this._segment2._point);\n\t},\n\n\tgetPart: function(from, to) {\n\t\treturn new Curve(Curve.getPart(this.getValues(), from, to));\n\t},\n\n\tgetPartLength: function(from, to) {\n\t\treturn Curve.getLength(this.getValues(), from, to);\n\t},\n\n\tgetIntersections: function(curve) {\n\t\treturn Curve._getIntersections(this.getValues(),\n\t\t\t\tcurve && curve !== this ? curve.getValues() : null,\n\t\t\t\tthis, curve, [], {});\n\t},\n\n\t_getParameter: function(offset, isParameter) {\n\t\treturn isParameter\n\t\t\t\t? offset\n\t\t\t\t: offset && offset.curve === this\n\t\t\t\t\t? offset.parameter\n\t\t\t\t\t: offset === undefined && isParameter === undefined\n\t\t\t\t\t\t? 0.5\n\t\t\t\t\t\t: this.getParameterAt(offset, 0);\n\t},\n\n\tdivide: function(offset, isParameter, _setHandles) {\n\t\tvar parameter = this._getParameter(offset, isParameter),\n\t\t\ttMin = 4e-7,\n\t\t\ttMax = 1 - tMin,\n\t\t\tres = null;\n\t\tif (parameter >= tMin && parameter <= tMax) {\n\t\t\tvar parts = Curve.subdivide(this.getValues(), parameter),\n\t\t\t\tleft = parts[0],\n\t\t\t\tright = parts[1],\n\t\t\t\tsetHandles = _setHandles || this.hasHandles(),\n\t\t\t\tsegment1 = this._segment1,\n\t\t\t\tsegment2 = this._segment2,\n\t\t\t\tpath = this._path;\n\t\t\tif (setHandles) {\n\t\t\t\tsegment1._handleOut.set(left[2] - left[0],\n\t\t\t\t\t\tleft[3] - left[1]);\n\t\t\t\tsegment2._handleIn.set(right[4] - right[6],\n\t\t\t\t\t\tright[5] - right[7]);\n\t\t\t}\n\t\t\tvar x = left[6], y = left[7],\n\t\t\t\tsegment = new Segment(new Point(x, y),\n\t\t\t\t\t\tsetHandles && new Point(left[4] - x, left[5] - y),\n\t\t\t\t\t\tsetHandles && new Point(right[2] - x, right[3] - y));\n\t\t\tif (path) {\n\t\t\t\tpath.insert(segment1._index + 1, segment);\n\t\t\t\tres = this.getNext();\n\t\t\t} else {\n\t\t\t\tthis._segment2 = segment;\n\t\t\t\tres = new Curve(segment, segment2);\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t},\n\n\tsplit: function(offset, isParameter) {\n\t\treturn this._path\n\t\t\t? this._path.split(this._segment1._index,\n\t\t\t\t\tthis._getParameter(offset, isParameter))\n\t\t\t: null;\n\t},\n\n\treversed: function() {\n\t\treturn new Curve(this._segment2.reversed(), this._segment1.reversed());\n\t},\n\n\tclearHandles: function() {\n\t\tthis._segment1._handleOut.set(0, 0);\n\t\tthis._segment2._handleIn.set(0, 0);\n\t},\n\nstatics: {\n\tgetValues: function(segment1, segment2, matrix) {\n\t\tvar p1 = segment1._point,\n\t\t\th1 = segment1._handleOut,\n\t\t\th2 = segment2._handleIn,\n\t\t\tp2 = segment2._point,\n\t\t\tvalues = [\n\t\t\t\tp1._x, p1._y,\n\t\t\t\tp1._x + h1._x, p1._y + h1._y,\n\t\t\t\tp2._x + h2._x, p2._y + h2._y,\n\t\t\t\tp2._x, p2._y\n\t\t\t];\n\t\tif (matrix)\n\t\t\tmatrix._transformCoordinates(values, values, 4);\n\t\treturn values;\n\t},\n\n\tsubdivide: function(v, t) {\n\t\tvar p1x = v[0], p1y = v[1],\n\t\t\tc1x = v[2], c1y = v[3],\n\t\t\tc2x = v[4], c2y = v[5],\n\t\t\tp2x = v[6], p2y = v[7];\n\t\tif (t === undefined)\n\t\t\tt = 0.5;\n\t\tvar u = 1 - t,\n\t\t\tp3x = u * p1x + t * c1x, p3y = u * p1y + t * c1y,\n\t\t\tp4x = u * c1x + t * c2x, p4y = u * c1y + t * c2y,\n\t\t\tp5x = u * c2x + t * p2x, p5y = u * c2y + t * p2y,\n\t\t\tp6x = u * p3x + t * p4x, p6y = u * p3y + t * p4y,\n\t\t\tp7x = u * p4x + t * p5x, p7y = u * p4y + t * p5y,\n\t\t\tp8x = u * p6x + t * p7x, p8y = u * p6y + t * p7y;\n\t\treturn [\n\t\t\t[p1x, p1y, p3x, p3y, p6x, p6y, p8x, p8y],\n\t\t\t[p8x, p8y, p7x, p7y, p5x, p5y, p2x, p2y]\n\t\t];\n\t},\n\n\tsolveCubic: function (v, coord, val, roots, min, max) {\n\t\tvar p1 = v[coord],\n\t\t\tc1 = v[coord + 2],\n\t\t\tc2 = v[coord + 4],\n\t\t\tp2 = v[coord + 6],\n\t\t\tc = 3 * (c1 - p1),\n\t\t\tb = 3 * (c2 - c1) - c,\n\t\t\ta = p2 - p1 - c - b;\n\t\treturn Numerical.solveCubic(a, b, c, p1 - val, roots, min, max);\n\t},\n\n\tgetParameterOf: function(v, point) {\n\t\tvar p1 = new Point(v[0], v[1]),\n\t\t\tp2 = new Point(v[6], v[7]),\n\t\t\tepsilon = 1e-12,\n\t\t\tt = point.isClose(p1, epsilon) ? 0\n\t\t\t  : point.isClose(p2, epsilon) ? 1\n\t\t\t  : null;\n\t\tif (t !== null)\n\t\t\treturn t;\n\t\tvar coords = [point.x, point.y],\n\t\t\troots = [],\n\t\t\tgeomEpsilon = 2e-7;\n\t\tfor (var c = 0; c < 2; c++) {\n\t\t\tvar count = Curve.solveCubic(v, c, coords[c], roots, 0, 1);\n\t\t\tfor (var i = 0; i < count; i++) {\n\t\t\t\tt = roots[i];\n\t\t\t\tif (point.isClose(Curve.getPoint(v, t), geomEpsilon))\n\t\t\t\t\treturn t;\n\t\t\t}\n\t\t}\n\t\treturn point.isClose(p1, geomEpsilon) ? 0\n\t\t\t : point.isClose(p2, geomEpsilon) ? 1\n\t\t\t : null;\n\t},\n\n\tgetNearestParameter: function(v, point) {\n\t\tif (Curve.isStraight(v)) {\n\t\t\tvar p1x = v[0], p1y = v[1],\n\t\t\t\tp2x = v[6], p2y = v[7],\n\t\t\t\tvx = p2x - p1x, vy = p2y - p1y,\n\t\t\t\tdet = vx * vx + vy * vy;\n\t\t\tif (det === 0)\n\t\t\t\treturn 0;\n\t\t\tvar u = ((point.x - p1x) * vx + (point.y - p1y) * vy) / det;\n\t\t\treturn u < 1e-12 ? 0\n\t\t\t\t : u > 0.999999999999 ? 1\n\t\t\t\t : Curve.getParameterOf(v,\n\t\t\t\t\tnew Point(p1x + u * vx, p1y + u * vy));\n\t\t}\n\n\t\tvar count = 100,\n\t\t\tminDist = Infinity,\n\t\t\tminT = 0;\n\n\t\tfunction refine(t) {\n\t\t\tif (t >= 0 && t <= 1) {\n\t\t\t\tvar dist = point.getDistance(Curve.getPoint(v, t), true);\n\t\t\t\tif (dist < minDist) {\n\t\t\t\t\tminDist = dist;\n\t\t\t\t\tminT = t;\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (var i = 0; i <= count; i++)\n\t\t\trefine(i / count);\n\n\t\tvar step = 1 / (count * 2);\n\t\twhile (step > 4e-7) {\n\t\t\tif (!refine(minT - step) && !refine(minT + step))\n\t\t\t\tstep /= 2;\n\t\t}\n\t\treturn minT;\n\t},\n\n\tgetPart: function(v, from, to) {\n\t\tvar flip = from > to;\n\t\tif (flip) {\n\t\t\tvar tmp = from;\n\t\t\tfrom = to;\n\t\t\tto = tmp;\n\t\t}\n\t\tif (from > 0)\n\t\t\tv = Curve.subdivide(v, from)[1];\n\t\tif (to < 1)\n\t\t\tv = Curve.subdivide(v, (to - from) / (1 - from))[0];\n\t\treturn flip\n\t\t\t\t? [v[6], v[7], v[4], v[5], v[2], v[3], v[0], v[1]]\n\t\t\t\t: v;\n\t},\n\n\thasHandles: function(v) {\n\t\tvar isZero = Numerical.isZero;\n\t\treturn !(isZero(v[0] - v[2]) && isZero(v[1] - v[3])\n\t\t\t\t&& isZero(v[4] - v[6]) && isZero(v[5] - v[7]));\n\t},\n\n\tisFlatEnough: function(v, tolerance) {\n\t\tvar p1x = v[0], p1y = v[1],\n\t\t\tc1x = v[2], c1y = v[3],\n\t\t\tc2x = v[4], c2y = v[5],\n\t\t\tp2x = v[6], p2y = v[7],\n\t\t\tux = 3 * c1x - 2 * p1x - p2x,\n\t\t\tuy = 3 * c1y - 2 * p1y - p2y,\n\t\t\tvx = 3 * c2x - 2 * p2x - p1x,\n\t\t\tvy = 3 * c2y - 2 * p2y - p1y;\n\t\treturn Math.max(ux * ux, vx * vx) + Math.max(uy * uy, vy * vy)\n\t\t\t\t< 10 * tolerance * tolerance;\n\t},\n\n\tgetArea: function(v) {\n\t\tvar p1x = v[0], p1y = v[1],\n\t\t\tp2x = v[6], p2y = v[7],\n\t\t\th1x = (v[2] + p1x) / 2,\n\t\t\th1y = (v[3] + p1y) / 2,\n\t\t\th2x = (v[4] + v[6]) / 2,\n\t\t\th2y = (v[5] + v[7]) / 2;\n\t\treturn 6 * ((p1x - h1x) * (h1y + p1y)\n\t\t\t\t  + (h1x - h2x) * (h2y + h1y)\n\t\t\t\t  + (h2x - p2x) * (p2y + h2y)) / 10;\n\t},\n\n\tgetBounds: function(v) {\n\t\tvar min = v.slice(0, 2),\n\t\t\tmax = min.slice(),\n\t\t\troots = [0, 0];\n\t\tfor (var i = 0; i < 2; i++)\n\t\t\tCurve._addBounds(v[i], v[i + 2], v[i + 4], v[i + 6],\n\t\t\t\t\ti, 0, min, max, roots);\n\t\treturn new Rectangle(min[0], min[1], max[0] - min[0], max[1] - min[1]);\n\t},\n\n\t_addBounds: function(v0, v1, v2, v3, coord, padding, min, max, roots) {\n\t\tfunction add(value, padding) {\n\t\t\tvar left = value - padding,\n\t\t\t\tright = value + padding;\n\t\t\tif (left < min[coord])\n\t\t\t\tmin[coord] = left;\n\t\t\tif (right > max[coord])\n\t\t\t\tmax[coord] = right;\n\t\t}\n\t\tvar a = 3 * (v1 - v2) - v0 + v3,\n\t\t\tb = 2 * (v0 + v2) - 4 * v1,\n\t\t\tc = v1 - v0,\n\t\t\tcount = Numerical.solveQuadratic(a, b, c, roots),\n\t\t\ttMin = 4e-7,\n\t\t\ttMax = 1 - tMin;\n\t\tadd(v3, 0);\n\t\tfor (var i = 0; i < count; i++) {\n\t\t\tvar t = roots[i],\n\t\t\t\tu = 1 - t;\n\t\t\tif (tMin < t && t < tMax)\n\t\t\t\tadd(u * u * u * v0\n\t\t\t\t\t+ 3 * u * u * t * v1\n\t\t\t\t\t+ 3 * u * t * t * v2\n\t\t\t\t\t+ t * t * t * v3,\n\t\t\t\t\tpadding);\n\t\t}\n\t}\n}}, Base.each(\n\t['getBounds', 'getStrokeBounds', 'getHandleBounds', 'getRoughBounds'],\n\tfunction(name) {\n\t\tthis[name] = function() {\n\t\t\tif (!this._bounds)\n\t\t\t\tthis._bounds = {};\n\t\t\tvar bounds = this._bounds[name];\n\t\t\tif (!bounds) {\n\t\t\t\tvar path = this._path;\n\t\t\t\tbounds = this._bounds[name] = Path[name](\n\t\t\t\t\t\t[this._segment1, this._segment2], false,\n\t\t\t\t\t\tpath && path.getStyle());\n\t\t\t}\n\t\t\treturn bounds.clone();\n\t\t};\n\t},\n{\n\n}), Base.each({\n\tisStraight: function(l, h1, h2) {\n\t\tif (h1.isZero() && h2.isZero()) {\n\t\t\treturn true;\n\t\t} else if (l.isZero()) {\n\t\t\treturn false;\n\t\t} else if (h1.isCollinear(l) && h2.isCollinear(l)) {\n\t\t\tvar div = l.dot(l),\n\t\t\t\tp1 = l.dot(h1) / div,\n\t\t\t\tp2 = l.dot(h2) / div;\n\t\t\treturn p1 >= 0 && p1 <= 1 && p2 <= 0 && p2 >= -1;\n\t\t}\n\t\treturn false;\n\t},\n\n\tisLinear: function(l, h1, h2) {\n\t\tvar third = l.divide(3);\n\t\treturn h1.equals(third) && h2.negate().equals(third);\n\t}\n}, function(test, name) {\n\tthis[name] = function() {\n\t\tvar seg1 = this._segment1,\n\t\t\tseg2 = this._segment2;\n\t\treturn test(seg2._point.subtract(seg1._point),\n\t\t\t\tseg1._handleOut, seg2._handleIn);\n\t};\n\n\tthis.statics[name] = function(v) {\n\t\tvar p1x = v[0], p1y = v[1],\n\t\t\tp2x = v[6], p2y = v[7];\n\t\treturn test(new Point(p2x - p1x, p2y - p1y),\n\t\t\t\tnew Point(v[2] - p1x, v[3] - p1y),\n\t\t\t\tnew Point(v[4] - p2x, v[5] - p2y));\n\t};\n}, {\n\tstatics: {},\n\n\thasHandles: function() {\n\t\treturn !this._segment1._handleOut.isZero()\n\t\t\t\t|| !this._segment2._handleIn.isZero();\n\t},\n\n\tisCollinear: function(curve) {\n\t\treturn curve && this.isStraight() && curve.isStraight()\n\t\t\t\t&& this.getLine().isCollinear(curve.getLine());\n\t},\n\n\tisHorizontal: function() {\n\t\treturn this.isStraight() && Math.abs(this.getTangentAt(0.5, true).y)\n\t\t\t\t< 1e-7;\n\t},\n\n\tisVertical: function() {\n\t\treturn this.isStraight() && Math.abs(this.getTangentAt(0.5, true).x)\n\t\t\t\t< 1e-7;\n\t}\n}), {\n\tbeans: false,\n\n\tgetParameterAt: function(offset, start) {\n\t\treturn Curve.getParameterAt(this.getValues(), offset, start);\n\t},\n\n\tgetParameterOf: function() {\n\t\treturn Curve.getParameterOf(this.getValues(), Point.read(arguments));\n\t},\n\n\tgetLocationAt: function(offset, isParameter) {\n\t\tvar t = isParameter ? offset : this.getParameterAt(offset);\n\t\treturn t != null && t >= 0 && t <= 1\n\t\t\t\t? new CurveLocation(this, t)\n\t\t\t\t: null;\n\t},\n\n\tgetLocationOf: function() {\n\t\treturn this.getLocationAt(this.getParameterOf(Point.read(arguments)),\n\t\t\t\ttrue);\n\t},\n\n\tgetOffsetOf: function() {\n\t\tvar loc = this.getLocationOf.apply(this, arguments);\n\t\treturn loc ? loc.getOffset() : null;\n\t},\n\n\tgetNearestLocation: function() {\n\t\tvar point = Point.read(arguments),\n\t\t\tvalues = this.getValues(),\n\t\t\tt = Curve.getNearestParameter(values, point),\n\t\t\tpt = Curve.getPoint(values, t);\n\t\treturn new CurveLocation(this, t, pt, null, point.getDistance(pt));\n\t},\n\n\tgetNearestPoint: function() {\n\t\treturn this.getNearestLocation.apply(this, arguments).getPoint();\n\t}\n\n},\nnew function() {\n\tvar methods = ['getPoint', 'getTangent', 'getNormal', 'getWeightedTangent',\n\t\t'getWeightedNormal', 'getCurvature'];\n\treturn Base.each(methods,\n\tfunction(name) {\n\t\tthis[name + 'At'] = function(offset, isParameter) {\n\t\t\tvar values = this.getValues();\n\t\t\treturn Curve[name](values, isParameter ? offset\n\t\t\t\t\t: Curve.getParameterAt(values, offset, 0));\n\t\t};\n\t}, {\n\t\tstatics: {\n\t\t\tevaluateMethods: methods\n\t\t}\n\t})\n},\nnew function() {\n\n\tfunction getLengthIntegrand(v) {\n\t\tvar p1x = v[0], p1y = v[1],\n\t\t\tc1x = v[2], c1y = v[3],\n\t\t\tc2x = v[4], c2y = v[5],\n\t\t\tp2x = v[6], p2y = v[7],\n\n\t\t\tax = 9 * (c1x - c2x) + 3 * (p2x - p1x),\n\t\t\tbx = 6 * (p1x + c2x) - 12 * c1x,\n\t\t\tcx = 3 * (c1x - p1x),\n\n\t\t\tay = 9 * (c1y - c2y) + 3 * (p2y - p1y),\n\t\t\tby = 6 * (p1y + c2y) - 12 * c1y,\n\t\t\tcy = 3 * (c1y - p1y);\n\n\t\treturn function(t) {\n\t\t\tvar dx = (ax * t + bx) * t + cx,\n\t\t\t\tdy = (ay * t + by) * t + cy;\n\t\t\treturn Math.sqrt(dx * dx + dy * dy);\n\t\t};\n\t}\n\n\tfunction getIterations(a, b) {\n\t\treturn Math.max(2, Math.min(16, Math.ceil(Math.abs(b - a) * 32)));\n\t}\n\n\tfunction evaluate(v, t, type, normalized) {\n\t\tif (t == null || t < 0 || t > 1)\n\t\t\treturn null;\n\t\tvar p1x = v[0], p1y = v[1],\n\t\t\tc1x = v[2], c1y = v[3],\n\t\t\tc2x = v[4], c2y = v[5],\n\t\t\tp2x = v[6], p2y = v[7],\n\t\t\ttMin = 4e-7,\n\t\t\ttMax = 1 - tMin,\n\t\t\tx, y;\n\n\t\tif (type === 0 && (t < tMin || t > tMax)) {\n\t\t\tvar isZero = t < tMin;\n\t\t\tx = isZero ? p1x : p2x;\n\t\t\ty = isZero ? p1y : p2y;\n\t\t} else {\n\t\t\tvar cx = 3 * (c1x - p1x),\n\t\t\t\tbx = 3 * (c2x - c1x) - cx,\n\t\t\t\tax = p2x - p1x - cx - bx,\n\n\t\t\t\tcy = 3 * (c1y - p1y),\n\t\t\t\tby = 3 * (c2y - c1y) - cy,\n\t\t\t\tay = p2y - p1y - cy - by;\n\t\t\tif (type === 0) {\n\t\t\t\tx = ((ax * t + bx) * t + cx) * t + p1x;\n\t\t\t\ty = ((ay * t + by) * t + cy) * t + p1y;\n\t\t\t} else {\n\t\t\t\tif (t < tMin) {\n\t\t\t\t\tx = cx;\n\t\t\t\t\ty = cy;\n\t\t\t\t} else if (t > tMax) {\n\t\t\t\t\tx = 3 * (p2x - c2x);\n\t\t\t\t\ty = 3 * (p2y - c2y);\n\t\t\t\t} else {\n\t\t\t\t\tx = (3 * ax * t + 2 * bx) * t + cx;\n\t\t\t\t\ty = (3 * ay * t + 2 * by) * t + cy;\n\t\t\t\t}\n\t\t\t\tif (normalized) {\n\t\t\t\t\tif (x === 0 && y === 0 && (t < tMin || t > tMax)) {\n\t\t\t\t\t\tx = c2x - c1x;\n\t\t\t\t\t\ty = c2y - c1y;\n\t\t\t\t\t}\n\t\t\t\t\tvar len = Math.sqrt(x * x + y * y);\n\t\t\t\t\tif (len) {\n\t\t\t\t\t\tx /= len;\n\t\t\t\t\t\ty /= len;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (type === 3) {\n\t\t\t\t\tvar x2 = 6 * ax * t + 2 * bx,\n\t\t\t\t\t\ty2 = 6 * ay * t + 2 * by,\n\t\t\t\t\t\td = Math.pow(x * x + y * y, 3 / 2);\n\t\t\t\t\tx = d !== 0 ? (x * y2 - y * x2) / d : 0;\n\t\t\t\t\ty = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn type === 2 ? new Point(y, -x) : new Point(x, y);\n\t}\n\n\treturn { statics: {\n\n\t\tgetLength: function(v, a, b) {\n\t\t\tif (a === undefined)\n\t\t\t\ta = 0;\n\t\t\tif (b === undefined)\n\t\t\t\tb = 1;\n\t\t\tif (a === 0 && b === 1 && Curve.isStraight(v)) {\n\t\t\t\tvar dx = v[6] - v[0],\n\t\t\t\t\tdy = v[7] - v[1];\n\t\t\t\treturn Math.sqrt(dx * dx + dy * dy);\n\t\t\t}\n\t\t\tvar ds = getLengthIntegrand(v);\n\t\t\treturn Numerical.integrate(ds, a, b, getIterations(a, b));\n\t\t},\n\n\t\tgetParameterAt: function(v, offset, start) {\n\t\t\tif (start === undefined)\n\t\t\t\tstart = offset < 0 ? 1 : 0\n\t\t\tif (offset === 0)\n\t\t\t\treturn start;\n\t\t\tvar abs = Math.abs,\n\t\t\t\tforward = offset > 0,\n\t\t\t\ta = forward ? start : 0,\n\t\t\t\tb = forward ? 1 : start,\n\t\t\t\tds = getLengthIntegrand(v),\n\t\t\t\trangeLength = Numerical.integrate(ds, a, b,\n\t\t\t\t\t\tgetIterations(a, b));\n\t\t\tif (abs(offset - rangeLength) < 1e-12) {\n\t\t\t\treturn forward ? b : a;\n\t\t\t} else if (abs(offset) > rangeLength) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tvar guess = offset / rangeLength,\n\t\t\t\tlength = 0;\n\t\t\tfunction f(t) {\n\t\t\t\tlength += Numerical.integrate(ds, start, t,\n\t\t\t\t\t\tgetIterations(start, t));\n\t\t\t\tstart = t;\n\t\t\t\treturn length - offset;\n\t\t\t}\n\t\t\treturn Numerical.findRoot(f, ds, start + guess, a, b, 32,\n\t\t\t\t\t1e-12);\n\t\t},\n\n\t\tgetPoint: function(v, t) {\n\t\t\treturn evaluate(v, t, 0, false);\n\t\t},\n\n\t\tgetTangent: function(v, t) {\n\t\t\treturn evaluate(v, t, 1, true);\n\t\t},\n\n\t\tgetWeightedTangent: function(v, t) {\n\t\t\treturn evaluate(v, t, 1, false);\n\t\t},\n\n\t\tgetNormal: function(v, t) {\n\t\t\treturn evaluate(v, t, 2, true);\n\t\t},\n\n\t\tgetWeightedNormal: function(v, t) {\n\t\t\treturn evaluate(v, t, 2, false);\n\t\t},\n\n\t\tgetCurvature: function(v, t) {\n\t\t\treturn evaluate(v, t, 3, false).x;\n\t\t}\n\t}};\n},\nnew function() {\n\n\tfunction addLocation(locations, param, v1, c1, t1, p1, v2, c2, t2, p2,\n\t\t\toverlap) {\n\t\tvar startConnected = param.startConnected,\n\t\t\tendConnected = param.endConnected,\n\t\t\ttMin = 4e-7,\n\t\t\ttMax = 1 - tMin;\n\t\tif (t1 == null)\n\t\t\tt1 = Curve.getParameterOf(v1, p1);\n\t\tif (t1 !== null && t1 >= (startConnected ? tMin : 0) &&\n\t\t\tt1 <= (endConnected ? tMax : 1)) {\n\t\t\tif (t2 == null)\n\t\t\t\tt2 = Curve.getParameterOf(v2, p2);\n\t\t\tif (t2 !== null && t2 >= (endConnected ? tMin : 0) &&\n\t\t\t\tt2 <= (startConnected ? tMax : 1)) {\n\t\t\t\tvar renormalize = param.renormalize;\n\t\t\t\tif (renormalize) {\n\t\t\t\t\tvar res = renormalize(t1, t2);\n\t\t\t\t\tt1 = res[0];\n\t\t\t\t\tt2 = res[1];\n\t\t\t\t}\n\t\t\t\tvar loc1 = new CurveLocation(c1, t1,\n\t\t\t\t\t\tp1 || Curve.getPoint(v1, t1), overlap),\n\t\t\t\t\tloc2 = new CurveLocation(c2, t2,\n\t\t\t\t\t\tp2 || Curve.getPoint(v2, t2), overlap),\n\t\t\t\t\tflip = loc1.getPath() === loc2.getPath()\n\t\t\t\t\t\t&& loc1.getIndex() > loc2.getIndex(),\n\t\t\t\t\tloc = flip ? loc2 : loc1,\n\t\t\t\t\tinclude = param.include;\n\t\t\t\tloc1._intersection = loc2;\n\t\t\t\tloc2._intersection = loc1;\n\t\t\t\tif (!include || include(loc)) {\n\t\t\t\t\tCurveLocation.insert(locations, loc, true);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction addCurveIntersections(v1, v2, c1, c2, locations, param,\n\t\t\ttMin, tMax, uMin, uMax, oldTDiff, reverse, recursion) {\n\t\tif (++recursion >= 24)\n\t\t\treturn;\n\t\tvar q0x = v2[0], q0y = v2[1], q3x = v2[6], q3y = v2[7],\n\t\t\tgetSignedDistance = Line.getSignedDistance,\n\t\t\td1 = getSignedDistance(q0x, q0y, q3x, q3y, v2[2], v2[3]),\n\t\t\td2 = getSignedDistance(q0x, q0y, q3x, q3y, v2[4], v2[5]),\n\t\t\tfactor = d1 * d2 > 0 ? 3 / 4 : 4 / 9,\n\t\t\tdMin = factor * Math.min(0, d1, d2),\n\t\t\tdMax = factor * Math.max(0, d1, d2),\n\t\t\tdp0 = getSignedDistance(q0x, q0y, q3x, q3y, v1[0], v1[1]),\n\t\t\tdp1 = getSignedDistance(q0x, q0y, q3x, q3y, v1[2], v1[3]),\n\t\t\tdp2 = getSignedDistance(q0x, q0y, q3x, q3y, v1[4], v1[5]),\n\t\t\tdp3 = getSignedDistance(q0x, q0y, q3x, q3y, v1[6], v1[7]),\n\t\t\thull = getConvexHull(dp0, dp1, dp2, dp3),\n\t\t\ttop = hull[0],\n\t\t\tbottom = hull[1],\n\t\t\ttMinClip,\n\t\t\ttMaxClip;\n\t\tif ((tMinClip = clipConvexHull(top, bottom, dMin, dMax)) == null ||\n\t\t\t(tMaxClip = clipConvexHull(top.reverse(), bottom.reverse(),\n\t\t\t\tdMin, dMax)) == null)\n\t\t\treturn;\n\t\tv1 = Curve.getPart(v1, tMinClip, tMaxClip);\n\t\tvar tDiff = tMaxClip - tMinClip,\n\t\t\ttMinNew = tMin + (tMax - tMin) * tMinClip,\n\t\t\ttMaxNew = tMin + (tMax - tMin) * tMaxClip;\n\t\tif (oldTDiff > 0.5 && tDiff > 0.5) {\n\t\t\tif (tMaxNew - tMinNew > uMax - uMin) {\n\t\t\t\tvar parts = Curve.subdivide(v1, 0.5),\n\t\t\t\t\tt = tMinNew + (tMaxNew - tMinNew) / 2;\n\t\t\t\taddCurveIntersections(\n\t\t\t\t\tv2, parts[0], c2, c1, locations, param,\n\t\t\t\t\tuMin, uMax, tMinNew, t, tDiff, !reverse, recursion);\n\t\t\t\taddCurveIntersections(\n\t\t\t\t\tv2, parts[1], c2, c1, locations, param,\n\t\t\t\t\tuMin, uMax, t, tMaxNew, tDiff, !reverse, recursion);\n\t\t\t} else {\n\t\t\t\tvar parts = Curve.subdivide(v2, 0.5),\n\t\t\t\t\tt = uMin + (uMax - uMin) / 2;\n\t\t\t\taddCurveIntersections(\n\t\t\t\t\tparts[0], v1, c2, c1, locations, param,\n\t\t\t\t\tuMin, t, tMinNew, tMaxNew, tDiff, !reverse, recursion);\n\t\t\t\taddCurveIntersections(\n\t\t\t\t\tparts[1], v1, c2, c1, locations, param,\n\t\t\t\t\tt, uMax, tMinNew, tMaxNew, tDiff, !reverse, recursion);\n\t\t\t}\n\t\t} else if (Math.max(uMax - uMin, tMaxNew - tMinNew)\n\t\t\t\t< 1e-7) {\n\t\t\tvar t1 = tMinNew + (tMaxNew - tMinNew) / 2,\n\t\t\t\tt2 = uMin + (uMax - uMin) / 2;\n\t\t\tv1 = c1.getValues();\n\t\t\tv2 = c2.getValues();\n\t\t\taddLocation(locations, param,\n\t\t\t\treverse ? v2 : v1, reverse ? c2 : c1, reverse ? t2 : t1, null,\n\t\t\t\treverse ? v1 : v2, reverse ? c1 : c2, reverse ? t1 : t2, null);\n\t\t} else if (tDiff > 1e-12) {\n\t\t\taddCurveIntersections(v2, v1, c2, c1, locations, param,\n\t\t\t\t\tuMin, uMax, tMinNew, tMaxNew, tDiff, !reverse, recursion);\n\t\t}\n\t}\n\n\tfunction getConvexHull(dq0, dq1, dq2, dq3) {\n\t\tvar p0 = [ 0, dq0 ],\n\t\t\tp1 = [ 1 / 3, dq1 ],\n\t\t\tp2 = [ 2 / 3, dq2 ],\n\t\t\tp3 = [ 1, dq3 ],\n\t\t\tdist1 = dq1 - (2 * dq0 + dq3) / 3,\n\t\t\tdist2 = dq2 - (dq0 + 2 * dq3) / 3,\n\t\t\thull;\n\t\tif (dist1 * dist2 < 0) {\n\t\t\thull = [[p0, p1, p3], [p0, p2, p3]];\n\t\t} else {\n\t\t\tvar distRatio = dist1 / dist2;\n\t\t\thull = [\n\t\t\t\tdistRatio >= 2 ? [p0, p1, p3]\n\t\t\t\t: distRatio <= .5 ? [p0, p2, p3]\n\t\t\t\t: [p0, p1, p2, p3],\n\t\t\t\t[p0, p3]\n\t\t\t];\n\t\t}\n\t\treturn (dist1 || dist2) < 0 ? hull.reverse() : hull;\n\t}\n\n\tfunction clipConvexHull(hullTop, hullBottom, dMin, dMax) {\n\t\tif (hullTop[0][1] < dMin) {\n\t\t\treturn clipConvexHullPart(hullTop, true, dMin);\n\t\t} else if (hullBottom[0][1] > dMax) {\n\t\t\treturn clipConvexHullPart(hullBottom, false, dMax);\n\t\t} else {\n\t\t\treturn hullTop[0][0];\n\t\t}\n\t}\n\n\tfunction clipConvexHullPart(part, top, threshold) {\n\t\tvar px = part[0][0],\n\t\t\tpy = part[0][1];\n\t\tfor (var i = 1, l = part.length; i < l; i++) {\n\t\t\tvar qx = part[i][0],\n\t\t\t\tqy = part[i][1];\n\t\t\tif (top ? qy >= threshold : qy <= threshold) {\n\t\t\t\treturn qy === threshold ? qx\n\t\t\t\t\t\t: px + (threshold - py) * (qx - px) / (qy - py);\n\t\t\t}\n\t\t\tpx = qx;\n\t\t\tpy = qy;\n\t\t}\n\t\treturn null;\n\t}\n\n\tfunction addCurveLineIntersections(v1, v2, c1, c2, locations, param) {\n\t\tvar flip = Curve.isStraight(v1),\n\t\t\tvc = flip ? v2 : v1,\n\t\t\tvl = flip ? v1 : v2,\n\t\t\tlx1 = vl[0], ly1 = vl[1],\n\t\t\tlx2 = vl[6], ly2 = vl[7],\n\t\t\tldx = lx2 - lx1,\n\t\t\tldy = ly2 - ly1,\n\t\t\tangle = Math.atan2(-ldy, ldx),\n\t\t\tsin = Math.sin(angle),\n\t\t\tcos = Math.cos(angle),\n\t\t\trvc = [];\n\t\tfor(var i = 0; i < 8; i += 2) {\n\t\t\tvar x = vc[i] - lx1,\n\t\t\t\ty = vc[i + 1] - ly1;\n\t\t\trvc.push(\n\t\t\t\tx * cos - y * sin,\n\t\t\t\tx * sin + y * cos);\n\t\t}\n\t\tvar roots = [],\n\t\t\tcount = Curve.solveCubic(rvc, 1, 0, roots, 0, 1);\n\t\tfor (var i = 0; i < count; i++) {\n\t\t\tvar tc = roots[i],\n\t\t\t\tpc = Curve.getPoint(vc, tc),\n\t\t\t\ttl = Curve.getParameterOf(vl, pc);\n\t\t\tif (tl !== null) {\n\t\t\t\tvar pl = Curve.getPoint(vl, tl),\n\t\t\t\t\tt1 = flip ? tl : tc,\n\t\t\t\t\tt2 = flip ? tc : tl;\n\t\t\t\tif (!param.endConnected || t2 > Numerical.CURVETIME_EPSILON) {\n\t\t\t\t\taddLocation(locations, param,\n\t\t\t\t\t\t\tv1, c1, t1, flip ? pl : pc,\n\t\t\t\t\t\t\tv2, c2, t2, flip ? pc : pl);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction addLineIntersection(v1, v2, c1, c2, locations, param) {\n\t\tvar pt = Line.intersect(\n\t\t\t\tv1[0], v1[1], v1[6], v1[7],\n\t\t\t\tv2[0], v2[1], v2[6], v2[7]);\n\t\tif (pt) {\n\t\t\taddLocation(locations, param, v1, c1, null, pt, v2, c2, null, pt);\n\t\t}\n\t}\n\n\treturn { statics: {\n\t\t_getIntersections: function(v1, v2, c1, c2, locations, param) {\n\t\t\tif (!v2) {\n\t\t\t\treturn Curve._getSelfIntersection(v1, c1, locations, param);\n\t\t\t}\n\t\t\tvar c1p1x = v1[0], c1p1y = v1[1],\n\t\t\t\tc1p2x = v1[6], c1p2y = v1[7],\n\t\t\t\tc2p1x = v2[0], c2p1y = v2[1],\n\t\t\t\tc2p2x = v2[6], c2p2y = v2[7],\n\t\t\t\tc1s1x = (3 * v1[2] + c1p1x) / 4,\n\t\t\t\tc1s1y = (3 * v1[3] + c1p1y) / 4,\n\t\t\t\tc1s2x = (3 * v1[4] + c1p2x) / 4,\n\t\t\t\tc1s2y = (3 * v1[5] + c1p2y) / 4,\n\t\t\t\tc2s1x = (3 * v2[2] + c2p1x) / 4,\n\t\t\t\tc2s1y = (3 * v2[3] + c2p1y) / 4,\n\t\t\t\tc2s2x = (3 * v2[4] + c2p2x) / 4,\n\t\t\t\tc2s2y = (3 * v2[5] + c2p2y) / 4,\n\t\t\t\tmin = Math.min,\n\t\t\t\tmax = Math.max;\n\t\t\tif (!(\tmax(c1p1x, c1s1x, c1s2x, c1p2x) >=\n\t\t\t\t\tmin(c2p1x, c2s1x, c2s2x, c2p2x) &&\n\t\t\t\t\tmin(c1p1x, c1s1x, c1s2x, c1p2x) <=\n\t\t\t\t\tmax(c2p1x, c2s1x, c2s2x, c2p2x) &&\n\t\t\t\t\tmax(c1p1y, c1s1y, c1s2y, c1p2y) >=\n\t\t\t\t\tmin(c2p1y, c2s1y, c2s2y, c2p2y) &&\n\t\t\t\t\tmin(c1p1y, c1s1y, c1s2y, c1p2y) <=\n\t\t\t\t\tmax(c2p1y, c2s1y, c2s2y, c2p2y)))\n\t\t\t\treturn locations;\n\t\t\tif (!param.startConnected && !param.endConnected) {\n\t\t\t\tvar overlaps = Curve.getOverlaps(v1, v2);\n\t\t\t\tif (overlaps) {\n\t\t\t\t\tfor (var i = 0; i < 2; i++) {\n\t\t\t\t\t\tvar overlap = overlaps[i];\n\t\t\t\t\t\taddLocation(locations, param,\n\t\t\t\t\t\t\tv1, c1, overlap[0], null,\n\t\t\t\t\t\t\tv2, c2, overlap[1], null, true);\n\t\t\t\t\t}\n\t\t\t\t\treturn locations;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tvar straight1 = Curve.isStraight(v1),\n\t\t\t\tstraight2 = Curve.isStraight(v2),\n\t\t\t\tstraight = straight1 && straight2,\n\t\t\t\tepsilon = 1e-12,\n\t\t\t\tbefore = locations.length;\n\t\t\t(straight\n\t\t\t\t? addLineIntersection\n\t\t\t\t: straight1 || straight2\n\t\t\t\t\t? addCurveLineIntersections\n\t\t\t\t\t: addCurveIntersections)(\n\t\t\t\t\t\tv1, v2, c1, c2, locations, param,\n\t\t\t\t\t\t0, 1, 0, 1, 0, false, 0);\n\t\t\tif (straight && locations.length > before)\n\t\t\t\treturn locations;\n\t\t\tvar c1p1 = new Point(c1p1x, c1p1y),\n\t\t\t\tc1p2 = new Point(c1p2x, c1p2y),\n\t\t\t\tc2p1 = new Point(c2p1x, c2p1y),\n\t\t\t\tc2p2 = new Point(c2p2x, c2p2y);\n\t\t\tif (c1p1.isClose(c2p1, epsilon))\n\t\t\t\taddLocation(locations, param, v1, c1, 0, c1p1, v2, c2, 0, c2p1);\n\t\t\tif (!param.startConnected && c1p1.isClose(c2p2, epsilon))\n\t\t\t\taddLocation(locations, param, v1, c1, 0, c1p1, v2, c2, 1, c2p2);\n\t\t\tif (!param.endConnected && c1p2.isClose(c2p1, epsilon))\n\t\t\t\taddLocation(locations, param, v1, c1, 1, c1p2, v2, c2, 0, c2p1);\n\t\t\tif (c1p2.isClose(c2p2, epsilon))\n\t\t\t\taddLocation(locations, param, v1, c1, 1, c1p2, v2, c2, 1, c2p2);\n\t\t\treturn locations;\n\t\t},\n\n\t\t_getSelfIntersection: function(v1, c1, locations, param) {\n\t\t\tvar p1x = v1[0], p1y = v1[1],\n\t\t\t\th1x = v1[2], h1y = v1[3],\n\t\t\t\th2x = v1[4], h2y = v1[5],\n\t\t\t\tp2x = v1[6], p2y = v1[7];\n\t\t\tvar line = new Line(p1x, p1y, p2x, p2y, false),\n\t\t\t\tside1 = line.getSide(new Point(h1x, h1y), true),\n\t\t\t\tside2 = line.getSide(new Point(h2x, h2y), true);\n\t\t\tif (side1 === side2) {\n\t\t\t\tvar edgeSum = (p1x - h2x) * (h1y - p2y)\n\t\t\t\t\t\t\t+ (h1x - p2x) * (h2y - p1y);\n\t\t\t\tif (edgeSum * side1 > 0)\n\t\t\t\t\treturn locations;\n\t\t\t}\n\t\t\tvar ax = p2x - 3 * h2x + 3 * h1x - p1x,\n\t\t\t\tbx = h2x - 2 * h1x + p1x,\n\t\t\t\tcx = h1x - p1x,\n\t\t\t\tay = p2y - 3 * h2y + 3 * h1y - p1y,\n\t\t\t\tby = h2y - 2 * h1y + p1y,\n\t\t\t\tcy = h1y - p1y,\n\t\t\t\tac = ay * cx - ax * cy,\n\t\t\t\tab = ay * bx - ax * by,\n\t\t\t\tbc = by * cx - bx * cy;\n\t\t\tif (ac * ac - 4 * ab * bc < 0) {\n\t\t\t\tvar roots = [],\n\t\t\t\t\ttSplit,\n\t\t\t\t\tcount = Numerical.solveCubic(\n\t\t\t\t\t\t\tax * ax\t + ay * ay,\n\t\t\t\t\t\t\t3 * (ax * bx + ay * by),\n\t\t\t\t\t\t\t2 * (bx * bx + by * by) + ax * cx + ay * cy,\n\t\t\t\t\t\t\tbx * cx + by * cy,\n\t\t\t\t\t\t\troots, 0, 1);\n\t\t\t\tif (count > 0) {\n\t\t\t\t\tfor (var i = 0, maxCurvature = 0; i < count; i++) {\n\t\t\t\t\t\tvar curvature = Math.abs(\n\t\t\t\t\t\t\t\tc1.getCurvatureAt(roots[i], true));\n\t\t\t\t\t\tif (curvature > maxCurvature) {\n\t\t\t\t\t\t\tmaxCurvature = curvature;\n\t\t\t\t\t\t\ttSplit = roots[i];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tvar parts = Curve.subdivide(v1, tSplit);\n\t\t\t\t\tparam.endConnected = true;\n\t\t\t\t\tparam.renormalize = function(t1, t2) {\n\t\t\t\t\t\treturn [t1 * tSplit, t2 * (1 - tSplit) + tSplit];\n\t\t\t\t\t};\n\t\t\t\t\tCurve._getIntersections(parts[0], parts[1], c1, c1,\n\t\t\t\t\t\t\tlocations, param);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn locations;\n\t\t},\n\n\t\tgetOverlaps: function(v1, v2) {\n\t\t\tvar abs = Math.abs,\n\t\t\t\ttimeEpsilon = 4e-7,\n\t\t\t\tgeomEpsilon = 2e-7,\n\t\t\t\tstraight1 = Curve.isStraight(v1),\n\t\t\t\tstraight2 = Curve.isStraight(v2),\n\t\t\t\tstraight =\tstraight1 && straight2;\n\n\t\t\tfunction getLineLengthSquared(v) {\n\t\t\t\tvar x = v[6] - v[0],\n\t\t\t\t\ty = v[7] - v[1];\n\t\t\t\treturn x * x + y * y;\n\t\t\t}\n\n\t\t\tif (straight) {\n\t\t\t\tvar flip = getLineLengthSquared(v1) < getLineLengthSquared(v2),\n\t\t\t\t\tl1 = flip ? v2 : v1,\n\t\t\t\t\tl2 = flip ? v1 : v2,\n\t\t\t\t\tline = new Line(l1[0], l1[1], l1[6], l1[7]);\n\t\t\t\tif (line.getDistance(new Point(l2[0], l2[1])) > geomEpsilon ||\n\t\t\t\t\tline.getDistance(new Point(l2[6], l2[7])) > geomEpsilon)\n\t\t\t\t\treturn null;\n\t\t\t} else if (straight1 ^ straight2) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tvar v = [v1, v2],\n\t\t\t\tpairs = [];\n\t\t\tfor (var i = 0, t1 = 0;\n\t\t\t\t\ti < 2 && pairs.length < 2;\n\t\t\t\t\ti += t1 === 0 ? 0 : 1, t1 = t1 ^ 1) {\n\t\t\t\tvar t2 = Curve.getParameterOf(v[i ^ 1], new Point(\n\t\t\t\t\t\tv[i][t1 === 0 ? 0 : 6],\n\t\t\t\t\t\tv[i][t1 === 0 ? 1 : 7]));\n\t\t\t\tif (t2 != null) {\n\t\t\t\t\tvar pair = i === 0 ? [t1, t2] : [t2, t1];\n\t\t\t\t\tif (pairs.length === 0 ||\n\t\t\t\t\t\tabs(pair[0] - pairs[0][0]) > timeEpsilon &&\n\t\t\t\t\t\tabs(pair[1] - pairs[0][1]) > timeEpsilon)\n\t\t\t\t\t\tpairs.push(pair);\n\t\t\t\t}\n\t\t\t\tif (i === 1 && pairs.length === 0)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (pairs.length !== 2) {\n\t\t\t\tpairs = null;\n\t\t\t} else if (!straight) {\n\t\t\t\tvar o1 = Curve.getPart(v1, pairs[0][0], pairs[1][0]),\n\t\t\t\t\to2 = Curve.getPart(v2, pairs[0][1], pairs[1][1]);\n\t\t\t\tif (abs(o2[2] - o1[2]) > geomEpsilon ||\n\t\t\t\t\tabs(o2[3] - o1[3]) > geomEpsilon ||\n\t\t\t\t\tabs(o2[4] - o1[4]) > geomEpsilon ||\n\t\t\t\t\tabs(o2[5] - o1[5]) > geomEpsilon)\n\t\t\t\t\tpairs = null;\n\t\t\t}\n\t\t\treturn pairs;\n\t\t}\n\t}};\n});\n\nvar CurveLocation = Base.extend({\n\t_class: 'CurveLocation',\n\tbeans: true,\n\n\tinitialize: function CurveLocation(curve, parameter, point,\n\t\t\t_overlap, _distance) {\n\t\tif (parameter > 0.9999996) {\n\t\t\tvar next = curve.getNext();\n\t\t\tif (next) {\n\t\t\t\tparameter = 0;\n\t\t\t\tcurve = next;\n\t\t\t}\n\t\t}\n\t\tthis._id = UID.get(CurveLocation);\n\t\tthis._setCurve(curve);\n\t\tthis._parameter = parameter;\n\t\tthis._point = point || curve.getPointAt(parameter, true);\n\t\tthis._overlap = _overlap;\n\t\tthis._distance = _distance;\n\t\tthis._intersection = this._next = this._prev = null;\n\t},\n\n\t_setCurve: function(curve) {\n\t\tvar path = curve._path;\n\t\tthis._version = path ? path._version : 0;\n\t\tthis._curve = curve;\n\t\tthis._segment = null;\n\t\tthis._segment1 = curve._segment1;\n\t\tthis._segment2 = curve._segment2;\n\t},\n\n\t_setSegment: function(segment) {\n\t\tthis._setCurve(segment.getCurve());\n\t\tthis._segment = segment;\n\t\tthis._parameter = segment === this._segment1 ? 0 : 1;\n\t\tthis._point = segment._point.clone();\n\t},\n\n\tgetSegment: function() {\n\t\tvar curve = this.getCurve(),\n\t\t\tsegment = this._segment;\n\t\tif (!segment) {\n\t\t\tvar parameter = this.getParameter();\n\t\t\tif (parameter === 0) {\n\t\t\t\tsegment = curve._segment1;\n\t\t\t} else if (parameter === 1) {\n\t\t\t\tsegment = curve._segment2;\n\t\t\t} else if (parameter != null) {\n\t\t\t\tsegment = curve.getPartLength(0, parameter)\n\t\t\t\t\t< curve.getPartLength(parameter, 1)\n\t\t\t\t\t\t? curve._segment1\n\t\t\t\t\t\t: curve._segment2;\n\t\t\t}\n\t\t\tthis._segment = segment;\n\t\t}\n\t\treturn segment;\n\t},\n\n\tgetCurve: function() {\n\t\tvar curve = this._curve,\n\t\t\tpath = curve && curve._path,\n\t\t\tthat = this;\n\t\tif (path && path._version !== this._version) {\n\t\t\tcurve = this._parameter = this._curve = this._offset = null;\n\t\t}\n\n\t\tfunction trySegment(segment) {\n\t\t\tvar curve = segment && segment.getCurve();\n\t\t\tif (curve && (that._parameter = curve.getParameterOf(that._point))\n\t\t\t\t\t!= null) {\n\t\t\t\tthat._setCurve(curve);\n\t\t\t\tthat._segment = segment;\n\t\t\t\treturn curve;\n\t\t\t}\n\t\t}\n\n\t\treturn curve\n\t\t\t|| trySegment(this._segment)\n\t\t\t|| trySegment(this._segment1)\n\t\t\t|| trySegment(this._segment2.getPrevious());\n\t},\n\n\tgetPath: function() {\n\t\tvar curve = this.getCurve();\n\t\treturn curve && curve._path;\n\t},\n\n\tgetIndex: function() {\n\t\tvar curve = this.getCurve();\n\t\treturn curve && curve.getIndex();\n\t},\n\n\tgetParameter: function() {\n\t\tvar curve = this.getCurve(),\n\t\t\tparameter = this._parameter;\n\t\treturn curve && parameter == null\n\t\t\t? this._parameter = curve.getParameterOf(this._point)\n\t\t\t: parameter;\n\t},\n\n\tgetPoint: function() {\n\t\treturn this._point;\n\t},\n\n\tgetOffset: function() {\n\t\tvar offset = this._offset;\n\t\tif (offset == null) {\n\t\t\toffset = 0;\n\t\t\tvar path = this.getPath(),\n\t\t\t\tindex = this.getIndex();\n\t\t\tif (path && index != null) {\n\t\t\t\tvar curves = path.getCurves();\n\t\t\t\tfor (var i = 0; i < index; i++)\n\t\t\t\t\toffset += curves[i].getLength();\n\t\t\t}\n\t\t\tthis._offset = offset += this.getCurveOffset();\n\t\t}\n\t\treturn offset;\n\t},\n\n\tgetCurveOffset: function() {\n\t\tvar curve = this.getCurve(),\n\t\t\tparameter = this.getParameter();\n\t\treturn parameter != null && curve && curve.getPartLength(0, parameter);\n\t},\n\n\tgetIntersection: function() {\n\t\treturn this._intersection;\n\t},\n\n\tgetDistance: function() {\n\t\treturn this._distance;\n\t},\n\n\tdivide: function() {\n\t\tvar curve = this.getCurve(),\n\t\t\tres = null;\n\t\tif (curve) {\n\t\t\tres = curve.divide(this.getParameter(), true);\n\t\t\tif (res)\n\t\t\t\tthis._setSegment(res._segment1);\n\t\t}\n\t\treturn res;\n\t},\n\n\tsplit: function() {\n\t\tvar curve = this.getCurve();\n\t\treturn curve ? curve.split(this.getParameter(), true) : null;\n\t},\n\n\tequals: function(loc, _ignoreOther) {\n\t\tvar res = this === loc,\n\t\t\tepsilon = 2e-7;\n\t\tif (!res && loc instanceof CurveLocation\n\t\t\t\t&& this.getPath() === loc.getPath()\n\t\t\t\t&& this.getPoint().isClose(loc.getPoint(), epsilon)) {\n\t\t\tvar c1 = this.getCurve(),\n\t\t\t\tc2 = loc.getCurve(),\n\t\t\t\tabs = Math.abs,\n\t\t\t\tdiff = abs(\n\t\t\t\t\t((c1.isLast() && c2.isFirst() ? -1 : c1.getIndex())\n\t\t\t\t\t\t\t+ this.getParameter()) -\n\t\t\t\t\t((c2.isLast() && c1.isFirst() ? -1 : c2.getIndex())\n\t\t\t\t\t\t\t+ loc.getParameter()));\n\t\t\tres = (diff < 4e-7\n\t\t\t\t|| ((diff = abs(this.getOffset() - loc.getOffset())) < epsilon\n\t\t\t\t\t|| abs(this.getPath().getLength() - diff) < epsilon))\n\t\t\t\t&& (_ignoreOther\n\t\t\t\t\t|| (!this._intersection && !loc._intersection\n\t\t\t\t\t\t|| this._intersection && this._intersection.equals(\n\t\t\t\t\t\t\t\tloc._intersection, true)));\n\t\t}\n\t\treturn res;\n\t},\n\n\ttoString: function() {\n\t\tvar parts = [],\n\t\t\tpoint = this.getPoint(),\n\t\t\tf = Formatter.instance;\n\t\tif (point)\n\t\t\tparts.push('point: ' + point);\n\t\tvar index = this.getIndex();\n\t\tif (index != null)\n\t\t\tparts.push('index: ' + index);\n\t\tvar parameter = this.getParameter();\n\t\tif (parameter != null)\n\t\t\tparts.push('parameter: ' + f.number(parameter));\n\t\tif (this._distance != null)\n\t\t\tparts.push('distance: ' + f.number(this._distance));\n\t\treturn '{ ' + parts.join(', ') + ' }';\n\t},\n\n\tisTouching: function() {\n\t\tvar inter = this._intersection;\n\t\tif (inter && this.getTangent().isCollinear(inter.getTangent())) {\n\t\t\tvar curve1 = this.getCurve(),\n\t\t\t\tcurve2 = inter.getCurve();\n\t\t\treturn !(curve1.isStraight() && curve2.isStraight()\n\t\t\t\t\t&& curve1.getLine().intersect(curve2.getLine()));\n\t\t}\n\t\treturn false;\n\t},\n\n\tisCrossing: function() {\n\t\tvar inter = this._intersection;\n\t\tif (!inter)\n\t\t\treturn false;\n\t\tvar t1 = this.getParameter(),\n\t\t\tt2 = inter.getParameter(),\n\t\t\ttMin = 4e-7,\n\t\t\ttMax = 1 - tMin;\n\t\tif (t1 >= tMin && t1 <= tMax || t2 >= tMin && t2 <= tMax)\n\t\t\treturn !this.isTouching();\n\t\tvar c2 = this.getCurve(),\n\t\t\tc1 = c2.getPrevious(),\n\t\t\tc4 = inter.getCurve(),\n\t\t\tc3 = c4.getPrevious(),\n\t\t\tPI = Math.PI;\n\t\tif (!c1 || !c3)\n\t\t\treturn false;\n\n\t\tfunction isInRange(angle, min, max) {\n\t\t\treturn min < max\n\t\t\t\t? angle > min && angle < max\n\t\t\t\t: angle > min && angle <= PI || angle >= -PI && angle < max;\n\t\t}\n\n\t\tvar a1 = c1.getTangentAt(tMax, true).negate().getAngleInRadians(),\n\t\t\ta2 = c2.getTangentAt(tMin, true).getAngleInRadians(),\n\t\t\ta3 = c3.getTangentAt(tMax, true).negate().getAngleInRadians(),\n\t\t\ta4 = c4.getTangentAt(tMin, true).getAngleInRadians();\n\n\t\treturn (isInRange(a3, a1, a2) ^ isInRange(a4, a1, a2))\n\t\t\t&& (isInRange(a3, a2, a1) ^ isInRange(a4, a2, a1));\n\t},\n\n\tisOverlap: function() {\n\t\treturn !!this._overlap;\n\t}\n}, Base.each(Curve.evaluateMethods, function(name) {\n\tvar get = name + 'At';\n\tthis[name] = function() {\n\t\tvar parameter = this.getParameter(),\n\t\t\tcurve = this.getCurve();\n\t\treturn parameter != null && curve && curve[get](parameter, true);\n\t};\n}, {\n\tpreserve: true\n}),\nnew function() {\n\n\tfunction insert(locations, loc, merge) {\n\t\tvar length = locations.length,\n\t\t\tl = 0,\n\t\t\tr = length - 1;\n\n\t\tfunction search(index, dir) {\n\t\t\tfor (var i = index + dir; i >= -1 && i <= length; i += dir) {\n\t\t\t\tvar loc2 = locations[((i % length) + length) % length];\n\t\t\t\tif (!loc.getPoint().isClose(loc2.getPoint(),\n\t\t\t\t\t\t2e-7))\n\t\t\t\t\tbreak;\n\t\t\t\tif (loc.equals(loc2))\n\t\t\t\t\treturn loc2;\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\n\t\twhile (l <= r) {\n\t\t\tvar m = (l + r) >>> 1,\n\t\t\t\tloc2 = locations[m],\n\t\t\t\tfound;\n\t\t\tif (merge && (found = loc.equals(loc2) ? loc2\n\t\t\t\t\t: (search(m, -1) || search(m, 1)))) {\n\t\t\t\tif (loc._overlap) {\n\t\t\t\t\tfound._overlap = found._intersection._overlap = true;\n\t\t\t\t}\n\t\t\t\treturn found;\n\t\t\t}\n\t\tvar path1 = loc.getPath(),\n\t\t\tpath2 = loc2.getPath(),\n\t\t\tdiff = path1 === path2\n\t\t\t\t? (loc.getIndex() + loc.getParameter())\n\t\t\t\t- (loc2.getIndex() + loc2.getParameter())\n\t\t\t\t: path1._id - path2._id;\n\t\t\tif (diff < 0) {\n\t\t\t\tr = m - 1;\n\t\t\t} else {\n\t\t\t\tl = m + 1;\n\t\t\t}\n\t\t}\n\t\tlocations.splice(l, 0, loc);\n\t\treturn loc;\n\t}\n\n\treturn { statics: {\n\t\tinsert: insert,\n\n\t\texpand: function(locations) {\n\t\t\tvar expanded = locations.slice();\n\t\t\tfor (var i = 0, l = locations.length; i < l; i++) {\n\t\t\t\tinsert(expanded, locations[i]._intersection, false);\n\t\t\t}\n\t\t\treturn expanded;\n\t\t}\n\t}};\n});\n\nvar PathItem = Item.extend({\n\t_class: 'PathItem',\n\n\tinitialize: function PathItem() {\n\t},\n\n\tgetIntersections: function(path, include, _matrix, _returnFirst) {\n\t\tvar self = this === path || !path,\n\t\t\tmatrix1 = this._matrix.orNullIfIdentity(),\n\t\t\tmatrix2 = self ? matrix1\n\t\t\t\t: (_matrix || path._matrix).orNullIfIdentity();\n\t\tif (!self && !this.getBounds(matrix1).touches(path.getBounds(matrix2)))\n\t\t\treturn [];\n\t\tvar curves1 = this.getCurves(),\n\t\t\tcurves2 = self ? curves1 : path.getCurves(),\n\t\t\tlength1 = curves1.length,\n\t\t\tlength2 = self ? length1 : curves2.length,\n\t\t\tvalues2 = [],\n\t\t\tarrays = [],\n\t\t\tlocations,\n\t\t\tpath;\n\t\tfor (var i = 0; i < length2; i++)\n\t\t\tvalues2[i] = curves2[i].getValues(matrix2);\n\t\tfor (var i = 0; i < length1; i++) {\n\t\t\tvar curve1 = curves1[i],\n\t\t\t\tvalues1 = self ? values2[i] : curve1.getValues(matrix1),\n\t\t\t\tpath1 = curve1.getPath();\n\t\t\tif (path1 !== path) {\n\t\t\t\tpath = path1;\n\t\t\t\tlocations = [];\n\t\t\t\tarrays.push(locations);\n\t\t\t}\n\t\t\tif (self) {\n\t\t\t\tCurve._getSelfIntersection(values1, curve1, locations, {\n\t\t\t\t\tinclude: include,\n\t\t\t\t\tstartConnected: length1 === 1 &&\n\t\t\t\t\t\t\tcurve1.getPoint1().equals(curve1.getPoint2())\n\t\t\t\t});\n\t\t\t}\n\t\t\tfor (var j = self ? i + 1 : 0; j < length2; j++) {\n\t\t\t\tif (_returnFirst && locations.length)\n\t\t\t\t\treturn locations;\n\t\t\t\tvar curve2 = curves2[j];\n\t\t\t\tCurve._getIntersections(\n\t\t\t\t\tvalues1, values2[j], curve1, curve2, locations,\n\t\t\t\t\t{\n\t\t\t\t\t\tinclude: include,\n\t\t\t\t\t\tstartConnected: self && curve1.getPrevious() === curve2,\n\t\t\t\t\t\tendConnected: self && curve1.getNext() === curve2\n\t\t\t\t\t}\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t\tlocations = [];\n\t\tfor (var i = 0, l = arrays.length; i < l; i++) {\n\t\t\tlocations.push.apply(locations, arrays[i]);\n\t\t}\n\t\treturn locations;\n\t},\n\n\tgetCrossings: function(path) {\n\t\treturn this.getIntersections(path, function(inter) {\n\t\t\treturn inter.isCrossing();\n\t\t});\n\t},\n\n\t_asPathItem: function() {\n\t\treturn this;\n\t},\n\n\tsetPathData: function(data) {\n\n\t\tvar parts = data.match(/[mlhvcsqtaz][^mlhvcsqtaz]*/ig),\n\t\t\tcoords,\n\t\t\trelative = false,\n\t\t\tprevious,\n\t\t\tcontrol,\n\t\t\tcurrent = new Point(),\n\t\t\tstart = new Point();\n\n\t\tfunction getCoord(index, coord) {\n\t\t\tvar val = +coords[index];\n\t\t\tif (relative)\n\t\t\t\tval += current[coord];\n\t\t\treturn val;\n\t\t}\n\n\t\tfunction getPoint(index) {\n\t\t\treturn new Point(\n\t\t\t\tgetCoord(index, 'x'),\n\t\t\t\tgetCoord(index + 1, 'y')\n\t\t\t);\n\t\t}\n\n\t\tthis.clear();\n\n\t\tfor (var i = 0, l = parts && parts.length; i < l; i++) {\n\t\t\tvar part = parts[i],\n\t\t\t\tcommand = part[0],\n\t\t\t\tlower = command.toLowerCase();\n\t\t\tcoords = part.match(/[+-]?(?:\\d*\\.\\d+|\\d+\\.?)(?:[eE][+-]?\\d+)?/g);\n\t\t\tvar length = coords && coords.length;\n\t\t\trelative = command === lower;\n\t\t\tif (previous === 'z' && !/[mz]/.test(lower))\n\t\t\t\tthis.moveTo(current = start);\n\t\t\tswitch (lower) {\n\t\t\tcase 'm':\n\t\t\tcase 'l':\n\t\t\t\tvar move = lower === 'm';\n\t\t\t\tfor (var j = 0; j < length; j += 2)\n\t\t\t\t\tthis[j === 0 && move ? 'moveTo' : 'lineTo'](\n\t\t\t\t\t\t\tcurrent = getPoint(j));\n\t\t\t\tcontrol = current;\n\t\t\t\tif (move)\n\t\t\t\t\tstart = current;\n\t\t\t\tbreak;\n\t\t\tcase 'h':\n\t\t\tcase 'v':\n\t\t\t\tvar coord = lower === 'h' ? 'x' : 'y';\n\t\t\t\tfor (var j = 0; j < length; j++) {\n\t\t\t\t\tcurrent[coord] = getCoord(j, coord);\n\t\t\t\t\tthis.lineTo(current);\n\t\t\t\t}\n\t\t\t\tcontrol = current;\n\t\t\t\tbreak;\n\t\t\tcase 'c':\n\t\t\t\tfor (var j = 0; j < length; j += 6) {\n\t\t\t\t\tthis.cubicCurveTo(\n\t\t\t\t\t\t\tgetPoint(j),\n\t\t\t\t\t\t\tcontrol = getPoint(j + 2),\n\t\t\t\t\t\t\tcurrent = getPoint(j + 4));\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 's':\n\t\t\t\tfor (var j = 0; j < length; j += 4) {\n\t\t\t\t\tthis.cubicCurveTo(\n\t\t\t\t\t\t\t/[cs]/.test(previous)\n\t\t\t\t\t\t\t\t\t? current.multiply(2).subtract(control)\n\t\t\t\t\t\t\t\t\t: current,\n\t\t\t\t\t\t\tcontrol = getPoint(j),\n\t\t\t\t\t\t\tcurrent = getPoint(j + 2));\n\t\t\t\t\tprevious = lower;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'q':\n\t\t\t\tfor (var j = 0; j < length; j += 4) {\n\t\t\t\t\tthis.quadraticCurveTo(\n\t\t\t\t\t\t\tcontrol = getPoint(j),\n\t\t\t\t\t\t\tcurrent = getPoint(j + 2));\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 't':\n\t\t\t\tfor (var j = 0; j < length; j += 2) {\n\t\t\t\t\tthis.quadraticCurveTo(\n\t\t\t\t\t\t\tcontrol = (/[qt]/.test(previous)\n\t\t\t\t\t\t\t\t\t? current.multiply(2).subtract(control)\n\t\t\t\t\t\t\t\t\t: current),\n\t\t\t\t\t\t\tcurrent = getPoint(j));\n\t\t\t\t\tprevious = lower;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'a':\n\t\t\t\tfor (var j = 0; j < length; j += 7) {\n\t\t\t\t\tthis.arcTo(current = getPoint(j + 5),\n\t\t\t\t\t\t\tnew Size(+coords[j], +coords[j + 1]),\n\t\t\t\t\t\t\t+coords[j + 2], +coords[j + 4], +coords[j + 3]);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'z':\n\t\t\t\tthis.closePath(true);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tprevious = lower;\n\t\t}\n\t},\n\n\t_canComposite: function() {\n\t\treturn !(this.hasFill() && this.hasStroke());\n\t},\n\n\t_contains: function(point) {\n\t\tvar winding = this._getWinding(point, false, true);\n\t\treturn !!(this.getWindingRule() === 'evenodd' ? winding & 1 : winding);\n\t}\n\n});\n\nvar Path = PathItem.extend({\n\t_class: 'Path',\n\t_serializeFields: {\n\t\tsegments: [],\n\t\tclosed: false\n\t},\n\n\tinitialize: function Path(arg) {\n\t\tthis._closed = false;\n\t\tthis._segments = [];\n\t\tthis._version = 0;\n\t\tvar segments = Array.isArray(arg)\n\t\t\t? typeof arg[0] === 'object'\n\t\t\t\t? arg\n\t\t\t\t: arguments\n\t\t\t: arg && (arg.size === undefined && (arg.x !== undefined\n\t\t\t\t\t|| arg.point !== undefined))\n\t\t\t\t? arguments\n\t\t\t\t: null;\n\t\tif (segments && segments.length > 0) {\n\t\t\tthis.setSegments(segments);\n\t\t} else {\n\t\t\tthis._curves = undefined;\n\t\t\tthis._selectedSegmentState = 0;\n\t\t\tif (!segments && typeof arg === 'string') {\n\t\t\t\tthis.setPathData(arg);\n\t\t\t\targ = null;\n\t\t\t}\n\t\t}\n\t\tthis._initialize(!segments && arg);\n\t},\n\n\t_equals: function(item) {\n\t\treturn this._closed === item._closed\n\t\t\t\t&& Base.equals(this._segments, item._segments);\n\t},\n\n\tclone: function(insert) {\n\t\tvar copy = new Path(Item.NO_INSERT);\n\t\tcopy.setSegments(this._segments);\n\t\tcopy._closed = this._closed;\n\t\tif (this._clockwise !== undefined)\n\t\t\tcopy._clockwise = this._clockwise;\n\t\treturn this._clone(copy, insert);\n\t},\n\n\t_changed: function _changed(flags) {\n\t\t_changed.base.call(this, flags);\n\t\tif (flags & 8) {\n\t\t\tvar parent = this._parent;\n\t\t\tif (parent)\n\t\t\t\tparent._currentPath = undefined;\n\t\t\tthis._length = this._area = this._clockwise = this._monoCurves =\n\t\t\t\t\tundefined;\n\t\t\tif (flags & 16) {\n\t\t\t\tthis._version++;\n\t\t\t} else if (this._curves) {\n\t\t\t   for (var i = 0, l = this._curves.length; i < l; i++)\n\t\t\t\t\tthis._curves[i]._changed();\n\t\t\t}\n\t\t} else if (flags & 32) {\n\t\t\tthis._bounds = undefined;\n\t\t}\n\t},\n\n\tgetStyle: function() {\n\t\tvar parent = this._parent;\n\t\treturn (parent instanceof CompoundPath ? parent : this)._style;\n\t},\n\n\tgetSegments: function() {\n\t\treturn this._segments;\n\t},\n\n\tsetSegments: function(segments) {\n\t\tvar fullySelected = this.isFullySelected();\n\t\tthis._segments.length = 0;\n\t\tthis._selectedSegmentState = 0;\n\t\tthis._curves = undefined;\n\t\tif (segments && segments.length > 0)\n\t\t\tthis._add(Segment.readAll(segments));\n\t\tif (fullySelected)\n\t\t\tthis.setFullySelected(true);\n\t},\n\n\tgetFirstSegment: function() {\n\t\treturn this._segments[0];\n\t},\n\n\tgetLastSegment: function() {\n\t\treturn this._segments[this._segments.length - 1];\n\t},\n\n\tgetCurves: function() {\n\t\tvar curves = this._curves,\n\t\t\tsegments = this._segments;\n\t\tif (!curves) {\n\t\t\tvar length = this._countCurves();\n\t\t\tcurves = this._curves = new Array(length);\n\t\t\tfor (var i = 0; i < length; i++)\n\t\t\t\tcurves[i] = new Curve(this, segments[i],\n\t\t\t\t\tsegments[i + 1] || segments[0]);\n\t\t}\n\t\treturn curves;\n\t},\n\n\tgetFirstCurve: function() {\n\t\treturn this.getCurves()[0];\n\t},\n\n\tgetLastCurve: function() {\n\t\tvar curves = this.getCurves();\n\t\treturn curves[curves.length - 1];\n\t},\n\n\tisClosed: function() {\n\t\treturn this._closed;\n\t},\n\n\tsetClosed: function(closed) {\n\t\tif (this._closed != (closed = !!closed)) {\n\t\t\tthis._closed = closed;\n\t\t\tif (this._curves) {\n\t\t\t\tvar length = this._curves.length = this._countCurves();\n\t\t\t\tif (closed)\n\t\t\t\t\tthis._curves[length - 1] = new Curve(this,\n\t\t\t\t\t\tthis._segments[length - 1], this._segments[0]);\n\t\t\t}\n\t\t\tthis._changed(25);\n\t\t}\n\t}\n}, {\n\tbeans: true,\n\n\tgetPathData: function(_matrix, _precision) {\n\t\tvar segments = this._segments,\n\t\t\tlength = segments.length,\n\t\t\tf = new Formatter(_precision),\n\t\t\tcoords = new Array(6),\n\t\t\tfirst = true,\n\t\t\tcurX, curY,\n\t\t\tprevX, prevY,\n\t\t\tinX, inY,\n\t\t\toutX, outY,\n\t\t\tparts = [];\n\n\t\tfunction addSegment(segment, skipLine) {\n\t\t\tsegment._transformCoordinates(_matrix, coords, false);\n\t\t\tcurX = coords[0];\n\t\t\tcurY = coords[1];\n\t\t\tif (first) {\n\t\t\t\tparts.push('M' + f.pair(curX, curY));\n\t\t\t\tfirst = false;\n\t\t\t} else {\n\t\t\t\tinX = coords[2];\n\t\t\t\tinY = coords[3];\n\t\t\t\tif (inX === curX && inY === curY\n\t\t\t\t\t\t&& outX === prevX && outY === prevY) {\n\t\t\t\t\tif (!skipLine)\n\t\t\t\t\t\tparts.push('l' + f.pair(curX - prevX, curY - prevY));\n\t\t\t\t} else {\n\t\t\t\t\tparts.push('c' + f.pair(outX - prevX, outY - prevY)\n\t\t\t\t\t\t\t+ ' ' + f.pair(inX - prevX, inY - prevY)\n\t\t\t\t\t\t\t+ ' ' + f.pair(curX - prevX, curY - prevY));\n\t\t\t\t}\n\t\t\t}\n\t\t\tprevX = curX;\n\t\t\tprevY = curY;\n\t\t\toutX = coords[4];\n\t\t\toutY = coords[5];\n\t\t}\n\n\t\tif (length === 0)\n\t\t\treturn '';\n\n\t\tfor (var i = 0; i < length; i++)\n\t\t\taddSegment(segments[i]);\n\t\tif (this._closed && length > 0) {\n\t\t\taddSegment(segments[0], true);\n\t\t\tparts.push('z');\n\t\t}\n\t\treturn parts.join('');\n\t}\n}, {\n\n\tisEmpty: function() {\n\t\treturn this._segments.length === 0;\n\t},\n\n\t_transformContent: function(matrix) {\n\t\tvar coords = new Array(6);\n\t\tfor (var i = 0, l = this._segments.length; i < l; i++)\n\t\t\tthis._segments[i]._transformCoordinates(matrix, coords, true);\n\t\treturn true;\n\t},\n\n\t_add: function(segs, index) {\n\t\tvar segments = this._segments,\n\t\t\tcurves = this._curves,\n\t\t\tamount = segs.length,\n\t\t\tappend = index == null,\n\t\t\tindex = append ? segments.length : index;\n\t\tfor (var i = 0; i < amount; i++) {\n\t\t\tvar segment = segs[i];\n\t\t\tif (segment._path)\n\t\t\t\tsegment = segs[i] = segment.clone();\n\t\t\tsegment._path = this;\n\t\t\tsegment._index = index + i;\n\t\t\tif (segment._selectionState)\n\t\t\t\tthis._updateSelection(segment, 0, segment._selectionState);\n\t\t}\n\t\tif (append) {\n\t\t\tsegments.push.apply(segments, segs);\n\t\t} else {\n\t\t\tsegments.splice.apply(segments, [index, 0].concat(segs));\n\t\t\tfor (var i = index + amount, l = segments.length; i < l; i++)\n\t\t\t\tsegments[i]._index = i;\n\t\t}\n\t\tif (curves) {\n\t\t\tvar total = this._countCurves(),\n\t\t\t\tfrom = index + amount - 1 === total ? index - 1 : index,\n\t\t\t\tstart = from,\n\t\t\t\tto = Math.min(from + amount, total);\n\t\t\tif (segs._curves) {\n\t\t\t\tcurves.splice.apply(curves, [from, 0].concat(segs._curves));\n\t\t\t\tstart += segs._curves.length;\n\t\t\t}\n\t\t\tfor (var i = start; i < to; i++)\n\t\t\t\tcurves.splice(i, 0, new Curve(this, null, null));\n\t\t\tthis._adjustCurves(from, to);\n\t\t}\n\t\tthis._changed(25);\n\t\treturn segs;\n\t},\n\n\t_adjustCurves: function(from, to) {\n\t\tvar segments = this._segments,\n\t\t\tcurves = this._curves,\n\t\t\tcurve;\n\t\tfor (var i = from; i < to; i++) {\n\t\t\tcurve = curves[i];\n\t\t\tcurve._path = this;\n\t\t\tcurve._segment1 = segments[i];\n\t\t\tcurve._segment2 = segments[i + 1] || segments[0];\n\t\t\tcurve._changed();\n\t\t}\n\t\tif (curve = curves[this._closed && from === 0 ? segments.length - 1\n\t\t\t\t: from - 1]) {\n\t\t\tcurve._segment2 = segments[from] || segments[0];\n\t\t\tcurve._changed();\n\t\t}\n\t\tif (curve = curves[to]) {\n\t\t\tcurve._segment1 = segments[to];\n\t\t\tcurve._changed();\n\t\t}\n\t},\n\n\t_countCurves: function() {\n\t\tvar length = this._segments.length;\n\t\treturn !this._closed && length > 0 ? length - 1 : length;\n\t},\n\n\tadd: function(segment1 ) {\n\t\treturn arguments.length > 1 && typeof segment1 !== 'number'\n\t\t\t? this._add(Segment.readAll(arguments))\n\t\t\t: this._add([ Segment.read(arguments) ])[0];\n\t},\n\n\tinsert: function(index, segment1 ) {\n\t\treturn arguments.length > 2 && typeof segment1 !== 'number'\n\t\t\t? this._add(Segment.readAll(arguments, 1), index)\n\t\t\t: this._add([ Segment.read(arguments, 1) ], index)[0];\n\t},\n\n\taddSegment: function() {\n\t\treturn this._add([ Segment.read(arguments) ])[0];\n\t},\n\n\tinsertSegment: function(index ) {\n\t\treturn this._add([ Segment.read(arguments, 1) ], index)[0];\n\t},\n\n\taddSegments: function(segments) {\n\t\treturn this._add(Segment.readAll(segments));\n\t},\n\n\tinsertSegments: function(index, segments) {\n\t\treturn this._add(Segment.readAll(segments), index);\n\t},\n\n\tremoveSegment: function(index) {\n\t\treturn this.removeSegments(index, index + 1)[0] || null;\n\t},\n\n\tremoveSegments: function(from, to, _includeCurves) {\n\t\tfrom = from || 0;\n\t\tto = Base.pick(to, this._segments.length);\n\t\tvar segments = this._segments,\n\t\t\tcurves = this._curves,\n\t\t\tcount = segments.length,\n\t\t\tremoved = segments.splice(from, to - from),\n\t\t\tamount = removed.length;\n\t\tif (!amount)\n\t\t\treturn removed;\n\t\tfor (var i = 0; i < amount; i++) {\n\t\t\tvar segment = removed[i];\n\t\t\tif (segment._selectionState)\n\t\t\t\tthis._updateSelection(segment, segment._selectionState, 0);\n\t\t\tsegment._index = segment._path = null;\n\t\t}\n\t\tfor (var i = from, l = segments.length; i < l; i++)\n\t\t\tsegments[i]._index = i;\n\t\tif (curves) {\n\t\t\tvar index = from > 0 && to === count + (this._closed ? 1 : 0)\n\t\t\t\t\t? from - 1\n\t\t\t\t\t: from,\n\t\t\t\tcurves = curves.splice(index, amount);\n\t\t\tif (_includeCurves)\n\t\t\t\tremoved._curves = curves.slice(1);\n\t\t\tthis._adjustCurves(index, index);\n\t\t}\n\t\tthis._changed(25);\n\t\treturn removed;\n\t},\n\n\tclear: '#removeSegments',\n\n\thasHandles: function() {\n\t\tvar segments = this._segments;\n\t\tfor (var i = 0, l = segments.length; i < l; i++) {\n\t\t\tif (segments[i].hasHandles())\n\t\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t},\n\n\tclearHandles: function() {\n\t\tvar segments = this._segments;\n\t\tfor (var i = 0, l = segments.length; i < l; i++)\n\t\t\tsegments[i].clearHandles();\n\t},\n\n\tgetLength: function() {\n\t\tif (this._length == null) {\n\t\t\tvar curves = this.getCurves(),\n\t\t\t\tlength = 0;\n\t\t\tfor (var i = 0, l = curves.length; i < l; i++)\n\t\t\t\tlength += curves[i].getLength();\n\t\t\tthis._length = length;\n\t\t}\n\t\treturn this._length;\n\t},\n\n\tgetArea: function() {\n\t\tif (this._area == null) {\n\t\t\tvar segments = this._segments,\n\t\t\t\tcount = segments.length,\n\t\t\t\tlast = count - 1,\n\t\t\t\tarea = 0;\n\t\t\tfor (var i = 0, l = this._closed ? count : last; i < l; i++) {\n\t\t\t\tarea += Curve.getArea(Curve.getValues(\n\t\t\t\t\t\tsegments[i], segments[i < last ? i + 1 : 0]));\n\t\t\t}\n\t\t\tthis._area = area;\n\t\t}\n\t\treturn this._area;\n\t},\n\n\tisClockwise: function() {\n\t\tif (this._clockwise !== undefined)\n\t\t\treturn this._clockwise;\n\t\treturn this.getArea() >= 0;\n\t},\n\n\tsetClockwise: function(clockwise) {\n\t\tif (this.isClockwise() != (clockwise = !!clockwise))\n\t\t\tthis.reverse();\n\t\tthis._clockwise = clockwise;\n\t},\n\n\tisFullySelected: function() {\n\t\tvar length = this._segments.length;\n\t\treturn this._selected && length > 0 && this._selectedSegmentState\n\t\t\t\t=== length * 7;\n\t},\n\n\tsetFullySelected: function(selected) {\n\t\tif (selected)\n\t\t\tthis._selectSegments(true);\n\t\tthis.setSelected(selected);\n\t},\n\n\tsetSelected: function setSelected(selected) {\n\t\tif (!selected)\n\t\t\tthis._selectSegments(false);\n\t\tsetSelected.base.call(this, selected);\n\t},\n\n\t_selectSegments: function(selected) {\n\t\tvar length = this._segments.length;\n\t\tthis._selectedSegmentState = selected\n\t\t\t\t? length * 7 : 0;\n\t\tfor (var i = 0; i < length; i++)\n\t\t\tthis._segments[i]._selectionState = selected\n\t\t\t\t\t? 7 : 0;\n\t},\n\n\t_updateSelection: function(segment, oldState, newState) {\n\t\tsegment._selectionState = newState;\n\t\tvar total = this._selectedSegmentState += newState - oldState;\n\t\tif (total > 0)\n\t\t\tthis.setSelected(true);\n\t},\n\n\tflatten: function(maxDistance) {\n\t\tvar iterator = new PathIterator(this, 64, 0.1),\n\t\t\tpos = 0,\n\t\t\tstep = iterator.length / Math.ceil(iterator.length / maxDistance),\n\t\t\tend = iterator.length + (this._closed ? -step : step) / 2;\n\t\tvar segments = [];\n\t\twhile (pos <= end) {\n\t\t\tsegments.push(new Segment(iterator.getPointAt(pos)));\n\t\t\tpos += step;\n\t\t}\n\t\tthis.setSegments(segments);\n\t},\n\n\treduce: function() {\n\t\tvar curves = this.getCurves();\n\t\tfor (var i = curves.length - 1; i >= 0; i--) {\n\t\t\tvar curve = curves[i];\n\t\t\tif (!curve.hasHandles() && (curve.getLength() === 0\n\t\t\t\t\t|| curve.isCollinear(curve.getNext())))\n\t\t\t\tcurve.remove();\n\t\t}\n\t\treturn this;\n\t},\n\n\tsimplify: function(tolerance) {\n\t\tif (this._segments.length > 2) {\n\t\t\tvar fitter = new PathFitter(this, tolerance || 2.5);\n\t\t\tthis.setSegments(fitter.fit());\n\t\t}\n\t},\n\n\tsplit: function(index, parameter) {\n\t\tif (parameter === null)\n\t\t\treturn null;\n\t\tif (arguments.length === 1) {\n\t\t\tvar arg = index;\n\t\t\tif (typeof arg === 'number')\n\t\t\t\targ = this.getLocationAt(arg);\n\t\t\tif (!arg)\n\t\t\t\treturn null\n\t\t\tindex = arg.index;\n\t\t\tparameter = arg.parameter;\n\t\t}\n\t\tvar tMin = 4e-7,\n\t\t\ttMax = 1 - tMin;\n\t\tif (parameter >= tMax) {\n\t\t\tindex++;\n\t\t\tparameter--;\n\t\t}\n\t\tvar curves = this.getCurves();\n\t\tif (index >= 0 && index < curves.length) {\n\t\t\tif (parameter >= tMin) {\n\t\t\t\tcurves[index++].divide(parameter, true);\n\t\t\t}\n\t\t\tvar segs = this.removeSegments(index, this._segments.length, true),\n\t\t\t\tpath;\n\t\t\tif (this._closed) {\n\t\t\t\tthis.setClosed(false);\n\t\t\t\tpath = this;\n\t\t\t} else {\n\t\t\t\tpath = new Path(Item.NO_INSERT);\n\t\t\t\tpath.insertAbove(this, true);\n\t\t\t\tthis._clone(path);\n\t\t\t}\n\t\t\tpath._add(segs, 0);\n\t\t\tthis.addSegment(segs[0]);\n\t\t\treturn path;\n\t\t}\n\t\treturn null;\n\t},\n\n\treverse: function() {\n\t\tthis._segments.reverse();\n\t\tfor (var i = 0, l = this._segments.length; i < l; i++) {\n\t\t\tvar segment = this._segments[i];\n\t\t\tvar handleIn = segment._handleIn;\n\t\t\tsegment._handleIn = segment._handleOut;\n\t\t\tsegment._handleOut = handleIn;\n\t\t\tsegment._index = i;\n\t\t}\n\t\tthis._curves = null;\n\t\tif (this._clockwise !== undefined)\n\t\t\tthis._clockwise = !this._clockwise;\n\t\tthis._changed(9);\n\t},\n\n\tjoin: function(path) {\n\t\tif (path) {\n\t\t\tvar segments = path._segments,\n\t\t\t\tlast1 = this.getLastSegment(),\n\t\t\t\tlast2 = path.getLastSegment();\n\t\t\tif (!last2)\n\t\t\t\treturn this;\n\t\t\tif (last1 && last1._point.equals(last2._point))\n\t\t\t\tpath.reverse();\n\t\t\tvar first2 = path.getFirstSegment();\n\t\t\tif (last1 && last1._point.equals(first2._point)) {\n\t\t\t\tlast1.setHandleOut(first2._handleOut);\n\t\t\t\tthis._add(segments.slice(1));\n\t\t\t} else {\n\t\t\t\tvar first1 = this.getFirstSegment();\n\t\t\t\tif (first1 && first1._point.equals(first2._point))\n\t\t\t\t\tpath.reverse();\n\t\t\t\tlast2 = path.getLastSegment();\n\t\t\t\tif (first1 && first1._point.equals(last2._point)) {\n\t\t\t\t\tfirst1.setHandleIn(last2._handleIn);\n\t\t\t\t\tthis._add(segments.slice(0, segments.length - 1), 0);\n\t\t\t\t} else {\n\t\t\t\t\tthis._add(segments.slice());\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (path._closed)\n\t\t\t\tthis._add([segments[0]]);\n\t\t\tpath.remove();\n\t\t}\n\t\tvar first = this.getFirstSegment(),\n\t\t\tlast = this.getLastSegment();\n\t\tif (first !== last && first._point.equals(last._point)) {\n\t\t\tfirst.setHandleIn(last._handleIn);\n\t\t\tlast.remove();\n\t\t\tthis.setClosed(true);\n\t\t}\n\t\treturn this;\n\t},\n\n\ttoShape: function(insert) {\n\t\tif (!this._closed)\n\t\t\treturn null;\n\n\t\tvar segments = this._segments,\n\t\t\ttype,\n\t\t\tsize,\n\t\t\tradius,\n\t\t\ttopCenter;\n\n\t\tfunction isCollinear(i, j) {\n\t\t\tvar seg1 = segments[i],\n\t\t\t\tseg2 = seg1.getNext(),\n\t\t\t\tseg3 = segments[j],\n\t\t\t\tseg4 = seg3.getNext();\n\t\t\treturn seg1._handleOut.isZero() && seg2._handleIn.isZero()\n\t\t\t\t\t&& seg3._handleOut.isZero() && seg4._handleIn.isZero()\n\t\t\t\t\t&& seg2._point.subtract(seg1._point).isCollinear(\n\t\t\t\t\t\tseg4._point.subtract(seg3._point));\n\t\t}\n\n\t\tfunction isOrthogonal(i) {\n\t\t\tvar seg2 = segments[i],\n\t\t\t\tseg1 = seg2.getPrevious(),\n\t\t\t\tseg3 = seg2.getNext();\n\t\t\treturn seg1._handleOut.isZero() && seg2._handleIn.isZero()\n\t\t\t\t\t&& seg2._handleOut.isZero() && seg3._handleIn.isZero()\n\t\t\t\t\t&& seg2._point.subtract(seg1._point).isOrthogonal(\n\t\t\t\t\t\tseg3._point.subtract(seg2._point));\n\t\t}\n\n\t\tfunction isArc(i) {\n\t\t\tvar seg1 = segments[i],\n\t\t\t\tseg2 = seg1.getNext(),\n\t\t\t\thandle1 = seg1._handleOut,\n\t\t\t\thandle2 = seg2._handleIn,\n\t\t\t\tkappa = 0.5522847498307936;\n\t\t\tif (handle1.isOrthogonal(handle2)) {\n\t\t\t\tvar pt1 = seg1._point,\n\t\t\t\t\tpt2 = seg2._point,\n\t\t\t\t\tcorner = new Line(pt1, handle1, true).intersect(\n\t\t\t\t\t\t\tnew Line(pt2, handle2, true), true);\n\t\t\t\treturn corner && Numerical.isZero(handle1.getLength() /\n\t\t\t\t\t\tcorner.subtract(pt1).getLength() - kappa)\n\t\t\t\t\t&& Numerical.isZero(handle2.getLength() /\n\t\t\t\t\t\tcorner.subtract(pt2).getLength() - kappa);\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\n\t\tfunction getDistance(i, j) {\n\t\t\treturn segments[i]._point.getDistance(segments[j]._point);\n\t\t}\n\n\t\tif (!this.hasHandles() && segments.length === 4\n\t\t\t\t&& isCollinear(0, 2) && isCollinear(1, 3) && isOrthogonal(1)) {\n\t\t\ttype = Shape.Rectangle;\n\t\t\tsize = new Size(getDistance(0, 3), getDistance(0, 1));\n\t\t\ttopCenter = segments[1]._point.add(segments[2]._point).divide(2);\n\t\t} else if (segments.length === 8 && isArc(0) && isArc(2) && isArc(4)\n\t\t\t\t&& isArc(6) && isCollinear(1, 5) && isCollinear(3, 7)) {\n\t\t\ttype = Shape.Rectangle;\n\t\t\tsize = new Size(getDistance(1, 6), getDistance(0, 3));\n\t\t\tradius = size.subtract(new Size(getDistance(0, 7),\n\t\t\t\t\tgetDistance(1, 2))).divide(2);\n\t\t\ttopCenter = segments[3]._point.add(segments[4]._point).divide(2);\n\t\t} else if (segments.length === 4\n\t\t\t\t&& isArc(0) && isArc(1) && isArc(2) && isArc(3)) {\n\t\t\tif (Numerical.isZero(getDistance(0, 2) - getDistance(1, 3))) {\n\t\t\t\ttype = Shape.Circle;\n\t\t\t\tradius = getDistance(0, 2) / 2;\n\t\t\t} else {\n\t\t\t\ttype = Shape.Ellipse;\n\t\t\t\tradius = new Size(getDistance(2, 0) / 2, getDistance(3, 1) / 2);\n\t\t\t}\n\t\t\ttopCenter = segments[1]._point;\n\t\t}\n\n\t\tif (type) {\n\t\t\tvar center = this.getPosition(true),\n\t\t\t\tshape = this._clone(new type({\n\t\t\t\t\tcenter: center,\n\t\t\t\t\tsize: size,\n\t\t\t\t\tradius: radius,\n\t\t\t\t\tinsert: false\n\t\t\t\t}), insert, false);\n\t\t\tshape.rotate(topCenter.subtract(center).getAngle() + 90);\n\t\t\treturn shape;\n\t\t}\n\t\treturn null;\n\t},\n\n\t_hitTestSelf: function(point, options) {\n\t\tvar that = this,\n\t\t\tstyle = this.getStyle(),\n\t\t\tsegments = this._segments,\n\t\t\tnumSegments = segments.length,\n\t\t\tclosed = this._closed,\n\t\t\ttolerancePadding = options._tolerancePadding,\n\t\t\tstrokePadding = tolerancePadding,\n\t\t\tjoin, cap, miterLimit,\n\t\t\tarea, loc, res,\n\t\t\thitStroke = options.stroke && style.hasStroke(),\n\t\t\thitFill = options.fill && style.hasFill(),\n\t\t\thitCurves = options.curves,\n\t\t\tradius = hitStroke\n\t\t\t\t\t? style.getStrokeWidth() / 2\n\t\t\t\t\t: hitFill && options.tolerance > 0 || hitCurves\n\t\t\t\t\t\t? 0 : null;\n\t\tif (radius !== null) {\n\t\t\tif (radius > 0) {\n\t\t\t\tjoin = style.getStrokeJoin();\n\t\t\t\tcap = style.getStrokeCap();\n\t\t\t\tmiterLimit = radius * style.getMiterLimit();\n\t\t\t\tstrokePadding = tolerancePadding.add(new Point(radius, radius));\n\t\t\t} else {\n\t\t\t\tjoin = cap = 'round';\n\t\t\t}\n\t\t}\n\n\t\tfunction isCloseEnough(pt, padding) {\n\t\t\treturn point.subtract(pt).divide(padding).length <= 1;\n\t\t}\n\n\t\tfunction checkSegmentPoint(seg, pt, name) {\n\t\t\tif (!options.selected || pt.isSelected()) {\n\t\t\t\tvar anchor = seg._point;\n\t\t\t\tif (pt !== anchor)\n\t\t\t\t\tpt = pt.add(anchor);\n\t\t\t\tif (isCloseEnough(pt, strokePadding)) {\n\t\t\t\t\treturn new HitResult(name, that, {\n\t\t\t\t\t\tsegment: seg,\n\t\t\t\t\t\tpoint: pt\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfunction checkSegmentPoints(seg, ends) {\n\t\t\treturn (ends || options.segments)\n\t\t\t\t&& checkSegmentPoint(seg, seg._point, 'segment')\n\t\t\t\t|| (!ends && options.handles) && (\n\t\t\t\t\tcheckSegmentPoint(seg, seg._handleIn, 'handle-in') ||\n\t\t\t\t\tcheckSegmentPoint(seg, seg._handleOut, 'handle-out'));\n\t\t}\n\n\t\tfunction addToArea(point) {\n\t\t\tarea.add(point);\n\t\t}\n\n\t\tfunction checkSegmentStroke(segment) {\n\t\t\tif (join !== 'round' || cap !== 'round') {\n\t\t\t\tarea = new Path({ internal: true, closed: true });\n\t\t\t\tif (closed || segment._index > 0\n\t\t\t\t\t\t&& segment._index < numSegments - 1) {\n\t\t\t\t\tif (join !== 'round' && (segment._handleIn.isZero()\n\t\t\t\t\t\t\t|| segment._handleOut.isZero()))\n\t\t\t\t\t\tPath._addBevelJoin(segment, join, radius, miterLimit,\n\t\t\t\t\t\t\t\taddToArea, true);\n\t\t\t\t} else if (cap !== 'round') {\n\t\t\t\t\tPath._addSquareCap(segment, cap, radius, addToArea, true);\n\t\t\t\t}\n\t\t\t\tif (!area.isEmpty()) {\n\t\t\t\t\tvar loc;\n\t\t\t\t\treturn area.contains(point)\n\t\t\t\t\t\t|| (loc = area.getNearestLocation(point))\n\t\t\t\t\t\t\t&& isCloseEnough(loc.getPoint(), tolerancePadding);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn isCloseEnough(segment._point, strokePadding);\n\t\t}\n\n\t\tif (options.ends && !options.segments && !closed) {\n\t\t\tif (res = checkSegmentPoints(segments[0], true)\n\t\t\t\t\t|| checkSegmentPoints(segments[numSegments - 1], true))\n\t\t\t\treturn res;\n\t\t} else if (options.segments || options.handles) {\n\t\t\tfor (var i = 0; i < numSegments; i++)\n\t\t\t\tif (res = checkSegmentPoints(segments[i]))\n\t\t\t\t\treturn res;\n\t\t}\n\t\tif (radius !== null) {\n\t\t\tloc = this.getNearestLocation(point);\n\t\t\tif (loc) {\n\t\t\t\tvar parameter = loc.getParameter();\n\t\t\t\tif (parameter === 0 || parameter === 1 && numSegments > 1) {\n\t\t\t\t\tif (!checkSegmentStroke(loc.getSegment()))\n\t\t\t\t\t\tloc = null;\n\t\t\t\t} else if (!isCloseEnough(loc.getPoint(), strokePadding)) {\n\t\t\t\t\tloc = null;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!loc && join === 'miter' && numSegments > 1) {\n\t\t\t\tfor (var i = 0; i < numSegments; i++) {\n\t\t\t\t\tvar segment = segments[i];\n\t\t\t\t\tif (point.getDistance(segment._point) <= miterLimit\n\t\t\t\t\t\t\t&& checkSegmentStroke(segment)) {\n\t\t\t\t\t\tloc = segment.getLocation();\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn !loc && hitFill && this._contains(point)\n\t\t\t\t|| loc && !hitStroke && !hitCurves\n\t\t\t\t\t? new HitResult('fill', this)\n\t\t\t\t\t: loc\n\t\t\t\t\t\t? new HitResult(hitStroke ? 'stroke' : 'curve', this, {\n\t\t\t\t\t\t\tlocation: loc,\n\t\t\t\t\t\t\tpoint: loc.getPoint()\n\t\t\t\t\t\t})\n\t\t\t\t\t\t: null;\n\t}\n\n}, Base.each(Curve.evaluateMethods,\n\tfunction(name) {\n\t\tthis[name + 'At'] = function(offset, isParameter) {\n\t\t\tvar loc = this.getLocationAt(offset, isParameter);\n\t\t\treturn loc && loc[name]();\n\t\t};\n\t},\n{\n\tbeans: false,\n\n\tgetLocationOf: function() {\n\t\tvar point = Point.read(arguments),\n\t\t\tcurves = this.getCurves();\n\t\tfor (var i = 0, l = curves.length; i < l; i++) {\n\t\t\tvar loc = curves[i].getLocationOf(point);\n\t\t\tif (loc)\n\t\t\t\treturn loc;\n\t\t}\n\t\treturn null;\n\t},\n\n\tgetOffsetOf: function() {\n\t\tvar loc = this.getLocationOf.apply(this, arguments);\n\t\treturn loc ? loc.getOffset() : null;\n\t},\n\n\tgetLocationAt: function(offset, isParameter) {\n\t\tvar curves = this.getCurves(),\n\t\t\tlength = 0;\n\t\tif (isParameter) {\n\t\t\tvar index = ~~offset,\n\t\t\t\tcurve = curves[index];\n\t\t\treturn curve ? curve.getLocationAt(offset - index, true) : null;\n\t\t}\n\t\tfor (var i = 0, l = curves.length; i < l; i++) {\n\t\t\tvar start = length,\n\t\t\t\tcurve = curves[i];\n\t\t\tlength += curve.getLength();\n\t\t\tif (length > offset) {\n\t\t\t\treturn curve.getLocationAt(offset - start);\n\t\t\t}\n\t\t}\n\t\tif (curves.length > 0 && offset <= this.getLength())\n\t\t\treturn new CurveLocation(curves[curves.length - 1], 1);\n\t\treturn null;\n\t},\n\n\tgetNearestLocation: function() {\n\t\tvar point = Point.read(arguments),\n\t\t\tcurves = this.getCurves(),\n\t\t\tminDist = Infinity,\n\t\t\tminLoc = null;\n\t\tfor (var i = 0, l = curves.length; i < l; i++) {\n\t\t\tvar loc = curves[i].getNearestLocation(point);\n\t\t\tif (loc._distance < minDist) {\n\t\t\t\tminDist = loc._distance;\n\t\t\t\tminLoc = loc;\n\t\t\t}\n\t\t}\n\t\treturn minLoc;\n\t},\n\n\tgetNearestPoint: function() {\n\t\treturn this.getNearestLocation.apply(this, arguments).getPoint();\n\t}\n}),\nnew function() {\n\n\tfunction drawHandles(ctx, segments, matrix, size) {\n\t\tvar half = size / 2;\n\n\t\tfunction drawHandle(index) {\n\t\t\tvar hX = coords[index],\n\t\t\t\thY = coords[index + 1];\n\t\t\tif (pX != hX || pY != hY) {\n\t\t\t\tctx.beginPath();\n\t\t\t\tctx.moveTo(pX, pY);\n\t\t\t\tctx.lineTo(hX, hY);\n\t\t\t\tctx.stroke();\n\t\t\t\tctx.beginPath();\n\t\t\t\tctx.arc(hX, hY, half, 0, Math.PI * 2, true);\n\t\t\t\tctx.fill();\n\t\t\t}\n\t\t}\n\n\t\tvar coords = new Array(6);\n\t\tfor (var i = 0, l = segments.length; i < l; i++) {\n\t\t\tvar segment = segments[i];\n\t\t\tsegment._transformCoordinates(matrix, coords, false);\n\t\t\tvar state = segment._selectionState,\n\t\t\t\tpX = coords[0],\n\t\t\t\tpY = coords[1];\n\t\t\tif (state & 1)\n\t\t\t\tdrawHandle(2);\n\t\t\tif (state & 2)\n\t\t\t\tdrawHandle(4);\n\t\t\tctx.fillRect(pX - half, pY - half, size, size);\n\t\t\tif (!(state & 4)) {\n\t\t\t\tvar fillStyle = ctx.fillStyle;\n\t\t\t\tctx.fillStyle = '#ffffff';\n\t\t\t\tctx.fillRect(pX - half + 1, pY - half + 1, size - 2, size - 2);\n\t\t\t\tctx.fillStyle = fillStyle;\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction drawSegments(ctx, path, matrix) {\n\t\tvar segments = path._segments,\n\t\t\tlength = segments.length,\n\t\t\tcoords = new Array(6),\n\t\t\tfirst = true,\n\t\t\tcurX, curY,\n\t\t\tprevX, prevY,\n\t\t\tinX, inY,\n\t\t\toutX, outY;\n\n\t\tfunction drawSegment(segment) {\n\t\t\tif (matrix) {\n\t\t\t\tsegment._transformCoordinates(matrix, coords, false);\n\t\t\t\tcurX = coords[0];\n\t\t\t\tcurY = coords[1];\n\t\t\t} else {\n\t\t\t\tvar point = segment._point;\n\t\t\t\tcurX = point._x;\n\t\t\t\tcurY = point._y;\n\t\t\t}\n\t\t\tif (first) {\n\t\t\t\tctx.moveTo(curX, curY);\n\t\t\t\tfirst = false;\n\t\t\t} else {\n\t\t\t\tif (matrix) {\n\t\t\t\t\tinX = coords[2];\n\t\t\t\t\tinY = coords[3];\n\t\t\t\t} else {\n\t\t\t\t\tvar handle = segment._handleIn;\n\t\t\t\t\tinX = curX + handle._x;\n\t\t\t\t\tinY = curY + handle._y;\n\t\t\t\t}\n\t\t\t\tif (inX === curX && inY === curY\n\t\t\t\t\t\t&& outX === prevX && outY === prevY) {\n\t\t\t\t\tctx.lineTo(curX, curY);\n\t\t\t\t} else {\n\t\t\t\t\tctx.bezierCurveTo(outX, outY, inX, inY, curX, curY);\n\t\t\t\t}\n\t\t\t}\n\t\t\tprevX = curX;\n\t\t\tprevY = curY;\n\t\t\tif (matrix) {\n\t\t\t\toutX = coords[4];\n\t\t\t\toutY = coords[5];\n\t\t\t} else {\n\t\t\t\tvar handle = segment._handleOut;\n\t\t\t\toutX = prevX + handle._x;\n\t\t\t\toutY = prevY + handle._y;\n\t\t\t}\n\t\t}\n\n\t\tfor (var i = 0; i < length; i++)\n\t\t\tdrawSegment(segments[i]);\n\t\tif (path._closed && length > 0)\n\t\t\tdrawSegment(segments[0]);\n\t}\n\n\treturn {\n\t\t_draw: function(ctx, param, strokeMatrix) {\n\t\t\tvar dontStart = param.dontStart,\n\t\t\t\tdontPaint = param.dontFinish || param.clip,\n\t\t\t\tstyle = this.getStyle(),\n\t\t\t\thasFill = style.hasFill(),\n\t\t\t\thasStroke = style.hasStroke(),\n\t\t\t\tdashArray = style.getDashArray(),\n\t\t\t\tdashLength = !paper.support.nativeDash && hasStroke\n\t\t\t\t\t\t&& dashArray && dashArray.length;\n\n\t\t\tif (!dontStart)\n\t\t\t\tctx.beginPath();\n\n\t\t\tif (!dontStart && this._currentPath) {\n\t\t\t\tctx.currentPath = this._currentPath;\n\t\t\t} else if (hasFill || hasStroke && !dashLength || dontPaint) {\n\t\t\t\tdrawSegments(ctx, this, strokeMatrix);\n\t\t\t\tif (this._closed)\n\t\t\t\t\tctx.closePath();\n\t\t\t\tif (!dontStart)\n\t\t\t\t\tthis._currentPath = ctx.currentPath;\n\t\t\t}\n\n\t\t\tfunction getOffset(i) {\n\t\t\t\treturn dashArray[((i % dashLength) + dashLength) % dashLength];\n\t\t\t}\n\n\t\t\tif (!dontPaint && (hasFill || hasStroke)) {\n\t\t\t\tthis._setStyles(ctx);\n\t\t\t\tif (hasFill) {\n\t\t\t\t\tctx.fill(style.getWindingRule());\n\t\t\t\t\tctx.shadowColor = 'rgba(0,0,0,0)';\n\t\t\t\t}\n\t\t\t\tif (hasStroke) {\n\t\t\t\t\tif (dashLength) {\n\t\t\t\t\t\tif (!dontStart)\n\t\t\t\t\t\t\tctx.beginPath();\n\t\t\t\t\t\tvar iterator = new PathIterator(this, 32, 0.25,\n\t\t\t\t\t\t\t\tstrokeMatrix),\n\t\t\t\t\t\t\tlength = iterator.length,\n\t\t\t\t\t\t\tfrom = -style.getDashOffset(), to,\n\t\t\t\t\t\t\ti = 0;\n\t\t\t\t\t\tfrom = from % length;\n\t\t\t\t\t\twhile (from > 0) {\n\t\t\t\t\t\t\tfrom -= getOffset(i--) + getOffset(i--);\n\t\t\t\t\t\t}\n\t\t\t\t\t\twhile (from < length) {\n\t\t\t\t\t\t\tto = from + getOffset(i++);\n\t\t\t\t\t\t\tif (from > 0 || to > 0)\n\t\t\t\t\t\t\t\titerator.drawPart(ctx,\n\t\t\t\t\t\t\t\t\t\tMath.max(from, 0), Math.max(to, 0));\n\t\t\t\t\t\t\tfrom = to + getOffset(i++);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tctx.stroke();\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\t_drawSelected: function(ctx, matrix) {\n\t\t\tctx.beginPath();\n\t\t\tdrawSegments(ctx, this, matrix);\n\t\t\tctx.stroke();\n\t\t\tdrawHandles(ctx, this._segments, matrix, paper.settings.handleSize);\n\t\t}\n\t};\n},\nnew function() {\n\tfunction getFirstControlPoints(rhs) {\n\t\tvar n = rhs.length,\n\t\t\tx = [],\n\t\t\ttmp = [],\n\t\t\tb = 2;\n\t\tx[0] = rhs[0] / b;\n\t\tfor (var i = 1; i < n; i++) {\n\t\t\ttmp[i] = 1 / b;\n\t\t\tb = (i < n - 1 ? 4 : 2) - tmp[i];\n\t\t\tx[i] = (rhs[i] - x[i - 1]) / b;\n\t\t}\n\t\tfor (var i = 1; i < n; i++) {\n\t\t\tx[n - i - 1] -= tmp[n - i] * x[n - i];\n\t\t}\n\t\treturn x;\n\t}\n\n\treturn {\n\t\tsmooth: function() {\n\t\t\tvar segments = this._segments,\n\t\t\t\tsize = segments.length,\n\t\t\t\tclosed = this._closed,\n\t\t\t\tn = size,\n\t\t\t\toverlap = 0;\n\t\t\tif (size <= 2)\n\t\t\t\treturn;\n\t\t\tif (closed) {\n\t\t\t\toverlap = Math.min(size, 4);\n\t\t\t\tn += Math.min(size, overlap) * 2;\n\t\t\t}\n\t\t\tvar knots = [];\n\t\t\tfor (var i = 0; i < size; i++)\n\t\t\t\tknots[i + overlap] = segments[i]._point;\n\t\t\tif (closed) {\n\t\t\t\tfor (var i = 0; i < overlap; i++) {\n\t\t\t\t\tknots[i] = segments[i + size - overlap]._point;\n\t\t\t\t\tknots[i + size + overlap] = segments[i]._point;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tn--;\n\t\t\t}\n\t\t\tvar rhs = [];\n\n\t\t\tfor (var i = 1; i < n - 1; i++)\n\t\t\t\trhs[i] = 4 * knots[i]._x + 2 * knots[i + 1]._x;\n\t\t\trhs[0] = knots[0]._x + 2 * knots[1]._x;\n\t\t\trhs[n - 1] = 3 * knots[n - 1]._x;\n\t\t\tvar x = getFirstControlPoints(rhs);\n\n\t\t\tfor (var i = 1; i < n - 1; i++)\n\t\t\t\trhs[i] = 4 * knots[i]._y + 2 * knots[i + 1]._y;\n\t\t\trhs[0] = knots[0]._y + 2 * knots[1]._y;\n\t\t\trhs[n - 1] = 3 * knots[n - 1]._y;\n\t\t\tvar y = getFirstControlPoints(rhs);\n\n\t\t\tif (closed) {\n\t\t\t\tfor (var i = 0, j = size; i < overlap; i++, j++) {\n\t\t\t\t\tvar f1 = i / overlap,\n\t\t\t\t\t\tf2 = 1 - f1,\n\t\t\t\t\t\tie = i + overlap,\n\t\t\t\t\t\tje = j + overlap;\n\t\t\t\t\tx[j] = x[i] * f1 + x[j] * f2;\n\t\t\t\t\ty[j] = y[i] * f1 + y[j] * f2;\n\t\t\t\t\tx[je] = x[ie] * f2 + x[je] * f1;\n\t\t\t\t\ty[je] = y[ie] * f2 + y[je] * f1;\n\t\t\t\t}\n\t\t\t\tn--;\n\t\t\t}\n\t\t\tvar handleIn = null;\n\t\t\tfor (var i = overlap; i <= n - overlap; i++) {\n\t\t\t\tvar segment = segments[i - overlap];\n\t\t\t\tif (handleIn)\n\t\t\t\t\tsegment.setHandleIn(handleIn.subtract(segment._point));\n\t\t\t\tif (i < n) {\n\t\t\t\t\tsegment.setHandleOut(\n\t\t\t\t\t\t\tnew Point(x[i], y[i]).subtract(segment._point));\n\t\t\t\t\thandleIn = i < n - 1\n\t\t\t\t\t\t\t? new Point(\n\t\t\t\t\t\t\t\t2 * knots[i + 1]._x - x[i + 1],\n\t\t\t\t\t\t\t\t2 * knots[i + 1]._y - y[i + 1])\n\t\t\t\t\t\t\t: new Point(\n\t\t\t\t\t\t\t\t(knots[n]._x + x[n - 1]) / 2,\n\t\t\t\t\t\t\t\t(knots[n]._y + y[n - 1]) / 2);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (closed && handleIn) {\n\t\t\t\tvar segment = this._segments[0];\n\t\t\t\tsegment.setHandleIn(handleIn.subtract(segment._point));\n\t\t\t}\n\t\t}\n\t};\n},\nnew function() {\n\tfunction getCurrentSegment(that) {\n\t\tvar segments = that._segments;\n\t\tif (segments.length === 0)\n\t\t\tthrow new Error('Use a moveTo() command first');\n\t\treturn segments[segments.length - 1];\n\t}\n\n\treturn {\n\t\tmoveTo: function() {\n\t\t\tvar segments = this._segments;\n\t\t\tif (segments.length === 1)\n\t\t\t\tthis.removeSegment(0);\n\t\t\tif (!segments.length)\n\t\t\t\tthis._add([ new Segment(Point.read(arguments)) ]);\n\t\t},\n\n\t\tmoveBy: function() {\n\t\t\tthrow new Error('moveBy() is unsupported on Path items.');\n\t\t},\n\n\t\tlineTo: function() {\n\t\t\tthis._add([ new Segment(Point.read(arguments)) ]);\n\t\t},\n\n\t\tcubicCurveTo: function() {\n\t\t\tvar handle1 = Point.read(arguments),\n\t\t\t\thandle2 = Point.read(arguments),\n\t\t\t\tto = Point.read(arguments),\n\t\t\t\tcurrent = getCurrentSegment(this);\n\t\t\tcurrent.setHandleOut(handle1.subtract(current._point));\n\t\t\tthis._add([ new Segment(to, handle2.subtract(to)) ]);\n\t\t},\n\n\t\tquadraticCurveTo: function() {\n\t\t\tvar handle = Point.read(arguments),\n\t\t\t\tto = Point.read(arguments),\n\t\t\t\tcurrent = getCurrentSegment(this)._point;\n\t\t\tthis.cubicCurveTo(\n\t\t\t\thandle.add(current.subtract(handle).multiply(1 / 3)),\n\t\t\t\thandle.add(to.subtract(handle).multiply(1 / 3)),\n\t\t\t\tto\n\t\t\t);\n\t\t},\n\n\t\tcurveTo: function() {\n\t\t\tvar through = Point.read(arguments),\n\t\t\t\tto = Point.read(arguments),\n\t\t\t\tt = Base.pick(Base.read(arguments), 0.5),\n\t\t\t\tt1 = 1 - t,\n\t\t\t\tcurrent = getCurrentSegment(this)._point,\n\t\t\t\thandle = through.subtract(current.multiply(t1 * t1))\n\t\t\t\t\t.subtract(to.multiply(t * t)).divide(2 * t * t1);\n\t\t\tif (handle.isNaN())\n\t\t\t\tthrow new Error(\n\t\t\t\t\t'Cannot put a curve through points with parameter = ' + t);\n\t\t\tthis.quadraticCurveTo(handle, to);\n\t\t},\n\n\t\tarcTo: function() {\n\t\t\tvar current = getCurrentSegment(this),\n\t\t\t\tfrom = current._point,\n\t\t\t\tto = Point.read(arguments),\n\t\t\t\tthrough,\n\t\t\t\tpeek = Base.peek(arguments),\n\t\t\t\tclockwise = Base.pick(peek, true),\n\t\t\t\tcenter, extent, vector, matrix;\n\t\t\tif (typeof clockwise === 'boolean') {\n\t\t\t\tvar middle = from.add(to).divide(2),\n\t\t\t\tthrough = middle.add(middle.subtract(from).rotate(\n\t\t\t\t\t\tclockwise ? -90 : 90));\n\t\t\t} else if (Base.remain(arguments) <= 2) {\n\t\t\t\tthrough = to;\n\t\t\t\tto = Point.read(arguments);\n\t\t\t} else {\n\t\t\t\tvar radius = Size.read(arguments);\n\t\t\t\tif (radius.isZero())\n\t\t\t\t\treturn this.lineTo(to);\n\t\t\t\tvar rotation = Base.read(arguments),\n\t\t\t\t\tclockwise = !!Base.read(arguments),\n\t\t\t\t\tlarge = !!Base.read(arguments),\n\t\t\t\t\tmiddle = from.add(to).divide(2),\n\t\t\t\t\tpt = from.subtract(middle).rotate(-rotation),\n\t\t\t\t\tx = pt.x,\n\t\t\t\t\ty = pt.y,\n\t\t\t\t\tabs = Math.abs,\n\t\t\t\t\trx = abs(radius.width),\n\t\t\t\t\try = abs(radius.height),\n\t\t\t\t\trxSq = rx * rx,\n\t\t\t\t\trySq = ry * ry,\n\t\t\t\t\txSq =  x * x,\n\t\t\t\t\tySq =  y * y;\n\t\t\t\tvar factor = Math.sqrt(xSq / rxSq + ySq / rySq);\n\t\t\t\tif (factor > 1) {\n\t\t\t\t\trx *= factor;\n\t\t\t\t\try *= factor;\n\t\t\t\t\trxSq = rx * rx;\n\t\t\t\t\trySq = ry * ry;\n\t\t\t\t}\n\t\t\t\tfactor = (rxSq * rySq - rxSq * ySq - rySq * xSq) /\n\t\t\t\t\t\t(rxSq * ySq + rySq * xSq);\n\t\t\t\tif (abs(factor) < 1e-12)\n\t\t\t\t\tfactor = 0;\n\t\t\t\tif (factor < 0)\n\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t\t'Cannot create an arc with the given arguments');\n\t\t\t\tcenter = new Point(rx * y / ry, -ry * x / rx)\n\t\t\t\t\t\t.multiply((large === clockwise ? -1 : 1)\n\t\t\t\t\t\t\t* Math.sqrt(factor))\n\t\t\t\t\t\t.rotate(rotation).add(middle);\n\t\t\t\tmatrix = new Matrix().translate(center).rotate(rotation)\n\t\t\t\t\t\t.scale(rx, ry);\n\t\t\t\tvector = matrix._inverseTransform(from);\n\t\t\t\textent = vector.getDirectedAngle(matrix._inverseTransform(to));\n\t\t\t\tif (!clockwise && extent > 0)\n\t\t\t\t\textent -= 360;\n\t\t\t\telse if (clockwise && extent < 0)\n\t\t\t\t\textent += 360;\n\t\t\t}\n\t\t\tif (through) {\n\t\t\t\tvar l1 = new Line(from.add(through).divide(2),\n\t\t\t\t\t\t\tthrough.subtract(from).rotate(90), true),\n\t\t\t\t\tl2 = new Line(through.add(to).divide(2),\n\t\t\t\t\t\t\tto.subtract(through).rotate(90), true),\n\t\t\t\t\tline = new Line(from, to),\n\t\t\t\t\tthroughSide = line.getSide(through);\n\t\t\t\tcenter = l1.intersect(l2, true);\n\t\t\t\tif (!center) {\n\t\t\t\t\tif (!throughSide)\n\t\t\t\t\t\treturn this.lineTo(to);\n\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t\t'Cannot create an arc with the given arguments');\n\t\t\t\t}\n\t\t\t\tvector = from.subtract(center);\n\t\t\t\textent = vector.getDirectedAngle(to.subtract(center));\n\t\t\t\tvar centerSide = line.getSide(center);\n\t\t\t\tif (centerSide === 0) {\n\t\t\t\t\textent = throughSide * Math.abs(extent);\n\t\t\t\t} else if (throughSide === centerSide) {\n\t\t\t\t\textent += extent < 0 ? 360 : -360;\n\t\t\t\t}\n\t\t\t}\n\t\t\tvar ext = Math.abs(extent),\n\t\t\t\tcount = ext >= 360 ? 4 : Math.ceil(ext / 90),\n\t\t\t\tinc = extent / count,\n\t\t\t\thalf = inc * Math.PI / 360,\n\t\t\t\tz = 4 / 3 * Math.sin(half) / (1 + Math.cos(half)),\n\t\t\t\tsegments = [];\n\t\t\tfor (var i = 0; i <= count; i++) {\n\t\t\t\tvar pt = to,\n\t\t\t\t\tout = null;\n\t\t\t\tif (i < count) {\n\t\t\t\t\tout = vector.rotate(90).multiply(z);\n\t\t\t\t\tif (matrix) {\n\t\t\t\t\t\tpt = matrix._transformPoint(vector);\n\t\t\t\t\t\tout = matrix._transformPoint(vector.add(out))\n\t\t\t\t\t\t\t\t.subtract(pt);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tpt = center.add(vector);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (i === 0) {\n\t\t\t\t\tcurrent.setHandleOut(out);\n\t\t\t\t} else {\n\t\t\t\t\tvar _in = vector.rotate(-90).multiply(z);\n\t\t\t\t\tif (matrix) {\n\t\t\t\t\t\t_in = matrix._transformPoint(vector.add(_in))\n\t\t\t\t\t\t\t\t.subtract(pt);\n\t\t\t\t\t}\n\t\t\t\t\tsegments.push(new Segment(pt, _in, out));\n\t\t\t\t}\n\t\t\t\tvector = vector.rotate(inc);\n\t\t\t}\n\t\t\tthis._add(segments);\n\t\t},\n\n\t\tlineBy: function() {\n\t\t\tvar to = Point.read(arguments),\n\t\t\t\tcurrent = getCurrentSegment(this)._point;\n\t\t\tthis.lineTo(current.add(to));\n\t\t},\n\n\t\tcurveBy: function() {\n\t\t\tvar through = Point.read(arguments),\n\t\t\t\tto = Point.read(arguments),\n\t\t\t\tparameter = Base.read(arguments),\n\t\t\t\tcurrent = getCurrentSegment(this)._point;\n\t\t\tthis.curveTo(current.add(through), current.add(to), parameter);\n\t\t},\n\n\t\tcubicCurveBy: function() {\n\t\t\tvar handle1 = Point.read(arguments),\n\t\t\t\thandle2 = Point.read(arguments),\n\t\t\t\tto = Point.read(arguments),\n\t\t\t\tcurrent = getCurrentSegment(this)._point;\n\t\t\tthis.cubicCurveTo(current.add(handle1), current.add(handle2),\n\t\t\t\t\tcurrent.add(to));\n\t\t},\n\n\t\tquadraticCurveBy: function() {\n\t\t\tvar handle = Point.read(arguments),\n\t\t\t\tto = Point.read(arguments),\n\t\t\t\tcurrent = getCurrentSegment(this)._point;\n\t\t\tthis.quadraticCurveTo(current.add(handle), current.add(to));\n\t\t},\n\n\t\tarcBy: function() {\n\t\t\tvar current = getCurrentSegment(this)._point,\n\t\t\t\tpoint = current.add(Point.read(arguments)),\n\t\t\t\tclockwise = Base.pick(Base.peek(arguments), true);\n\t\t\tif (typeof clockwise === 'boolean') {\n\t\t\t\tthis.arcTo(point, clockwise);\n\t\t\t} else {\n\t\t\t\tthis.arcTo(point, current.add(Point.read(arguments)));\n\t\t\t}\n\t\t},\n\n\t\tclosePath: function(join) {\n\t\t\tthis.setClosed(true);\n\t\t\tif (join)\n\t\t\t\tthis.join();\n\t\t}\n\t};\n}, {\n\n\t_getBounds: function(getter, matrix) {\n\t\treturn Path[getter](this._segments, this._closed, this.getStyle(),\n\t\t\t\tmatrix);\n\t},\n\nstatics: {\n\tgetBounds: function(segments, closed, style, matrix, strokePadding) {\n\t\tvar first = segments[0];\n\t\tif (!first)\n\t\t\treturn new Rectangle();\n\t\tvar coords = new Array(6),\n\t\t\tprevCoords = first._transformCoordinates(matrix, new Array(6), false),\n\t\t\tmin = prevCoords.slice(0, 2),\n\t\t\tmax = min.slice(),\n\t\t\troots = new Array(2);\n\n\t\tfunction processSegment(segment) {\n\t\t\tsegment._transformCoordinates(matrix, coords, false);\n\t\t\tfor (var i = 0; i < 2; i++) {\n\t\t\t\tCurve._addBounds(\n\t\t\t\t\tprevCoords[i],\n\t\t\t\t\tprevCoords[i + 4],\n\t\t\t\t\tcoords[i + 2],\n\t\t\t\t\tcoords[i],\n\t\t\t\t\ti, strokePadding ? strokePadding[i] : 0, min, max, roots);\n\t\t\t}\n\t\t\tvar tmp = prevCoords;\n\t\t\tprevCoords = coords;\n\t\t\tcoords = tmp;\n\t\t}\n\n\t\tfor (var i = 1, l = segments.length; i < l; i++)\n\t\t\tprocessSegment(segments[i]);\n\t\tif (closed)\n\t\t\tprocessSegment(first);\n\t\treturn new Rectangle(min[0], min[1], max[0] - min[0], max[1] - min[1]);\n\t},\n\n\tgetStrokeBounds: function(segments, closed, style, matrix) {\n\t\tif (!style.hasStroke())\n\t\t\treturn Path.getBounds(segments, closed, style, matrix);\n\t\tvar length = segments.length - (closed ? 0 : 1),\n\t\t\tradius = style.getStrokeWidth() / 2,\n\t\t\tpadding = Path._getPenPadding(radius, matrix),\n\t\t\tbounds = Path.getBounds(segments, closed, style, matrix, padding),\n\t\t\tjoin = style.getStrokeJoin(),\n\t\t\tcap = style.getStrokeCap(),\n\t\t\tmiterLimit = radius * style.getMiterLimit();\n\t\tvar joinBounds = new Rectangle(new Size(padding).multiply(2));\n\n\t\tfunction add(point) {\n\t\t\tbounds = bounds.include(matrix\n\t\t\t\t? matrix._transformPoint(point, point) : point);\n\t\t}\n\n\t\tfunction addRound(segment) {\n\t\t\tbounds = bounds.unite(joinBounds.setCenter(matrix\n\t\t\t\t? matrix._transformPoint(segment._point) : segment._point));\n\t\t}\n\n\t\tfunction addJoin(segment, join) {\n\t\t\tvar handleIn = segment._handleIn,\n\t\t\t\thandleOut = segment._handleOut;\n\t\t\tif (join === 'round' || !handleIn.isZero() && !handleOut.isZero()\n\t\t\t\t\t&& handleIn.isCollinear(handleOut)) {\n\t\t\t\taddRound(segment);\n\t\t\t} else {\n\t\t\t\tPath._addBevelJoin(segment, join, radius, miterLimit, add);\n\t\t\t}\n\t\t}\n\n\t\tfunction addCap(segment, cap) {\n\t\t\tif (cap === 'round') {\n\t\t\t\taddRound(segment);\n\t\t\t} else {\n\t\t\t\tPath._addSquareCap(segment, cap, radius, add);\n\t\t\t}\n\t\t}\n\n\t\tfor (var i = 1; i < length; i++)\n\t\t\taddJoin(segments[i], join);\n\t\tif (closed) {\n\t\t\taddJoin(segments[0], join);\n\t\t} else if (length > 0) {\n\t\t\taddCap(segments[0], cap);\n\t\t\taddCap(segments[segments.length - 1], cap);\n\t\t}\n\t\treturn bounds;\n\t},\n\n\t_getPenPadding: function(radius, matrix) {\n\t\tif (!matrix)\n\t\t\treturn [radius, radius];\n\t\tvar mx = matrix.shiftless(),\n\t\t\thor = mx.transform(new Point(radius, 0)),\n\t\t\tver = mx.transform(new Point(0, radius)),\n\t\t\tphi = hor.getAngleInRadians(),\n\t\t\ta = hor.getLength(),\n\t\t\tb = ver.getLength();\n\t\tvar sin = Math.sin(phi),\n\t\t\tcos = Math.cos(phi),\n\t\t\ttan = Math.tan(phi),\n\t\t\ttx = -Math.atan(b * tan / a),\n\t\t\tty = Math.atan(b / (tan * a));\n\t\treturn [Math.abs(a * Math.cos(tx) * cos - b * Math.sin(tx) * sin),\n\t\t\t\tMath.abs(b * Math.sin(ty) * cos + a * Math.cos(ty) * sin)];\n\t},\n\n\t_addBevelJoin: function(segment, join, radius, miterLimit, addPoint, area) {\n\t\tvar curve2 = segment.getCurve(),\n\t\t\tcurve1 = curve2.getPrevious(),\n\t\t\tpoint = curve2.getPointAt(0, true),\n\t\t\tnormal1 = curve1.getNormalAt(1, true),\n\t\t\tnormal2 = curve2.getNormalAt(0, true),\n\t\t\tstep = normal1.getDirectedAngle(normal2) < 0 ? -radius : radius;\n\t\tnormal1.setLength(step);\n\t\tnormal2.setLength(step);\n\t\tif (area) {\n\t\t\taddPoint(point);\n\t\t\taddPoint(point.add(normal1));\n\t\t}\n\t\tif (join === 'miter') {\n\t\t\tvar corner = new Line(\n\t\t\t\t\tpoint.add(normal1),\n\t\t\t\t\tnew Point(-normal1.y, normal1.x), true\n\t\t\t\t).intersect(new Line(\n\t\t\t\t\tpoint.add(normal2),\n\t\t\t\t\tnew Point(-normal2.y, normal2.x), true\n\t\t\t\t), true);\n\t\t\tif (corner && point.getDistance(corner) <= miterLimit) {\n\t\t\t\taddPoint(corner);\n\t\t\t\tif (!area)\n\t\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tif (!area)\n\t\t\taddPoint(point.add(normal1));\n\t\taddPoint(point.add(normal2));\n\t},\n\n\t_addSquareCap: function(segment, cap, radius, addPoint, area) {\n\t\tvar point = segment._point,\n\t\t\tloc = segment.getLocation(),\n\t\t\tnormal = loc.getNormal().multiply(radius);\n\t\tif (area) {\n\t\t\taddPoint(point.subtract(normal));\n\t\t\taddPoint(point.add(normal));\n\t\t}\n\t\tif (cap === 'square')\n\t\t\tpoint = point.add(normal.rotate(loc.getParameter() === 0 ? -90 : 90));\n\t\taddPoint(point.add(normal));\n\t\taddPoint(point.subtract(normal));\n\t},\n\n\tgetHandleBounds: function(segments, closed, style, matrix, strokePadding,\n\t\t\tjoinPadding) {\n\t\tvar coords = new Array(6),\n\t\t\tx1 = Infinity,\n\t\t\tx2 = -x1,\n\t\t\ty1 = x1,\n\t\t\ty2 = x2;\n\t\tfor (var i = 0, l = segments.length; i < l; i++) {\n\t\t\tvar segment = segments[i];\n\t\t\tsegment._transformCoordinates(matrix, coords, false);\n\t\t\tfor (var j = 0; j < 6; j += 2) {\n\t\t\t\tvar padding = j === 0 ? joinPadding : strokePadding,\n\t\t\t\t\tpaddingX = padding ? padding[0] : 0,\n\t\t\t\t\tpaddingY = padding ? padding[1] : 0,\n\t\t\t\t\tx = coords[j],\n\t\t\t\t\ty = coords[j + 1],\n\t\t\t\t\txn = x - paddingX,\n\t\t\t\t\txx = x + paddingX,\n\t\t\t\t\tyn = y - paddingY,\n\t\t\t\t\tyx = y + paddingY;\n\t\t\t\tif (xn < x1) x1 = xn;\n\t\t\t\tif (xx > x2) x2 = xx;\n\t\t\t\tif (yn < y1) y1 = yn;\n\t\t\t\tif (yx > y2) y2 = yx;\n\t\t\t}\n\t\t}\n\t\treturn new Rectangle(x1, y1, x2 - x1, y2 - y1);\n\t},\n\n\tgetRoughBounds: function(segments, closed, style, matrix) {\n\t\tvar strokeRadius = style.hasStroke() ? style.getStrokeWidth() / 2 : 0,\n\t\t\tjoinRadius = strokeRadius;\n\t\tif (strokeRadius > 0) {\n\t\t\tif (style.getStrokeJoin() === 'miter')\n\t\t\t\tjoinRadius = strokeRadius * style.getMiterLimit();\n\t\t\tif (style.getStrokeCap() === 'square')\n\t\t\t\tjoinRadius = Math.max(joinRadius, strokeRadius * Math.sqrt(2));\n\t\t}\n\t\treturn Path.getHandleBounds(segments, closed, style, matrix,\n\t\t\t\tPath._getPenPadding(strokeRadius, matrix),\n\t\t\t\tPath._getPenPadding(joinRadius, matrix));\n\t}\n}});\n\nPath.inject({ statics: new function() {\n\n\tvar kappa = 0.5522847498307936,\n\t\tellipseSegments = [\n\t\t\tnew Segment([-1, 0], [0, kappa ], [0, -kappa]),\n\t\t\tnew Segment([0, -1], [-kappa, 0], [kappa, 0 ]),\n\t\t\tnew Segment([1, 0], [0, -kappa], [0, kappa ]),\n\t\t\tnew Segment([0, 1], [kappa, 0 ], [-kappa, 0])\n\t\t];\n\n\tfunction createPath(segments, closed, args) {\n\t\tvar props = Base.getNamed(args),\n\t\t\tpath = new Path(props && props.insert === false && Item.NO_INSERT);\n\t\tpath._add(segments);\n\t\tpath._closed = closed;\n\t\treturn path.set(props);\n\t}\n\n\tfunction createEllipse(center, radius, args) {\n\t\tvar segments = new Array(4);\n\t\tfor (var i = 0; i < 4; i++) {\n\t\t\tvar segment = ellipseSegments[i];\n\t\t\tsegments[i] = new Segment(\n\t\t\t\tsegment._point.multiply(radius).add(center),\n\t\t\t\tsegment._handleIn.multiply(radius),\n\t\t\t\tsegment._handleOut.multiply(radius)\n\t\t\t);\n\t\t}\n\t\treturn createPath(segments, true, args);\n\t}\n\n\treturn {\n\t\tLine: function() {\n\t\t\treturn createPath([\n\t\t\t\tnew Segment(Point.readNamed(arguments, 'from')),\n\t\t\t\tnew Segment(Point.readNamed(arguments, 'to'))\n\t\t\t], false, arguments);\n\t\t},\n\n\t\tCircle: function() {\n\t\t\tvar center = Point.readNamed(arguments, 'center'),\n\t\t\t\tradius = Base.readNamed(arguments, 'radius');\n\t\t\treturn createEllipse(center, new Size(radius), arguments);\n\t\t},\n\n\t\tRectangle: function() {\n\t\t\tvar rect = Rectangle.readNamed(arguments, 'rectangle'),\n\t\t\t\tradius = Size.readNamed(arguments, 'radius', 0,\n\t\t\t\t\t\t{ readNull: true }),\n\t\t\t\tbl = rect.getBottomLeft(true),\n\t\t\t\ttl = rect.getTopLeft(true),\n\t\t\t\ttr = rect.getTopRight(true),\n\t\t\t\tbr = rect.getBottomRight(true),\n\t\t\t\tsegments;\n\t\t\tif (!radius || radius.isZero()) {\n\t\t\t\tsegments = [\n\t\t\t\t\tnew Segment(bl),\n\t\t\t\t\tnew Segment(tl),\n\t\t\t\t\tnew Segment(tr),\n\t\t\t\t\tnew Segment(br)\n\t\t\t\t];\n\t\t\t} else {\n\t\t\t\tradius = Size.min(radius, rect.getSize(true).divide(2));\n\t\t\t\tvar rx = radius.width,\n\t\t\t\t\try = radius.height,\n\t\t\t\t\thx = rx * kappa,\n\t\t\t\t\thy = ry * kappa;\n\t\t\t\tsegments = [\n\t\t\t\t\tnew Segment(bl.add(rx, 0), null, [-hx, 0]),\n\t\t\t\t\tnew Segment(bl.subtract(0, ry), [0, hy]),\n\t\t\t\t\tnew Segment(tl.add(0, ry), null, [0, -hy]),\n\t\t\t\t\tnew Segment(tl.add(rx, 0), [-hx, 0], null),\n\t\t\t\t\tnew Segment(tr.subtract(rx, 0), null, [hx, 0]),\n\t\t\t\t\tnew Segment(tr.add(0, ry), [0, -hy], null),\n\t\t\t\t\tnew Segment(br.subtract(0, ry), null, [0, hy]),\n\t\t\t\t\tnew Segment(br.subtract(rx, 0), [hx, 0])\n\t\t\t\t];\n\t\t\t}\n\t\t\treturn createPath(segments, true, arguments);\n\t\t},\n\n\t\tRoundRectangle: '#Rectangle',\n\n\t\tEllipse: function() {\n\t\t\tvar ellipse = Shape._readEllipse(arguments);\n\t\t\treturn createEllipse(ellipse.center, ellipse.radius, arguments);\n\t\t},\n\n\t\tOval: '#Ellipse',\n\n\t\tArc: function() {\n\t\t\tvar from = Point.readNamed(arguments, 'from'),\n\t\t\t\tthrough = Point.readNamed(arguments, 'through'),\n\t\t\t\tto = Point.readNamed(arguments, 'to'),\n\t\t\t\tprops = Base.getNamed(arguments),\n\t\t\t\tpath = new Path(props && props.insert === false\n\t\t\t\t\t\t&& Item.NO_INSERT);\n\t\t\tpath.moveTo(from);\n\t\t\tpath.arcTo(through, to);\n\t\t\treturn path.set(props);\n\t\t},\n\n\t\tRegularPolygon: function() {\n\t\t\tvar center = Point.readNamed(arguments, 'center'),\n\t\t\t\tsides = Base.readNamed(arguments, 'sides'),\n\t\t\t\tradius = Base.readNamed(arguments, 'radius'),\n\t\t\t\tstep = 360 / sides,\n\t\t\t\tthree = !(sides % 3),\n\t\t\t\tvector = new Point(0, three ? -radius : radius),\n\t\t\t\toffset = three ? -1 : 0.5,\n\t\t\t\tsegments = new Array(sides);\n\t\t\tfor (var i = 0; i < sides; i++)\n\t\t\t\tsegments[i] = new Segment(center.add(\n\t\t\t\t\tvector.rotate((i + offset) * step)));\n\t\t\treturn createPath(segments, true, arguments);\n\t\t},\n\n\t\tStar: function() {\n\t\t\tvar center = Point.readNamed(arguments, 'center'),\n\t\t\t\tpoints = Base.readNamed(arguments, 'points') * 2,\n\t\t\t\tradius1 = Base.readNamed(arguments, 'radius1'),\n\t\t\t\tradius2 = Base.readNamed(arguments, 'radius2'),\n\t\t\t\tstep = 360 / points,\n\t\t\t\tvector = new Point(0, -1),\n\t\t\t\tsegments = new Array(points);\n\t\t\tfor (var i = 0; i < points; i++)\n\t\t\t\tsegments[i] = new Segment(center.add(vector.rotate(step * i)\n\t\t\t\t\t\t.multiply(i % 2 ? radius2 : radius1)));\n\t\t\treturn createPath(segments, true, arguments);\n\t\t}\n\t};\n}});\n\nvar CompoundPath = PathItem.extend({\n\t_class: 'CompoundPath',\n\t_serializeFields: {\n\t\tchildren: []\n\t},\n\n\tinitialize: function CompoundPath(arg) {\n\t\tthis._children = [];\n\t\tthis._namedChildren = {};\n\t\tif (!this._initialize(arg)) {\n\t\t\tif (typeof arg === 'string') {\n\t\t\t\tthis.setPathData(arg);\n\t\t\t} else {\n\t\t\t\tthis.addChildren(Array.isArray(arg) ? arg : arguments);\n\t\t\t}\n\t\t}\n\t},\n\n\tinsertChildren: function insertChildren(index, items, _preserve) {\n\t\tfor (var i = items.length - 1; i >= 0; i--) {\n\t\t\tvar item = items[i];\n\t\t\tif (item instanceof CompoundPath) {\n\t\t\t\titems.splice.apply(items, [i, 1].concat(item.removeChildren()));\n\t\t\t\titem.remove();\n\t\t\t}\n\t\t}\n\t\titems = insertChildren.base.call(this, index, items, _preserve, Path);\n\t\tfor (var i = 0, l = !_preserve && items && items.length; i < l; i++) {\n\t\t\tvar item = items[i];\n\t\t\tif (item._clockwise === undefined)\n\t\t\t\titem.setClockwise(item._index === 0);\n\t\t}\n\t\treturn items;\n\t},\n\n\treverse: function() {\n\t\tvar children = this._children;\n\t\tfor (var i = 0, l = children.length; i < l; i++)\n\t\t\tchildren[i].reverse();\n\t},\n\n\tsmooth: function() {\n\t\tfor (var i = 0, l = this._children.length; i < l; i++)\n\t\t\tthis._children[i].smooth();\n\t},\n\n\treduce: function reduce() {\n\t\tvar children = this._children;\n\t\tfor (var i = children.length - 1; i >= 0; i--) {\n\t\t\tvar path = children[i].reduce();\n\t\t\tif (path.isEmpty())\n\t\t\t\tchildren.splice(i, 1);\n\t\t}\n\t\tif (children.length === 0) {\n\t\t\tvar path = new Path(Item.NO_INSERT);\n\t\t\tpath.insertAbove(this);\n\t\t\tpath.setStyle(this._style);\n\t\t\tthis.remove();\n\t\t\treturn path;\n\t\t}\n\t\treturn reduce.base.call(this);\n\t},\n\n\tisClockwise: function() {\n\t\tvar child = this.getFirstChild();\n\t\treturn child && child.isClockwise();\n\t},\n\n\tsetClockwise: function(clockwise) {\n\t\tif (this.isClockwise() !== !!clockwise)\n\t\t\tthis.reverse();\n\t},\n\n\tgetFirstSegment: function() {\n\t\tvar first = this.getFirstChild();\n\t\treturn first && first.getFirstSegment();\n\t},\n\n\tgetLastSegment: function() {\n\t\tvar last = this.getLastChild();\n\t\treturn last && last.getLastSegment();\n\t},\n\n\tgetCurves: function() {\n\t\tvar children = this._children,\n\t\t\tcurves = [];\n\t\tfor (var i = 0, l = children.length; i < l; i++)\n\t\t\tcurves.push.apply(curves, children[i].getCurves());\n\t\treturn curves;\n\t},\n\n\tgetFirstCurve: function() {\n\t\tvar first = this.getFirstChild();\n\t\treturn first && first.getFirstCurve();\n\t},\n\n\tgetLastCurve: function() {\n\t\tvar last = this.getLastChild();\n\t\treturn last && last.getFirstCurve();\n\t},\n\n\tgetArea: function() {\n\t\tvar children = this._children,\n\t\t\tarea = 0;\n\t\tfor (var i = 0, l = children.length; i < l; i++)\n\t\t\tarea += children[i].getArea();\n\t\treturn area;\n\t}\n}, {\n\tbeans: true,\n\n\tgetPathData: function(_matrix, _precision) {\n\t\tvar children = this._children,\n\t\t\tpaths = [];\n\t\tfor (var i = 0, l = children.length; i < l; i++) {\n\t\t\tvar child = children[i],\n\t\t\t\tmx = child._matrix;\n\t\t\tpaths.push(child.getPathData(_matrix && !mx.isIdentity()\n\t\t\t\t\t? _matrix.chain(mx) : _matrix, _precision));\n\t\t}\n\t\treturn paths.join(' ');\n\t}\n}, {\n\t_getChildHitTestOptions: function(options) {\n\t\treturn options.class === Path || options.type === 'path'\n\t\t\t\t? options\n\t\t\t\t: new Base(options, { fill: false });\n\t},\n\n\t_draw: function(ctx, param, strokeMatrix) {\n\t\tvar children = this._children;\n\t\tif (children.length === 0)\n\t\t\treturn;\n\n\t\tif (this._currentPath) {\n\t\t\tctx.currentPath = this._currentPath;\n\t\t} else {\n\t\t\tparam = param.extend({ dontStart: true, dontFinish: true });\n\t\t\tctx.beginPath();\n\t\t\tfor (var i = 0, l = children.length; i < l; i++)\n\t\t\t\tchildren[i].draw(ctx, param, strokeMatrix);\n\t\t\tthis._currentPath = ctx.currentPath;\n\t\t}\n\n\t\tif (!param.clip) {\n\t\t\tthis._setStyles(ctx);\n\t\t\tvar style = this._style;\n\t\t\tif (style.hasFill()) {\n\t\t\t\tctx.fill(style.getWindingRule());\n\t\t\t\tctx.shadowColor = 'rgba(0,0,0,0)';\n\t\t\t}\n\t\t\tif (style.hasStroke())\n\t\t\t\tctx.stroke();\n\t\t}\n\t},\n\n\t_drawSelected: function(ctx, matrix, selectedItems) {\n\t\tvar children = this._children;\n\t\tfor (var i = 0, l = children.length; i < l; i++) {\n\t\t\tvar child = children[i],\n\t\t\t\tmx = child._matrix;\n\t\t\tif (!selectedItems[child._id])\n\t\t\t\tchild._drawSelected(ctx, mx.isIdentity() ? matrix\n\t\t\t\t\t\t: matrix.chain(mx));\n\t\t}\n\t}\n},\nnew function() {\n\tfunction getCurrentPath(that, check) {\n\t\tvar children = that._children;\n\t\tif (check && children.length === 0)\n\t\t\tthrow new Error('Use a moveTo() command first');\n\t\treturn children[children.length - 1];\n\t}\n\n\tvar fields = {\n\t\tmoveTo: function() {\n\t\t\tvar current = getCurrentPath(this),\n\t\t\t\tpath = current && current.isEmpty() ? current\n\t\t\t\t\t\t: new Path(Item.NO_INSERT);\n\t\t\tif (path !== current)\n\t\t\t\tthis.addChild(path);\n\t\t\tpath.moveTo.apply(path, arguments);\n\t\t},\n\n\t\tmoveBy: function() {\n\t\t\tvar current = getCurrentPath(this, true),\n\t\t\t\tlast = current && current.getLastSegment(),\n\t\t\t\tpoint = Point.read(arguments);\n\t\t\tthis.moveTo(last ? point.add(last._point) : point);\n\t\t},\n\n\t\tclosePath: function(join) {\n\t\t\tgetCurrentPath(this, true).closePath(join);\n\t\t}\n\t};\n\n\tBase.each(['lineTo', 'cubicCurveTo', 'quadraticCurveTo', 'curveTo', 'arcTo',\n\t\t\t'lineBy', 'cubicCurveBy', 'quadraticCurveBy', 'curveBy', 'arcBy'],\n\t\t\tfunction(key) {\n\t\t\t\tfields[key] = function() {\n\t\t\t\t\tvar path = getCurrentPath(this, true);\n\t\t\t\t\tpath[key].apply(path, arguments);\n\t\t\t\t};\n\t\t\t}\n\t);\n\n\treturn fields;\n});\n\nPathItem.inject(new function() {\n\tvar operators = {\n\t\tunite: function(w) {\n\t\t\treturn w === 1 || w === 0;\n\t\t},\n\n\t\tintersect: function(w) {\n\t\t\treturn w === 2;\n\t\t},\n\n\t\tsubtract: function(w) {\n\t\t\treturn w === 1;\n\t\t},\n\n\t\texclude: function(w) {\n\t\t\treturn w === 1;\n\t\t}\n\t};\n\n\tfunction preparePath(path, resolve) {\n\t\tvar res = path.clone(false).reduce().transform(null, true, true);\n\t\treturn resolve ? res.resolveCrossings().reorient() : res;\n\t}\n\n\tfunction finishBoolean(ctor, paths, path1, path2, reduce) {\n\t\tvar result = new ctor(Item.NO_INSERT);\n\t\tresult.addChildren(paths, true);\n\t\tif (reduce)\n\t\t\tresult = result.reduce();\n\t\tresult.insertAbove(path2 && path1.isSibling(path2)\n\t\t\t\t&& path1.getIndex() < path2.getIndex()\n\t\t\t\t\t? path2 : path1);\n\t\tresult.setStyle(path1._style);\n\t\treturn result;\n\t}\n\n\tfunction computeBoolean(path1, path2, operation) {\n\t\tif (!path1._children && !path1._closed)\n\t\t\treturn computeOpenBoolean(path1, path2, operation);\n\t\tvar _path1 = preparePath(path1, true),\n\t\t\t_path2 = path2 && path1 !== path2 && preparePath(path2, true);\n\t\tif (_path2 && /^(subtract|exclude)$/.test(operation)\n\t\t\t\t^ (_path2.isClockwise() !== _path1.isClockwise()))\n\t\t\t_path2.reverse();\n\t\tvar intersections = CurveLocation.expand(\n\t\t\t_path1.getIntersections(_path2, function(inter) {\n\t\t\t\treturn _path2 && inter.isOverlap() || inter.isCrossing();\n\t\t\t})\n\t\t);\n\t\tdivideLocations(intersections);\n\n\t\tvar segments = [],\n\t\t\tmonoCurves = [];\n\n\t\tfunction collect(paths) {\n\t\t\tfor (var i = 0, l = paths.length; i < l; i++) {\n\t\t\t\tvar path = paths[i];\n\t\t\t\tsegments.push.apply(segments, path._segments);\n\t\t\t\tmonoCurves.push.apply(monoCurves, path._getMonoCurves());\n\t\t\t}\n\t\t}\n\n\t\tcollect(_path1._children || [_path1]);\n\t\tif (_path2)\n\t\t\tcollect(_path2._children || [_path2]);\n\t\tfor (var i = 0, l = intersections.length; i < l; i++) {\n\t\t\tpropagateWinding(intersections[i]._segment, _path1, _path2,\n\t\t\t\t\tmonoCurves, operation);\n\t\t}\n\t\tfor (var i = 0, l = segments.length; i < l; i++) {\n\t\t\tvar segment = segments[i];\n\t\t\tif (segment._winding == null) {\n\t\t\t\tpropagateWinding(segment, _path1, _path2, monoCurves,\n\t\t\t\t\t\toperation);\n\t\t\t}\n\t\t}\n\t\treturn finishBoolean(CompoundPath, tracePaths(segments, operation),\n\t\t\t\tpath1, path2, true);\n\t}\n\n\tfunction computeOpenBoolean(path1, path2, operation) {\n\t\tif (!path2 || !path2._children && !path2._closed\n\t\t\t\t|| !/^(subtract|intersect)$/.test(operation))\n\t\t\treturn null;\n\t\tvar _path1 = preparePath(path1, false),\n\t\t\t_path2 = preparePath(path2, false),\n\t\t\tintersections = _path1.getIntersections(_path2, function(inter) {\n\t\t\t\treturn inter.isOverlap() || inter.isCrossing();\n\t\t\t}),\n\t\t\tsub = operation === 'subtract',\n\t\t\tpaths = [];\n\n\t\tfunction addPath(path) {\n\t\t\tif (_path2.contains(path.getPointAt(path.getLength() / 2)) ^ sub) {\n\t\t\t\tpaths.unshift(path);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\tfor (var i = intersections.length - 1; i >= 0; i--) {\n\t\t\tvar path = intersections[i].split();\n\t\t\tif (path) {\n\t\t\t\tif (addPath(path))\n\t\t\t\t\tpath.getFirstSegment().setHandleIn(0, 0);\n\t\t\t\t_path1.getLastSegment().setHandleOut(0, 0);\n\t\t\t}\n\t\t}\n\t\taddPath(_path1);\n\t\treturn finishBoolean(Group, paths, path1, path2);\n\t}\n\n\tfunction linkIntersections(from, to) {\n\t\tvar prev = from;\n\t\twhile (prev) {\n\t\t\tif (prev === to)\n\t\t\t\treturn;\n\t\t\tprev = prev._prev;\n\t\t}\n\t\twhile (from._next && from._next !== to)\n\t\t\tfrom = from._next;\n\t\tif (!from._next) {\n\t\t\twhile (to._prev)\n\t\t\t\tto = to._prev;\n\t\t\tfrom._next = to;\n\t\t\tto._prev = from;\n\t\t}\n\t}\n\n\tfunction divideLocations(locations) {\n\t\tvar tMin = 4e-7,\n\t\t\ttMax = 1 - tMin,\n\t\t\tnoHandles = false,\n\t\t\tclearSegments = [],\n\t\t\tprevCurve,\n\t\t\tprevT;\n\n\t\tfor (var i = locations.length - 1; i >= 0; i--) {\n\t\t\tvar loc = locations[i],\n\t\t\t\tcurve = loc._curve,\n\t\t\t\tt = loc._parameter,\n\t\t\t\torigT = t;\n\t\t\tif (curve !== prevCurve) {\n\t\t\t\tnoHandles = !curve.hasHandles();\n\t\t\t} else if (prevT > 0) {\n\t\t\t\tt /= prevT;\n\t\t\t}\n\t\t\tvar segment;\n\t\t\tif (t < tMin) {\n\t\t\t\tsegment = curve._segment1;\n\t\t\t} else if (t > tMax) {\n\t\t\t\tsegment = curve._segment2;\n\t\t\t} else {\n\t\t\t\tsegment = curve.divide(t, true, true)._segment1;\n\t\t\t\tif (noHandles)\n\t\t\t\t\tclearSegments.push(segment);\n\t\t\t}\n\t\t\tloc._setSegment(segment);\n\t\t\tvar inter = segment._intersection,\n\t\t\t\tdest = loc._intersection;\n\t\t\tif (inter) {\n\t\t\t\tlinkIntersections(inter, dest);\n\t\t\t\tvar other = inter;\n\t\t\t\twhile (other) {\n\t\t\t\t\tlinkIntersections(other._intersection, inter);\n\t\t\t\t\tother = other._next;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tsegment._intersection = dest;\n\t\t\t}\n\t\t\tprevCurve = curve;\n\t\t\tprevT = origT;\n\t\t}\n\t\tfor (var i = 0, l = clearSegments.length; i < l; i++) {\n\t\t\tclearSegments[i].clearHandles();\n\t\t}\n\t}\n\n\tfunction getWinding(point, curves, horizontal, testContains) {\n\t\tvar epsilon = 2e-7,\n\t\t\ttMin = 4e-7,\n\t\t\ttMax = 1 - tMin,\n\t\t\tpx = point.x,\n\t\t\tpy = point.y,\n\t\t\twindLeft = 0,\n\t\t\twindRight = 0,\n\t\t\troots = [],\n\t\t\tabs = Math.abs;\n\t\tif (horizontal) {\n\t\t\tvar yTop = -Infinity,\n\t\t\t\tyBottom = Infinity,\n\t\t\t\tyBefore = py - epsilon,\n\t\t\t\tyAfter = py + epsilon;\n\t\t\tfor (var i = 0, l = curves.length; i < l; i++) {\n\t\t\t\tvar values = curves[i].values;\n\t\t\t\tif (Curve.solveCubic(values, 0, px, roots, 0, 1) > 0) {\n\t\t\t\t\tfor (var j = roots.length - 1; j >= 0; j--) {\n\t\t\t\t\t\tvar y = Curve.getPoint(values, roots[j]).y;\n\t\t\t\t\t\tif (y < yBefore && y > yTop) {\n\t\t\t\t\t\t\tyTop = y;\n\t\t\t\t\t\t} else if (y > yAfter && y < yBottom) {\n\t\t\t\t\t\t\tyBottom = y;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tyTop = (yTop + py) / 2;\n\t\t\tyBottom = (yBottom + py) / 2;\n\t\t\tif (yTop > -Infinity)\n\t\t\t\twindLeft = getWinding(new Point(px, yTop), curves, false,\n\t\t\t\t\t\ttestContains);\n\t\t\tif (yBottom < Infinity)\n\t\t\t\twindRight = getWinding(new Point(px, yBottom), curves, false,\n\t\t\t\t\t\ttestContains);\n\t\t} else {\n\t\t\tvar xBefore = px - epsilon,\n\t\t\t\txAfter = px + epsilon;\n\t\t\tvar startCounted = false,\n\t\t\t\tprevCurve,\n\t\t\t\tprevT;\n\t\t\tfor (var i = 0, l = curves.length; i < l; i++) {\n\t\t\t\tvar curve = curves[i],\n\t\t\t\t\tvalues = curve.values,\n\t\t\t\t\twinding = curve.winding;\n\t\t\t\tif (winding && (winding === 1\n\t\t\t\t\t\t&& py >= values[1] && py <= values[7]\n\t\t\t\t\t\t|| py >= values[7] && py <= values[1])\n\t\t\t\t\t&& Curve.solveCubic(values, 1, py, roots, 0, 1) === 1) {\n\t\t\t\t\tvar t = roots[0];\n\t\t\t\t\tif (!(\n\t\t\t\t\t\tt > tMax && startCounted && curve.next !== curves[i + 1]\n\t\t\t\t\t\t|| t < tMin && prevT > tMax\n\t\t\t\t\t\t\t&& curve.previous === prevCurve)) {\n\t\t\t\t\t\tvar x = Curve.getPoint(values, t).x,\n\t\t\t\t\t\t\tslope = Curve.getTangent(values, t).y,\n\t\t\t\t\t\t\tcounted = false;\n\t\t\t\t\t\tif (Numerical.isZero(slope) && !Curve.isStraight(values)\n\t\t\t\t\t\t\t\t|| t < tMin && slope * Curve.getTangent(\n\t\t\t\t\t\t\t\t\tcurve.previous.values, 1).y < 0\n\t\t\t\t\t\t\t\t|| t > tMax && slope * Curve.getTangent(\n\t\t\t\t\t\t\t\t\tcurve.next.values, 0).y < 0) {\n\t\t\t\t\t\t\tif (testContains && x >= xBefore && x <= xAfter) {\n\t\t\t\t\t\t\t\t++windLeft;\n\t\t\t\t\t\t\t\t++windRight;\n\t\t\t\t\t\t\t\tcounted = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else if (x <= xBefore) {\n\t\t\t\t\t\t\twindLeft += winding;\n\t\t\t\t\t\t\tcounted = true;\n\t\t\t\t\t\t} else if (x >= xAfter) {\n\t\t\t\t\t\t\twindRight += winding;\n\t\t\t\t\t\t\tcounted = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (curve.previous !== curves[i - 1])\n\t\t\t\t\t\t\tstartCounted = t < tMin && counted;\n\t\t\t\t\t}\n\t\t\t\t\tprevCurve = curve;\n\t\t\t\t\tprevT = t;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn Math.max(abs(windLeft), abs(windRight));\n\t}\n\n\tfunction propagateWinding(segment, path1, path2, monoCurves, operation) {\n\t\tvar epsilon = 2e-7,\n\t\t\tchain = [],\n\t\t\tstart = segment,\n\t\t\ttotalLength = 0,\n\t\t\twindingSum = 0;\n\t\tdo {\n\t\t\tvar curve = segment.getCurve(),\n\t\t\t\tlength = curve.getLength();\n\t\t\tchain.push({ segment: segment, curve: curve, length: length });\n\t\t\ttotalLength += length;\n\t\t\tsegment = segment.getNext();\n\t\t} while (segment && !segment._intersection && segment !== start);\n\t\tfor (var i = 0; i < 3; i++) {\n\t\t\tvar length = totalLength * (i + 1) / 4;\n\t\t\tfor (var k = 0, m = chain.length; k < m; k++) {\n\t\t\t\tvar node = chain[k],\n\t\t\t\t\tcurveLength = node.length;\n\t\t\t\tif (length <= curveLength) {\n\t\t\t\t\tif (length < epsilon || curveLength - length < epsilon)\n\t\t\t\t\t\tlength = curveLength / 2;\n\t\t\t\t\tvar curve = node.curve,\n\t\t\t\t\t\tpath = curve._path,\n\t\t\t\t\t\tparent = path._parent,\n\t\t\t\t\t\tpt = curve.getPointAt(length),\n\t\t\t\t\t\thor = curve.isHorizontal();\n\t\t\t\t\tif (parent instanceof CompoundPath)\n\t\t\t\t\t\tpath = parent;\n\t\t\t\t\twindingSum += operation === 'subtract' && path2\n\t\t\t\t\t\t&& (path === path1 && path2._getWinding(pt, hor)\n\t\t\t\t\t\t|| path === path2 && !path1._getWinding(pt, hor))\n\t\t\t\t\t\t? 0\n\t\t\t\t\t\t: getWinding(pt, monoCurves, hor);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tlength -= curveLength;\n\t\t\t}\n\t\t}\n\t\tvar winding = Math.round(windingSum / 3);\n\t\tfor (var j = chain.length - 1; j >= 0; j--)\n\t\t\tchain[j].segment._winding = winding;\n\t}\n\n\tfunction tracePaths(segments, operation) {\n\t\tvar paths = [],\n\t\t\tstart,\n\t\t\totherStart,\n\t\t\toperator = operators[operation],\n\t\t\toverlapWinding = {\n\t\t\t\tunite: { 1: 2 },\n\t\t\t\tintersect: { 2: 1 }\n\t\t\t}[operation];\n\n\t\tfunction isValid(seg, adjusted) {\n\t\t\tif (seg._visited)\n\t\t\t\treturn false;\n\t\t\tif (!operator)\n\t\t\t\treturn true;\n\t\t\tvar winding = seg._winding,\n\t\t\t\tinter = seg._intersection;\n\t\t\tif (inter && adjusted && overlapWinding && inter.isOverlap())\n\t\t\t\twinding = overlapWinding[winding] || winding;\n\t\t\treturn operator(winding);\n\t\t}\n\n\t\tfunction isStart(seg) {\n\t\t\treturn seg === start || seg === otherStart;\n\t\t}\n\n\t\tfunction findBestIntersection(inter, strict) {\n\t\t\tif (!inter._next)\n\t\t\t\treturn inter;\n\t\t\twhile (inter) {\n\t\t\t\tvar seg = inter._segment,\n\t\t\t\t\tnextSeg = seg.getNext(),\n\t\t\t\t\tnextInter = nextSeg._intersection;\n\t\t\t\tif (isStart(nextSeg)\n\t\t\t\t\t|| !seg._visited && !nextSeg._visited\n\t\t\t\t\t&& (!operator\n\t\t\t\t\t\t|| (!strict || isValid(seg))\n\t\t\t\t\t\t&& (!(strict && nextInter && nextInter.isOverlap())\n\t\t\t\t\t\t\t&& isValid(nextSeg)\n\t\t\t\t\t\t\t|| !strict && nextInter\n\t\t\t\t\t\t\t&& isValid(nextInter._segment))\n\t\t\t\t\t))\n\t\t\t\t\treturn inter;\n\t\t\t\tinter = inter._next;\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\n\t\tfunction findStartSegment(inter, next) {\n\t\t\twhile (inter) {\n\t\t\t\tvar seg = inter._segment;\n\t\t\t\tif (isStart(seg))\n\t\t\t\t\treturn seg;\n\t\t\t\tinter = inter[next ? '_next' : '_prev'];\n\t\t\t}\n\t\t}\n\n\t\tfor (var i = 0, l = segments.length; i < l; i++) {\n\t\t\tvar seg = segments[i],\n\t\t\t\tpath = null,\n\t\t\t\tfinished = false;\n\t\t\tif (!isValid(seg, true))\n\t\t\t\tcontinue;\n\t\t\tstart = otherStart = null;\n\t\t\twhile (!finished) {\n\t\t\t\tvar inter = seg._intersection,\n\t\t\t\t\thandleIn = path && seg._handleIn;\n\t\t\t\tinter = inter && (findBestIntersection(inter, true)\n\t\t\t\t\t\t|| findBestIntersection(inter, false)) || inter;\n\t\t\t\tvar other = inter && inter._segment;\n\t\t\t\tif (other && isValid(other))\n\t\t\t\t\tseg = other;\n\t\t\t\tif (seg._visited) {\n\t\t\t\t\tfinished = isStart(seg);\n\t\t\t\t\tif (!finished && inter) {\n\t\t\t\t\t\tvar found = findStartSegment(inter, true)\n\t\t\t\t\t\t\t|| findStartSegment(inter, false);\n\t\t\t\t\t\tif (found) {\n\t\t\t\t\t\t\tseg = found;\n\t\t\t\t\t\t\tfinished = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (!path) {\n\t\t\t\t\tpath = new Path(Item.NO_INSERT);\n\t\t\t\t\tstart = seg;\n\t\t\t\t\totherStart = other;\n\t\t\t\t}\n\t\t\t\tpath.add(new Segment(seg._point, handleIn, seg._handleOut));\n\t\t\t\tseg._visited = true;\n\t\t\t\tseg = seg.getNext();\n\t\t\t\tfinished = isStart(seg);\n\t\t\t}\n\t\t\tif (finished) {\n\t\t\t\tpath.firstSegment.setHandleIn(seg._handleIn);\n\t\t\t\tpath.setClosed(true);\n\t\t\t} else if (path) {\n\t\t\t\tconsole.error('Boolean operation resulted in open path',\n\t\t\t\t\t\t'segments =', path._segments.length,\n\t\t\t\t\t\t'length =', path.getLength());\n\t\t\t\tpath = null;\n\t\t\t}\n\t\t\tif (path && (path._segments.length > 8\n\t\t\t\t\t|| !Numerical.isZero(path.getArea()))) {\n\t\t\t\tpaths.push(path);\n\t\t\t\tpath = null;\n\t\t\t}\n\t\t}\n\t\treturn paths;\n\t}\n\n\treturn {\n\t\t_getWinding: function(point, horizontal, testContains) {\n\t\t\treturn getWinding(point, this._getMonoCurves(),\n\t\t\t\t\thorizontal, testContains);\n\t\t},\n\n\t\tunite: function(path) {\n\t\t\treturn computeBoolean(this, path, 'unite');\n\t\t},\n\n\t\tintersect: function(path) {\n\t\t\treturn computeBoolean(this, path, 'intersect');\n\t\t},\n\n\t\tsubtract: function(path) {\n\t\t\treturn computeBoolean(this, path, 'subtract');\n\t\t},\n\n\t\texclude: function(path) {\n\t\t\treturn computeBoolean(this, path, 'exclude');\n\t\t},\n\n\t\tdivide: function(path) {\n\t\t\treturn finishBoolean(Group,\n\t\t\t\t\t[this.subtract(path), this.intersect(path)],\n\t\t\t\t\tthis, path, true);\n\t\t},\n\n\t\tresolveCrossings: function() {\n\t\t\tvar crossings = this.getCrossings();\n\t\t\tif (!crossings.length)\n\t\t\t\treturn this;\n\t\t\tdivideLocations(CurveLocation.expand(crossings));\n\t\t\tvar paths = this._children || [this],\n\t\t\t\tsegments = [];\n\t\t\tfor (var i = 0, l = paths.length; i < l; i++) {\n\t\t\t\tsegments.push.apply(segments, paths[i]._segments);\n\t\t\t}\n\t\t\treturn finishBoolean(CompoundPath, tracePaths(segments),\n\t\t\t\t\tthis, null, false);\n\t\t}\n\t};\n});\n\nPath.inject({\n\t_getMonoCurves: function() {\n\t\tvar monoCurves = this._monoCurves,\n\t\t\tprevCurve;\n\n\t\tfunction insertCurve(v) {\n\t\t\tvar y0 = v[1],\n\t\t\t\ty1 = v[7],\n\t\t\t\tcurve = {\n\t\t\t\t\tvalues: v,\n\t\t\t\t\twinding: y0 === y1\n\t\t\t\t\t\t? 0\n\t\t\t\t\t\t: y0 > y1\n\t\t\t\t\t\t\t? -1\n\t\t\t\t\t\t\t: 1,\n\t\t\t\t\tprevious: prevCurve,\n\t\t\t\t\tnext: null\n\t\t\t\t};\n\t\t\tif (prevCurve)\n\t\t\t\tprevCurve.next = curve;\n\t\t\tmonoCurves.push(curve);\n\t\t\tprevCurve = curve;\n\t\t}\n\n\t\tfunction handleCurve(v) {\n\t\t\tif (Curve.getLength(v) === 0)\n\t\t\t\treturn;\n\t\t\tvar y0 = v[1],\n\t\t\t\ty1 = v[3],\n\t\t\t\ty2 = v[5],\n\t\t\t\ty3 = v[7];\n\t\t\tif (Curve.isStraight(v)) {\n\t\t\t\tinsertCurve(v);\n\t\t\t} else {\n\t\t\t\tvar a = 3 * (y1 - y2) - y0 + y3,\n\t\t\t\t\tb = 2 * (y0 + y2) - 4 * y1,\n\t\t\t\t\tc = y1 - y0,\n\t\t\t\t\ttMin = 4e-7,\n\t\t\t\t\ttMax = 1 - tMin,\n\t\t\t\t\troots = [],\n\t\t\t\t\tn = Numerical.solveQuadratic(a, b, c, roots, tMin, tMax);\n\t\t\t\tif (n === 0) {\n\t\t\t\t\tinsertCurve(v);\n\t\t\t\t} else {\n\t\t\t\t\troots.sort();\n\t\t\t\t\tvar t = roots[0],\n\t\t\t\t\t\tparts = Curve.subdivide(v, t);\n\t\t\t\t\tinsertCurve(parts[0]);\n\t\t\t\t\tif (n > 1) {\n\t\t\t\t\t\tt = (roots[1] - t) / (1 - t);\n\t\t\t\t\t\tparts = Curve.subdivide(parts[1], t);\n\t\t\t\t\t\tinsertCurve(parts[0]);\n\t\t\t\t\t}\n\t\t\t\t\tinsertCurve(parts[1]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (!monoCurves) {\n\t\t\tmonoCurves = this._monoCurves = [];\n\t\t\tvar curves = this.getCurves(),\n\t\t\t\tsegments = this._segments;\n\t\t\tfor (var i = 0, l = curves.length; i < l; i++)\n\t\t\t\thandleCurve(curves[i].getValues());\n\t\t\tif (!this._closed && segments.length > 1) {\n\t\t\t\tvar p1 = segments[segments.length - 1]._point,\n\t\t\t\t\tp2 = segments[0]._point,\n\t\t\t\t\tp1x = p1._x, p1y = p1._y,\n\t\t\t\t\tp2x = p2._x, p2y = p2._y;\n\t\t\t\thandleCurve([p1x, p1y, p1x, p1y, p2x, p2y, p2x, p2y]);\n\t\t\t}\n\t\t\tif (monoCurves.length > 0) {\n\t\t\t\tvar first = monoCurves[0],\n\t\t\t\t\tlast = monoCurves[monoCurves.length - 1];\n\t\t\t\tfirst.previous = last;\n\t\t\t\tlast.next = first;\n\t\t\t}\n\t\t}\n\t\treturn monoCurves;\n\t},\n\n\tgetInteriorPoint: function() {\n\t\tvar bounds = this.getBounds(),\n\t\t\tpoint = bounds.getCenter(true);\n\t\tif (!this.contains(point)) {\n\t\t\tvar curves = this._getMonoCurves(),\n\t\t\t\troots = [],\n\t\t\t\ty = point.y,\n\t\t\t\txIntercepts = [];\n\t\t\tfor (var i = 0, l = curves.length; i < l; i++) {\n\t\t\t\tvar values = curves[i].values;\n\t\t\t\tif ((curves[i].winding === 1\n\t\t\t\t\t\t&& y >= values[1] && y <= values[7]\n\t\t\t\t\t\t|| y >= values[7] && y <= values[1])\n\t\t\t\t\t\t&& Curve.solveCubic(values, 1, y, roots, 0, 1) > 0) {\n\t\t\t\t\tfor (var j = roots.length - 1; j >= 0; j--)\n\t\t\t\t\t\txIntercepts.push(Curve.getPoint(values, roots[j]).x);\n\t\t\t\t}\n\t\t\t\tif (xIntercepts.length > 1)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tpoint.x = (xIntercepts[0] + xIntercepts[1]) / 2;\n\t\t}\n\t\treturn point;\n\t},\n\n\treorient: function() {\n\t\tthis.setClockwise(true);\n\t\treturn this;\n\t}\n});\n\nCompoundPath.inject({\n\t_getMonoCurves: function() {\n\t\tvar children = this._children,\n\t\t\tmonoCurves = [];\n\t\tfor (var i = 0, l = children.length; i < l; i++)\n\t\t\tmonoCurves.push.apply(monoCurves, children[i]._getMonoCurves());\n\t\treturn monoCurves;\n\t},\n\n\treorient: function() {\n\t\tvar children = this.removeChildren().sort(function(a, b) {\n\t\t\treturn b.getBounds().getArea() - a.getBounds().getArea();\n\t\t});\n\t\tif (children.length > 0) {\n\t\t\tthis.addChildren(children);\n\t\t\tvar clockwise = children[0].isClockwise();\n\t\t\tfor (var i = 1, l = children.length; i < l; i++) {\n\t\t\t\tvar point = children[i].getInteriorPoint(),\n\t\t\t\t\tcounters = 0;\n\t\t\t\tfor (var j = i - 1; j >= 0; j--) {\n\t\t\t\t\tif (children[j].contains(point))\n\t\t\t\t\t\tcounters++;\n\t\t\t\t}\n\t\t\t\tchildren[i].setClockwise(counters % 2 === 0 && clockwise);\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t}\n});\n\nvar PathIterator = Base.extend({\n\t_class: 'PathIterator',\n\n\tinitialize: function(path, maxRecursion, tolerance, matrix) {\n\t\tvar curves = [],\n\t\t\tparts = [],\n\t\t\tlength = 0,\n\t\t\tminDifference = 1 / (maxRecursion || 32),\n\t\t\tsegments = path._segments,\n\t\t\tsegment1 = segments[0],\n\t\t\tsegment2;\n\n\t\tfunction addCurve(segment1, segment2) {\n\t\t\tvar curve = Curve.getValues(segment1, segment2, matrix);\n\t\t\tcurves.push(curve);\n\t\t\tcomputeParts(curve, segment1._index, 0, 1);\n\t\t}\n\n\t\tfunction computeParts(curve, index, minT, maxT) {\n\t\t\tif ((maxT - minT) > minDifference\n\t\t\t\t\t&& !Curve.isFlatEnough(curve, tolerance || 0.25)) {\n\t\t\t\tvar split = Curve.subdivide(curve, 0.5),\n\t\t\t\t\thalfT = (minT + maxT) / 2;\n\t\t\t\tcomputeParts(split[0], index, minT, halfT);\n\t\t\t\tcomputeParts(split[1], index, halfT, maxT);\n\t\t\t} else {\n\t\t\t\tvar x = curve[6] - curve[0],\n\t\t\t\t\ty = curve[7] - curve[1],\n\t\t\t\t\tdist = Math.sqrt(x * x + y * y);\n\t\t\t\tif (dist > 1e-6) {\n\t\t\t\t\tlength += dist;\n\t\t\t\t\tparts.push({\n\t\t\t\t\t\toffset: length,\n\t\t\t\t\t\tvalue: maxT,\n\t\t\t\t\t\tindex: index\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (var i = 1, l = segments.length; i < l; i++) {\n\t\t\tsegment2 = segments[i];\n\t\t\taddCurve(segment1, segment2);\n\t\t\tsegment1 = segment2;\n\t\t}\n\t\tif (path._closed)\n\t\t\taddCurve(segment2, segments[0]);\n\n\t\tthis.curves = curves;\n\t\tthis.parts = parts;\n\t\tthis.length = length;\n\t\tthis.index = 0;\n\t},\n\n\tgetParameterAt: function(offset) {\n\t\tvar i, j = this.index;\n\t\tfor (;;) {\n\t\t\ti = j;\n\t\t\tif (j == 0 || this.parts[--j].offset < offset)\n\t\t\t\tbreak;\n\t\t}\n\t\tfor (var l = this.parts.length; i < l; i++) {\n\t\t\tvar part = this.parts[i];\n\t\t\tif (part.offset >= offset) {\n\t\t\t\tthis.index = i;\n\t\t\t\tvar prev = this.parts[i - 1];\n\t\t\t\tvar prevVal = prev && prev.index == part.index ? prev.value : 0,\n\t\t\t\t\tprevLen = prev ? prev.offset : 0;\n\t\t\t\treturn {\n\t\t\t\t\tvalue: prevVal + (part.value - prevVal)\n\t\t\t\t\t\t* (offset - prevLen) / (part.offset - prevLen),\n\t\t\t\t\tindex: part.index\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\t\tvar part = this.parts[this.parts.length - 1];\n\t\treturn {\n\t\t\tvalue: 1,\n\t\t\tindex: part.index\n\t\t};\n\t},\n\n\tdrawPart: function(ctx, from, to) {\n\t\tfrom = this.getParameterAt(from);\n\t\tto = this.getParameterAt(to);\n\t\tfor (var i = from.index; i <= to.index; i++) {\n\t\t\tvar curve = Curve.getPart(this.curves[i],\n\t\t\t\t\ti == from.index ? from.value : 0,\n\t\t\t\t\ti == to.index ? to.value : 1);\n\t\t\tif (i == from.index)\n\t\t\t\tctx.moveTo(curve[0], curve[1]);\n\t\t\tctx.bezierCurveTo.apply(ctx, curve.slice(2));\n\t\t}\n\t}\n}, Base.each(Curve.evaluateMethods,\n\tfunction(name) {\n\t\tthis[name + 'At'] = function(offset, weighted) {\n\t\t\tvar param = this.getParameterAt(offset);\n\t\t\treturn Curve[name](this.curves[param.index], param.value, weighted);\n\t\t};\n\t}, {})\n);\n\nvar PathFitter = Base.extend({\n\tinitialize: function(path, error) {\n\t\tvar points = this.points = [],\n\t\t\tsegments = path._segments,\n\t\t\tprev;\n\t\tfor (var i = 0, l = segments.length; i < l; i++) {\n\t\t\tvar point = segments[i].point.clone();\n\t\t\tif (!prev || !prev.equals(point)) {\n\t\t\t\tpoints.push(point);\n\t\t\t\tprev = point;\n\t\t\t}\n\t\t}\n\n\t\tif (path._closed) {\n\t\t\tthis.closed = true;\n\t\t\tpoints.unshift(points[points.length - 1]);\n\t\t\tpoints.push(points[1]);\n\t\t}\n\n\t\tthis.error = error;\n\t},\n\n\tfit: function() {\n\t\tvar points = this.points,\n\t\t\tlength = points.length,\n\t\t\tsegments = this.segments = length > 0\n\t\t\t\t\t? [new Segment(points[0])] : [];\n\t\tif (length > 1)\n\t\t\tthis.fitCubic(0, length - 1,\n\t\t\t\tpoints[1].subtract(points[0]).normalize(),\n\t\t\t\tpoints[length - 2].subtract(points[length - 1]).normalize());\n\n\t\tif (this.closed) {\n\t\t\tsegments.shift();\n\t\t\tsegments.pop();\n\t\t}\n\n\t\treturn segments;\n\t},\n\n\tfitCubic: function(first, last, tan1, tan2) {\n\t\tif (last - first == 1) {\n\t\t\tvar pt1 = this.points[first],\n\t\t\t\tpt2 = this.points[last],\n\t\t\t\tdist = pt1.getDistance(pt2) / 3;\n\t\t\tthis.addCurve([pt1, pt1.add(tan1.normalize(dist)),\n\t\t\t\t\tpt2.add(tan2.normalize(dist)), pt2]);\n\t\t\treturn;\n\t\t}\n\t\tvar uPrime = this.chordLengthParameterize(first, last),\n\t\t\tmaxError = Math.max(this.error, this.error * this.error),\n\t\t\tsplit,\n\t\t\tparametersInOrder = true;\n\t\tfor (var i = 0; i <= 4; i++) {\n\t\t\tvar curve = this.generateBezier(first, last, uPrime, tan1, tan2);\n\t\t\tvar max = this.findMaxError(first, last, curve, uPrime);\n\t\t\tif (max.error < this.error && parametersInOrder) {\n\t\t\t\tthis.addCurve(curve);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tsplit = max.index;\n\t\t\tif (max.error >= maxError)\n\t\t\t\tbreak;\n\t\t\tparametersInOrder = this.reparameterize(first, last, uPrime, curve);\n\t\t\tmaxError = max.error;\n\t\t}\n\t\tvar V1 = this.points[split - 1].subtract(this.points[split]),\n\t\t\tV2 = this.points[split].subtract(this.points[split + 1]),\n\t\t\ttanCenter = V1.add(V2).divide(2).normalize();\n\t\tthis.fitCubic(first, split, tan1, tanCenter);\n\t\tthis.fitCubic(split, last, tanCenter.negate(), tan2);\n\t},\n\n\taddCurve: function(curve) {\n\t\tvar prev = this.segments[this.segments.length - 1];\n\t\tprev.setHandleOut(curve[1].subtract(curve[0]));\n\t\tthis.segments.push(\n\t\t\t\tnew Segment(curve[3], curve[2].subtract(curve[3])));\n\t},\n\n\tgenerateBezier: function(first, last, uPrime, tan1, tan2) {\n\t\tvar epsilon = 1e-12,\n\t\t\tpt1 = this.points[first],\n\t\t\tpt2 = this.points[last],\n\t\t\tC = [[0, 0], [0, 0]],\n\t\t\tX = [0, 0];\n\n\t\tfor (var i = 0, l = last - first + 1; i < l; i++) {\n\t\t\tvar u = uPrime[i],\n\t\t\t\tt = 1 - u,\n\t\t\t\tb = 3 * u * t,\n\t\t\t\tb0 = t * t * t,\n\t\t\t\tb1 = b * t,\n\t\t\t\tb2 = b * u,\n\t\t\t\tb3 = u * u * u,\n\t\t\t\ta1 = tan1.normalize(b1),\n\t\t\t\ta2 = tan2.normalize(b2),\n\t\t\t\ttmp = this.points[first + i]\n\t\t\t\t\t.subtract(pt1.multiply(b0 + b1))\n\t\t\t\t\t.subtract(pt2.multiply(b2 + b3));\n\t\t\tC[0][0] += a1.dot(a1);\n\t\t\tC[0][1] += a1.dot(a2);\n\t\t\tC[1][0] = C[0][1];\n\t\t\tC[1][1] += a2.dot(a2);\n\t\t\tX[0] += a1.dot(tmp);\n\t\t\tX[1] += a2.dot(tmp);\n\t\t}\n\n\t\tvar detC0C1 = C[0][0] * C[1][1] - C[1][0] * C[0][1],\n\t\t\talpha1, alpha2;\n\t\tif (Math.abs(detC0C1) > epsilon) {\n\t\t\tvar detC0X\t= C[0][0] * X[1]\t- C[1][0] * X[0],\n\t\t\t\tdetXC1\t= X[0]\t  * C[1][1] - X[1]\t  * C[0][1];\n\t\t\talpha1 = detXC1 / detC0C1;\n\t\t\talpha2 = detC0X / detC0C1;\n\t\t} else {\n\t\t\tvar c0 = C[0][0] + C[0][1],\n\t\t\t\tc1 = C[1][0] + C[1][1];\n\t\t\tif (Math.abs(c0) > epsilon) {\n\t\t\t\talpha1 = alpha2 = X[0] / c0;\n\t\t\t} else if (Math.abs(c1) > epsilon) {\n\t\t\t\talpha1 = alpha2 = X[1] / c1;\n\t\t\t} else {\n\t\t\t\talpha1 = alpha2 = 0;\n\t\t\t}\n\t\t}\n\n\t\tvar segLength = pt2.getDistance(pt1),\n\t\t\teps = epsilon * segLength,\n\t\t\thandle1,\n\t\t\thandle2;\n\t\tif (alpha1 < eps || alpha2 < eps) {\n\t\t\talpha1 = alpha2 = segLength / 3;\n\t\t} else {\n\t\t\tvar line = pt2.subtract(pt1);\n\t\t\thandle1 = tan1.normalize(alpha1);\n\t\t\thandle2 = tan2.normalize(alpha2);\n\t\t\tif (handle1.dot(line) - handle2.dot(line) > segLength * segLength) {\n\t\t\t\talpha1 = alpha2 = segLength / 3;\n\t\t\t\thandle1 = handle2 = null;\n\t\t\t}\n\t\t}\n\n\t\treturn [pt1, pt1.add(handle1 || tan1.normalize(alpha1)),\n\t\t\t\tpt2.add(handle2 || tan2.normalize(alpha2)), pt2];\n\t},\n\n\treparameterize: function(first, last, u, curve) {\n\t\tfor (var i = first; i <= last; i++) {\n\t\t\tu[i - first] = this.findRoot(curve, this.points[i], u[i - first]);\n\t\t}\n\t\tfor (var i = 1, l = u.length; i < l; i++) {\n\t\t\tif (u[i] <= u[i - 1])\n\t\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t},\n\n\tfindRoot: function(curve, point, u) {\n\t\tvar curve1 = [],\n\t\t\tcurve2 = [];\n\t\tfor (var i = 0; i <= 2; i++) {\n\t\t\tcurve1[i] = curve[i + 1].subtract(curve[i]).multiply(3);\n\t\t}\n\t\tfor (var i = 0; i <= 1; i++) {\n\t\t\tcurve2[i] = curve1[i + 1].subtract(curve1[i]).multiply(2);\n\t\t}\n\t\tvar pt = this.evaluate(3, curve, u),\n\t\t\tpt1 = this.evaluate(2, curve1, u),\n\t\t\tpt2 = this.evaluate(1, curve2, u),\n\t\t\tdiff = pt.subtract(point),\n\t\t\tdf = pt1.dot(pt1) + diff.dot(pt2);\n\t\tif (Math.abs(df) < 1e-6)\n\t\t\treturn u;\n\t\treturn u - diff.dot(pt1) / df;\n\t},\n\n\tevaluate: function(degree, curve, t) {\n\t\tvar tmp = curve.slice();\n\t\tfor (var i = 1; i <= degree; i++) {\n\t\t\tfor (var j = 0; j <= degree - i; j++) {\n\t\t\t\ttmp[j] = tmp[j].multiply(1 - t).add(tmp[j + 1].multiply(t));\n\t\t\t}\n\t\t}\n\t\treturn tmp[0];\n\t},\n\n\tchordLengthParameterize: function(first, last) {\n\t\tvar u = [0];\n\t\tfor (var i = first + 1; i <= last; i++) {\n\t\t\tu[i - first] = u[i - first - 1]\n\t\t\t\t\t+ this.points[i].getDistance(this.points[i - 1]);\n\t\t}\n\t\tfor (var i = 1, m = last - first; i <= m; i++) {\n\t\t\tu[i] /= u[m];\n\t\t}\n\t\treturn u;\n\t},\n\n\tfindMaxError: function(first, last, curve, u) {\n\t\tvar index = Math.floor((last - first + 1) / 2),\n\t\t\tmaxDist = 0;\n\t\tfor (var i = first + 1; i < last; i++) {\n\t\t\tvar P = this.evaluate(3, curve, u[i - first]);\n\t\t\tvar v = P.subtract(this.points[i]);\n\t\t\tvar dist = v.x * v.x + v.y * v.y;\n\t\t\tif (dist >= maxDist) {\n\t\t\t\tmaxDist = dist;\n\t\t\t\tindex = i;\n\t\t\t}\n\t\t}\n\t\treturn {\n\t\t\terror: maxDist,\n\t\t\tindex: index\n\t\t};\n\t}\n});\n\nvar TextItem = Item.extend({\n\t_class: 'TextItem',\n\t_boundsSelected: true,\n\t_applyMatrix: false,\n\t_canApplyMatrix: false,\n\t_serializeFields: {\n\t\tcontent: null\n\t},\n\t_boundsGetter: 'getBounds',\n\n\tinitialize: function TextItem(arg) {\n\t\tthis._content = '';\n\t\tthis._lines = [];\n\t\tvar hasProps = arg && Base.isPlainObject(arg)\n\t\t\t\t&& arg.x === undefined && arg.y === undefined;\n\t\tthis._initialize(hasProps && arg, !hasProps && Point.read(arguments));\n\t},\n\n\t_equals: function(item) {\n\t\treturn this._content === item._content;\n\t},\n\n\t_clone: function _clone(copy, insert, includeMatrix) {\n\t\tcopy.setContent(this._content);\n\t\treturn _clone.base.call(this, copy, insert, includeMatrix);\n\t},\n\n\tgetContent: function() {\n\t\treturn this._content;\n\t},\n\n\tsetContent: function(content) {\n\t\tthis._content = '' + content;\n\t\tthis._lines = this._content.split(/\\r\\n|\\n|\\r/mg);\n\t\tthis._changed(265);\n\t},\n\n\tisEmpty: function() {\n\t\treturn !this._content;\n\t},\n\n\tgetCharacterStyle: '#getStyle',\n\tsetCharacterStyle: '#setStyle',\n\n\tgetParagraphStyle: '#getStyle',\n\tsetParagraphStyle: '#setStyle'\n});\n\nvar PointText = TextItem.extend({\n\t_class: 'PointText',\n\n\tinitialize: function PointText() {\n\t\tTextItem.apply(this, arguments);\n\t},\n\n\tclone: function(insert) {\n\t\treturn this._clone(new PointText(Item.NO_INSERT), insert);\n\t},\n\n\tgetPoint: function() {\n\t\tvar point = this._matrix.getTranslation();\n\t\treturn new LinkedPoint(point.x, point.y, this, 'setPoint');\n\t},\n\n\tsetPoint: function() {\n\t\tvar point = Point.read(arguments);\n\t\tthis.translate(point.subtract(this._matrix.getTranslation()));\n\t},\n\n\t_draw: function(ctx) {\n\t\tif (!this._content)\n\t\t\treturn;\n\t\tthis._setStyles(ctx);\n\t\tvar style = this._style,\n\t\t\tlines = this._lines,\n\t\t\tleading = style.getLeading(),\n\t\t\tshadowColor = ctx.shadowColor;\n\t\tctx.font = style.getFontStyle();\n\t\tctx.textAlign = style.getJustification();\n\t\tfor (var i = 0, l = lines.length; i < l; i++) {\n\t\t\tctx.shadowColor = shadowColor;\n\t\t\tvar line = lines[i];\n\t\t\tif (style.hasFill()) {\n\t\t\t\tctx.fillText(line, 0, 0);\n\t\t\t\tctx.shadowColor = 'rgba(0,0,0,0)';\n\t\t\t}\n\t\t\tif (style.hasStroke())\n\t\t\t\tctx.strokeText(line, 0, 0);\n\t\t\tctx.translate(0, leading);\n\t\t}\n\t},\n\n\t_getBounds: function(getter, matrix) {\n\t\tvar style = this._style,\n\t\t\tlines = this._lines,\n\t\t\tnumLines = lines.length,\n\t\t\tjustification = style.getJustification(),\n\t\t\tleading = style.getLeading(),\n\t\t\twidth = this.getView().getTextWidth(style.getFontStyle(), lines),\n\t\t\tx = 0;\n\t\tif (justification !== 'left')\n\t\t\tx -= width / (justification === 'center' ? 2: 1);\n\t\tvar bounds = new Rectangle(x,\n\t\t\t\t\tnumLines ? - 0.75 * leading : 0,\n\t\t\t\t\twidth, numLines * leading);\n\t\treturn matrix ? matrix._transformBounds(bounds, bounds) : bounds;\n\t}\n});\n\nvar Color = Base.extend(new function() {\n\tvar types = {\n\t\tgray: ['gray'],\n\t\trgb: ['red', 'green', 'blue'],\n\t\thsb: ['hue', 'saturation', 'brightness'],\n\t\thsl: ['hue', 'saturation', 'lightness'],\n\t\tgradient: ['gradient', 'origin', 'destination', 'highlight']\n\t};\n\n\tvar componentParsers = {},\n\t\tcolorCache = {},\n\t\tcolorCtx;\n\n\tfunction fromCSS(string) {\n\t\tvar match = string.match(/^#(\\w{1,2})(\\w{1,2})(\\w{1,2})$/),\n\t\t\tcomponents;\n\t\tif (match) {\n\t\t\tcomponents = [0, 0, 0];\n\t\t\tfor (var i = 0; i < 3; i++) {\n\t\t\t\tvar value = match[i + 1];\n\t\t\t\tcomponents[i] = parseInt(value.length == 1\n\t\t\t\t\t\t? value + value : value, 16) / 255;\n\t\t\t}\n\t\t} else if (match = string.match(/^rgba?\\((.*)\\)$/)) {\n\t\t\tcomponents = match[1].split(',');\n\t\t\tfor (var i = 0, l = components.length; i < l; i++) {\n\t\t\t\tvar value = +components[i];\n\t\t\t\tcomponents[i] = i < 3 ? value / 255 : value;\n\t\t\t}\n\t\t} else {\n\t\t\tvar cached = colorCache[string];\n\t\t\tif (!cached) {\n\t\t\t\tif (!colorCtx) {\n\t\t\t\t\tcolorCtx = CanvasProvider.getContext(1, 1);\n\t\t\t\t\tcolorCtx.globalCompositeOperation = 'copy';\n\t\t\t\t}\n\t\t\t\tcolorCtx.fillStyle = 'rgba(0,0,0,0)';\n\t\t\t\tcolorCtx.fillStyle = string;\n\t\t\t\tcolorCtx.fillRect(0, 0, 1, 1);\n\t\t\t\tvar data = colorCtx.getImageData(0, 0, 1, 1).data;\n\t\t\t\tcached = colorCache[string] = [\n\t\t\t\t\tdata[0] / 255,\n\t\t\t\t\tdata[1] / 255,\n\t\t\t\t\tdata[2] / 255\n\t\t\t\t];\n\t\t\t}\n\t\t\tcomponents = cached.slice();\n\t\t}\n\t\treturn components;\n\t}\n\n\tvar hsbIndices = [\n\t\t[0, 3, 1],\n\t\t[2, 0, 1],\n\t\t[1, 0, 3],\n\t\t[1, 2, 0],\n\t\t[3, 1, 0],\n\t\t[0, 1, 2]\n\t];\n\n\tvar converters = {\n\t\t'rgb-hsb': function(r, g, b) {\n\t\t\tvar max = Math.max(r, g, b),\n\t\t\t\tmin = Math.min(r, g, b),\n\t\t\t\tdelta = max - min,\n\t\t\t\th = delta === 0 ? 0\n\t\t\t\t\t:\t( max == r ? (g - b) / delta + (g < b ? 6 : 0)\n\t\t\t\t\t\t: max == g ? (b - r) / delta + 2\n\t\t\t\t\t\t:\t\t\t (r - g) / delta + 4) * 60;\n\t\t\treturn [h, max === 0 ? 0 : delta / max, max];\n\t\t},\n\n\t\t'hsb-rgb': function(h, s, b) {\n\t\t\th = (((h / 60) % 6) + 6) % 6;\n\t\t\tvar i = Math.floor(h),\n\t\t\t\tf = h - i,\n\t\t\t\ti = hsbIndices[i],\n\t\t\t\tv = [\n\t\t\t\t\tb,\n\t\t\t\t\tb * (1 - s),\n\t\t\t\t\tb * (1 - s * f),\n\t\t\t\t\tb * (1 - s * (1 - f))\n\t\t\t\t];\n\t\t\treturn [v[i[0]], v[i[1]], v[i[2]]];\n\t\t},\n\n\t\t'rgb-hsl': function(r, g, b) {\n\t\t\tvar max = Math.max(r, g, b),\n\t\t\t\tmin = Math.min(r, g, b),\n\t\t\t\tdelta = max - min,\n\t\t\t\tachromatic = delta === 0,\n\t\t\t\th = achromatic ? 0\n\t\t\t\t\t:\t( max == r ? (g - b) / delta + (g < b ? 6 : 0)\n\t\t\t\t\t\t: max == g ? (b - r) / delta + 2\n\t\t\t\t\t\t:\t\t\t (r - g) / delta + 4) * 60,\n\t\t\t\tl = (max + min) / 2,\n\t\t\t\ts = achromatic ? 0 : l < 0.5\n\t\t\t\t\t\t? delta / (max + min)\n\t\t\t\t\t\t: delta / (2 - max - min);\n\t\t\treturn [h, s, l];\n\t\t},\n\n\t\t'hsl-rgb': function(h, s, l) {\n\t\t\th = (((h / 360) % 1) + 1) % 1;\n\t\t\tif (s === 0)\n\t\t\t\treturn [l, l, l];\n\t\t\tvar t3s = [ h + 1 / 3, h, h - 1 / 3 ],\n\t\t\t\tt2 = l < 0.5 ? l * (1 + s) : l + s - l * s,\n\t\t\t\tt1 = 2 * l - t2,\n\t\t\t\tc = [];\n\t\t\tfor (var i = 0; i < 3; i++) {\n\t\t\t\tvar t3 = t3s[i];\n\t\t\t\tif (t3 < 0) t3 += 1;\n\t\t\t\tif (t3 > 1) t3 -= 1;\n\t\t\t\tc[i] = 6 * t3 < 1\n\t\t\t\t\t? t1 + (t2 - t1) * 6 * t3\n\t\t\t\t\t: 2 * t3 < 1\n\t\t\t\t\t\t? t2\n\t\t\t\t\t\t: 3 * t3 < 2\n\t\t\t\t\t\t\t? t1 + (t2 - t1) * ((2 / 3) - t3) * 6\n\t\t\t\t\t\t\t: t1;\n\t\t\t}\n\t\t\treturn c;\n\t\t},\n\n\t\t'rgb-gray': function(r, g, b) {\n\t\t\treturn [r * 0.2989 + g * 0.587 + b * 0.114];\n\t\t},\n\n\t\t'gray-rgb': function(g) {\n\t\t\treturn [g, g, g];\n\t\t},\n\n\t\t'gray-hsb': function(g) {\n\t\t\treturn [0, 0, g];\n\t\t},\n\n\t\t'gray-hsl': function(g) {\n\t\t\treturn [0, 0, g];\n\t\t},\n\n\t\t'gradient-rgb': function() {\n\t\t\treturn [];\n\t\t},\n\n\t\t'rgb-gradient': function() {\n\t\t\treturn [];\n\t\t}\n\n\t};\n\n\treturn Base.each(types, function(properties, type) {\n\t\tcomponentParsers[type] = [];\n\t\tBase.each(properties, function(name, index) {\n\t\t\tvar part = Base.capitalize(name),\n\t\t\t\thasOverlap = /^(hue|saturation)$/.test(name),\n\t\t\t\tparser = componentParsers[type][index] = name === 'gradient'\n\t\t\t\t\t? function(value) {\n\t\t\t\t\t\tvar current = this._components[0];\n\t\t\t\t\t\tvalue = Gradient.read(Array.isArray(value) ? value\n\t\t\t\t\t\t\t\t: arguments, 0, { readNull: true });\n\t\t\t\t\t\tif (current !== value) {\n\t\t\t\t\t\t\tif (current)\n\t\t\t\t\t\t\t\tcurrent._removeOwner(this);\n\t\t\t\t\t\t\tif (value)\n\t\t\t\t\t\t\t\tvalue._addOwner(this);\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn value;\n\t\t\t\t\t}\n\t\t\t\t\t: type === 'gradient'\n\t\t\t\t\t\t? function() {\n\t\t\t\t\t\t\treturn Point.read(arguments, 0, {\n\t\t\t\t\t\t\t\t\treadNull: name === 'highlight',\n\t\t\t\t\t\t\t\t\tclone: true\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t\t: function(value) {\n\t\t\t\t\t\t\treturn value == null || isNaN(value) ? 0 : value;\n\t\t\t\t\t\t};\n\n\t\t\tthis['get' + part] = function() {\n\t\t\t\treturn this._type === type\n\t\t\t\t\t|| hasOverlap && /^hs[bl]$/.test(this._type)\n\t\t\t\t\t\t? this._components[index]\n\t\t\t\t\t\t: this._convert(type)[index];\n\t\t\t};\n\n\t\t\tthis['set' + part] = function(value) {\n\t\t\t\tif (this._type !== type\n\t\t\t\t\t\t&& !(hasOverlap && /^hs[bl]$/.test(this._type))) {\n\t\t\t\t\tthis._components = this._convert(type);\n\t\t\t\t\tthis._properties = types[type];\n\t\t\t\t\tthis._type = type;\n\t\t\t\t}\n\t\t\t\tthis._components[index] = parser.call(this, value);\n\t\t\t\tthis._changed();\n\t\t\t};\n\t\t}, this);\n\t}, {\n\t\t_class: 'Color',\n\t\t_readIndex: true,\n\n\t\tinitialize: function Color(arg) {\n\t\t\tvar slice = Array.prototype.slice,\n\t\t\t\targs = arguments,\n\t\t\t\tread = 0,\n\t\t\t\ttype,\n\t\t\t\tcomponents,\n\t\t\t\talpha,\n\t\t\t\tvalues;\n\t\t\tif (Array.isArray(arg)) {\n\t\t\t\targs = arg;\n\t\t\t\targ = args[0];\n\t\t\t}\n\t\t\tvar argType = arg != null && typeof arg;\n\t\t\tif (argType === 'string' && arg in types) {\n\t\t\t\ttype = arg;\n\t\t\t\targ = args[1];\n\t\t\t\tif (Array.isArray(arg)) {\n\t\t\t\t\tcomponents = arg;\n\t\t\t\t\talpha = args[2];\n\t\t\t\t} else {\n\t\t\t\t\tif (this.__read)\n\t\t\t\t\t\tread = 1;\n\t\t\t\t\targs = slice.call(args, 1);\n\t\t\t\t\targType = typeof arg;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!components) {\n\t\t\t\tvalues = argType === 'number'\n\t\t\t\t\t\t? args\n\t\t\t\t\t\t: argType === 'object' && arg.length != null\n\t\t\t\t\t\t\t? arg\n\t\t\t\t\t\t\t: null;\n\t\t\t\tif (values) {\n\t\t\t\t\tif (!type)\n\t\t\t\t\t\ttype = values.length >= 3\n\t\t\t\t\t\t\t\t? 'rgb'\n\t\t\t\t\t\t\t\t: 'gray';\n\t\t\t\t\tvar length = types[type].length;\n\t\t\t\t\talpha = values[length];\n\t\t\t\t\tif (this.__read)\n\t\t\t\t\t\tread += values === arguments\n\t\t\t\t\t\t\t? length + (alpha != null ? 1 : 0)\n\t\t\t\t\t\t\t: 1;\n\t\t\t\t\tif (values.length > length)\n\t\t\t\t\t\tvalues = slice.call(values, 0, length);\n\t\t\t\t} else if (argType === 'string') {\n\t\t\t\t\ttype = 'rgb';\n\t\t\t\t\tcomponents = fromCSS(arg);\n\t\t\t\t\tif (components.length === 4) {\n\t\t\t\t\t\talpha = components[3];\n\t\t\t\t\t\tcomponents.length--;\n\t\t\t\t\t}\n\t\t\t\t} else if (argType === 'object') {\n\t\t\t\t\tif (arg.constructor === Color) {\n\t\t\t\t\t\ttype = arg._type;\n\t\t\t\t\t\tcomponents = arg._components.slice();\n\t\t\t\t\t\talpha = arg._alpha;\n\t\t\t\t\t\tif (type === 'gradient') {\n\t\t\t\t\t\t\tfor (var i = 1, l = components.length; i < l; i++) {\n\t\t\t\t\t\t\t\tvar point = components[i];\n\t\t\t\t\t\t\t\tif (point)\n\t\t\t\t\t\t\t\t\tcomponents[i] = point.clone();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (arg.constructor === Gradient) {\n\t\t\t\t\t\ttype = 'gradient';\n\t\t\t\t\t\tvalues = args;\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttype = 'hue' in arg\n\t\t\t\t\t\t\t? 'lightness' in arg\n\t\t\t\t\t\t\t\t? 'hsl'\n\t\t\t\t\t\t\t\t: 'hsb'\n\t\t\t\t\t\t\t: 'gradient' in arg || 'stops' in arg\n\t\t\t\t\t\t\t\t\t|| 'radial' in arg\n\t\t\t\t\t\t\t\t? 'gradient'\n\t\t\t\t\t\t\t\t: 'gray' in arg\n\t\t\t\t\t\t\t\t\t? 'gray'\n\t\t\t\t\t\t\t\t\t: 'rgb';\n\t\t\t\t\t\tvar properties = types[type],\n\t\t\t\t\t\t\tparsers = componentParsers[type];\n\t\t\t\t\t\tthis._components = components = [];\n\t\t\t\t\t\tfor (var i = 0, l = properties.length; i < l; i++) {\n\t\t\t\t\t\t\tvar value = arg[properties[i]];\n\t\t\t\t\t\t\tif (value == null && i === 0 && type === 'gradient'\n\t\t\t\t\t\t\t\t\t&& 'stops' in arg) {\n\t\t\t\t\t\t\t\tvalue = {\n\t\t\t\t\t\t\t\t\tstops: arg.stops,\n\t\t\t\t\t\t\t\t\tradial: arg.radial\n\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tvalue = parsers[i].call(this, value);\n\t\t\t\t\t\t\tif (value != null)\n\t\t\t\t\t\t\t\tcomponents[i] = value;\n\t\t\t\t\t\t}\n\t\t\t\t\t\talpha = arg.alpha;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (this.__read && type)\n\t\t\t\t\tread = 1;\n\t\t\t}\n\t\t\tthis._type = type || 'rgb';\n\t\t\tthis._id = UID.get(Color);\n\t\t\tif (!components) {\n\t\t\t\tthis._components = components = [];\n\t\t\t\tvar parsers = componentParsers[this._type];\n\t\t\t\tfor (var i = 0, l = parsers.length; i < l; i++) {\n\t\t\t\t\tvar value = parsers[i].call(this, values && values[i]);\n\t\t\t\t\tif (value != null)\n\t\t\t\t\t\tcomponents[i] = value;\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis._components = components;\n\t\t\tthis._properties = types[this._type];\n\t\t\tthis._alpha = alpha;\n\t\t\tif (this.__read)\n\t\t\t\tthis.__read = read;\n\t\t},\n\n\t\t_serialize: function(options, dictionary) {\n\t\t\tvar components = this.getComponents();\n\t\t\treturn Base.serialize(\n\t\t\t\t\t/^(gray|rgb)$/.test(this._type)\n\t\t\t\t\t\t? components\n\t\t\t\t\t\t: [this._type].concat(components),\n\t\t\t\t\toptions, true, dictionary);\n\t\t},\n\n\t\t_changed: function() {\n\t\t\tthis._canvasStyle = null;\n\t\t\tif (this._owner)\n\t\t\t\tthis._owner._changed(65);\n\t\t},\n\n\t\t_convert: function(type) {\n\t\t\tvar converter;\n\t\t\treturn this._type === type\n\t\t\t\t\t? this._components.slice()\n\t\t\t\t\t: (converter = converters[this._type + '-' + type])\n\t\t\t\t\t\t? converter.apply(this, this._components)\n\t\t\t\t\t\t: converters['rgb-' + type].apply(this,\n\t\t\t\t\t\t\tconverters[this._type + '-rgb'].apply(this,\n\t\t\t\t\t\t\t\tthis._components));\n\t\t},\n\n\t\tconvert: function(type) {\n\t\t\treturn new Color(type, this._convert(type), this._alpha);\n\t\t},\n\n\t\tgetType: function() {\n\t\t\treturn this._type;\n\t\t},\n\n\t\tsetType: function(type) {\n\t\t\tthis._components = this._convert(type);\n\t\t\tthis._properties = types[type];\n\t\t\tthis._type = type;\n\t\t},\n\n\t\tgetComponents: function() {\n\t\t\tvar components = this._components.slice();\n\t\t\tif (this._alpha != null)\n\t\t\t\tcomponents.push(this._alpha);\n\t\t\treturn components;\n\t\t},\n\n\t\tgetAlpha: function() {\n\t\t\treturn this._alpha != null ? this._alpha : 1;\n\t\t},\n\n\t\tsetAlpha: function(alpha) {\n\t\t\tthis._alpha = alpha == null ? null : Math.min(Math.max(alpha, 0), 1);\n\t\t\tthis._changed();\n\t\t},\n\n\t\thasAlpha: function() {\n\t\t\treturn this._alpha != null;\n\t\t},\n\n\t\tequals: function(color) {\n\t\t\tvar col = Base.isPlainValue(color, true)\n\t\t\t\t\t? Color.read(arguments)\n\t\t\t\t\t: color;\n\t\t\treturn col === this || col && this._class === col._class\n\t\t\t\t\t&& this._type === col._type\n\t\t\t\t\t&& this._alpha === col._alpha\n\t\t\t\t\t&& Base.equals(this._components, col._components)\n\t\t\t\t\t|| false;\n\t\t},\n\n\t\ttoString: function() {\n\t\t\tvar properties = this._properties,\n\t\t\t\tparts = [],\n\t\t\t\tisGradient = this._type === 'gradient',\n\t\t\t\tf = Formatter.instance;\n\t\t\tfor (var i = 0, l = properties.length; i < l; i++) {\n\t\t\t\tvar value = this._components[i];\n\t\t\t\tif (value != null)\n\t\t\t\t\tparts.push(properties[i] + ': '\n\t\t\t\t\t\t\t+ (isGradient ? value : f.number(value)));\n\t\t\t}\n\t\t\tif (this._alpha != null)\n\t\t\t\tparts.push('alpha: ' + f.number(this._alpha));\n\t\t\treturn '{ ' + parts.join(', ') + ' }';\n\t\t},\n\n\t\ttoCSS: function(hex) {\n\t\t\tvar components = this._convert('rgb'),\n\t\t\t\talpha = hex || this._alpha == null ? 1 : this._alpha;\n\t\t\tfunction convert(val) {\n\t\t\t\treturn Math.round((val < 0 ? 0 : val > 1 ? 1 : val) * 255);\n\t\t\t}\n\t\t\tcomponents = [\n\t\t\t\tconvert(components[0]),\n\t\t\t\tconvert(components[1]),\n\t\t\t\tconvert(components[2])\n\t\t\t];\n\t\t\tif (alpha < 1)\n\t\t\t\tcomponents.push(alpha < 0 ? 0 : alpha);\n\t\t\treturn hex\n\t\t\t\t\t? '#' + ((1 << 24) + (components[0] << 16)\n\t\t\t\t\t\t+ (components[1] << 8)\n\t\t\t\t\t\t+ components[2]).toString(16).slice(1)\n\t\t\t\t\t: (components.length == 4 ? 'rgba(' : 'rgb(')\n\t\t\t\t\t\t+ components.join(',') + ')';\n\t\t},\n\n\t\ttoCanvasStyle: function(ctx) {\n\t\t\tif (this._canvasStyle)\n\t\t\t\treturn this._canvasStyle;\n\t\t\tif (this._type !== 'gradient')\n\t\t\t\treturn this._canvasStyle = this.toCSS();\n\t\t\tvar components = this._components,\n\t\t\t\tgradient = components[0],\n\t\t\t\tstops = gradient._stops,\n\t\t\t\torigin = components[1],\n\t\t\t\tdestination = components[2],\n\t\t\t\tcanvasGradient;\n\t\t\tif (gradient._radial) {\n\t\t\t\tvar radius = destination.getDistance(origin),\n\t\t\t\t\thighlight = components[3];\n\t\t\t\tif (highlight) {\n\t\t\t\t\tvar vector = highlight.subtract(origin);\n\t\t\t\t\tif (vector.getLength() > radius)\n\t\t\t\t\t\thighlight = origin.add(vector.normalize(radius - 0.1));\n\t\t\t\t}\n\t\t\t\tvar start = highlight || origin;\n\t\t\t\tcanvasGradient = ctx.createRadialGradient(start.x, start.y,\n\t\t\t\t\t\t0, origin.x, origin.y, radius);\n\t\t\t} else {\n\t\t\t\tcanvasGradient = ctx.createLinearGradient(origin.x, origin.y,\n\t\t\t\t\t\tdestination.x, destination.y);\n\t\t\t}\n\t\t\tfor (var i = 0, l = stops.length; i < l; i++) {\n\t\t\t\tvar stop = stops[i];\n\t\t\t\tcanvasGradient.addColorStop(stop._rampPoint,\n\t\t\t\t\t\tstop._color.toCanvasStyle());\n\t\t\t}\n\t\t\treturn this._canvasStyle = canvasGradient;\n\t\t},\n\n\t\ttransform: function(matrix) {\n\t\t\tif (this._type === 'gradient') {\n\t\t\t\tvar components = this._components;\n\t\t\t\tfor (var i = 1, l = components.length; i < l; i++) {\n\t\t\t\t\tvar point = components[i];\n\t\t\t\t\tmatrix._transformPoint(point, point, true);\n\t\t\t\t}\n\t\t\t\tthis._changed();\n\t\t\t}\n\t\t},\n\n\t\tstatics: {\n\t\t\t_types: types,\n\n\t\t\trandom: function() {\n\t\t\t\tvar random = Math.random;\n\t\t\t\treturn new Color(random(), random(), random());\n\t\t\t}\n\t\t}\n\t});\n},\nnew function() {\n\tvar operators = {\n\t\tadd: function(a, b) {\n\t\t\treturn a + b;\n\t\t},\n\n\t\tsubtract: function(a, b) {\n\t\t\treturn a - b;\n\t\t},\n\n\t\tmultiply: function(a, b) {\n\t\t\treturn a * b;\n\t\t},\n\n\t\tdivide: function(a, b) {\n\t\t\treturn a / b;\n\t\t}\n\t};\n\n\treturn Base.each(operators, function(operator, name) {\n\t\tthis[name] = function(color) {\n\t\t\tcolor = Color.read(arguments);\n\t\t\tvar type = this._type,\n\t\t\t\tcomponents1 = this._components,\n\t\t\t\tcomponents2 = color._convert(type);\n\t\t\tfor (var i = 0, l = components1.length; i < l; i++)\n\t\t\t\tcomponents2[i] = operator(components1[i], components2[i]);\n\t\t\treturn new Color(type, components2,\n\t\t\t\t\tthis._alpha != null\n\t\t\t\t\t\t\t? operator(this._alpha, color.getAlpha())\n\t\t\t\t\t\t\t: null);\n\t\t};\n\t}, {\n\t});\n});\n\nvar Gradient = Base.extend({\n\t_class: 'Gradient',\n\n\tinitialize: function Gradient(stops, radial) {\n\t\tthis._id = UID.get();\n\t\tif (stops && this._set(stops))\n\t\t\tstops = radial = null;\n\t\tif (!this._stops)\n\t\t\tthis.setStops(stops || ['white', 'black']);\n\t\tif (this._radial == null)\n\t\t\tthis.setRadial(typeof radial === 'string' && radial === 'radial'\n\t\t\t\t\t|| radial || false);\n\t},\n\n\t_serialize: function(options, dictionary) {\n\t\treturn dictionary.add(this, function() {\n\t\t\treturn Base.serialize([this._stops, this._radial],\n\t\t\t\t\toptions, true, dictionary);\n\t\t});\n\t},\n\n\t_changed: function() {\n\t\tfor (var i = 0, l = this._owners && this._owners.length; i < l; i++)\n\t\t\tthis._owners[i]._changed();\n\t},\n\n\t_addOwner: function(color) {\n\t\tif (!this._owners)\n\t\t\tthis._owners = [];\n\t\tthis._owners.push(color);\n\t},\n\n\t_removeOwner: function(color) {\n\t\tvar index = this._owners ? this._owners.indexOf(color) : -1;\n\t\tif (index != -1) {\n\t\t\tthis._owners.splice(index, 1);\n\t\t\tif (this._owners.length === 0)\n\t\t\t\tthis._owners = undefined;\n\t\t}\n\t},\n\n\tclone: function() {\n\t\tvar stops = [];\n\t\tfor (var i = 0, l = this._stops.length; i < l; i++)\n\t\t\tstops[i] = this._stops[i].clone();\n\t\treturn new Gradient(stops, this._radial);\n\t},\n\n\tgetStops: function() {\n\t\treturn this._stops;\n\t},\n\n\tsetStops: function(stops) {\n\t\tif (this.stops) {\n\t\t\tfor (var i = 0, l = this._stops.length; i < l; i++)\n\t\t\t\tthis._stops[i]._owner = undefined;\n\t\t}\n\t\tif (stops.length < 2)\n\t\t\tthrow new Error(\n\t\t\t\t\t'Gradient stop list needs to contain at least two stops.');\n\t\tthis._stops = GradientStop.readAll(stops, 0, { clone: true });\n\t\tfor (var i = 0, l = this._stops.length; i < l; i++) {\n\t\t\tvar stop = this._stops[i];\n\t\t\tstop._owner = this;\n\t\t\tif (stop._defaultRamp)\n\t\t\t\tstop.setRampPoint(i / (l - 1));\n\t\t}\n\t\tthis._changed();\n\t},\n\n\tgetRadial: function() {\n\t\treturn this._radial;\n\t},\n\n\tsetRadial: function(radial) {\n\t\tthis._radial = radial;\n\t\tthis._changed();\n\t},\n\n\tequals: function(gradient) {\n\t\tif (gradient === this)\n\t\t\treturn true;\n\t\tif (gradient && this._class === gradient._class\n\t\t\t\t&& this._stops.length === gradient._stops.length) {\n\t\t\tfor (var i = 0, l = this._stops.length; i < l; i++) {\n\t\t\t\tif (!this._stops[i].equals(gradient._stops[i]))\n\t\t\t\t\treturn false;\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n});\n\nvar GradientStop = Base.extend({\n\t_class: 'GradientStop',\n\n\tinitialize: function GradientStop(arg0, arg1) {\n\t\tif (arg0) {\n\t\t\tvar color, rampPoint;\n\t\t\tif (arg1 === undefined && Array.isArray(arg0)) {\n\t\t\t\tcolor = arg0[0];\n\t\t\t\trampPoint = arg0[1];\n\t\t\t} else if (arg0.color) {\n\t\t\t\tcolor = arg0.color;\n\t\t\t\trampPoint = arg0.rampPoint;\n\t\t\t} else {\n\t\t\t\tcolor = arg0;\n\t\t\t\trampPoint = arg1;\n\t\t\t}\n\t\t\tthis.setColor(color);\n\t\t\tthis.setRampPoint(rampPoint);\n\t\t}\n\t},\n\n\tclone: function() {\n\t\treturn new GradientStop(this._color.clone(), this._rampPoint);\n\t},\n\n\t_serialize: function(options, dictionary) {\n\t\treturn Base.serialize([this._color, this._rampPoint], options, true,\n\t\t\t\tdictionary);\n\t},\n\n\t_changed: function() {\n\t\tif (this._owner)\n\t\t\tthis._owner._changed(65);\n\t},\n\n\tgetRampPoint: function() {\n\t\treturn this._rampPoint;\n\t},\n\n\tsetRampPoint: function(rampPoint) {\n\t\tthis._defaultRamp = rampPoint == null;\n\t\tthis._rampPoint = rampPoint || 0;\n\t\tthis._changed();\n\t},\n\n\tgetColor: function() {\n\t\treturn this._color;\n\t},\n\n\tsetColor: function(color) {\n\t\tthis._color = Color.read(arguments);\n\t\tif (this._color === color)\n\t\t\tthis._color = color.clone();\n\t\tthis._color._owner = this;\n\t\tthis._changed();\n\t},\n\n\tequals: function(stop) {\n\t\treturn stop === this || stop && this._class === stop._class\n\t\t\t\t&& this._color.equals(stop._color)\n\t\t\t\t&& this._rampPoint == stop._rampPoint\n\t\t\t\t|| false;\n\t}\n});\n\nvar Style = Base.extend(new function() {\n\tvar defaults = {\n\t\tfillColor: undefined,\n\t\tstrokeColor: undefined,\n\t\tstrokeWidth: 1,\n\t\tstrokeCap: 'butt',\n\t\tstrokeJoin: 'miter',\n\t\tstrokeScaling: true,\n\t\tmiterLimit: 10,\n\t\tdashOffset: 0,\n\t\tdashArray: [],\n\t\twindingRule: 'nonzero',\n\t\tshadowColor: undefined,\n\t\tshadowBlur: 0,\n\t\tshadowOffset: new Point(),\n\t\tselectedColor: undefined,\n\t\tfontFamily: 'sans-serif',\n\t\tfontWeight: 'normal',\n\t\tfontSize: 12,\n\t\tfont: 'sans-serif',\n\t\tleading: null,\n\t\tjustification: 'left'\n\t};\n\n\tvar flags = {\n\t\tstrokeWidth: 97,\n\t\tstrokeCap: 97,\n\t\tstrokeJoin: 97,\n\t\tstrokeScaling: 105,\n\t\tmiterLimit: 97,\n\t\tfontFamily: 9,\n\t\tfontWeight: 9,\n\t\tfontSize: 9,\n\t\tfont: 9,\n\t\tleading: 9,\n\t\tjustification: 9\n\t};\n\n\tvar item = { beans: true },\n\t\tfields = {\n\t\t\t_defaults: defaults,\n\t\t\t_textDefaults: new Base(defaults, {\n\t\t\t\tfillColor: new Color()\n\t\t\t}),\n\t\t\tbeans: true\n\t\t};\n\n\tBase.each(defaults, function(value, key) {\n\t\tvar isColor = /Color$/.test(key),\n\t\t\tisPoint = key === 'shadowOffset',\n\t\t\tpart = Base.capitalize(key),\n\t\t\tflag = flags[key],\n\t\t\tset = 'set' + part,\n\t\t\tget = 'get' + part;\n\n\t\tfields[set] = function(value) {\n\t\t\tvar owner = this._owner,\n\t\t\t\tchildren = owner && owner._children;\n\t\t\tif (children && children.length > 0\n\t\t\t\t\t&& !(owner instanceof CompoundPath)) {\n\t\t\t\tfor (var i = 0, l = children.length; i < l; i++)\n\t\t\t\t\tchildren[i]._style[set](value);\n\t\t\t} else {\n\t\t\t\tvar old = this._values[key];\n\t\t\t\tif (old !== value) {\n\t\t\t\t\tif (isColor) {\n\t\t\t\t\t\tif (old)\n\t\t\t\t\t\t\told._owner = undefined;\n\t\t\t\t\t\tif (value && value.constructor === Color) {\n\t\t\t\t\t\t\tif (value._owner)\n\t\t\t\t\t\t\t\tvalue = value.clone();\n\t\t\t\t\t\t\tvalue._owner = owner;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tthis._values[key] = value;\n\t\t\t\t\tif (owner)\n\t\t\t\t\t\towner._changed(flag || 65);\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\tfields[get] = function(_dontMerge) {\n\t\t\tvar owner = this._owner,\n\t\t\t\tchildren = owner && owner._children,\n\t\t\t\tvalue;\n\t\t\tif (!children || children.length === 0 || _dontMerge\n\t\t\t\t\t|| owner instanceof CompoundPath) {\n\t\t\t\tvar value = this._values[key];\n\t\t\t\tif (value === undefined) {\n\t\t\t\t\tvalue = this._defaults[key];\n\t\t\t\t\tif (value && value.clone)\n\t\t\t\t\t\tvalue = value.clone();\n\t\t\t\t} else {\n\t\t\t\t\tvar ctor = isColor ? Color : isPoint ? Point : null;\n\t\t\t\t\tif (ctor && !(value && value.constructor === ctor)) {\n\t\t\t\t\t\tthis._values[key] = value = ctor.read([value], 0,\n\t\t\t\t\t\t\t\t{ readNull: true, clone: true });\n\t\t\t\t\t\tif (value && isColor)\n\t\t\t\t\t\t\tvalue._owner = owner;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn value;\n\t\t\t}\n\t\t\tfor (var i = 0, l = children.length; i < l; i++) {\n\t\t\t\tvar childValue = children[i]._style[get]();\n\t\t\t\tif (i === 0) {\n\t\t\t\t\tvalue = childValue;\n\t\t\t\t} else if (!Base.equals(value, childValue)) {\n\t\t\t\t\treturn undefined;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn value;\n\t\t};\n\n\t\titem[get] = function(_dontMerge) {\n\t\t\treturn this._style[get](_dontMerge);\n\t\t};\n\n\t\titem[set] = function(value) {\n\t\t\tthis._style[set](value);\n\t\t};\n\t});\n\n\tItem.inject(item);\n\treturn fields;\n}, {\n\t_class: 'Style',\n\n\tinitialize: function Style(style, _owner, _project) {\n\t\tthis._values = {};\n\t\tthis._owner = _owner;\n\t\tthis._project = _owner && _owner._project || _project || paper.project;\n\t\tif (_owner instanceof TextItem)\n\t\t\tthis._defaults = this._textDefaults;\n\t\tif (style)\n\t\t\tthis.set(style);\n\t},\n\n\tset: function(style) {\n\t\tvar isStyle = style instanceof Style,\n\t\t\tvalues = isStyle ? style._values : style;\n\t\tif (values) {\n\t\t\tfor (var key in values) {\n\t\t\t\tif (key in this._defaults) {\n\t\t\t\t\tvar value = values[key];\n\t\t\t\t\tthis[key] = value && isStyle && value.clone\n\t\t\t\t\t\t\t? value.clone() : value;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t},\n\n\tequals: function(style) {\n\t\treturn style === this || style && this._class === style._class\n\t\t\t\t&& Base.equals(this._values, style._values)\n\t\t\t\t|| false;\n\t},\n\n\thasFill: function() {\n\t\treturn !!this.getFillColor();\n\t},\n\n\thasStroke: function() {\n\t\treturn !!this.getStrokeColor() && this.getStrokeWidth() > 0;\n\t},\n\n\thasShadow: function() {\n\t\treturn !!this.getShadowColor() && this.getShadowBlur() > 0;\n\t},\n\n\tgetView: function() {\n\t\treturn this._project.getView();\n\t},\n\n\tgetFontStyle: function() {\n\t\tvar fontSize = this.getFontSize();\n\t\treturn this.getFontWeight()\n\t\t\t\t+ ' ' + fontSize + (/[a-z]/i.test(fontSize + '') ? ' ' : 'px ')\n\t\t\t\t+ this.getFontFamily();\n\t},\n\n\tgetFont: '#getFontFamily',\n\tsetFont: '#setFontFamily',\n\n\tgetLeading: function getLeading() {\n\t\tvar leading = getLeading.base.call(this),\n\t\t\tfontSize = this.getFontSize();\n\t\tif (/pt|em|%|px/.test(fontSize))\n\t\t\tfontSize = this.getView().getPixelSize(fontSize);\n\t\treturn leading != null ? leading : fontSize * 1.2;\n\t}\n\n});\n\nvar DomElement = new function() {\n\tfunction handlePrefix(el, name, set, value) {\n\t\tvar prefixes = ['', 'webkit', 'moz', 'Moz', 'ms', 'o'],\n\t\t\tsuffix = name[0].toUpperCase() + name.substring(1);\n\t\tfor (var i = 0; i < 6; i++) {\n\t\t\tvar prefix = prefixes[i],\n\t\t\t\tkey = prefix ? prefix + suffix : name;\n\t\t\tif (key in el) {\n\t\t\t\tif (set) {\n\t\t\t\t\tel[key] = value;\n\t\t\t\t} else {\n\t\t\t\t\treturn el[key];\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn {\n\t\tgetStyles: function(el) {\n\t\t\tvar doc = el && el.nodeType !== 9 ? el.ownerDocument : el,\n\t\t\t\tview = doc && doc.defaultView;\n\t\t\treturn view && view.getComputedStyle(el, '');\n\t\t},\n\n\t\tgetBounds: function(el, viewport) {\n\t\t\tvar doc = el.ownerDocument,\n\t\t\t\tbody = doc.body,\n\t\t\t\thtml = doc.documentElement,\n\t\t\t\trect;\n\t\t\ttry {\n\t\t\t\trect = el.getBoundingClientRect();\n\t\t\t} catch (e) {\n\t\t\t\trect = { left: 0, top: 0, width: 0, height: 0 };\n\t\t\t}\n\t\t\tvar x = rect.left - (html.clientLeft || body.clientLeft || 0),\n\t\t\t\ty = rect.top - (html.clientTop || body.clientTop || 0);\n\t\t\tif (!viewport) {\n\t\t\t\tvar view = doc.defaultView;\n\t\t\t\tx += view.pageXOffset || html.scrollLeft || body.scrollLeft;\n\t\t\t\ty += view.pageYOffset || html.scrollTop || body.scrollTop;\n\t\t\t}\n\t\t\treturn new Rectangle(x, y, rect.width, rect.height);\n\t\t},\n\n\t\tgetViewportBounds: function(el) {\n\t\t\tvar doc = el.ownerDocument,\n\t\t\t\tview = doc.defaultView,\n\t\t\t\thtml = doc.documentElement;\n\t\t\treturn new Rectangle(0, 0,\n\t\t\t\tview.innerWidth || html.clientWidth,\n\t\t\t\tview.innerHeight || html.clientHeight\n\t\t\t);\n\t\t},\n\n\t\tgetOffset: function(el, viewport) {\n\t\t\treturn DomElement.getBounds(el, viewport).getPoint();\n\t\t},\n\n\t\tgetSize: function(el) {\n\t\t\treturn DomElement.getBounds(el, true).getSize();\n\t\t},\n\n\t\tisInvisible: function(el) {\n\t\t\treturn DomElement.getSize(el).equals(new Size(0, 0));\n\t\t},\n\n\t\tisInView: function(el) {\n\t\t\treturn !DomElement.isInvisible(el)\n\t\t\t\t\t&& DomElement.getViewportBounds(el).intersects(\n\t\t\t\t\t\tDomElement.getBounds(el, true));\n\t\t},\n\n\t\tgetPrefixed: function(el, name) {\n\t\t\treturn handlePrefix(el, name);\n\t\t},\n\n\t\tsetPrefixed: function(el, name, value) {\n\t\t\tif (typeof name === 'object') {\n\t\t\t\tfor (var key in name)\n\t\t\t\t\thandlePrefix(el, key, true, name[key]);\n\t\t\t} else {\n\t\t\t\thandlePrefix(el, name, true, value);\n\t\t\t}\n\t\t}\n\t};\n};\n\nvar DomEvent = {\n\tadd: function(el, events) {\n\t\tfor (var type in events) {\n\t\t\tvar func = events[type],\n\t\t\t\tparts = type.split(/[\\s,]+/g);\n\t\t\tfor (var i = 0, l = parts.length; i < l; i++)\n\t\t\t\tel.addEventListener(parts[i], func, false);\n\t\t}\n\t},\n\n\tremove: function(el, events) {\n\t\tfor (var type in events) {\n\t\t\tvar func = events[type],\n\t\t\t\tparts = type.split(/[\\s,]+/g);\n\t\t\tfor (var i = 0, l = parts.length; i < l; i++)\n\t\t\t\tel.removeEventListener(parts[i], func, false);\n\t\t}\n\t},\n\n\tgetPoint: function(event) {\n\t\tvar pos = event.targetTouches\n\t\t\t\t? event.targetTouches.length\n\t\t\t\t\t? event.targetTouches[0]\n\t\t\t\t\t: event.changedTouches[0]\n\t\t\t\t: event;\n\t\treturn new Point(\n\t\t\tpos.pageX || pos.clientX + document.documentElement.scrollLeft,\n\t\t\tpos.pageY || pos.clientY + document.documentElement.scrollTop\n\t\t);\n\t},\n\n\tgetTarget: function(event) {\n\t\treturn event.target || event.srcElement;\n\t},\n\n\tgetRelatedTarget: function(event) {\n\t\treturn event.relatedTarget || event.toElement;\n\t},\n\n\tgetOffset: function(event, target) {\n\t\treturn DomEvent.getPoint(event).subtract(DomElement.getOffset(\n\t\t\t\ttarget || DomEvent.getTarget(event)));\n\t},\n\n\tstop: function(event) {\n\t\tevent.stopPropagation();\n\t\tevent.preventDefault();\n\t}\n};\n\nDomEvent.requestAnimationFrame = new function() {\n\tvar nativeRequest = DomElement.getPrefixed(window, 'requestAnimationFrame'),\n\t\trequested = false,\n\t\tcallbacks = [],\n\t\tfocused = true,\n\t\ttimer;\n\n\tDomEvent.add(window, {\n\t\tfocus: function() {\n\t\t\tfocused = true;\n\t\t},\n\t\tblur: function() {\n\t\t\tfocused = false;\n\t\t}\n\t});\n\n\tfunction handleCallbacks() {\n\t\tfor (var i = callbacks.length - 1; i >= 0; i--) {\n\t\t\tvar entry = callbacks[i],\n\t\t\t\tfunc = entry[0],\n\t\t\t\tel = entry[1];\n\t\t\tif (!el || (PaperScope.getAttribute(el, 'keepalive') == 'true'\n\t\t\t\t\t|| focused) && DomElement.isInView(el)) {\n\t\t\t\tcallbacks.splice(i, 1);\n\t\t\t\tfunc();\n\t\t\t}\n\t\t}\n\t\tif (nativeRequest) {\n\t\t\tif (callbacks.length) {\n\t\t\t\tnativeRequest(handleCallbacks);\n\t\t\t} else {\n\t\t\t\trequested = false;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn function(callback, element) {\n\t\tcallbacks.push([callback, element]);\n\t\tif (nativeRequest) {\n\t\t\tif (!requested) {\n\t\t\t\tnativeRequest(handleCallbacks);\n\t\t\t\trequested = true;\n\t\t\t}\n\t\t} else if (!timer) {\n\t\t\ttimer = setInterval(handleCallbacks, 1000 / 60);\n\t\t}\n\t};\n};\n\nvar View = Base.extend(Emitter, {\n\t_class: 'View',\n\n\tinitialize: function View(project, element) {\n\t\tthis._project = project;\n\t\tthis._scope = project._scope;\n\t\tthis._element = element;\n\t\tvar size;\n\t\tif (!this._pixelRatio)\n\t\t\tthis._pixelRatio = window.devicePixelRatio || 1;\n\t\tthis._id = element.getAttribute('id');\n\t\tif (this._id == null)\n\t\t\telement.setAttribute('id', this._id = 'view-' + View._id++);\n\t\tDomEvent.add(element, this._viewEvents);\n\t\tvar none = 'none';\n\t\tDomElement.setPrefixed(element.style, {\n\t\t\tuserSelect: none,\n\t\t\ttouchAction: none,\n\t\t\ttouchCallout: none,\n\t\t\tcontentZooming: none,\n\t\t\tuserDrag: none,\n\t\t\ttapHighlightColor: 'rgba(0,0,0,0)'\n\t\t});\n\n\t\tfunction getSize(name) {\n\t\t\treturn element[name] || parseInt(element.getAttribute(name), 10);\n\t\t};\n\n\t\tfunction getCanvasSize() {\n\t\t\tvar size = DomElement.getSize(element);\n\t\t\treturn size.isNaN() || size.isZero()\n\t\t\t\t\t? new Size(getSize('width'), getSize('height'))\n\t\t\t\t\t: size;\n\t\t};\n\n\t\tif (PaperScope.hasAttribute(element, 'resize')) {\n\t\t\tvar that = this;\n\t\t\tDomEvent.add(window, this._windowEvents = {\n\t\t\t\tresize: function() {\n\t\t\t\t\tthat.setViewSize(getCanvasSize());\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\tthis._setViewSize(size = getCanvasSize());\n\t\tif (PaperScope.hasAttribute(element, 'stats')\n\t\t\t\t&& typeof Stats !== 'undefined') {\n\t\t\tthis._stats = new Stats();\n\t\t\tvar stats = this._stats.domElement,\n\t\t\t\tstyle = stats.style,\n\t\t\t\toffset = DomElement.getOffset(element);\n\t\t\tstyle.position = 'absolute';\n\t\t\tstyle.left = offset.x + 'px';\n\t\t\tstyle.top = offset.y + 'px';\n\t\t\tdocument.body.appendChild(stats);\n\t\t}\n\t\tView._views.push(this);\n\t\tView._viewsById[this._id] = this;\n\t\tthis._viewSize = size;\n\t\t(this._matrix = new Matrix())._owner = this;\n\t\tthis._zoom = 1;\n\t\tif (!View._focused)\n\t\t\tView._focused = this;\n\t\tthis._frameItems = {};\n\t\tthis._frameItemCount = 0;\n\t},\n\n\tremove: function() {\n\t\tif (!this._project)\n\t\t\treturn false;\n\t\tif (View._focused === this)\n\t\t\tView._focused = null;\n\t\tView._views.splice(View._views.indexOf(this), 1);\n\t\tdelete View._viewsById[this._id];\n\t\tif (this._project._view === this)\n\t\t\tthis._project._view = null;\n\t\tDomEvent.remove(this._element, this._viewEvents);\n\t\tDomEvent.remove(window, this._windowEvents);\n\t\tthis._element = this._project = null;\n\t\tthis.off('frame');\n\t\tthis._animate = false;\n\t\tthis._frameItems = {};\n\t\treturn true;\n\t},\n\n\t_events: Base.each(['onResize', 'onMouseDown', 'onMouseUp', 'onMouseMove'],\n\t\tfunction(name) {\n\t\t\tthis[name] = {\n\t\t\t\tinstall: function(type) {\n\t\t\t\t\tthis._installEvent(type);\n\t\t\t\t},\n\n\t\t\t\tuninstall: function(type) {\n\t\t\t\t\tthis._uninstallEvent(type);\n\t\t\t\t}\n\t\t\t};\n\t\t}, {\n\t\t\tonFrame: {\n\t\t\t\tinstall: function() {\n\t\t\t\t\tthis.play();\n\t\t\t\t},\n\n\t\t\t\tuninstall: function() {\n\t\t\t\t\tthis.pause();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t),\n\n\t_animate: false,\n\t_time: 0,\n\t_count: 0,\n\n\t_requestFrame: function() {\n\t\tvar that = this;\n\t\tDomEvent.requestAnimationFrame(function() {\n\t\t\tthat._requested = false;\n\t\t\tif (!that._animate)\n\t\t\t\treturn;\n\t\t\tthat._requestFrame();\n\t\t\tthat._handleFrame();\n\t\t}, this._element);\n\t\tthis._requested = true;\n\t},\n\n\t_handleFrame: function() {\n\t\tpaper = this._scope;\n\t\tvar now = Date.now() / 1000,\n\t\t\tdelta = this._before ? now - this._before : 0;\n\t\tthis._before = now;\n\t\tthis._handlingFrame = true;\n\t\tthis.emit('frame', new Base({\n\t\t\tdelta: delta,\n\t\t\ttime: this._time += delta,\n\t\t\tcount: this._count++\n\t\t}));\n\t\tif (this._stats)\n\t\t\tthis._stats.update();\n\t\tthis._handlingFrame = false;\n\t\tthis.update();\n\t},\n\n\t_animateItem: function(item, animate) {\n\t\tvar items = this._frameItems;\n\t\tif (animate) {\n\t\t\titems[item._id] = {\n\t\t\t\titem: item,\n\t\t\t\ttime: 0,\n\t\t\t\tcount: 0\n\t\t\t};\n\t\t\tif (++this._frameItemCount === 1)\n\t\t\t\tthis.on('frame', this._handleFrameItems);\n\t\t} else {\n\t\t\tdelete items[item._id];\n\t\t\tif (--this._frameItemCount === 0) {\n\t\t\t\tthis.off('frame', this._handleFrameItems);\n\t\t\t}\n\t\t}\n\t},\n\n\t_handleFrameItems: function(event) {\n\t\tfor (var i in this._frameItems) {\n\t\t\tvar entry = this._frameItems[i];\n\t\t\tentry.item.emit('frame', new Base(event, {\n\t\t\t\ttime: entry.time += event.delta,\n\t\t\t\tcount: entry.count++\n\t\t\t}));\n\t\t}\n\t},\n\n\t_update: function() {\n\t\tthis._project._needsUpdate = true;\n\t\tif (this._handlingFrame)\n\t\t\treturn;\n\t\tif (this._animate) {\n\t\t\tthis._handleFrame();\n\t\t} else {\n\t\t\tthis.update();\n\t\t}\n\t},\n\n\t_changed: function(flags) {\n\t\tif (flags & 1)\n\t\t\tthis._project._needsUpdate = true;\n\t},\n\n\t_transform: function(matrix) {\n\t\tthis._matrix.concatenate(matrix);\n\t\tthis._bounds = null;\n\t\tthis._update();\n\t},\n\n\tgetElement: function() {\n\t\treturn this._element;\n\t},\n\n\tgetPixelRatio: function() {\n\t\treturn this._pixelRatio;\n\t},\n\n\tgetResolution: function() {\n\t\treturn this._pixelRatio * 72;\n\t},\n\n\tgetViewSize: function() {\n\t\tvar size = this._viewSize;\n\t\treturn new LinkedSize(size.width, size.height, this, 'setViewSize');\n\t},\n\n\tsetViewSize: function() {\n\t\tvar size = Size.read(arguments),\n\t\t\tdelta = size.subtract(this._viewSize);\n\t\tif (delta.isZero())\n\t\t\treturn;\n\t\tthis._viewSize.set(size.width, size.height);\n\t\tthis._setViewSize(size);\n\t\tthis._bounds = null;\n\t\tthis.emit('resize', {\n\t\t\tsize: size,\n\t\t\tdelta: delta\n\t\t});\n\t\tthis._update();\n\t},\n\n\t_setViewSize: function(size) {\n\t\tvar element = this._element;\n\t\telement.width = size.width;\n\t\telement.height = size.height;\n\t},\n\n\tgetBounds: function() {\n\t\tif (!this._bounds)\n\t\t\tthis._bounds = this._matrix.inverted()._transformBounds(\n\t\t\t\t\tnew Rectangle(new Point(), this._viewSize));\n\t\treturn this._bounds;\n\t},\n\n\tgetSize: function() {\n\t\treturn this.getBounds().getSize();\n\t},\n\n\tgetCenter: function() {\n\t\treturn this.getBounds().getCenter();\n\t},\n\n\tsetCenter: function() {\n\t\tvar center = Point.read(arguments);\n\t\tthis.scrollBy(center.subtract(this.getCenter()));\n\t},\n\n\tgetZoom: function() {\n\t\treturn this._zoom;\n\t},\n\n\tsetZoom: function(zoom) {\n\t\tthis._transform(new Matrix().scale(zoom / this._zoom,\n\t\t\tthis.getCenter()));\n\t\tthis._zoom = zoom;\n\t},\n\n\tisVisible: function() {\n\t\treturn DomElement.isInView(this._element);\n\t},\n\n\tscrollBy: function() {\n\t\tthis._transform(new Matrix().translate(Point.read(arguments).negate()));\n\t},\n\n\tplay: function() {\n\t\tthis._animate = true;\n\t\tif (!this._requested)\n\t\t\tthis._requestFrame();\n\t},\n\n\tpause: function() {\n\t\tthis._animate = false;\n\t},\n\n\tdraw: function() {\n\t\tthis.update();\n\t},\n\n\tprojectToView: function() {\n\t\treturn this._matrix._transformPoint(Point.read(arguments));\n\t},\n\n\tviewToProject: function() {\n\t\treturn this._matrix._inverseTransform(Point.read(arguments));\n\t}\n\n}, {\n\tstatics: {\n\t\t_views: [],\n\t\t_viewsById: {},\n\t\t_id: 0,\n\n\t\tcreate: function(project, element) {\n\t\t\tif (typeof element === 'string')\n\t\t\t\telement = document.getElementById(element);\n\t\t\treturn new CanvasView(project, element);\n\t\t}\n\t}\n},\nnew function() {\n\tvar tool,\n\t\tprevFocus,\n\t\ttempFocus,\n\t\tdragging = false;\n\n\tfunction getView(event) {\n\t\tvar target = DomEvent.getTarget(event);\n\t\treturn target.getAttribute && View._viewsById[target.getAttribute('id')];\n\t}\n\n\tfunction viewToProject(view, event) {\n\t\treturn view.viewToProject(DomEvent.getOffset(event, view._element));\n\t}\n\n\tfunction updateFocus() {\n\t\tif (!View._focused || !View._focused.isVisible()) {\n\t\t\tfor (var i = 0, l = View._views.length; i < l; i++) {\n\t\t\t\tvar view = View._views[i];\n\t\t\t\tif (view && view.isVisible()) {\n\t\t\t\t\tView._focused = tempFocus = view;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction handleMouseMove(view, point, event) {\n\t\tview._handleEvent('mousemove', point, event);\n\t\tvar tool = view._scope.tool;\n\t\tif (tool) {\n\t\t\ttool._handleEvent(dragging && tool.responds('mousedrag')\n\t\t\t\t\t? 'mousedrag' : 'mousemove', point, event);\n\t\t}\n\t\tview.update();\n\t\treturn tool;\n\t}\n\n\tvar navigator = window.navigator,\n\t\tmousedown, mousemove, mouseup;\n\tif (navigator.pointerEnabled || navigator.msPointerEnabled) {\n\t\tmousedown = 'pointerdown MSPointerDown';\n\t\tmousemove = 'pointermove MSPointerMove';\n\t\tmouseup = 'pointerup pointercancel MSPointerUp MSPointerCancel';\n\t} else {\n\t\tmousedown = 'touchstart';\n\t\tmousemove = 'touchmove';\n\t\tmouseup = 'touchend touchcancel';\n\t\tif (!('ontouchstart' in window && navigator.userAgent.match(\n\t\t\t\t/mobile|tablet|ip(ad|hone|od)|android|silk/i))) {\n\t\t\tmousedown += ' mousedown';\n\t\t\tmousemove += ' mousemove';\n\t\t\tmouseup += ' mouseup';\n\t\t}\n\t}\n\n\tvar viewEvents = {\n\t\t'selectstart dragstart': function(event) {\n\t\t\tif (dragging)\n\t\t\t\tevent.preventDefault();\n\t\t}\n\t};\n\n\tvar docEvents = {\n\t\tmouseout: function(event) {\n\t\t\tvar view = View._focused,\n\t\t\t\ttarget = DomEvent.getRelatedTarget(event);\n\t\t\tif (view && (!target || target.nodeName === 'HTML'))\n\t\t\t\thandleMouseMove(view, viewToProject(view, event), event);\n\t\t},\n\n\t\tscroll: updateFocus\n\t};\n\n\tviewEvents[mousedown] = function(event) {\n\t\tvar view = View._focused = getView(event),\n\t\t\tpoint = viewToProject(view, event);\n\t\tdragging = true;\n\t\tview._handleEvent('mousedown', point, event);\n\t\tif (tool = view._scope.tool)\n\t\t\ttool._handleEvent('mousedown', point, event);\n\t\tview.update();\n\t};\n\n\tdocEvents[mousemove] = function(event) {\n\t\tvar view = View._focused;\n\t\tif (!dragging) {\n\t\t\tvar target = getView(event);\n\t\t\tif (target) {\n\t\t\t\tif (view !== target)\n\t\t\t\t\thandleMouseMove(view, viewToProject(view, event), event);\n\t\t\t\tprevFocus = view;\n\t\t\t\tview = View._focused = tempFocus = target;\n\t\t\t} else if (tempFocus && tempFocus === view) {\n\t\t\t\tview = View._focused = prevFocus;\n\t\t\t\tupdateFocus();\n\t\t\t}\n\t\t}\n\t\tif (view) {\n\t\t\tvar point = viewToProject(view, event);\n\t\t\tif (dragging || view.getBounds().contains(point))\n\t\t\t\ttool = handleMouseMove(view, point, event);\n\t\t}\n\t};\n\n\tdocEvents[mouseup] = function(event) {\n\t\tvar view = View._focused;\n\t\tif (!view || !dragging)\n\t\t\treturn;\n\t\tvar point = viewToProject(view, event);\n\t\tdragging = false;\n\t\tview._handleEvent('mouseup', point, event);\n\t\tif (tool)\n\t\t\ttool._handleEvent('mouseup', point, event);\n\t\tview.update();\n\t};\n\n\tDomEvent.add(document, docEvents);\n\n\tDomEvent.add(window, {\n\t\tload: updateFocus\n\t});\n\n\tvar mouseFlags = {\n\t\tmousedown: {\n\t\t\tmousedown: 1,\n\t\t\tmousedrag: 1,\n\t\t\tclick: 1,\n\t\t\tdoubleclick: 1\n\t\t},\n\t\tmouseup: {\n\t\t\tmouseup: 1,\n\t\t\tmousedrag: 1,\n\t\t\tclick: 1,\n\t\t\tdoubleclick: 1\n\t\t},\n\t\tmousemove: {\n\t\t\tmousedrag: 1,\n\t\t\tmousemove: 1,\n\t\t\tmouseenter: 1,\n\t\t\tmouseleave: 1\n\t\t}\n\t};\n\n\treturn {\n\t\t_viewEvents: viewEvents,\n\n\t\t_handleEvent: function() {},\n\n\t\t_installEvent: function(type) {\n\t\t\tvar counters = this._eventCounters;\n\t\t\tif (counters) {\n\t\t\t\tfor (var key in mouseFlags) {\n\t\t\t\t\tcounters[key] = (counters[key] || 0)\n\t\t\t\t\t\t\t+ (mouseFlags[key][type] || 0);\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\t_uninstallEvent: function(type) {\n\t\t\tvar counters = this._eventCounters;\n\t\t\tif (counters) {\n\t\t\t\tfor (var key in mouseFlags)\n\t\t\t\t\tcounters[key] -= mouseFlags[key][type] || 0;\n\t\t\t}\n\t\t},\n\n\t\tstatics: {\n\t\t\tupdateFocus: updateFocus\n\t\t}\n\t};\n});\n\nvar CanvasView = View.extend({\n\t_class: 'CanvasView',\n\n\tinitialize: function CanvasView(project, canvas) {\n\t\tif (!(canvas instanceof HTMLCanvasElement)) {\n\t\t\tvar size = Size.read(arguments, 1);\n\t\t\tif (size.isZero())\n\t\t\t\tthrow new Error(\n\t\t\t\t\t\t'Cannot create CanvasView with the provided argument: '\n\t\t\t\t\t\t+ [].slice.call(arguments, 1));\n\t\t\tcanvas = CanvasProvider.getCanvas(size);\n\t\t}\n\t\tthis._context = canvas.getContext('2d');\n\t\tthis._eventCounters = {};\n\t\tthis._pixelRatio = 1;\n\t\tif (!/^off|false$/.test(PaperScope.getAttribute(canvas, 'hidpi'))) {\n\t\t\tvar deviceRatio = window.devicePixelRatio || 1,\n\t\t\t\tbackingStoreRatio = DomElement.getPrefixed(this._context,\n\t\t\t\t\t\t'backingStorePixelRatio') || 1;\n\t\t\tthis._pixelRatio = deviceRatio / backingStoreRatio;\n\t\t}\n\t\tView.call(this, project, canvas);\n\t},\n\n\t_setViewSize: function(size) {\n\t\tvar element = this._element,\n\t\t\tpixelRatio = this._pixelRatio,\n\t\t\twidth = size.width,\n\t\t\theight = size.height;\n\t\telement.width = width * pixelRatio;\n\t\telement.height = height * pixelRatio;\n\t\tif (pixelRatio !== 1) {\n\t\t\tif (!PaperScope.hasAttribute(element, 'resize')) {\n\t\t\t\tvar style = element.style;\n\t\t\t\tstyle.width = width + 'px';\n\t\t\t\tstyle.height = height + 'px';\n\t\t\t}\n\t\t\tthis._context.scale(pixelRatio, pixelRatio);\n\t\t}\n\t},\n\n\tgetPixelSize: function(size) {\n\t\tvar browser = paper.browser,\n\t\t\tpixels;\n\t\tif (browser && browser.firefox) {\n\t\t\tvar parent = this._element.parentNode,\n\t\t\t\ttemp = document.createElement('div');\n\t\t\ttemp.style.fontSize = size;\n\t\t\tparent.appendChild(temp);\n\t\t\tpixels = parseFloat(DomElement.getStyles(temp).fontSize);\n\t\t\tparent.removeChild(temp);\n\t\t} else {\n\t\t\tvar ctx = this._context,\n\t\t\t\tprevFont = ctx.font;\n\t\t\tctx.font = size + ' serif';\n\t\t\tpixels = parseFloat(ctx.font);\n\t\t\tctx.font = prevFont;\n\t\t}\n\t\treturn pixels;\n\t},\n\n\tgetTextWidth: function(font, lines) {\n\t\tvar ctx = this._context,\n\t\t\tprevFont = ctx.font,\n\t\t\twidth = 0;\n\t\tctx.font = font;\n\t\tfor (var i = 0, l = lines.length; i < l; i++)\n\t\t\twidth = Math.max(width, ctx.measureText(lines[i]).width);\n\t\tctx.font = prevFont;\n\t\treturn width;\n\t},\n\n\tupdate: function(force) {\n\t\tvar project = this._project;\n\t\tif (!project || !force && !project._needsUpdate)\n\t\t\treturn false;\n\t\tvar ctx = this._context,\n\t\t\tsize = this._viewSize;\n\t\tctx.clearRect(0, 0, size.width + 1, size.height + 1);\n\t\tproject.draw(ctx, this._matrix, this._pixelRatio);\n\t\tproject._needsUpdate = false;\n\t\treturn true;\n\t}\n},\nnew function() {\n\tvar downPoint,\n\t\tlastPoint,\n\t\toverPoint,\n\t\tdownItem,\n\t\tlastItem,\n\t\toverItem,\n\t\tdragItem,\n\t\tdblClick,\n\t\tclickTime;\n\n\tfunction callEvent(view, type, event, point, target, lastPoint) {\n\t\tvar item = target,\n\t\t\tmouseEvent;\n\n\t\tfunction call(obj) {\n\t\t\tif (obj.responds(type)) {\n\t\t\t\tif (!mouseEvent) {\n\t\t\t\t\tmouseEvent = new MouseEvent(type, event, point, target,\n\t\t\t\t\t\t\tlastPoint ? point.subtract(lastPoint) : null);\n\t\t\t\t}\n\t\t\t\tif (obj.emit(type, mouseEvent) && mouseEvent.isStopped) {\n\t\t\t\t\tevent.preventDefault();\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\twhile (item) {\n\t\t\tif (call(item))\n\t\t\t\treturn true;\n\t\t\titem = item.getParent();\n\t\t}\n\t\tif (call(view))\n\t\t\treturn true;\n\t\treturn false;\n\t}\n\n\treturn {\n\t\t_handleEvent: function(type, point, event) {\n\t\t\tif (!this._eventCounters[type])\n\t\t\t\treturn;\n\t\t\tvar project = this._project,\n\t\t\t\thit = project.hitTest(point, {\n\t\t\t\t\ttolerance: 0,\n\t\t\t\t\tfill: true,\n\t\t\t\t\tstroke: true\n\t\t\t\t}),\n\t\t\t\titem = hit && hit.item,\n\t\t\t\tstopped = false;\n\t\t\tswitch (type) {\n\t\t\tcase 'mousedown':\n\t\t\t\tstopped = callEvent(this, type, event, point, item);\n\t\t\t\tdblClick = lastItem == item && (Date.now() - clickTime < 300);\n\t\t\t\tdownItem = lastItem = item;\n\t\t\t\tdownPoint = lastPoint = overPoint = point;\n\t\t\t\tdragItem = !stopped && item;\n\t\t\t\twhile (dragItem && !dragItem.responds('mousedrag'))\n\t\t\t\t\tdragItem = dragItem._parent;\n\t\t\t\tbreak;\n\t\t\tcase 'mouseup':\n\t\t\t\tstopped = callEvent(this, type, event, point, item, downPoint);\n\t\t\t\tif (dragItem) {\n\t\t\t\t\tif (lastPoint && !lastPoint.equals(point))\n\t\t\t\t\t\tcallEvent(this, 'mousedrag', event, point, dragItem,\n\t\t\t\t\t\t\t\tlastPoint);\n\t\t\t\t\tif (item !== dragItem) {\n\t\t\t\t\t\toverPoint = point;\n\t\t\t\t\t\tcallEvent(this, 'mousemove', event, point, item,\n\t\t\t\t\t\t\t\toverPoint);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!stopped && item && item === downItem) {\n\t\t\t\t\tclickTime = Date.now();\n\t\t\t\t\tcallEvent(this, dblClick && downItem.responds('doubleclick')\n\t\t\t\t\t\t\t? 'doubleclick' : 'click', event, downPoint, item);\n\t\t\t\t\tdblClick = false;\n\t\t\t\t}\n\t\t\t\tdownItem = dragItem = null;\n\t\t\t\tbreak;\n\t\t\tcase 'mousemove':\n\t\t\t\tif (dragItem)\n\t\t\t\t\tstopped = callEvent(this, 'mousedrag', event, point,\n\t\t\t\t\t\t\tdragItem, lastPoint);\n\t\t\t\tif (!stopped) {\n\t\t\t\t\tif (item !== overItem)\n\t\t\t\t\t\toverPoint = point;\n\t\t\t\t\tstopped = callEvent(this, type, event, point, item,\n\t\t\t\t\t\t\toverPoint);\n\t\t\t\t}\n\t\t\t\tlastPoint = overPoint = point;\n\t\t\t\tif (item !== overItem) {\n\t\t\t\t\tcallEvent(this, 'mouseleave', event, point, overItem);\n\t\t\t\t\toverItem = item;\n\t\t\t\t\tcallEvent(this, 'mouseenter', event, point, item);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\treturn stopped;\n\t\t}\n\t};\n});\n\nvar Event = Base.extend({\n\t_class: 'Event',\n\n\tinitialize: function Event(event) {\n\t\tthis.event = event;\n\t},\n\n\tisPrevented: false,\n\tisStopped: false,\n\n\tpreventDefault: function() {\n\t\tthis.isPrevented = true;\n\t\tthis.event.preventDefault();\n\t},\n\n\tstopPropagation: function() {\n\t\tthis.isStopped = true;\n\t\tthis.event.stopPropagation();\n\t},\n\n\tstop: function() {\n\t\tthis.stopPropagation();\n\t\tthis.preventDefault();\n\t},\n\n\tgetModifiers: function() {\n\t\treturn Key.modifiers;\n\t}\n});\n\nvar KeyEvent = Event.extend({\n\t_class: 'KeyEvent',\n\n\tinitialize: function KeyEvent(down, key, character, event) {\n\t\tEvent.call(this, event);\n\t\tthis.type = down ? 'keydown' : 'keyup';\n\t\tthis.key = key;\n\t\tthis.character = character;\n\t},\n\n\ttoString: function() {\n\t\treturn \"{ type: '\" + this.type\n\t\t\t\t+ \"', key: '\" + this.key\n\t\t\t\t+ \"', character: '\" + this.character\n\t\t\t\t+ \"', modifiers: \" + this.getModifiers()\n\t\t\t\t+ \" }\";\n\t}\n});\n\nvar Key = new function() {\n\n\tvar specialKeys = {\n\t\t8: 'backspace',\n\t\t9: 'tab',\n\t\t13: 'enter',\n\t\t16: 'shift',\n\t\t17: 'control',\n\t\t18: 'option',\n\t\t19: 'pause',\n\t\t20: 'caps-lock',\n\t\t27: 'escape',\n\t\t32: 'space',\n\t\t35: 'end',\n\t\t36: 'home',\n\t\t37: 'left',\n\t\t38: 'up',\n\t\t39: 'right',\n\t\t40: 'down',\n\t\t46: 'delete',\n\t\t91: 'command',\n\t\t93: 'command',\n\t\t224: 'command'\n\t},\n\n\tspecialChars = {\n\t\t9: true,\n\t\t13: true,\n\t\t32: true\n\t},\n\n\tmodifiers = new Base({\n\t\tshift: false,\n\t\tcontrol: false,\n\t\toption: false,\n\t\tcommand: false,\n\t\tcapsLock: false,\n\t\tspace: false\n\t}),\n\n\tcharCodeMap = {},\n\tkeyMap = {},\n\tcommandFixMap,\n\tdownCode;\n\n\tfunction handleKey(down, keyCode, charCode, event) {\n\t\tvar character = charCode ? String.fromCharCode(charCode) : '',\n\t\t\tspecialKey = specialKeys[keyCode],\n\t\t\tkey = specialKey || character.toLowerCase(),\n\t\t\ttype = down ? 'keydown' : 'keyup',\n\t\t\tview = View._focused,\n\t\t\tscope = view && view.isVisible() && view._scope,\n\t\t\ttool = scope && scope.tool,\n\t\t\tname;\n\t\tkeyMap[key] = down;\n\t\tif (down) {\n\t\t\tcharCodeMap[keyCode] = charCode;\n\t\t} else {\n\t\t\tdelete charCodeMap[keyCode];\n\t\t}\n\t\tif (specialKey && (name = Base.camelize(specialKey)) in modifiers) {\n\t\t\tmodifiers[name] = down;\n\t\t\tvar browser = paper.browser;\n\t\t\tif (name === 'command' && browser && browser.mac) {\n\t\t\t\tif (down) {\n\t\t\t\t\tcommandFixMap = {};\n\t\t\t\t} else {\n\t\t\t\t\tfor (var code in commandFixMap) {\n\t\t\t\t\t\tif (code in charCodeMap)\n\t\t\t\t\t\t\thandleKey(false, code, commandFixMap[code], event);\n\t\t\t\t\t}\n\t\t\t\t\tcommandFixMap = null;\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (down && commandFixMap) {\n\t\t\tcommandFixMap[keyCode] = charCode;\n\t\t}\n\t\tif (tool && tool.responds(type)) {\n\t\t\tpaper = scope;\n\t\t\ttool.emit(type, new KeyEvent(down, key, character, event));\n\t\t\tif (view)\n\t\t\t\tview.update();\n\t\t}\n\t}\n\n\tDomEvent.add(document, {\n\t\tkeydown: function(event) {\n\t\t\tvar code = event.which || event.keyCode;\n\t\t\tif (code in specialKeys || modifiers.command) {\n\t\t\t\thandleKey(true, code,\n\t\t\t\t\t\tcode in specialChars || modifiers.command ? code : 0,\n\t\t\t\t\t\tevent);\n\t\t\t} else {\n\t\t\t\tdownCode = code;\n\t\t\t}\n\t\t},\n\n\t\tkeypress: function(event) {\n\t\t\tif (downCode != null) {\n\t\t\t\thandleKey(true, downCode, event.which || event.keyCode, event);\n\t\t\t\tdownCode = null;\n\t\t\t}\n\t\t},\n\n\t\tkeyup: function(event) {\n\t\t\tvar code = event.which || event.keyCode;\n\t\t\tif (code in charCodeMap)\n\t\t\t\thandleKey(false, code, charCodeMap[code], event);\n\t\t}\n\t});\n\n\tDomEvent.add(window, {\n\t\tblur: function(event) {\n\t\t\tfor (var code in charCodeMap)\n\t\t\t\thandleKey(false, code, charCodeMap[code], event);\n\t\t}\n\t});\n\n\treturn {\n\t\tmodifiers: modifiers,\n\n\t\tisDown: function(key) {\n\t\t\treturn !!keyMap[key];\n\t\t}\n\t};\n};\n\nvar MouseEvent = Event.extend({\n\t_class: 'MouseEvent',\n\n\tinitialize: function MouseEvent(type, event, point, target, delta) {\n\t\tEvent.call(this, event);\n\t\tthis.type = type;\n\t\tthis.point = point;\n\t\tthis.target = target;\n\t\tthis.delta = delta;\n\t},\n\n\ttoString: function() {\n\t\treturn \"{ type: '\" + this.type\n\t\t\t\t+ \"', point: \" + this.point\n\t\t\t\t+ ', target: ' + this.target\n\t\t\t\t+ (this.delta ? ', delta: ' + this.delta : '')\n\t\t\t\t+ ', modifiers: ' + this.getModifiers()\n\t\t\t\t+ ' }';\n\t}\n});\n\nvar ToolEvent = Event.extend({\n\t_class: 'ToolEvent',\n\t_item: null,\n\n\tinitialize: function ToolEvent(tool, type, event) {\n\t\tthis.tool = tool;\n\t\tthis.type = type;\n\t\tthis.event = event;\n\t},\n\n\t_choosePoint: function(point, toolPoint) {\n\t\treturn point ? point : toolPoint ? toolPoint.clone() : null;\n\t},\n\n\tgetPoint: function() {\n\t\treturn this._choosePoint(this._point, this.tool._point);\n\t},\n\n\tsetPoint: function(point) {\n\t\tthis._point = point;\n\t},\n\n\tgetLastPoint: function() {\n\t\treturn this._choosePoint(this._lastPoint, this.tool._lastPoint);\n\t},\n\n\tsetLastPoint: function(lastPoint) {\n\t\tthis._lastPoint = lastPoint;\n\t},\n\n\tgetDownPoint: function() {\n\t\treturn this._choosePoint(this._downPoint, this.tool._downPoint);\n\t},\n\n\tsetDownPoint: function(downPoint) {\n\t\tthis._downPoint = downPoint;\n\t},\n\n\tgetMiddlePoint: function() {\n\t\tif (!this._middlePoint && this.tool._lastPoint) {\n\t\t\treturn this.tool._point.add(this.tool._lastPoint).divide(2);\n\t\t}\n\t\treturn this._middlePoint;\n\t},\n\n\tsetMiddlePoint: function(middlePoint) {\n\t\tthis._middlePoint = middlePoint;\n\t},\n\n\tgetDelta: function() {\n\t\treturn !this._delta && this.tool._lastPoint\n\t\t\t\t? this.tool._point.subtract(this.tool._lastPoint)\n\t\t\t\t: this._delta;\n\t},\n\n\tsetDelta: function(delta) {\n\t\tthis._delta = delta;\n\t},\n\n\tgetCount: function() {\n\t\treturn /^mouse(down|up)$/.test(this.type)\n\t\t\t\t? this.tool._downCount\n\t\t\t\t: this.tool._count;\n\t},\n\n\tsetCount: function(count) {\n\t\tthis.tool[/^mouse(down|up)$/.test(this.type) ? 'downCount' : 'count']\n\t\t\t= count;\n\t},\n\n\tgetItem: function() {\n\t\tif (!this._item) {\n\t\t\tvar result = this.tool._scope.project.hitTest(this.getPoint());\n\t\t\tif (result) {\n\t\t\t\tvar item = result.item,\n\t\t\t\t\tparent = item._parent;\n\t\t\t\twhile (/^(Group|CompoundPath)$/.test(parent._class)) {\n\t\t\t\t\titem = parent;\n\t\t\t\t\tparent = parent._parent;\n\t\t\t\t}\n\t\t\t\tthis._item = item;\n\t\t\t}\n\t\t}\n\t\treturn this._item;\n\t},\n\n\tsetItem: function(item) {\n\t\tthis._item = item;\n\t},\n\n\ttoString: function() {\n\t\treturn '{ type: ' + this.type\n\t\t\t\t+ ', point: ' + this.getPoint()\n\t\t\t\t+ ', count: ' + this.getCount()\n\t\t\t\t+ ', modifiers: ' + this.getModifiers()\n\t\t\t\t+ ' }';\n\t}\n});\n\nvar Tool = PaperScopeItem.extend({\n\t_class: 'Tool',\n\t_list: 'tools',\n\t_reference: 'tool',\n\t_events: [ 'onActivate', 'onDeactivate', 'onEditOptions',\n\t\t\t'onMouseDown', 'onMouseUp', 'onMouseDrag', 'onMouseMove',\n\t\t\t'onKeyDown', 'onKeyUp' ],\n\n\tinitialize: function Tool(props) {\n\t\tPaperScopeItem.call(this);\n\t\tthis._firstMove = true;\n\t\tthis._count = 0;\n\t\tthis._downCount = 0;\n\t\tthis._set(props);\n\t},\n\n\tgetMinDistance: function() {\n\t\treturn this._minDistance;\n\t},\n\n\tsetMinDistance: function(minDistance) {\n\t\tthis._minDistance = minDistance;\n\t\tif (minDistance != null && this._maxDistance != null\n\t\t\t\t&& minDistance > this._maxDistance) {\n\t\t\tthis._maxDistance = minDistance;\n\t\t}\n\t},\n\n\tgetMaxDistance: function() {\n\t\treturn this._maxDistance;\n\t},\n\n\tsetMaxDistance: function(maxDistance) {\n\t\tthis._maxDistance = maxDistance;\n\t\tif (this._minDistance != null && maxDistance != null\n\t\t\t\t&& maxDistance < this._minDistance) {\n\t\t\tthis._minDistance = maxDistance;\n\t\t}\n\t},\n\n\tgetFixedDistance: function() {\n\t\treturn this._minDistance == this._maxDistance\n\t\t\t? this._minDistance : null;\n\t},\n\n\tsetFixedDistance: function(distance) {\n\t\tthis._minDistance = this._maxDistance = distance;\n\t},\n\n\t_updateEvent: function(type, point, minDistance, maxDistance, start,\n\t\t\tneedsChange, matchMaxDistance) {\n\t\tif (!start) {\n\t\t\tif (minDistance != null || maxDistance != null) {\n\t\t\t\tvar minDist = minDistance != null ? minDistance : 0,\n\t\t\t\t\tvector = point.subtract(this._point),\n\t\t\t\t\tdistance = vector.getLength();\n\t\t\t\tif (distance < minDist)\n\t\t\t\t\treturn false;\n\t\t\t\tif (maxDistance != null && maxDistance != 0) {\n\t\t\t\t\tif (distance > maxDistance) {\n\t\t\t\t\t\tpoint = this._point.add(vector.normalize(maxDistance));\n\t\t\t\t\t} else if (matchMaxDistance) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (needsChange && point.equals(this._point))\n\t\t\t\treturn false;\n\t\t}\n\t\tthis._lastPoint = start && type == 'mousemove' ? point : this._point;\n\t\tthis._point = point;\n\t\tswitch (type) {\n\t\tcase 'mousedown':\n\t\t\tthis._lastPoint = this._downPoint;\n\t\t\tthis._downPoint = this._point;\n\t\t\tthis._downCount++;\n\t\t\tbreak;\n\t\tcase 'mouseup':\n\t\t\tthis._lastPoint = this._downPoint;\n\t\t\tbreak;\n\t\t}\n\t\tthis._count = start ? 0 : this._count + 1;\n\t\treturn true;\n\t},\n\n\t_fireEvent: function(type, event) {\n\t\tvar sets = paper.project._removeSets;\n\t\tif (sets) {\n\t\t\tif (type === 'mouseup')\n\t\t\t\tsets.mousedrag = null;\n\t\t\tvar set = sets[type];\n\t\t\tif (set) {\n\t\t\t\tfor (var id in set) {\n\t\t\t\t\tvar item = set[id];\n\t\t\t\t\tfor (var key in sets) {\n\t\t\t\t\t\tvar other = sets[key];\n\t\t\t\t\t\tif (other && other != set)\n\t\t\t\t\t\t\tdelete other[item._id];\n\t\t\t\t\t}\n\t\t\t\t\titem.remove();\n\t\t\t\t}\n\t\t\t\tsets[type] = null;\n\t\t\t}\n\t\t}\n\t\treturn this.responds(type)\n\t\t\t\t&& this.emit(type, new ToolEvent(this, type, event));\n\t},\n\n\t_handleEvent: function(type, point, event) {\n\t\tpaper = this._scope;\n\t\tvar called = false;\n\t\tswitch (type) {\n\t\tcase 'mousedown':\n\t\t\tthis._updateEvent(type, point, null, null, true, false, false);\n\t\t\tcalled = this._fireEvent(type, event);\n\t\t\tbreak;\n\t\tcase 'mousedrag':\n\t\t\tvar needsChange = false,\n\t\t\t\tmatchMaxDistance = false;\n\t\t\twhile (this._updateEvent(type, point, this.minDistance,\n\t\t\t\t\tthis.maxDistance, false, needsChange, matchMaxDistance)) {\n\t\t\t\tcalled = this._fireEvent(type, event) || called;\n\t\t\t\tneedsChange = true;\n\t\t\t\tmatchMaxDistance = true;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'mouseup':\n\t\t\tif (!point.equals(this._point)\n\t\t\t\t\t&& this._updateEvent('mousedrag', point, this.minDistance,\n\t\t\t\t\t\t\tthis.maxDistance, false, false, false)) {\n\t\t\t\tcalled = this._fireEvent('mousedrag', event);\n\t\t\t}\n\t\t\tthis._updateEvent(type, point, null, this.maxDistance, false,\n\t\t\t\t\tfalse, false);\n\t\t\tcalled = this._fireEvent(type, event) || called;\n\t\t\tthis._updateEvent(type, point, null, null, true, false, false);\n\t\t\tthis._firstMove = true;\n\t\t\tbreak;\n\t\tcase 'mousemove':\n\t\t\twhile (this._updateEvent(type, point, this.minDistance,\n\t\t\t\t\tthis.maxDistance, this._firstMove, true, false)) {\n\t\t\t\tcalled = this._fireEvent(type, event) || called;\n\t\t\t\tthis._firstMove = false;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tif (called)\n\t\t\tevent.preventDefault();\n\t\treturn called;\n\t}\n\n});\n\nvar Http = {\n\trequest: function(method, url, callback, async) {\n\t\tasync = (async === undefined) ? true : async;\n\t\tvar xhr = new (window.ActiveXObject || XMLHttpRequest)(\n\t\t\t\t\t'Microsoft.XMLHTTP');\n\t\txhr.open(method.toUpperCase(), url, async);\n\t\tif ('overrideMimeType' in xhr)\n\t\t\txhr.overrideMimeType('text/plain');\n\t\txhr.onreadystatechange = function() {\n\t\t\tif (xhr.readyState === 4) {\n\t\t\t\tvar status = xhr.status;\n\t\t\t\tif (status === 0 || status === 200) {\n\t\t\t\t\tcallback.call(xhr, xhr.responseText);\n\t\t\t\t} else {\n\t\t\t\t\tthrow new Error('Could not load ' + url + ' (Error '\n\t\t\t\t\t\t\t+ status + ')');\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\treturn xhr.send(null);\n\t}\n};\n\nvar CanvasProvider = {\n\tcanvases: [],\n\n\tgetCanvas: function(width, height) {\n\t\tvar canvas,\n\t\t\tclear = true;\n\t\tif (typeof width === 'object') {\n\t\t\theight = width.height;\n\t\t\twidth = width.width;\n\t\t}\n\t\tif (this.canvases.length) {\n\t\t\tcanvas = this.canvases.pop();\n\t\t} else {\n\t\t\tcanvas = document.createElement('canvas');\n\t\t}\n\t\tvar ctx = canvas.getContext('2d');\n\t\tif (canvas.width === width && canvas.height === height) {\n\t\t\tif (clear)\n\t\t\t\tctx.clearRect(0, 0, width + 1, height + 1);\n\t\t} else {\n\t\t\tcanvas.width = width;\n\t\t\tcanvas.height = height;\n\t\t}\n\t\tctx.save();\n\t\treturn canvas;\n\t},\n\n\tgetContext: function(width, height) {\n\t\treturn this.getCanvas(width, height).getContext('2d');\n\t},\n\n\trelease: function(obj) {\n\t\tvar canvas = obj.canvas ? obj.canvas : obj;\n\t\tcanvas.getContext('2d').restore();\n\t\tthis.canvases.push(canvas);\n\t}\n};\n\nvar BlendMode = new function() {\n\tvar min = Math.min,\n\t\tmax = Math.max,\n\t\tabs = Math.abs,\n\t\tsr, sg, sb, sa,\n\t\tbr, bg, bb, ba,\n\t\tdr, dg, db;\n\n\tfunction getLum(r, g, b) {\n\t\treturn 0.2989 * r + 0.587 * g + 0.114 * b;\n\t}\n\n\tfunction setLum(r, g, b, l) {\n\t\tvar d = l - getLum(r, g, b);\n\t\tdr = r + d;\n\t\tdg = g + d;\n\t\tdb = b + d;\n\t\tvar l = getLum(dr, dg, db),\n\t\t\tmn = min(dr, dg, db),\n\t\t\tmx = max(dr, dg, db);\n\t\tif (mn < 0) {\n\t\t\tvar lmn = l - mn;\n\t\t\tdr = l + (dr - l) * l / lmn;\n\t\t\tdg = l + (dg - l) * l / lmn;\n\t\t\tdb = l + (db - l) * l / lmn;\n\t\t}\n\t\tif (mx > 255) {\n\t\t\tvar ln = 255 - l,\n\t\t\t\tmxl = mx - l;\n\t\t\tdr = l + (dr - l) * ln / mxl;\n\t\t\tdg = l + (dg - l) * ln / mxl;\n\t\t\tdb = l + (db - l) * ln / mxl;\n\t\t}\n\t}\n\n\tfunction getSat(r, g, b) {\n\t\treturn max(r, g, b) - min(r, g, b);\n\t}\n\n\tfunction setSat(r, g, b, s) {\n\t\tvar col = [r, g, b],\n\t\t\tmx = max(r, g, b),\n\t\t\tmn = min(r, g, b),\n\t\t\tmd;\n\t\tmn = mn === r ? 0 : mn === g ? 1 : 2;\n\t\tmx = mx === r ? 0 : mx === g ? 1 : 2;\n\t\tmd = min(mn, mx) === 0 ? max(mn, mx) === 1 ? 2 : 1 : 0;\n\t\tif (col[mx] > col[mn]) {\n\t\t\tcol[md] = (col[md] - col[mn]) * s / (col[mx] - col[mn]);\n\t\t\tcol[mx] = s;\n\t\t} else {\n\t\t\tcol[md] = col[mx] = 0;\n\t\t}\n\t\tcol[mn] = 0;\n\t\tdr = col[0];\n\t\tdg = col[1];\n\t\tdb = col[2];\n\t}\n\n\tvar modes = {\n\t\tmultiply: function() {\n\t\t\tdr = br * sr / 255;\n\t\t\tdg = bg * sg / 255;\n\t\t\tdb = bb * sb / 255;\n\t\t},\n\n\t\tscreen: function() {\n\t\t\tdr = br + sr - (br * sr / 255);\n\t\t\tdg = bg + sg - (bg * sg / 255);\n\t\t\tdb = bb + sb - (bb * sb / 255);\n\t\t},\n\n\t\toverlay: function() {\n\t\t\tdr = br < 128 ? 2 * br * sr / 255 : 255 - 2 * (255 - br) * (255 - sr) / 255;\n\t\t\tdg = bg < 128 ? 2 * bg * sg / 255 : 255 - 2 * (255 - bg) * (255 - sg) / 255;\n\t\t\tdb = bb < 128 ? 2 * bb * sb / 255 : 255 - 2 * (255 - bb) * (255 - sb) / 255;\n\t\t},\n\n\t\t'soft-light': function() {\n\t\t\tvar t = sr * br / 255;\n\t\t\tdr = t + br * (255 - (255 - br) * (255 - sr) / 255 - t) / 255;\n\t\t\tt = sg * bg / 255;\n\t\t\tdg = t + bg * (255 - (255 - bg) * (255 - sg) / 255 - t) / 255;\n\t\t\tt = sb * bb / 255;\n\t\t\tdb = t + bb * (255 - (255 - bb) * (255 - sb) / 255 - t) / 255;\n\t\t},\n\n\t\t'hard-light': function() {\n\t\t\tdr = sr < 128 ? 2 * sr * br / 255 : 255 - 2 * (255 - sr) * (255 - br) / 255;\n\t\t\tdg = sg < 128 ? 2 * sg * bg / 255 : 255 - 2 * (255 - sg) * (255 - bg) / 255;\n\t\t\tdb = sb < 128 ? 2 * sb * bb / 255 : 255 - 2 * (255 - sb) * (255 - bb) / 255;\n\t\t},\n\n\t\t'color-dodge': function() {\n\t\t\tdr = br === 0 ? 0 : sr === 255 ? 255 : min(255, 255 * br / (255 - sr));\n\t\t\tdg = bg === 0 ? 0 : sg === 255 ? 255 : min(255, 255 * bg / (255 - sg));\n\t\t\tdb = bb === 0 ? 0 : sb === 255 ? 255 : min(255, 255 * bb / (255 - sb));\n\t\t},\n\n\t\t'color-burn': function() {\n\t\t\tdr = br === 255 ? 255 : sr === 0 ? 0 : max(0, 255 - (255 - br) * 255 / sr);\n\t\t\tdg = bg === 255 ? 255 : sg === 0 ? 0 : max(0, 255 - (255 - bg) * 255 / sg);\n\t\t\tdb = bb === 255 ? 255 : sb === 0 ? 0 : max(0, 255 - (255 - bb) * 255 / sb);\n\t\t},\n\n\t\tdarken: function() {\n\t\t\tdr = br < sr ? br : sr;\n\t\t\tdg = bg < sg ? bg : sg;\n\t\t\tdb = bb < sb ? bb : sb;\n\t\t},\n\n\t\tlighten: function() {\n\t\t\tdr = br > sr ? br : sr;\n\t\t\tdg = bg > sg ? bg : sg;\n\t\t\tdb = bb > sb ? bb : sb;\n\t\t},\n\n\t\tdifference: function() {\n\t\t\tdr = br - sr;\n\t\t\tif (dr < 0)\n\t\t\t\tdr = -dr;\n\t\t\tdg = bg - sg;\n\t\t\tif (dg < 0)\n\t\t\t\tdg = -dg;\n\t\t\tdb = bb - sb;\n\t\t\tif (db < 0)\n\t\t\t\tdb = -db;\n\t\t},\n\n\t\texclusion: function() {\n\t\t\tdr = br + sr * (255 - br - br) / 255;\n\t\t\tdg = bg + sg * (255 - bg - bg) / 255;\n\t\t\tdb = bb + sb * (255 - bb - bb) / 255;\n\t\t},\n\n\t\thue: function() {\n\t\t\tsetSat(sr, sg, sb, getSat(br, bg, bb));\n\t\t\tsetLum(dr, dg, db, getLum(br, bg, bb));\n\t\t},\n\n\t\tsaturation: function() {\n\t\t\tsetSat(br, bg, bb, getSat(sr, sg, sb));\n\t\t\tsetLum(dr, dg, db, getLum(br, bg, bb));\n\t\t},\n\n\t\tluminosity: function() {\n\t\t\tsetLum(br, bg, bb, getLum(sr, sg, sb));\n\t\t},\n\n\t\tcolor: function() {\n\t\t\tsetLum(sr, sg, sb, getLum(br, bg, bb));\n\t\t},\n\n\t\tadd: function() {\n\t\t\tdr = min(br + sr, 255);\n\t\t\tdg = min(bg + sg, 255);\n\t\t\tdb = min(bb + sb, 255);\n\t\t},\n\n\t\tsubtract: function() {\n\t\t\tdr = max(br - sr, 0);\n\t\t\tdg = max(bg - sg, 0);\n\t\t\tdb = max(bb - sb, 0);\n\t\t},\n\n\t\taverage: function() {\n\t\t\tdr = (br + sr) / 2;\n\t\t\tdg = (bg + sg) / 2;\n\t\t\tdb = (bb + sb) / 2;\n\t\t},\n\n\t\tnegation: function() {\n\t\t\tdr = 255 - abs(255 - sr - br);\n\t\t\tdg = 255 - abs(255 - sg - bg);\n\t\t\tdb = 255 - abs(255 - sb - bb);\n\t\t}\n\t};\n\n\tvar nativeModes = this.nativeModes = Base.each([\n\t\t'source-over', 'source-in', 'source-out', 'source-atop',\n\t\t'destination-over', 'destination-in', 'destination-out',\n\t\t'destination-atop', 'lighter', 'darker', 'copy', 'xor'\n\t], function(mode) {\n\t\tthis[mode] = true;\n\t}, {});\n\n\tvar ctx = CanvasProvider.getContext(1, 1);\n\tBase.each(modes, function(func, mode) {\n\t\tvar darken = mode === 'darken',\n\t\t\tok = false;\n\t\tctx.save();\n\t\ttry {\n\t\t\tctx.fillStyle = darken ? '#300' : '#a00';\n\t\t\tctx.fillRect(0, 0, 1, 1);\n\t\t\tctx.globalCompositeOperation = mode;\n\t\t\tif (ctx.globalCompositeOperation === mode) {\n\t\t\t\tctx.fillStyle = darken ? '#a00' : '#300';\n\t\t\t\tctx.fillRect(0, 0, 1, 1);\n\t\t\t\tok = ctx.getImageData(0, 0, 1, 1).data[0] !== darken ? 170 : 51;\n\t\t\t}\n\t\t} catch (e) {}\n\t\tctx.restore();\n\t\tnativeModes[mode] = ok;\n\t});\n\tCanvasProvider.release(ctx);\n\n\tthis.process = function(mode, srcContext, dstContext, alpha, offset) {\n\t\tvar srcCanvas = srcContext.canvas,\n\t\t\tnormal = mode === 'normal';\n\t\tif (normal || nativeModes[mode]) {\n\t\t\tdstContext.save();\n\t\t\tdstContext.setTransform(1, 0, 0, 1, 0, 0);\n\t\t\tdstContext.globalAlpha = alpha;\n\t\t\tif (!normal)\n\t\t\t\tdstContext.globalCompositeOperation = mode;\n\t\t\tdstContext.drawImage(srcCanvas, offset.x, offset.y);\n\t\t\tdstContext.restore();\n\t\t} else {\n\t\t\tvar process = modes[mode];\n\t\t\tif (!process)\n\t\t\t\treturn;\n\t\t\tvar dstData = dstContext.getImageData(offset.x, offset.y,\n\t\t\t\t\tsrcCanvas.width, srcCanvas.height),\n\t\t\t\tdst = dstData.data,\n\t\t\t\tsrc = srcContext.getImageData(0, 0,\n\t\t\t\t\tsrcCanvas.width, srcCanvas.height).data;\n\t\t\tfor (var i = 0, l = dst.length; i < l; i += 4) {\n\t\t\t\tsr = src[i];\n\t\t\t\tbr = dst[i];\n\t\t\t\tsg = src[i + 1];\n\t\t\t\tbg = dst[i + 1];\n\t\t\t\tsb = src[i + 2];\n\t\t\t\tbb = dst[i + 2];\n\t\t\t\tsa = src[i + 3];\n\t\t\t\tba = dst[i + 3];\n\t\t\t\tprocess();\n\t\t\t\tvar a1 = sa * alpha / 255,\n\t\t\t\t\ta2 = 1 - a1;\n\t\t\t\tdst[i] = a1 * dr + a2 * br;\n\t\t\t\tdst[i + 1] = a1 * dg + a2 * bg;\n\t\t\t\tdst[i + 2] = a1 * db + a2 * bb;\n\t\t\t\tdst[i + 3] = sa * alpha + a2 * ba;\n\t\t\t}\n\t\t\tdstContext.putImageData(dstData, offset.x, offset.y);\n\t\t}\n\t};\n};\n\nvar SVGStyles = Base.each({\n\tfillColor: ['fill', 'color'],\n\tstrokeColor: ['stroke', 'color'],\n\tstrokeWidth: ['stroke-width', 'number'],\n\tstrokeCap: ['stroke-linecap', 'string'],\n\tstrokeJoin: ['stroke-linejoin', 'string'],\n\tstrokeScaling: ['vector-effect', 'lookup', {\n\t\ttrue: 'none',\n\t\tfalse: 'non-scaling-stroke'\n\t}, function(item, value) {\n\t\treturn !value\n\t\t\t\t&& (item instanceof PathItem\n\t\t\t\t\t|| item instanceof Shape\n\t\t\t\t\t|| item instanceof TextItem);\n\t}],\n\tmiterLimit: ['stroke-miterlimit', 'number'],\n\tdashArray: ['stroke-dasharray', 'array'],\n\tdashOffset: ['stroke-dashoffset', 'number'],\n\tfontFamily: ['font-family', 'string'],\n\tfontWeight: ['font-weight', 'string'],\n\tfontSize: ['font-size', 'number'],\n\tjustification: ['text-anchor', 'lookup', {\n\t\tleft: 'start',\n\t\tcenter: 'middle',\n\t\tright: 'end'\n\t}],\n\topacity: ['opacity', 'number'],\n\tblendMode: ['mix-blend-mode', 'string']\n}, function(entry, key) {\n\tvar part = Base.capitalize(key),\n\t\tlookup = entry[2];\n\tthis[key] = {\n\t\ttype: entry[1],\n\t\tproperty: key,\n\t\tattribute: entry[0],\n\t\ttoSVG: lookup,\n\t\tfromSVG: lookup && Base.each(lookup, function(value, name) {\n\t\t\tthis[value] = name;\n\t\t}, {}),\n\t\texportFilter: entry[3],\n\t\tget: 'get' + part,\n\t\tset: 'set' + part\n\t};\n}, {});\n\nvar SVGNamespaces = {\n\thref: 'http://www.w3.org/1999/xlink',\n\txlink: 'http://www.w3.org/2000/xmlns'\n};\n\nnew function() {\n\tvar formatter;\n\n\tfunction setAttributes(node, attrs) {\n\t\tfor (var key in attrs) {\n\t\t\tvar val = attrs[key],\n\t\t\t\tnamespace = SVGNamespaces[key];\n\t\t\tif (typeof val === 'number')\n\t\t\t\tval = formatter.number(val);\n\t\t\tif (namespace) {\n\t\t\t\tnode.setAttributeNS(namespace, key, val);\n\t\t\t} else {\n\t\t\t\tnode.setAttribute(key, val);\n\t\t\t}\n\t\t}\n\t\treturn node;\n\t}\n\n\tfunction createElement(tag, attrs) {\n\t\treturn setAttributes(\n\t\t\tdocument.createElementNS('http://www.w3.org/2000/svg', tag), attrs);\n\t}\n\n\tfunction getTransform(matrix, coordinates, center) {\n\t\tvar attrs = new Base(),\n\t\t\ttrans = matrix.getTranslation();\n\t\tif (coordinates) {\n\t\t\tmatrix = matrix.shiftless();\n\t\t\tvar point = matrix._inverseTransform(trans);\n\t\t\tattrs[center ? 'cx' : 'x'] = point.x;\n\t\t\tattrs[center ? 'cy' : 'y'] = point.y;\n\t\t\ttrans = null;\n\t\t}\n\t\tif (!matrix.isIdentity()) {\n\t\t\tvar decomposed = matrix.decompose();\n\t\t\tif (decomposed && !decomposed.shearing) {\n\t\t\t\tvar parts = [],\n\t\t\t\t\tangle = decomposed.rotation,\n\t\t\t\t\tscale = decomposed.scaling;\n\t\t\t\tif (trans && !trans.isZero())\n\t\t\t\t\tparts.push('translate(' + formatter.point(trans) + ')');\n\t\t\t\tif (!Numerical.isZero(scale.x - 1)\n\t\t\t\t\t\t|| !Numerical.isZero(scale.y - 1))\n\t\t\t\t\tparts.push('scale(' + formatter.point(scale) +')');\n\t\t\t\tif (angle)\n\t\t\t\t\tparts.push('rotate(' + formatter.number(angle) + ')');\n\t\t\t\tattrs.transform = parts.join(' ');\n\t\t\t} else {\n\t\t\t\tattrs.transform = 'matrix(' + matrix.getValues().join(',') + ')';\n\t\t\t}\n\t\t}\n\t\treturn attrs;\n\t}\n\n\tfunction exportGroup(item, options) {\n\t\tvar attrs = getTransform(item._matrix),\n\t\t\tchildren = item._children;\n\t\tvar node = createElement('g', attrs);\n\t\tfor (var i = 0, l = children.length; i < l; i++) {\n\t\t\tvar child = children[i];\n\t\t\tvar childNode = exportSVG(child, options);\n\t\t\tif (childNode) {\n\t\t\t\tif (child.isClipMask()) {\n\t\t\t\t\tvar clip = createElement('clipPath');\n\t\t\t\t\tclip.appendChild(childNode);\n\t\t\t\t\tsetDefinition(child, clip, 'clip');\n\t\t\t\t\tsetAttributes(node, {\n\t\t\t\t\t\t'clip-path': 'url(#' + clip.id + ')'\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\tnode.appendChild(childNode);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn node;\n\t}\n\n\tfunction exportRaster(item, options) {\n\t\tvar attrs = getTransform(item._matrix, true),\n\t\t\tsize = item.getSize(),\n\t\t\timage = item.getImage();\n\t\tattrs.x -= size.width / 2;\n\t\tattrs.y -= size.height / 2;\n\t\tattrs.width = size.width;\n\t\tattrs.height = size.height;\n\t\tattrs.href = options.embedImages === false && image && image.src\n\t\t\t\t|| item.toDataURL();\n\t\treturn createElement('image', attrs);\n\t}\n\n\tfunction exportPath(item, options) {\n\t\tvar matchShapes = options.matchShapes;\n\t\tif (matchShapes) {\n\t\t\tvar shape = item.toShape(false);\n\t\t\tif (shape)\n\t\t\t\treturn exportShape(shape, options);\n\t\t}\n\t\tvar segments = item._segments,\n\t\t\ttype,\n\t\t\tattrs = getTransform(item._matrix);\n\t\tif (segments.length === 0)\n\t\t\treturn null;\n\t\tif (matchShapes && !item.hasHandles()) {\n\t\t\tif (segments.length >= 3) {\n\t\t\t\ttype = item._closed ? 'polygon' : 'polyline';\n\t\t\t\tvar parts = [];\n\t\t\t\tfor(var i = 0, l = segments.length; i < l; i++)\n\t\t\t\t\tparts.push(formatter.point(segments[i]._point));\n\t\t\t\tattrs.points = parts.join(' ');\n\t\t\t} else {\n\t\t\t\ttype = 'line';\n\t\t\t\tvar first = segments[0]._point,\n\t\t\t\t\tlast = segments[segments.length - 1]._point;\n\t\t\t\tattrs.set({\n\t\t\t\t\tx1: first.x,\n\t\t\t\t\ty1: first.y,\n\t\t\t\t\tx2: last.x,\n\t\t\t\t\ty2: last.y\n\t\t\t\t});\n\t\t\t}\n\t\t} else {\n\t\t\ttype = 'path';\n\t\t\tattrs.d = item.getPathData(null, options.precision);\n\t\t}\n\t\treturn createElement(type, attrs);\n\t}\n\n\tfunction exportShape(item) {\n\t\tvar type = item._type,\n\t\t\tradius = item._radius,\n\t\t\tattrs = getTransform(item._matrix, true, type !== 'rectangle');\n\t\tif (type === 'rectangle') {\n\t\t\ttype = 'rect';\n\t\t\tvar size = item._size,\n\t\t\t\twidth = size.width,\n\t\t\t\theight = size.height;\n\t\t\tattrs.x -= width / 2;\n\t\t\tattrs.y -= height / 2;\n\t\t\tattrs.width = width;\n\t\t\tattrs.height = height;\n\t\t\tif (radius.isZero())\n\t\t\t\tradius = null;\n\t\t}\n\t\tif (radius) {\n\t\t\tif (type === 'circle') {\n\t\t\t\tattrs.r = radius;\n\t\t\t} else {\n\t\t\t\tattrs.rx = radius.width;\n\t\t\t\tattrs.ry = radius.height;\n\t\t\t}\n\t\t}\n\t\treturn createElement(type, attrs);\n\t}\n\n\tfunction exportCompoundPath(item, options) {\n\t\tvar attrs = getTransform(item._matrix);\n\t\tvar data = item.getPathData(null, options.precision);\n\t\tif (data)\n\t\t\tattrs.d = data;\n\t\treturn createElement('path', attrs);\n\t}\n\n\tfunction exportPlacedSymbol(item, options) {\n\t\tvar attrs = getTransform(item._matrix, true),\n\t\t\tsymbol = item.getSymbol(),\n\t\t\tsymbolNode = getDefinition(symbol, 'symbol'),\n\t\t\tdefinition = symbol.getDefinition(),\n\t\t\tbounds = definition.getBounds();\n\t\tif (!symbolNode) {\n\t\t\tsymbolNode = createElement('symbol', {\n\t\t\t\tviewBox: formatter.rectangle(bounds)\n\t\t\t});\n\t\t\tsymbolNode.appendChild(exportSVG(definition, options));\n\t\t\tsetDefinition(symbol, symbolNode, 'symbol');\n\t\t}\n\t\tattrs.href = '#' + symbolNode.id;\n\t\tattrs.x += bounds.x;\n\t\tattrs.y += bounds.y;\n\t\tattrs.width = formatter.number(bounds.width);\n\t\tattrs.height = formatter.number(bounds.height);\n\t\tattrs.overflow = 'visible';\n\t\treturn createElement('use', attrs);\n\t}\n\n\tfunction exportGradient(color) {\n\t\tvar gradientNode = getDefinition(color, 'color');\n\t\tif (!gradientNode) {\n\t\t\tvar gradient = color.getGradient(),\n\t\t\t\tradial = gradient._radial,\n\t\t\t\torigin = color.getOrigin().transform(),\n\t\t\t\tdestination = color.getDestination().transform(),\n\t\t\t\tattrs;\n\t\t\tif (radial) {\n\t\t\t\tattrs = {\n\t\t\t\t\tcx: origin.x,\n\t\t\t\t\tcy: origin.y,\n\t\t\t\t\tr: origin.getDistance(destination)\n\t\t\t\t};\n\t\t\t\tvar highlight = color.getHighlight();\n\t\t\t\tif (highlight) {\n\t\t\t\t\thighlight = highlight.transform();\n\t\t\t\t\tattrs.fx = highlight.x;\n\t\t\t\t\tattrs.fy = highlight.y;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tattrs = {\n\t\t\t\t\tx1: origin.x,\n\t\t\t\t\ty1: origin.y,\n\t\t\t\t\tx2: destination.x,\n\t\t\t\t\ty2: destination.y\n\t\t\t\t};\n\t\t\t}\n\t\t\tattrs.gradientUnits = 'userSpaceOnUse';\n\t\t\tgradientNode = createElement(\n\t\t\t\t\t(radial ? 'radial' : 'linear') + 'Gradient', attrs);\n\t\t\tvar stops = gradient._stops;\n\t\t\tfor (var i = 0, l = stops.length; i < l; i++) {\n\t\t\t\tvar stop = stops[i],\n\t\t\t\t\tstopColor = stop._color,\n\t\t\t\t\talpha = stopColor.getAlpha();\n\t\t\t\tattrs = {\n\t\t\t\t\toffset: stop._rampPoint,\n\t\t\t\t\t'stop-color': stopColor.toCSS(true)\n\t\t\t\t};\n\t\t\t\tif (alpha < 1)\n\t\t\t\t\tattrs['stop-opacity'] = alpha;\n\t\t\t\tgradientNode.appendChild(createElement('stop', attrs));\n\t\t\t}\n\t\t\tsetDefinition(color, gradientNode, 'color');\n\t\t}\n\t\treturn 'url(#' + gradientNode.id + ')';\n\t}\n\n\tfunction exportText(item) {\n\t\tvar node = createElement('text', getTransform(item._matrix, true));\n\t\tnode.textContent = item._content;\n\t\treturn node;\n\t}\n\n\tvar exporters = {\n\t\tGroup: exportGroup,\n\t\tLayer: exportGroup,\n\t\tRaster: exportRaster,\n\t\tPath: exportPath,\n\t\tShape: exportShape,\n\t\tCompoundPath: exportCompoundPath,\n\t\tPlacedSymbol: exportPlacedSymbol,\n\t\tPointText: exportText\n\t};\n\n\tfunction applyStyle(item, node, isRoot) {\n\t\tvar attrs = {},\n\t\t\tparent = !isRoot && item.getParent();\n\n\t\tif (item._name != null)\n\t\t\tattrs.id = item._name;\n\n\t\tBase.each(SVGStyles, function(entry) {\n\t\t\tvar get = entry.get,\n\t\t\t\ttype = entry.type,\n\t\t\t\tvalue = item[get]();\n\t\t\tif (entry.exportFilter\n\t\t\t\t\t? entry.exportFilter(item, value)\n\t\t\t\t\t: !parent || !Base.equals(parent[get](), value)) {\n\t\t\t\tif (type === 'color' && value != null) {\n\t\t\t\t\tvar alpha = value.getAlpha();\n\t\t\t\t\tif (alpha < 1)\n\t\t\t\t\t\tattrs[entry.attribute + '-opacity'] = alpha;\n\t\t\t\t}\n\t\t\t\tattrs[entry.attribute] = value == null\n\t\t\t\t\t? 'none'\n\t\t\t\t\t: type === 'number'\n\t\t\t\t\t\t? formatter.number(value)\n\t\t\t\t\t\t: type === 'color'\n\t\t\t\t\t\t\t? value.gradient\n\t\t\t\t\t\t\t\t? exportGradient(value, item)\n\t\t\t\t\t\t\t\t: value.toCSS(true)\n\t\t\t\t\t\t\t: type === 'array'\n\t\t\t\t\t\t\t\t? value.join(',')\n\t\t\t\t\t\t\t\t: type === 'lookup'\n\t\t\t\t\t\t\t\t\t? entry.toSVG[value]\n\t\t\t\t\t\t\t\t\t: value;\n\t\t\t}\n\t\t});\n\n\t\tif (attrs.opacity === 1)\n\t\t\tdelete attrs.opacity;\n\n\t\tif (!item._visible)\n\t\t\tattrs.visibility = 'hidden';\n\n\t\treturn setAttributes(node, attrs);\n\t}\n\n\tvar definitions;\n\tfunction getDefinition(item, type) {\n\t\tif (!definitions)\n\t\t\tdefinitions = { ids: {}, svgs: {} };\n\t\treturn item && definitions.svgs[type + '-' + item._id];\n\t}\n\n\tfunction setDefinition(item, node, type) {\n\t\tif (!definitions)\n\t\t\tgetDefinition();\n\t\tvar id = definitions.ids[type] = (definitions.ids[type] || 0) + 1;\n\t\tnode.id = type + '-' + id;\n\t\tdefinitions.svgs[type + '-' + item._id] = node;\n\t}\n\n\tfunction exportDefinitions(node, options) {\n\t\tvar svg = node,\n\t\t\tdefs = null;\n\t\tif (definitions) {\n\t\t\tsvg = node.nodeName.toLowerCase() === 'svg' && node;\n\t\t\tfor (var i in definitions.svgs) {\n\t\t\t\tif (!defs) {\n\t\t\t\t\tif (!svg) {\n\t\t\t\t\t\tsvg = createElement('svg');\n\t\t\t\t\t\tsvg.appendChild(node);\n\t\t\t\t\t}\n\t\t\t\t\tdefs = svg.insertBefore(createElement('defs'),\n\t\t\t\t\t\t\tsvg.firstChild);\n\t\t\t\t}\n\t\t\t\tdefs.appendChild(definitions.svgs[i]);\n\t\t\t}\n\t\t\tdefinitions = null;\n\t\t}\n\t\treturn options.asString\n\t\t\t\t? new XMLSerializer().serializeToString(svg)\n\t\t\t\t: svg;\n\t}\n\n\tfunction exportSVG(item, options, isRoot) {\n\t\tvar exporter = exporters[item._class],\n\t\t\tnode = exporter && exporter(item, options);\n\t\tif (node) {\n\t\t\tvar onExport = options.onExport;\n\t\t\tif (onExport)\n\t\t\t\tnode = onExport(item, node, options) || node;\n\t\t\tvar data = JSON.stringify(item._data);\n\t\t\tif (data && data !== '{}' && data !== 'null')\n\t\t\t\tnode.setAttribute('data-paper-data', data);\n\t\t}\n\t\treturn node && applyStyle(item, node, isRoot);\n\t}\n\n\tfunction setOptions(options) {\n\t\tif (!options)\n\t\t\toptions = {};\n\t\tformatter = new Formatter(options.precision);\n\t\treturn options;\n\t}\n\n\tItem.inject({\n\t\texportSVG: function(options) {\n\t\t\toptions = setOptions(options);\n\t\t\treturn exportDefinitions(exportSVG(this, options, true), options);\n\t\t}\n\t});\n\n\tProject.inject({\n\t\texportSVG: function(options) {\n\t\t\toptions = setOptions(options);\n\t\t\tvar layers = this.layers,\n\t\t\t\tview = this.getView(),\n\t\t\t\tsize = view.getViewSize(),\n\t\t\t\tnode = createElement('svg', {\n\t\t\t\t\tx: 0,\n\t\t\t\t\ty: 0,\n\t\t\t\t\twidth: size.width,\n\t\t\t\t\theight: size.height,\n\t\t\t\t\tversion: '1.1',\n\t\t\t\t\txmlns: 'http://www.w3.org/2000/svg',\n\t\t\t\t\t'xmlns:xlink': 'http://www.w3.org/1999/xlink'\n\t\t\t\t}),\n\t\t\t\tparent = node,\n\t\t\t\tmatrix = view._matrix;\n\t\t\tif (!matrix.isIdentity())\n\t\t\t\tparent = node.appendChild(\n\t\t\t\t\t\tcreateElement('g', getTransform(matrix)));\n\t\t\tfor (var i = 0, l = layers.length; i < l; i++)\n\t\t\t\tparent.appendChild(exportSVG(layers[i], options, true));\n\t\t\treturn exportDefinitions(node, options);\n\t\t}\n\t});\n};\n\nnew function() {\n\n\tfunction getValue(node, name, isString, allowNull) {\n\t\tvar namespace = SVGNamespaces[name],\n\t\t\tvalue = namespace\n\t\t\t\t? node.getAttributeNS(namespace, name)\n\t\t\t\t: node.getAttribute(name);\n\t\tif (value === 'null')\n\t\t\tvalue = null;\n\t\treturn value == null\n\t\t\t\t? allowNull\n\t\t\t\t\t? null\n\t\t\t\t\t: isString\n\t\t\t\t\t\t? ''\n\t\t\t\t\t\t: 0\n\t\t\t\t: isString\n\t\t\t\t\t? value\n\t\t\t\t\t: parseFloat(value);\n\t}\n\n\tfunction getPoint(node, x, y, allowNull) {\n\t\tx = getValue(node, x, false, allowNull);\n\t\ty = getValue(node, y, false, allowNull);\n\t\treturn allowNull && (x == null || y == null) ? null\n\t\t\t\t: new Point(x, y);\n\t}\n\n\tfunction getSize(node, w, h, allowNull) {\n\t\tw = getValue(node, w, false, allowNull);\n\t\th = getValue(node, h, false, allowNull);\n\t\treturn allowNull && (w == null || h == null) ? null\n\t\t\t\t: new Size(w, h);\n\t}\n\n\tfunction convertValue(value, type, lookup) {\n\t\treturn value === 'none'\n\t\t\t\t? null\n\t\t\t\t: type === 'number'\n\t\t\t\t\t? parseFloat(value)\n\t\t\t\t\t: type === 'array'\n\t\t\t\t\t\t? value ? value.split(/[\\s,]+/g).map(parseFloat) : []\n\t\t\t\t\t\t: type === 'color'\n\t\t\t\t\t\t\t? getDefinition(value) || value\n\t\t\t\t\t\t\t: type === 'lookup'\n\t\t\t\t\t\t\t\t? lookup[value]\n\t\t\t\t\t\t\t\t: value;\n\t}\n\n\tfunction importGroup(node, type, options, isRoot) {\n\t\tvar nodes = node.childNodes,\n\t\t\tisClip = type === 'clippath',\n\t\t\titem = new Group(),\n\t\t\tproject = item._project,\n\t\t\tcurrentStyle = project._currentStyle,\n\t\t\tchildren = [];\n\t\tif (!isClip) {\n\t\t\titem = applyAttributes(item, node, isRoot);\n\t\t\tproject._currentStyle = item._style.clone();\n\t\t}\n\t\tif (isRoot) {\n\t\t\tvar defs = node.querySelectorAll('defs');\n\t\t\tfor (var i = 0, l = defs.length; i < l; i++) {\n\t\t\t\timportSVG(defs[i], options, false);\n\t\t\t}\n\t\t}\n\t\tfor (var i = 0, l = nodes.length; i < l; i++) {\n\t\t\tvar childNode = nodes[i],\n\t\t\t\tchild;\n\t\t\tif (childNode.nodeType === 1\n\t\t\t\t\t&& childNode.nodeName.toLowerCase() !== 'defs'\n\t\t\t\t\t&& (child = importSVG(childNode, options, false))\n\t\t\t\t\t&& !(child instanceof Symbol))\n\t\t\t\tchildren.push(child);\n\t\t}\n\t\titem.addChildren(children);\n\t\tif (isClip)\n\t\t\titem = applyAttributes(item.reduce(), node, isRoot);\n\t\tproject._currentStyle = currentStyle;\n\t\tif (isClip || type === 'defs') {\n\t\t\titem.remove();\n\t\t\titem = null;\n\t\t}\n\t\treturn item;\n\t}\n\n\tfunction importPoly(node, type) {\n\t\tvar coords = node.getAttribute('points').match(\n\t\t\t\t\t/[+-]?(?:\\d*\\.\\d+|\\d+\\.?)(?:[eE][+-]?\\d+)?/g),\n\t\t\tpoints = [];\n\t\tfor (var i = 0, l = coords.length; i < l; i += 2)\n\t\t\tpoints.push(new Point(\n\t\t\t\t\tparseFloat(coords[i]),\n\t\t\t\t\tparseFloat(coords[i + 1])));\n\t\tvar path = new Path(points);\n\t\tif (type === 'polygon')\n\t\t\tpath.closePath();\n\t\treturn path;\n\t}\n\n\tfunction importPath(node) {\n\t\tvar data = node.getAttribute('d'),\n\t\t\tparam = { pathData: data };\n\t\treturn (data.match(/m/gi) || []).length > 1 || /z\\S+/i.test(data)\n\t\t\t\t? new CompoundPath(param)\n\t\t\t\t: new Path(param);\n\t}\n\n\tfunction importGradient(node, type) {\n\t\tvar id = (getValue(node, 'href', true) || '').substring(1),\n\t\t\tisRadial = type === 'radialgradient',\n\t\t\tgradient;\n\t\tif (id) {\n\t\t\tgradient = definitions[id].getGradient();\n\t\t} else {\n\t\t\tvar nodes = node.childNodes,\n\t\t\t\tstops = [];\n\t\t\tfor (var i = 0, l = nodes.length; i < l; i++) {\n\t\t\t\tvar child = nodes[i];\n\t\t\t\tif (child.nodeType === 1)\n\t\t\t\t\tstops.push(applyAttributes(new GradientStop(), child));\n\t\t\t}\n\t\t\tgradient = new Gradient(stops, isRadial);\n\t\t}\n\t\tvar origin, destination, highlight;\n\t\tif (isRadial) {\n\t\t\torigin = getPoint(node, 'cx', 'cy');\n\t\t\tdestination = origin.add(getValue(node, 'r'), 0);\n\t\t\thighlight = getPoint(node, 'fx', 'fy', true);\n\t\t} else {\n\t\t\torigin = getPoint(node, 'x1', 'y1');\n\t\t\tdestination = getPoint(node, 'x2', 'y2');\n\t\t}\n\t\tapplyAttributes(\n\t\t\tnew Color(gradient, origin, destination, highlight), node);\n\t\treturn null;\n\t}\n\n\tvar importers = {\n\t\t'#document': function (node, type, options, isRoot) {\n\t\t\tvar nodes = node.childNodes;\n\t\t\tfor (var i = 0, l = nodes.length; i < l; i++) {\n\t\t\t\tvar child = nodes[i];\n\t\t\t\tif (child.nodeType === 1) {\n\t\t\t\t\tvar next = child.nextSibling;\n\t\t\t\t\tdocument.body.appendChild(child);\n\t\t\t\t\tvar item = importSVG(child, options, isRoot);\n\t\t\t\t\tif (next) {\n\t\t\t\t\t\tnode.insertBefore(child, next);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tnode.appendChild(child);\n\t\t\t\t\t}\n\t\t\t\t\treturn item;\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\tg: importGroup,\n\t\tsvg: importGroup,\n\t\tclippath: importGroup,\n\t\tpolygon: importPoly,\n\t\tpolyline: importPoly,\n\t\tpath: importPath,\n\t\tlineargradient: importGradient,\n\t\tradialgradient: importGradient,\n\n\t\timage: function (node) {\n\t\t\tvar raster = new Raster(getValue(node, 'href', true));\n\t\t\traster.on('load', function() {\n\t\t\t\tvar size = getSize(node, 'width', 'height');\n\t\t\t\tthis.setSize(size);\n\t\t\t\tvar center = this._matrix._transformPoint(\n\t\t\t\t\t\tgetPoint(node, 'x', 'y').add(size.divide(2)));\n\t\t\t\tthis.translate(center);\n\t\t\t});\n\t\t\treturn raster;\n\t\t},\n\n\t\tsymbol: function(node, type, options, isRoot) {\n\t\t\treturn new Symbol(importGroup(node, type, options, isRoot), true);\n\t\t},\n\n\t\tdefs: importGroup,\n\n\t\tuse: function(node) {\n\t\t\tvar id = (getValue(node, 'href', true) || '').substring(1),\n\t\t\t\tdefinition = definitions[id],\n\t\t\t\tpoint = getPoint(node, 'x', 'y');\n\t\t\treturn definition\n\t\t\t\t\t? definition instanceof Symbol\n\t\t\t\t\t\t? definition.place(point)\n\t\t\t\t\t\t: definition.clone().translate(point)\n\t\t\t\t\t: null;\n\t\t},\n\n\t\tcircle: function(node) {\n\t\t\treturn new Shape.Circle(getPoint(node, 'cx', 'cy'),\n\t\t\t\t\tgetValue(node, 'r'));\n\t\t},\n\n\t\tellipse: function(node) {\n\t\t\treturn new Shape.Ellipse({\n\t\t\t\tcenter: getPoint(node, 'cx', 'cy'),\n\t\t\t\tradius: getSize(node, 'rx', 'ry')\n\t\t\t});\n\t\t},\n\n\t\trect: function(node) {\n\t\t\tvar point = getPoint(node, 'x', 'y'),\n\t\t\t\tsize = getSize(node, 'width', 'height'),\n\t\t\t\tradius = getSize(node, 'rx', 'ry');\n\t\t\treturn new Shape.Rectangle(new Rectangle(point, size), radius);\n\t\t},\n\n\t\tline: function(node) {\n\t\t\treturn new Path.Line(getPoint(node, 'x1', 'y1'),\n\t\t\t\t\tgetPoint(node, 'x2', 'y2'));\n\t\t},\n\n\t\ttext: function(node) {\n\t\t\tvar text = new PointText(getPoint(node, 'x', 'y')\n\t\t\t\t\t.add(getPoint(node, 'dx', 'dy')));\n\t\t\ttext.setContent(node.textContent.trim() || '');\n\t\t\treturn text;\n\t\t}\n\t};\n\n\tfunction applyTransform(item, value, name, node) {\n\t\tvar transforms = (node.getAttribute(name) || '').split(/\\)\\s*/g),\n\t\t\tmatrix = new Matrix();\n\t\tfor (var i = 0, l = transforms.length; i < l; i++) {\n\t\t\tvar transform = transforms[i];\n\t\t\tif (!transform)\n\t\t\t\tbreak;\n\t\t\tvar parts = transform.split(/\\(\\s*/),\n\t\t\t\tcommand = parts[0],\n\t\t\t\tv = parts[1].split(/[\\s,]+/g);\n\t\t\tfor (var j = 0, m = v.length; j < m; j++)\n\t\t\t\tv[j] = parseFloat(v[j]);\n\t\t\tswitch (command) {\n\t\t\tcase 'matrix':\n\t\t\t\tmatrix.concatenate(\n\t\t\t\t\t\tnew Matrix(v[0], v[1], v[2], v[3], v[4], v[5]));\n\t\t\t\tbreak;\n\t\t\tcase 'rotate':\n\t\t\t\tmatrix.rotate(v[0], v[1], v[2]);\n\t\t\t\tbreak;\n\t\t\tcase 'translate':\n\t\t\t\tmatrix.translate(v[0], v[1]);\n\t\t\t\tbreak;\n\t\t\tcase 'scale':\n\t\t\t\tmatrix.scale(v);\n\t\t\t\tbreak;\n\t\t\tcase 'skewX':\n\t\t\t\tmatrix.skew(v[0], 0);\n\t\t\t\tbreak;\n\t\t\tcase 'skewY':\n\t\t\t\tmatrix.skew(0, v[0]);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\titem.transform(matrix);\n\t}\n\n\tfunction applyOpacity(item, value, name) {\n\t\tvar color = item[name === 'fill-opacity' ? 'getFillColor'\n\t\t\t\t: 'getStrokeColor']();\n\t\tif (color)\n\t\t\tcolor.setAlpha(parseFloat(value));\n\t}\n\n\tvar attributes = Base.set(Base.each(SVGStyles, function(entry) {\n\t\tthis[entry.attribute] = function(item, value) {\n\t\t\titem[entry.set](convertValue(value, entry.type, entry.fromSVG));\n\t\t\tif (entry.type === 'color' && item instanceof Shape) {\n\t\t\t\tvar color = item[entry.get]();\n\t\t\t\tif (color)\n\t\t\t\t\tcolor.transform(new Matrix().translate(\n\t\t\t\t\t\t\titem.getPosition(true).negate()));\n\t\t\t}\n\t\t};\n\t}, {}), {\n\t\tid: function(item, value) {\n\t\t\tdefinitions[value] = item;\n\t\t\tif (item.setName)\n\t\t\t\titem.setName(value);\n\t\t},\n\n\t\t'clip-path': function(item, value) {\n\t\t\tvar clip = getDefinition(value);\n\t\t\tif (clip) {\n\t\t\t\tclip = clip.clone();\n\t\t\t\tclip.setClipMask(true);\n\t\t\t\tif (item instanceof Group) {\n\t\t\t\t\titem.insertChild(0, clip);\n\t\t\t\t} else {\n\t\t\t\t\treturn new Group(clip, item);\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\tgradientTransform: applyTransform,\n\t\ttransform: applyTransform,\n\n\t\t'fill-opacity': applyOpacity,\n\t\t'stroke-opacity': applyOpacity,\n\n\t\tvisibility: function(item, value) {\n\t\t\titem.setVisible(value === 'visible');\n\t\t},\n\n\t\tdisplay: function(item, value) {\n\t\t\titem.setVisible(value !== null);\n\t\t},\n\n\t\t'stop-color': function(item, value) {\n\t\t\tif (item.setColor)\n\t\t\t\titem.setColor(value);\n\t\t},\n\n\t\t'stop-opacity': function(item, value) {\n\t\t\tif (item._color)\n\t\t\t\titem._color.setAlpha(parseFloat(value));\n\t\t},\n\n\t\toffset: function(item, value) {\n\t\t\tvar percentage = value.match(/(.*)%$/);\n\t\t\titem.setRampPoint(percentage\n\t\t\t\t\t? percentage[1] / 100\n\t\t\t\t\t: parseFloat(value));\n\t\t},\n\n\t\tviewBox: function(item, value, name, node, styles) {\n\t\t\tvar rect = new Rectangle(convertValue(value, 'array')),\n\t\t\t\tsize = getSize(node, 'width', 'height', true);\n\t\t\tif (item instanceof Group) {\n\t\t\t\tvar scale = size ? rect.getSize().divide(size) : 1,\n\t\t\t\t\tmatrix = new Matrix().translate(rect.getPoint()).scale(scale);\n\t\t\t\titem.transform(matrix.inverted());\n\t\t\t} else if (item instanceof Symbol) {\n\t\t\t\tif (size)\n\t\t\t\t\trect.setSize(size);\n\t\t\t\tvar clip = getAttribute(node, 'overflow', styles) != 'visible',\n\t\t\t\t\tgroup = item._definition;\n\t\t\t\tif (clip && !rect.contains(group.getBounds())) {\n\t\t\t\t\tclip = new Shape.Rectangle(rect).transform(group._matrix);\n\t\t\t\t\tclip.setClipMask(true);\n\t\t\t\t\tgroup.addChild(clip);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t});\n\n\tfunction getAttribute(node, name, styles) {\n\t\tvar attr = node.attributes[name],\n\t\t\tvalue = attr && attr.value;\n\t\tif (!value) {\n\t\t\tvar style = Base.camelize(name);\n\t\t\tvalue = node.style[style];\n\t\t\tif (!value && styles.node[style] !== styles.parent[style])\n\t\t\t\tvalue = styles.node[style];\n\t\t}\n\t\treturn !value\n\t\t\t\t? undefined\n\t\t\t\t: value === 'none'\n\t\t\t\t\t? null\n\t\t\t\t\t: value;\n\t}\n\n\tfunction applyAttributes(item, node, isRoot) {\n\t\tvar styles = {\n\t\t\tnode: DomElement.getStyles(node) || {},\n\t\t\tparent: !isRoot && DomElement.getStyles(node.parentNode) || {}\n\t\t};\n\t\tBase.each(attributes, function(apply, name) {\n\t\t\tvar value = getAttribute(node, name, styles);\n\t\t\tif (value !== undefined)\n\t\t\t\titem = Base.pick(apply(item, value, name, node, styles), item);\n\t\t});\n\t\treturn item;\n\t}\n\n\tvar definitions = {};\n\tfunction getDefinition(value) {\n\t\tvar match = value && value.match(/\\((?:#|)([^)']+)/);\n\t\treturn match && definitions[match[1]];\n\t}\n\n\tfunction importSVG(source, options, isRoot) {\n\t\tif (!source)\n\t\t\treturn null;\n\t\tif (!options) {\n\t\t\toptions = {};\n\t\t} else if (typeof options === 'function') {\n\t\t\toptions = { onLoad: options };\n\t\t}\n\n\t\tvar node = source,\n\t\t\tscope = paper;\n\n\t\tfunction onLoadCallback(svg) {\n\t\t\tpaper = scope;\n\t\t\tvar item = importSVG(svg, options, isRoot),\n\t\t\t\tonLoad = options.onLoad,\n\t\t\t\tview = scope.project && scope.getView();\n\t\t\tif (onLoad)\n\t\t\t\tonLoad.call(this, item);\n\t\t\tview.update();\n\t\t}\n\n\t\tif (isRoot) {\n\t\t\tif (typeof source === 'string' && !/^.*</.test(source)) {\n\t\t\t\tnode = document.getElementById(source);\n\t\t\t\tif (node) {\n\t\t\t\t\tsource = null;\n\t\t\t\t} else {\n\t\t\t\t\treturn Http.request('get', source, onLoadCallback);\n\t\t\t\t}\n\t\t\t} else if (typeof File !== 'undefined' && source instanceof File) {\n\t\t\t\tvar reader = new FileReader();\n\t\t\t\treader.onload = function() {\n\t\t\t\t\tonLoadCallback(reader.result);\n\t\t\t\t};\n\t\t\t\treturn reader.readAsText(source);\n\t\t\t}\n\t\t}\n\n\t\tif (typeof source === 'string')\n\t\t\tnode = new DOMParser().parseFromString(source, 'image/svg+xml');\n\t\tif (!node.nodeName)\n\t\t\tthrow new Error('Unsupported SVG source: ' + source);\n\t\tvar type = node.nodeName.toLowerCase(),\n\t\t\timporter = importers[type],\n\t\t\titem,\n\t\t\tdata = node.getAttribute && node.getAttribute('data-paper-data'),\n\t\t\tsettings = scope.settings,\n\t\t\tapplyMatrix = settings.applyMatrix;\n\t\tsettings.applyMatrix = false;\n\t\titem = importer && importer(node, type, options, isRoot) || null;\n\t\tsettings.applyMatrix = applyMatrix;\n\t\tif (item) {\n\t\t\tif (type !== '#document' && !(item instanceof Group))\n\t\t\t\titem = applyAttributes(item, node, isRoot);\n\t\t\tvar onImport = options.onImport;\n\t\t\tif (onImport)\n\t\t\t\titem = onImport(node, item, options) || item;\n\t\t\tif (options.expandShapes && item instanceof Shape) {\n\t\t\t\titem.remove();\n\t\t\t\titem = item.toPath();\n\t\t\t}\n\t\t\tif (data)\n\t\t\t\titem._data = JSON.parse(data);\n\t\t}\n\t\tif (isRoot) {\n\t\t\tdefinitions = {};\n\t\t\tif (item && Base.pick(options.applyMatrix, applyMatrix))\n\t\t\t\titem.matrix.apply(true, true);\n\t\t}\n\t\treturn item;\n\t}\n\n\tItem.inject({\n\t\timportSVG: function(node, options) {\n\t\t\treturn this.addChild(importSVG(node, options, true));\n\t\t}\n\t});\n\n\tProject.inject({\n\t\timportSVG: function(node, options) {\n\t\t\tthis.activate();\n\t\t\treturn importSVG(node, options, true);\n\t\t}\n\t});\n};\n\nBase.exports.PaperScript = (function() {\n\tvar exports, define,\n\t\tscope = this;\n!function(e,r){return\"object\"==typeof exports&&\"object\"==typeof module?r(exports):\"function\"==typeof define&&define.amd?define([\"exports\"],r):(r(e.acorn||(e.acorn={})),void 0)}(this,function(e){\"use strict\";function r(e){fr=e||{};for(var r in mr)Object.prototype.hasOwnProperty.call(fr,r)||(fr[r]=mr[r]);hr=fr.sourceFile||null}function t(e,r){var t=vr(dr,e);r+=\" (\"+t.line+\":\"+t.column+\")\";var n=new SyntaxError(r);throw n.pos=e,n.loc=t,n.raisedAt=br,n}function n(e){function r(e){if(1==e.length)return t+=\"return str === \"+JSON.stringify(e[0])+\";\";t+=\"switch(str){\";for(var r=0;r<e.length;++r)t+=\"case \"+JSON.stringify(e[r])+\":\";t+=\"return true}return false;\"}e=e.split(\" \");var t=\"\",n=[];e:for(var a=0;a<e.length;++a){for(var o=0;o<n.length;++o)if(n[o][0].length==e[a].length){n[o].push(e[a]);continue e}n.push([e[a]])}if(n.length>3){n.sort(function(e,r){return r.length-e.length}),t+=\"switch(str.length){\";for(var a=0;a<n.length;++a){var i=n[a];t+=\"case \"+i[0].length+\":\",r(i)}t+=\"}\"}else r(e);return new Function(\"str\",t)}function a(){this.line=Ar,this.column=br-Sr}function o(){Ar=1,br=Sr=0,Er=!0,u()}function i(e,r){gr=br,fr.locations&&(kr=new a),wr=e,u(),Cr=r,Er=e.beforeExpr}function s(){var e=fr.onComment&&fr.locations&&new a,r=br,n=dr.indexOf(\"*/\",br+=2);if(-1===n&&t(br-2,\"Unterminated comment\"),br=n+2,fr.locations){Kt.lastIndex=r;for(var o;(o=Kt.exec(dr))&&o.index<br;)++Ar,Sr=o.index+o[0].length}fr.onComment&&fr.onComment(!0,dr.slice(r+2,n),r,br,e,fr.locations&&new a)}function c(){for(var e=br,r=fr.onComment&&fr.locations&&new a,t=dr.charCodeAt(br+=2);pr>br&&10!==t&&13!==t&&8232!==t&&8233!==t;)++br,t=dr.charCodeAt(br);fr.onComment&&fr.onComment(!1,dr.slice(e+2,br),e,br,r,fr.locations&&new a)}function u(){for(;pr>br;){var e=dr.charCodeAt(br);if(32===e)++br;else if(13===e){++br;var r=dr.charCodeAt(br);10===r&&++br,fr.locations&&(++Ar,Sr=br)}else if(10===e||8232===e||8233===e)++br,fr.locations&&(++Ar,Sr=br);else if(e>8&&14>e)++br;else if(47===e){var r=dr.charCodeAt(br+1);if(42===r)s();else{if(47!==r)break;c()}}else if(160===e)++br;else{if(!(e>=5760&&Jt.test(String.fromCharCode(e))))break;++br}}}function l(){var e=dr.charCodeAt(br+1);return e>=48&&57>=e?E(!0):(++br,i(xt))}function f(){var e=dr.charCodeAt(br+1);return Er?(++br,k()):61===e?x(Et,2):x(wt,1)}function d(){var e=dr.charCodeAt(br+1);return 61===e?x(Et,2):x(Dt,1)}function p(e){var r=dr.charCodeAt(br+1);return r===e?x(124===e?Lt:Ut,2):61===r?x(Et,2):x(124===e?Rt:Tt,1)}function h(){var e=dr.charCodeAt(br+1);return 61===e?x(Et,2):x(Vt,1)}function m(e){var r=dr.charCodeAt(br+1);return r===e?45==r&&62==dr.charCodeAt(br+2)&&Gt.test(dr.slice(Lr,br))?(br+=3,c(),u(),g()):x(St,2):61===r?x(Et,2):x(At,1)}function v(e){var r=dr.charCodeAt(br+1),t=1;return r===e?(t=62===e&&62===dr.charCodeAt(br+2)?3:2,61===dr.charCodeAt(br+t)?x(Et,t+1):x(jt,t)):33==r&&60==e&&45==dr.charCodeAt(br+2)&&45==dr.charCodeAt(br+3)?(br+=4,c(),u(),g()):(61===r&&(t=61===dr.charCodeAt(br+2)?3:2),x(Ot,t))}function b(e){var r=dr.charCodeAt(br+1);return 61===r?x(qt,61===dr.charCodeAt(br+2)?3:2):x(61===e?Ct:It,1)}function y(e){switch(e){case 46:return l();case 40:return++br,i(mt);case 41:return++br,i(vt);case 59:return++br,i(yt);case 44:return++br,i(bt);case 91:return++br,i(ft);case 93:return++br,i(dt);case 123:return++br,i(pt);case 125:return++br,i(ht);case 58:return++br,i(gt);case 63:return++br,i(kt);case 48:var r=dr.charCodeAt(br+1);if(120===r||88===r)return C();case 49:case 50:case 51:case 52:case 53:case 54:case 55:case 56:case 57:return E(!1);case 34:case 39:return A(e);case 47:return f(e);case 37:case 42:return d();case 124:case 38:return p(e);case 94:return h();case 43:case 45:return m(e);case 60:case 62:return v(e);case 61:case 33:return b(e);case 126:return x(It,1)}return!1}function g(e){if(e?br=yr+1:yr=br,fr.locations&&(xr=new a),e)return k();if(br>=pr)return i(Br);var r=dr.charCodeAt(br);if(Qt(r)||92===r)return L();var n=y(r);if(n===!1){var o=String.fromCharCode(r);if(\"\\\\\"===o||$t.test(o))return L();t(br,\"Unexpected character '\"+o+\"'\")}return n}function x(e,r){var t=dr.slice(br,br+r);br+=r,i(e,t)}function k(){for(var e,r,n=\"\",a=br;;){br>=pr&&t(a,\"Unterminated regular expression\");var o=dr.charAt(br);if(Gt.test(o)&&t(a,\"Unterminated regular expression\"),e)e=!1;else{if(\"[\"===o)r=!0;else if(\"]\"===o&&r)r=!1;else if(\"/\"===o&&!r)break;e=\"\\\\\"===o}++br}var n=dr.slice(a,br);++br;var s=I();return s&&!/^[gmsiy]*$/.test(s)&&t(a,\"Invalid regexp flag\"),i(jr,new RegExp(n,s))}function w(e,r){for(var t=br,n=0,a=0,o=null==r?1/0:r;o>a;++a){var i,s=dr.charCodeAt(br);if(i=s>=97?s-97+10:s>=65?s-65+10:s>=48&&57>=s?s-48:1/0,i>=e)break;++br,n=n*e+i}return br===t||null!=r&&br-t!==r?null:n}function C(){br+=2;var e=w(16);return null==e&&t(yr+2,\"Expected hexadecimal number\"),Qt(dr.charCodeAt(br))&&t(br,\"Identifier directly after number\"),i(Or,e)}function E(e){var r=br,n=!1,a=48===dr.charCodeAt(br);e||null!==w(10)||t(r,\"Invalid number\"),46===dr.charCodeAt(br)&&(++br,w(10),n=!0);var o=dr.charCodeAt(br);(69===o||101===o)&&(o=dr.charCodeAt(++br),(43===o||45===o)&&++br,null===w(10)&&t(r,\"Invalid number\"),n=!0),Qt(dr.charCodeAt(br))&&t(br,\"Identifier directly after number\");var s,c=dr.slice(r,br);return n?s=parseFloat(c):a&&1!==c.length?/[89]/.test(c)||Tr?t(r,\"Invalid number\"):s=parseInt(c,8):s=parseInt(c,10),i(Or,s)}function A(e){br++;for(var r=\"\";;){br>=pr&&t(yr,\"Unterminated string constant\");var n=dr.charCodeAt(br);if(n===e)return++br,i(Dr,r);if(92===n){n=dr.charCodeAt(++br);var a=/^[0-7]+/.exec(dr.slice(br,br+3));for(a&&(a=a[0]);a&&parseInt(a,8)>255;)a=a.slice(0,a.length-1);if(\"0\"===a&&(a=null),++br,a)Tr&&t(br-2,\"Octal literal in strict mode\"),r+=String.fromCharCode(parseInt(a,8)),br+=a.length-1;else switch(n){case 110:r+=\"\\n\";break;case 114:r+=\"\\r\";break;case 120:r+=String.fromCharCode(S(2));break;case 117:r+=String.fromCharCode(S(4));break;case 85:r+=String.fromCharCode(S(8));break;case 116:r+=\"\t\";break;case 98:r+=\"\\b\";break;case 118:r+=\"\u000b\";break;case 102:r+=\"\\f\";break;case 48:r+=\"\\0\";break;case 13:10===dr.charCodeAt(br)&&++br;case 10:fr.locations&&(Sr=br,++Ar);break;default:r+=String.fromCharCode(n)}}else(13===n||10===n||8232===n||8233===n)&&t(yr,\"Unterminated string constant\"),r+=String.fromCharCode(n),++br}}function S(e){var r=w(16,e);return null===r&&t(yr,\"Bad character escape sequence\"),r}function I(){Bt=!1;for(var e,r=!0,n=br;;){var a=dr.charCodeAt(br);if(Yt(a))Bt&&(e+=dr.charAt(br)),++br;else{if(92!==a)break;Bt||(e=dr.slice(n,br)),Bt=!0,117!=dr.charCodeAt(++br)&&t(br,\"Expecting Unicode escape sequence \\\\uXXXX\"),++br;var o=S(4),i=String.fromCharCode(o);i||t(br-1,\"Invalid Unicode escape\"),(r?Qt(o):Yt(o))||t(br-4,\"Invalid Unicode escape\"),e+=i}r=!1}return Bt?e:dr.slice(n,br)}function L(){var e=I(),r=Fr;return Bt||(Wt(e)?r=lt[e]:(fr.forbidReserved&&(3===fr.ecmaVersion?Mt:zt)(e)||Tr&&Xt(e))&&t(yr,\"The keyword '\"+e+\"' is reserved\")),i(r,e)}function U(){Ir=yr,Lr=gr,Ur=kr,g()}function R(e){if(Tr=e,br=Lr,fr.locations)for(;Sr>br;)Sr=dr.lastIndexOf(\"\\n\",Sr-2)+1,--Ar;u(),g()}function V(){this.type=null,this.start=yr,this.end=null}function T(){this.start=xr,this.end=null,null!==hr&&(this.source=hr)}function q(){var e=new V;return fr.locations&&(e.loc=new T),fr.ranges&&(e.range=[yr,0]),e}function O(e){var r=new V;return r.start=e.start,fr.locations&&(r.loc=new T,r.loc.start=e.loc.start),fr.ranges&&(r.range=[e.range[0],0]),r}function j(e,r){return e.type=r,e.end=Lr,fr.locations&&(e.loc.end=Ur),fr.ranges&&(e.range[1]=Lr),e}function D(e){return fr.ecmaVersion>=5&&\"ExpressionStatement\"===e.type&&\"Literal\"===e.expression.type&&\"use strict\"===e.expression.value}function F(e){return wr===e?(U(),!0):void 0}function B(){return!fr.strictSemicolons&&(wr===Br||wr===ht||Gt.test(dr.slice(Lr,yr)))}function M(){F(yt)||B()||X()}function z(e){wr===e?U():X()}function X(){t(yr,\"Unexpected token\")}function N(e){\"Identifier\"!==e.type&&\"MemberExpression\"!==e.type&&t(e.start,\"Assigning to rvalue\"),Tr&&\"Identifier\"===e.type&&Nt(e.name)&&t(e.start,\"Assigning to \"+e.name+\" in strict mode\")}function W(e){Ir=Lr=br,fr.locations&&(Ur=new a),Rr=Tr=null,Vr=[],g();var r=e||q(),t=!0;for(e||(r.body=[]);wr!==Br;){var n=J();r.body.push(n),t&&D(n)&&R(!0),t=!1}return j(r,\"Program\")}function J(){(wr===wt||wr===Et&&\"/=\"==Cr)&&g(!0);var e=wr,r=q();switch(e){case Mr:case Nr:U();var n=e===Mr;F(yt)||B()?r.label=null:wr!==Fr?X():(r.label=lr(),M());for(var a=0;a<Vr.length;++a){var o=Vr[a];if(null==r.label||o.name===r.label.name){if(null!=o.kind&&(n||\"loop\"===o.kind))break;if(r.label&&n)break}}return a===Vr.length&&t(r.start,\"Unsyntactic \"+e.keyword),j(r,n?\"BreakStatement\":\"ContinueStatement\");case Wr:return U(),M(),j(r,\"DebuggerStatement\");case Pr:return U(),Vr.push(Zt),r.body=J(),Vr.pop(),z(tt),r.test=P(),M(),j(r,\"DoWhileStatement\");case _r:if(U(),Vr.push(Zt),z(mt),wr===yt)return $(r,null);if(wr===rt){var i=q();return U(),G(i,!0),j(i,\"VariableDeclaration\"),1===i.declarations.length&&F(ut)?_(r,i):$(r,i)}var i=K(!1,!0);return F(ut)?(N(i),_(r,i)):$(r,i);case Gr:return U(),cr(r,!0);case Kr:return U(),r.test=P(),r.consequent=J(),r.alternate=F(Hr)?J():null,j(r,\"IfStatement\");case Qr:return Rr||t(yr,\"'return' outside of function\"),U(),F(yt)||B()?r.argument=null:(r.argument=K(),M()),j(r,\"ReturnStatement\");case Yr:U(),r.discriminant=P(),r.cases=[],z(pt),Vr.push(en);for(var s,c;wr!=ht;)if(wr===zr||wr===Jr){var u=wr===zr;s&&j(s,\"SwitchCase\"),r.cases.push(s=q()),s.consequent=[],U(),u?s.test=K():(c&&t(Ir,\"Multiple default clauses\"),c=!0,s.test=null),z(gt)}else s||X(),s.consequent.push(J());return s&&j(s,\"SwitchCase\"),U(),Vr.pop(),j(r,\"SwitchStatement\");case Zr:return U(),Gt.test(dr.slice(Lr,yr))&&t(Lr,\"Illegal newline after throw\"),r.argument=K(),M(),j(r,\"ThrowStatement\");case et:if(U(),r.block=H(),r.handler=null,wr===Xr){var l=q();U(),z(mt),l.param=lr(),Tr&&Nt(l.param.name)&&t(l.param.start,\"Binding \"+l.param.name+\" in strict mode\"),z(vt),l.guard=null,l.body=H(),r.handler=j(l,\"CatchClause\")}return r.guardedHandlers=qr,r.finalizer=F($r)?H():null,r.handler||r.finalizer||t(r.start,\"Missing catch or finally clause\"),j(r,\"TryStatement\");case rt:return U(),G(r),M(),j(r,\"VariableDeclaration\");case tt:return U(),r.test=P(),Vr.push(Zt),r.body=J(),Vr.pop(),j(r,\"WhileStatement\");case nt:return Tr&&t(yr,\"'with' in strict mode\"),U(),r.object=P(),r.body=J(),j(r,\"WithStatement\");case pt:return H();case yt:return U(),j(r,\"EmptyStatement\");default:var f=Cr,d=K();if(e===Fr&&\"Identifier\"===d.type&&F(gt)){for(var a=0;a<Vr.length;++a)Vr[a].name===f&&t(d.start,\"Label '\"+f+\"' is already declared\");var p=wr.isLoop?\"loop\":wr===Yr?\"switch\":null;return Vr.push({name:f,kind:p}),r.body=J(),Vr.pop(),r.label=d,j(r,\"LabeledStatement\")}return r.expression=d,M(),j(r,\"ExpressionStatement\")}}function P(){z(mt);var e=K();return z(vt),e}function H(e){var r,t=q(),n=!0,a=!1;for(t.body=[],z(pt);!F(ht);){var o=J();t.body.push(o),n&&e&&D(o)&&(r=a,R(a=!0)),n=!1}return a&&!r&&R(!1),j(t,\"BlockStatement\")}function $(e,r){return e.init=r,z(yt),e.test=wr===yt?null:K(),z(yt),e.update=wr===vt?null:K(),z(vt),e.body=J(),Vr.pop(),j(e,\"ForStatement\")}function _(e,r){return e.left=r,e.right=K(),z(vt),e.body=J(),Vr.pop(),j(e,\"ForInStatement\")}function G(e,r){for(e.declarations=[],e.kind=\"var\";;){var n=q();if(n.id=lr(),Tr&&Nt(n.id.name)&&t(n.id.start,\"Binding \"+n.id.name+\" in strict mode\"),n.init=F(Ct)?K(!0,r):null,e.declarations.push(j(n,\"VariableDeclarator\")),!F(bt))break}return e}function K(e,r){var t=Q(r);if(!e&&wr===bt){var n=O(t);for(n.expressions=[t];F(bt);)n.expressions.push(Q(r));return j(n,\"SequenceExpression\")}return t}function Q(e){var r=Y(e);if(wr.isAssign){var t=O(r);return t.operator=Cr,t.left=r,U(),t.right=Q(e),N(r),j(t,\"AssignmentExpression\")}return r}function Y(e){var r=Z(e);if(F(kt)){var t=O(r);return t.test=r,t.consequent=K(!0),z(gt),t.alternate=K(!0,e),j(t,\"ConditionalExpression\")}return r}function Z(e){return er(rr(),-1,e)}function er(e,r,t){var n=wr.binop;if(null!=n&&(!t||wr!==ut)&&n>r){var a=O(e);a.left=e,a.operator=Cr,U(),a.right=er(rr(),n,t);var o=j(a,/&&|\\|\\|/.test(a.operator)?\"LogicalExpression\":\"BinaryExpression\");return er(o,r,t)}return e}function rr(){if(wr.prefix){var e=q(),r=wr.isUpdate;return e.operator=Cr,e.prefix=!0,Er=!0,U(),e.argument=rr(),r?N(e.argument):Tr&&\"delete\"===e.operator&&\"Identifier\"===e.argument.type&&t(e.start,\"Deleting local variable in strict mode\"),j(e,r?\"UpdateExpression\":\"UnaryExpression\")}for(var n=tr();wr.postfix&&!B();){var e=O(n);e.operator=Cr,e.prefix=!1,e.argument=n,N(n),U(),n=j(e,\"UpdateExpression\")}return n}function tr(){return nr(ar())}function nr(e,r){if(F(xt)){var t=O(e);return t.object=e,t.property=lr(!0),t.computed=!1,nr(j(t,\"MemberExpression\"),r)}if(F(ft)){var t=O(e);return t.object=e,t.property=K(),t.computed=!0,z(dt),nr(j(t,\"MemberExpression\"),r)}if(!r&&F(mt)){var t=O(e);return t.callee=e,t.arguments=ur(vt,!1),nr(j(t,\"CallExpression\"),r)}return e}function ar(){switch(wr){case ot:var e=q();return U(),j(e,\"ThisExpression\");case Fr:return lr();case Or:case Dr:case jr:var e=q();return e.value=Cr,e.raw=dr.slice(yr,gr),U(),j(e,\"Literal\");case it:case st:case ct:var e=q();return e.value=wr.atomValue,e.raw=wr.keyword,U(),j(e,\"Literal\");case mt:var r=xr,t=yr;U();var n=K();return n.start=t,n.end=gr,fr.locations&&(n.loc.start=r,n.loc.end=kr),fr.ranges&&(n.range=[t,gr]),z(vt),n;case ft:var e=q();return U(),e.elements=ur(dt,!0,!0),j(e,\"ArrayExpression\");case pt:return ir();case Gr:var e=q();return U(),cr(e,!1);case at:return or();default:X()}}function or(){var e=q();return U(),e.callee=nr(ar(),!0),e.arguments=F(mt)?ur(vt,!1):qr,j(e,\"NewExpression\")}function ir(){var e=q(),r=!0,n=!1;for(e.properties=[],U();!F(ht);){if(r)r=!1;else if(z(bt),fr.allowTrailingCommas&&F(ht))break;var a,o={key:sr()},i=!1;if(F(gt)?(o.value=K(!0),a=o.kind=\"init\"):fr.ecmaVersion>=5&&\"Identifier\"===o.key.type&&(\"get\"===o.key.name||\"set\"===o.key.name)?(i=n=!0,a=o.kind=o.key.name,o.key=sr(),wr!==mt&&X(),o.value=cr(q(),!1)):X(),\"Identifier\"===o.key.type&&(Tr||n))for(var s=0;s<e.properties.length;++s){var c=e.properties[s];if(c.key.name===o.key.name){var u=a==c.kind||i&&\"init\"===c.kind||\"init\"===a&&(\"get\"===c.kind||\"set\"===c.kind);u&&!Tr&&\"init\"===a&&\"init\"===c.kind&&(u=!1),u&&t(o.key.start,\"Redefinition of property\")}}e.properties.push(o)}return j(e,\"ObjectExpression\")}function sr(){return wr===Or||wr===Dr?ar():lr(!0)}function cr(e,r){wr===Fr?e.id=lr():r?X():e.id=null,e.params=[];var n=!0;for(z(mt);!F(vt);)n?n=!1:z(bt),e.params.push(lr());var a=Rr,o=Vr;if(Rr=!0,Vr=[],e.body=H(!0),Rr=a,Vr=o,Tr||e.body.body.length&&D(e.body.body[0]))for(var i=e.id?-1:0;i<e.params.length;++i){var s=0>i?e.id:e.params[i];if((Xt(s.name)||Nt(s.name))&&t(s.start,\"Defining '\"+s.name+\"' in strict mode\"),i>=0)for(var c=0;i>c;++c)s.name===e.params[c].name&&t(s.start,\"Argument name clash in strict mode\")}return j(e,r?\"FunctionDeclaration\":\"FunctionExpression\")}function ur(e,r,t){for(var n=[],a=!0;!F(e);){if(a)a=!1;else if(z(bt),r&&fr.allowTrailingCommas&&F(e))break;t&&wr===bt?n.push(null):n.push(K(!0))}return n}function lr(e){var r=q();return r.name=wr===Fr?Cr:e&&!fr.forbidReserved&&wr.keyword||X(),Er=!1,U(),j(r,\"Identifier\")}e.version=\"0.4.0\";var fr,dr,pr,hr;e.parse=function(e,t){return dr=String(e),pr=dr.length,r(t),o(),W(fr.program)};var mr=e.defaultOptions={ecmaVersion:5,strictSemicolons:!1,allowTrailingCommas:!0,forbidReserved:!1,locations:!1,onComment:null,ranges:!1,program:null,sourceFile:null},vr=e.getLineInfo=function(e,r){for(var t=1,n=0;;){Kt.lastIndex=n;var a=Kt.exec(e);if(!(a&&a.index<r))break;++t,n=a.index+a[0].length}return{line:t,column:r-n}};e.tokenize=function(e,t){function n(e){return g(e),a.start=yr,a.end=gr,a.startLoc=xr,a.endLoc=kr,a.type=wr,a.value=Cr,a}dr=String(e),pr=dr.length,r(t),o();var a={};return n.jumpTo=function(e,r){if(br=e,fr.locations){Ar=1,Sr=Kt.lastIndex=0;for(var t;(t=Kt.exec(dr))&&t.index<e;)++Ar,Sr=t.index+t[0].length}Er=r,u()},n};var br,yr,gr,xr,kr,wr,Cr,Er,Ar,Sr,Ir,Lr,Ur,Rr,Vr,Tr,qr=[],Or={type:\"num\"},jr={type:\"regexp\"},Dr={type:\"string\"},Fr={type:\"name\"},Br={type:\"eof\"},Mr={keyword:\"break\"},zr={keyword:\"case\",beforeExpr:!0},Xr={keyword:\"catch\"},Nr={keyword:\"continue\"},Wr={keyword:\"debugger\"},Jr={keyword:\"default\"},Pr={keyword:\"do\",isLoop:!0},Hr={keyword:\"else\",beforeExpr:!0},$r={keyword:\"finally\"},_r={keyword:\"for\",isLoop:!0},Gr={keyword:\"function\"},Kr={keyword:\"if\"},Qr={keyword:\"return\",beforeExpr:!0},Yr={keyword:\"switch\"},Zr={keyword:\"throw\",beforeExpr:!0},et={keyword:\"try\"},rt={keyword:\"var\"},tt={keyword:\"while\",isLoop:!0},nt={keyword:\"with\"},at={keyword:\"new\",beforeExpr:!0},ot={keyword:\"this\"},it={keyword:\"null\",atomValue:null},st={keyword:\"true\",atomValue:!0},ct={keyword:\"false\",atomValue:!1},ut={keyword:\"in\",binop:7,beforeExpr:!0},lt={\"break\":Mr,\"case\":zr,\"catch\":Xr,\"continue\":Nr,\"debugger\":Wr,\"default\":Jr,\"do\":Pr,\"else\":Hr,\"finally\":$r,\"for\":_r,\"function\":Gr,\"if\":Kr,\"return\":Qr,\"switch\":Yr,\"throw\":Zr,\"try\":et,\"var\":rt,\"while\":tt,\"with\":nt,\"null\":it,\"true\":st,\"false\":ct,\"new\":at,\"in\":ut,\"instanceof\":{keyword:\"instanceof\",binop:7,beforeExpr:!0},\"this\":ot,\"typeof\":{keyword:\"typeof\",prefix:!0,beforeExpr:!0},\"void\":{keyword:\"void\",prefix:!0,beforeExpr:!0},\"delete\":{keyword:\"delete\",prefix:!0,beforeExpr:!0}},ft={type:\"[\",beforeExpr:!0},dt={type:\"]\"},pt={type:\"{\",beforeExpr:!0},ht={type:\"}\"},mt={type:\"(\",beforeExpr:!0},vt={type:\")\"},bt={type:\",\",beforeExpr:!0},yt={type:\";\",beforeExpr:!0},gt={type:\":\",beforeExpr:!0},xt={type:\".\"},kt={type:\"?\",beforeExpr:!0},wt={binop:10,beforeExpr:!0},Ct={isAssign:!0,beforeExpr:!0},Et={isAssign:!0,beforeExpr:!0},At={binop:9,prefix:!0,beforeExpr:!0},St={postfix:!0,prefix:!0,isUpdate:!0},It={prefix:!0,beforeExpr:!0},Lt={binop:1,beforeExpr:!0},Ut={binop:2,beforeExpr:!0},Rt={binop:3,beforeExpr:!0},Vt={binop:4,beforeExpr:!0},Tt={binop:5,beforeExpr:!0},qt={binop:6,beforeExpr:!0},Ot={binop:7,beforeExpr:!0},jt={binop:8,beforeExpr:!0},Dt={binop:10,beforeExpr:!0};e.tokTypes={bracketL:ft,bracketR:dt,braceL:pt,braceR:ht,parenL:mt,parenR:vt,comma:bt,semi:yt,colon:gt,dot:xt,question:kt,slash:wt,eq:Ct,name:Fr,eof:Br,num:Or,regexp:jr,string:Dr};for(var Ft in lt)e.tokTypes[\"_\"+Ft]=lt[Ft];var Bt,Mt=n(\"abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile\"),zt=n(\"class enum extends super const export import\"),Xt=n(\"implements interface let package private protected public static yield\"),Nt=n(\"eval arguments\"),Wt=n(\"break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this\"),Jt=/[\\u1680\\u180e\\u2000-\\u200a\\u202f\\u205f\\u3000\\ufeff]/,Pt=\"\\xaa\\xb5\\xba\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u02c1\\u02c6-\\u02d1\\u02e0-\\u02e4\\u02ec\\u02ee\\u0370-\\u0374\\u0376\\u0377\\u037a-\\u037d\\u0386\\u0388-\\u038a\\u038c\\u038e-\\u03a1\\u03a3-\\u03f5\\u03f7-\\u0481\\u048a-\\u0527\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u05d0-\\u05ea\\u05f0-\\u05f2\\u0620-\\u064a\\u066e\\u066f\\u0671-\\u06d3\\u06d5\\u06e5\\u06e6\\u06ee\\u06ef\\u06fa-\\u06fc\\u06ff\\u0710\\u0712-\\u072f\\u074d-\\u07a5\\u07b1\\u07ca-\\u07ea\\u07f4\\u07f5\\u07fa\\u0800-\\u0815\\u081a\\u0824\\u0828\\u0840-\\u0858\\u08a0\\u08a2-\\u08ac\\u0904-\\u0939\\u093d\\u0950\\u0958-\\u0961\\u0971-\\u0977\\u0979-\\u097f\\u0985-\\u098c\\u098f\\u0990\\u0993-\\u09a8\\u09aa-\\u09b0\\u09b2\\u09b6-\\u09b9\\u09bd\\u09ce\\u09dc\\u09dd\\u09df-\\u09e1\\u09f0\\u09f1\\u0a05-\\u0a0a\\u0a0f\\u0a10\\u0a13-\\u0a28\\u0a2a-\\u0a30\\u0a32\\u0a33\\u0a35\\u0a36\\u0a38\\u0a39\\u0a59-\\u0a5c\\u0a5e\\u0a72-\\u0a74\\u0a85-\\u0a8d\\u0a8f-\\u0a91\\u0a93-\\u0aa8\\u0aaa-\\u0ab0\\u0ab2\\u0ab3\\u0ab5-\\u0ab9\\u0abd\\u0ad0\\u0ae0\\u0ae1\\u0b05-\\u0b0c\\u0b0f\\u0b10\\u0b13-\\u0b28\\u0b2a-\\u0b30\\u0b32\\u0b33\\u0b35-\\u0b39\\u0b3d\\u0b5c\\u0b5d\\u0b5f-\\u0b61\\u0b71\\u0b83\\u0b85-\\u0b8a\\u0b8e-\\u0b90\\u0b92-\\u0b95\\u0b99\\u0b9a\\u0b9c\\u0b9e\\u0b9f\\u0ba3\\u0ba4\\u0ba8-\\u0baa\\u0bae-\\u0bb9\\u0bd0\\u0c05-\\u0c0c\\u0c0e-\\u0c10\\u0c12-\\u0c28\\u0c2a-\\u0c33\\u0c35-\\u0c39\\u0c3d\\u0c58\\u0c59\\u0c60\\u0c61\\u0c85-\\u0c8c\\u0c8e-\\u0c90\\u0c92-\\u0ca8\\u0caa-\\u0cb3\\u0cb5-\\u0cb9\\u0cbd\\u0cde\\u0ce0\\u0ce1\\u0cf1\\u0cf2\\u0d05-\\u0d0c\\u0d0e-\\u0d10\\u0d12-\\u0d3a\\u0d3d\\u0d4e\\u0d60\\u0d61\\u0d7a-\\u0d7f\\u0d85-\\u0d96\\u0d9a-\\u0db1\\u0db3-\\u0dbb\\u0dbd\\u0dc0-\\u0dc6\\u0e01-\\u0e30\\u0e32\\u0e33\\u0e40-\\u0e46\\u0e81\\u0e82\\u0e84\\u0e87\\u0e88\\u0e8a\\u0e8d\\u0e94-\\u0e97\\u0e99-\\u0e9f\\u0ea1-\\u0ea3\\u0ea5\\u0ea7\\u0eaa\\u0eab\\u0ead-\\u0eb0\\u0eb2\\u0eb3\\u0ebd\\u0ec0-\\u0ec4\\u0ec6\\u0edc-\\u0edf\\u0f00\\u0f40-\\u0f47\\u0f49-\\u0f6c\\u0f88-\\u0f8c\\u1000-\\u102a\\u103f\\u1050-\\u1055\\u105a-\\u105d\\u1061\\u1065\\u1066\\u106e-\\u1070\\u1075-\\u1081\\u108e\\u10a0-\\u10c5\\u10c7\\u10cd\\u10d0-\\u10fa\\u10fc-\\u1248\\u124a-\\u124d\\u1250-\\u1256\\u1258\\u125a-\\u125d\\u1260-\\u1288\\u128a-\\u128d\\u1290-\\u12b0\\u12b2-\\u12b5\\u12b8-\\u12be\\u12c0\\u12c2-\\u12c5\\u12c8-\\u12d6\\u12d8-\\u1310\\u1312-\\u1315\\u1318-\\u135a\\u1380-\\u138f\\u13a0-\\u13f4\\u1401-\\u166c\\u166f-\\u167f\\u1681-\\u169a\\u16a0-\\u16ea\\u16ee-\\u16f0\\u1700-\\u170c\\u170e-\\u1711\\u1720-\\u1731\\u1740-\\u1751\\u1760-\\u176c\\u176e-\\u1770\\u1780-\\u17b3\\u17d7\\u17dc\\u1820-\\u1877\\u1880-\\u18a8\\u18aa\\u18b0-\\u18f5\\u1900-\\u191c\\u1950-\\u196d\\u1970-\\u1974\\u1980-\\u19ab\\u19c1-\\u19c7\\u1a00-\\u1a16\\u1a20-\\u1a54\\u1aa7\\u1b05-\\u1b33\\u1b45-\\u1b4b\\u1b83-\\u1ba0\\u1bae\\u1baf\\u1bba-\\u1be5\\u1c00-\\u1c23\\u1c4d-\\u1c4f\\u1c5a-\\u1c7d\\u1ce9-\\u1cec\\u1cee-\\u1cf1\\u1cf5\\u1cf6\\u1d00-\\u1dbf\\u1e00-\\u1f15\\u1f18-\\u1f1d\\u1f20-\\u1f45\\u1f48-\\u1f4d\\u1f50-\\u1f57\\u1f59\\u1f5b\\u1f5d\\u1f5f-\\u1f7d\\u1f80-\\u1fb4\\u1fb6-\\u1fbc\\u1fbe\\u1fc2-\\u1fc4\\u1fc6-\\u1fcc\\u1fd0-\\u1fd3\\u1fd6-\\u1fdb\\u1fe0-\\u1fec\\u1ff2-\\u1ff4\\u1ff6-\\u1ffc\\u2071\\u207f\\u2090-\\u209c\\u2102\\u2107\\u210a-\\u2113\\u2115\\u2119-\\u211d\\u2124\\u2126\\u2128\\u212a-\\u212d\\u212f-\\u2139\\u213c-\\u213f\\u2145-\\u2149\\u214e\\u2160-\\u2188\\u2c00-\\u2c2e\\u2c30-\\u2c5e\\u2c60-\\u2ce4\\u2ceb-\\u2cee\\u2cf2\\u2cf3\\u2d00-\\u2d25\\u2d27\\u2d2d\\u2d30-\\u2d67\\u2d6f\\u2d80-\\u2d96\\u2da0-\\u2da6\\u2da8-\\u2dae\\u2db0-\\u2db6\\u2db8-\\u2dbe\\u2dc0-\\u2dc6\\u2dc8-\\u2dce\\u2dd0-\\u2dd6\\u2dd8-\\u2dde\\u2e2f\\u3005-\\u3007\\u3021-\\u3029\\u3031-\\u3035\\u3038-\\u303c\\u3041-\\u3096\\u309d-\\u309f\\u30a1-\\u30fa\\u30fc-\\u30ff\\u3105-\\u312d\\u3131-\\u318e\\u31a0-\\u31ba\\u31f0-\\u31ff\\u3400-\\u4db5\\u4e00-\\u9fcc\\ua000-\\ua48c\\ua4d0-\\ua4fd\\ua500-\\ua60c\\ua610-\\ua61f\\ua62a\\ua62b\\ua640-\\ua66e\\ua67f-\\ua697\\ua6a0-\\ua6ef\\ua717-\\ua71f\\ua722-\\ua788\\ua78b-\\ua78e\\ua790-\\ua793\\ua7a0-\\ua7aa\\ua7f8-\\ua801\\ua803-\\ua805\\ua807-\\ua80a\\ua80c-\\ua822\\ua840-\\ua873\\ua882-\\ua8b3\\ua8f2-\\ua8f7\\ua8fb\\ua90a-\\ua925\\ua930-\\ua946\\ua960-\\ua97c\\ua984-\\ua9b2\\ua9cf\\uaa00-\\uaa28\\uaa40-\\uaa42\\uaa44-\\uaa4b\\uaa60-\\uaa76\\uaa7a\\uaa80-\\uaaaf\\uaab1\\uaab5\\uaab6\\uaab9-\\uaabd\\uaac0\\uaac2\\uaadb-\\uaadd\\uaae0-\\uaaea\\uaaf2-\\uaaf4\\uab01-\\uab06\\uab09-\\uab0e\\uab11-\\uab16\\uab20-\\uab26\\uab28-\\uab2e\\uabc0-\\uabe2\\uac00-\\ud7a3\\ud7b0-\\ud7c6\\ud7cb-\\ud7fb\\uf900-\\ufa6d\\ufa70-\\ufad9\\ufb00-\\ufb06\\ufb13-\\ufb17\\ufb1d\\ufb1f-\\ufb28\\ufb2a-\\ufb36\\ufb38-\\ufb3c\\ufb3e\\ufb40\\ufb41\\ufb43\\ufb44\\ufb46-\\ufbb1\\ufbd3-\\ufd3d\\ufd50-\\ufd8f\\ufd92-\\ufdc7\\ufdf0-\\ufdfb\\ufe70-\\ufe74\\ufe76-\\ufefc\\uff21-\\uff3a\\uff41-\\uff5a\\uff66-\\uffbe\\uffc2-\\uffc7\\uffca-\\uffcf\\uffd2-\\uffd7\\uffda-\\uffdc\",Ht=\"\\u0300-\\u036f\\u0483-\\u0487\\u0591-\\u05bd\\u05bf\\u05c1\\u05c2\\u05c4\\u05c5\\u05c7\\u0610-\\u061a\\u0620-\\u0649\\u0672-\\u06d3\\u06e7-\\u06e8\\u06fb-\\u06fc\\u0730-\\u074a\\u0800-\\u0814\\u081b-\\u0823\\u0825-\\u0827\\u0829-\\u082d\\u0840-\\u0857\\u08e4-\\u08fe\\u0900-\\u0903\\u093a-\\u093c\\u093e-\\u094f\\u0951-\\u0957\\u0962-\\u0963\\u0966-\\u096f\\u0981-\\u0983\\u09bc\\u09be-\\u09c4\\u09c7\\u09c8\\u09d7\\u09df-\\u09e0\\u0a01-\\u0a03\\u0a3c\\u0a3e-\\u0a42\\u0a47\\u0a48\\u0a4b-\\u0a4d\\u0a51\\u0a66-\\u0a71\\u0a75\\u0a81-\\u0a83\\u0abc\\u0abe-\\u0ac5\\u0ac7-\\u0ac9\\u0acb-\\u0acd\\u0ae2-\\u0ae3\\u0ae6-\\u0aef\\u0b01-\\u0b03\\u0b3c\\u0b3e-\\u0b44\\u0b47\\u0b48\\u0b4b-\\u0b4d\\u0b56\\u0b57\\u0b5f-\\u0b60\\u0b66-\\u0b6f\\u0b82\\u0bbe-\\u0bc2\\u0bc6-\\u0bc8\\u0bca-\\u0bcd\\u0bd7\\u0be6-\\u0bef\\u0c01-\\u0c03\\u0c46-\\u0c48\\u0c4a-\\u0c4d\\u0c55\\u0c56\\u0c62-\\u0c63\\u0c66-\\u0c6f\\u0c82\\u0c83\\u0cbc\\u0cbe-\\u0cc4\\u0cc6-\\u0cc8\\u0cca-\\u0ccd\\u0cd5\\u0cd6\\u0ce2-\\u0ce3\\u0ce6-\\u0cef\\u0d02\\u0d03\\u0d46-\\u0d48\\u0d57\\u0d62-\\u0d63\\u0d66-\\u0d6f\\u0d82\\u0d83\\u0dca\\u0dcf-\\u0dd4\\u0dd6\\u0dd8-\\u0ddf\\u0df2\\u0df3\\u0e34-\\u0e3a\\u0e40-\\u0e45\\u0e50-\\u0e59\\u0eb4-\\u0eb9\\u0ec8-\\u0ecd\\u0ed0-\\u0ed9\\u0f18\\u0f19\\u0f20-\\u0f29\\u0f35\\u0f37\\u0f39\\u0f41-\\u0f47\\u0f71-\\u0f84\\u0f86-\\u0f87\\u0f8d-\\u0f97\\u0f99-\\u0fbc\\u0fc6\\u1000-\\u1029\\u1040-\\u1049\\u1067-\\u106d\\u1071-\\u1074\\u1082-\\u108d\\u108f-\\u109d\\u135d-\\u135f\\u170e-\\u1710\\u1720-\\u1730\\u1740-\\u1750\\u1772\\u1773\\u1780-\\u17b2\\u17dd\\u17e0-\\u17e9\\u180b-\\u180d\\u1810-\\u1819\\u1920-\\u192b\\u1930-\\u193b\\u1951-\\u196d\\u19b0-\\u19c0\\u19c8-\\u19c9\\u19d0-\\u19d9\\u1a00-\\u1a15\\u1a20-\\u1a53\\u1a60-\\u1a7c\\u1a7f-\\u1a89\\u1a90-\\u1a99\\u1b46-\\u1b4b\\u1b50-\\u1b59\\u1b6b-\\u1b73\\u1bb0-\\u1bb9\\u1be6-\\u1bf3\\u1c00-\\u1c22\\u1c40-\\u1c49\\u1c5b-\\u1c7d\\u1cd0-\\u1cd2\\u1d00-\\u1dbe\\u1e01-\\u1f15\\u200c\\u200d\\u203f\\u2040\\u2054\\u20d0-\\u20dc\\u20e1\\u20e5-\\u20f0\\u2d81-\\u2d96\\u2de0-\\u2dff\\u3021-\\u3028\\u3099\\u309a\\ua640-\\ua66d\\ua674-\\ua67d\\ua69f\\ua6f0-\\ua6f1\\ua7f8-\\ua800\\ua806\\ua80b\\ua823-\\ua827\\ua880-\\ua881\\ua8b4-\\ua8c4\\ua8d0-\\ua8d9\\ua8f3-\\ua8f7\\ua900-\\ua909\\ua926-\\ua92d\\ua930-\\ua945\\ua980-\\ua983\\ua9b3-\\ua9c0\\uaa00-\\uaa27\\uaa40-\\uaa41\\uaa4c-\\uaa4d\\uaa50-\\uaa59\\uaa7b\\uaae0-\\uaae9\\uaaf2-\\uaaf3\\uabc0-\\uabe1\\uabec\\uabed\\uabf0-\\uabf9\\ufb20-\\ufb28\\ufe00-\\ufe0f\\ufe20-\\ufe26\\ufe33\\ufe34\\ufe4d-\\ufe4f\\uff10-\\uff19\\uff3f\",$t=new RegExp(\"[\"+Pt+\"]\"),_t=new RegExp(\"[\"+Pt+Ht+\"]\"),Gt=/[\\n\\r\\u2028\\u2029]/,Kt=/\\r\\n|[\\n\\r\\u2028\\u2029]/g,Qt=e.isIdentifierStart=function(e){return 65>e?36===e:91>e?!0:97>e?95===e:123>e?!0:e>=170&&$t.test(String.fromCharCode(e))},Yt=e.isIdentifierChar=function(e){return 48>e?36===e:58>e?!0:65>e?!1:91>e?!0:97>e?95===e:123>e?!0:e>=170&&_t.test(String.fromCharCode(e))},Zt={kind:\"loop\"},en={kind:\"switch\"}});\n\n\tvar binaryOperators = {\n\t\t'+': '__add',\n\t\t'-': '__subtract',\n\t\t'*': '__multiply',\n\t\t'/': '__divide',\n\t\t'%': '__modulo',\n\t\t'==': 'equals',\n\t\t'!=': 'equals'\n\t};\n\n\tvar unaryOperators = {\n\t\t'-': '__negate',\n\t\t'+': null\n\t};\n\n\tvar fields = Base.each(\n\t\t['add', 'subtract', 'multiply', 'divide', 'modulo', 'negate'],\n\t\tfunction(name) {\n\t\t\tthis['__' + name] = '#' + name;\n\t\t},\n\t\t{}\n\t);\n\tPoint.inject(fields);\n\tSize.inject(fields);\n\tColor.inject(fields);\n\n\tfunction __$__(left, operator, right) {\n\t\tvar handler = binaryOperators[operator];\n\t\tif (left && left[handler]) {\n\t\t\tvar res = left[handler](right);\n\t\t\treturn operator === '!=' ? !res : res;\n\t\t}\n\t\tswitch (operator) {\n\t\tcase '+': return left + right;\n\t\tcase '-': return left - right;\n\t\tcase '*': return left * right;\n\t\tcase '/': return left / right;\n\t\tcase '%': return left % right;\n\t\tcase '==': return left == right;\n\t\tcase '!=': return left != right;\n\t\t}\n\t}\n\n\tfunction $__(operator, value) {\n\t\tvar handler = unaryOperators[operator];\n\t\tif (handler && value && value[handler])\n\t\t\treturn value[handler]();\n\t\tswitch (operator) {\n\t\tcase '+': return +value;\n\t\tcase '-': return -value;\n\t\t}\n\t}\n\n\tfunction parse(code, options) {\n\t\treturn scope.acorn.parse(code, options);\n\t}\n\n\tfunction compile(code, url, options) {\n\t\tif (!code)\n\t\t\treturn '';\n\t\toptions = options || {};\n\t\turl = url || '';\n\n\t\tvar insertions = [];\n\n\t\tfunction getOffset(offset) {\n\t\t\tfor (var i = 0, l = insertions.length; i < l; i++) {\n\t\t\t\tvar insertion = insertions[i];\n\t\t\t\tif (insertion[0] >= offset)\n\t\t\t\t\tbreak;\n\t\t\t\toffset += insertion[1];\n\t\t\t}\n\t\t\treturn offset;\n\t\t}\n\n\t\tfunction getCode(node) {\n\t\t\treturn code.substring(getOffset(node.range[0]),\n\t\t\t\t\tgetOffset(node.range[1]));\n\t\t}\n\n\t\tfunction getBetween(left, right) {\n\t\t\treturn code.substring(getOffset(left.range[1]),\n\t\t\t\t\tgetOffset(right.range[0]));\n\t\t}\n\n\t\tfunction replaceCode(node, str) {\n\t\t\tvar start = getOffset(node.range[0]),\n\t\t\t\tend = getOffset(node.range[1]),\n\t\t\t\tinsert = 0;\n\t\t\tfor (var i = insertions.length - 1; i >= 0; i--) {\n\t\t\t\tif (start > insertions[i][0]) {\n\t\t\t\t\tinsert = i + 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tinsertions.splice(insert, 0, [start, str.length - end + start]);\n\t\t\tcode = code.substring(0, start) + str + code.substring(end);\n\t\t}\n\n\t\tfunction walkAST(node, parent) {\n\t\t\tif (!node)\n\t\t\t\treturn;\n\t\t\tfor (var key in node) {\n\t\t\t\tif (key === 'range' || key === 'loc')\n\t\t\t\t\tcontinue;\n\t\t\t\tvar value = node[key];\n\t\t\t\tif (Array.isArray(value)) {\n\t\t\t\t\tfor (var i = 0, l = value.length; i < l; i++)\n\t\t\t\t\t\twalkAST(value[i], node);\n\t\t\t\t} else if (value && typeof value === 'object') {\n\t\t\t\t\twalkAST(value, node);\n\t\t\t\t}\n\t\t\t}\n\t\t\tswitch (node.type) {\n\t\t\tcase 'UnaryExpression':\n\t\t\t\tif (node.operator in unaryOperators\n\t\t\t\t\t\t&& node.argument.type !== 'Literal') {\n\t\t\t\t\tvar arg = getCode(node.argument);\n\t\t\t\t\treplaceCode(node, '$__(\"' + node.operator + '\", '\n\t\t\t\t\t\t\t+ arg + ')');\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'BinaryExpression':\n\t\t\t\tif (node.operator in binaryOperators\n\t\t\t\t\t\t&& node.left.type !== 'Literal') {\n\t\t\t\t\tvar left = getCode(node.left),\n\t\t\t\t\t\tright = getCode(node.right),\n\t\t\t\t\t\tbetween = getBetween(node.left, node.right),\n\t\t\t\t\t\toperator = node.operator;\n\t\t\t\t\treplaceCode(node, '__$__(' + left + ','\n\t\t\t\t\t\t\t+ between.replace(new RegExp('\\\\' + operator),\n\t\t\t\t\t\t\t\t'\"' + operator + '\"')\n\t\t\t\t\t\t\t+ ', ' + right + ')');\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'UpdateExpression':\n\t\t\tcase 'AssignmentExpression':\n\t\t\t\tvar parentType = parent && parent.type;\n\t\t\t\tif (!(\n\t\t\t\t\t\tparentType === 'ForStatement'\n\t\t\t\t\t\t|| parentType === 'BinaryExpression'\n\t\t\t\t\t\t\t&& /^[=!<>]/.test(parent.operator)\n\t\t\t\t\t\t|| parentType === 'MemberExpression' && parent.computed\n\t\t\t\t)) {\n\t\t\t\t\tif (node.type === 'UpdateExpression') {\n\t\t\t\t\t\tvar arg = getCode(node.argument),\n\t\t\t\t\t\t\texp = '__$__(' + arg + ', \"' + node.operator[0]\n\t\t\t\t\t\t\t\t\t+ '\", 1)',\n\t\t\t\t\t\t\tstr = arg + ' = ' + exp;\n\t\t\t\t\t\tif (!node.prefix\n\t\t\t\t\t\t\t\t&& (parentType === 'AssignmentExpression'\n\t\t\t\t\t\t\t\t\t|| parentType === 'VariableDeclarator')) {\n\t\t\t\t\t\t\tif (getCode(parent.left || parent.id) === arg)\n\t\t\t\t\t\t\t\tstr = exp;\n\t\t\t\t\t\t\tstr = arg + '; ' + str;\n\t\t\t\t\t\t}\n\t\t\t\t\t\treplaceCode(node, str);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (/^.=$/.test(node.operator)\n\t\t\t\t\t\t\t\t&& node.left.type !== 'Literal') {\n\t\t\t\t\t\t\tvar left = getCode(node.left),\n\t\t\t\t\t\t\t\tright = getCode(node.right);\n\t\t\t\t\t\t\treplaceCode(node, left + ' = __$__(' + left + ', \"'\n\t\t\t\t\t\t\t\t\t+ node.operator[0] + '\", ' + right + ')');\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tvar sourceMap = null,\n\t\t\tbrowser = paper.browser,\n\t\t\tversion = browser.versionNumber,\n\t\t\tlineBreaks = /\\r\\n|\\n|\\r/mg;\n\t\tif (browser.chrome && version >= 30\n\t\t\t\t|| browser.webkit && version >= 537.76\n\t\t\t\t|| browser.firefox && version >= 23) {\n\t\t\tvar offset = 0;\n\t\t\tif (window.location.href.indexOf(url) === 0) {\n\t\t\t\tvar html = document.getElementsByTagName('html')[0].innerHTML;\n\t\t\t\toffset = html.substr(0, html.indexOf(code) + 1).match(\n\t\t\t\t\t\tlineBreaks).length + 1;\n\t\t\t}\n\t\t\tvar mappings = ['AAAA'];\n\t\t\tmappings.length = (code.match(lineBreaks) || []).length + 1 + offset;\n\t\t\tsourceMap = {\n\t\t\t\tversion: 3,\n\t\t\t\tfile: url,\n\t\t\t\tnames:[],\n\t\t\t\tmappings: mappings.join(';AACA'),\n\t\t\t\tsourceRoot: '',\n\t\t\t\tsources: [url]\n\t\t\t};\n\t\t\tvar source = options.source || !url && code;\n\t\t\tif (source)\n\t\t\t\tsourceMap.sourcesContent = [source];\n\t\t}\n\t\twalkAST(parse(code, { ranges: true }));\n\t\tif (sourceMap) {\n\t\t\tcode = new Array(offset + 1).join('\\n') + code\n\t\t\t\t\t+ \"\\n//# sourceMappingURL=data:application/json;base64,\"\n\t\t\t\t\t+ (btoa(unescape(encodeURIComponent(\n\t\t\t\t\t\tJSON.stringify(sourceMap)))))\n\t\t\t\t\t+ \"\\n//# sourceURL=\" + (url || 'paperscript');\n\t\t}\n\t\treturn code;\n\t}\n\n\tfunction execute(code, scope, url, options) {\n\t\tpaper = scope;\n\t\tvar view = scope.getView(),\n\t\t\ttool = /\\s+on(?:Key|Mouse)(?:Up|Down|Move|Drag)\\b/.test(code)\n\t\t\t\t\t? new Tool()\n\t\t\t\t\t: null,\n\t\t\ttoolHandlers = tool ? tool._events : [],\n\t\t\thandlers = ['onFrame', 'onResize'].concat(toolHandlers),\n\t\t\tparams = [],\n\t\t\targs = [],\n\t\t\tfunc;\n\t\tcode = compile(code, url, options);\n\t\tfunction expose(scope, hidden) {\n\t\t\tfor (var key in scope) {\n\t\t\t\tif ((hidden || !/^_/.test(key)) && new RegExp('([\\\\b\\\\s\\\\W]|^)'\n\t\t\t\t\t\t+ key.replace(/\\$/g, '\\\\$') + '\\\\b').test(code)) {\n\t\t\t\t\tparams.push(key);\n\t\t\t\t\targs.push(scope[key]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\texpose({ __$__: __$__, $__: $__, paper: scope, view: view, tool: tool },\n\t\t\t\ttrue);\n\t\texpose(scope);\n\t\thandlers = Base.each(handlers, function(key) {\n\t\t\tif (new RegExp('\\\\s+' + key + '\\\\b').test(code)) {\n\t\t\t\tparams.push(key);\n\t\t\t\tthis.push(key + ': ' + key);\n\t\t\t}\n\t\t}, []).join(', ');\n\t\tif (handlers)\n\t\t\tcode += '\\nreturn { ' + handlers + ' };';\n\t\tvar browser = paper.browser;\n\t\tif (browser.chrome || browser.firefox) {\n\t\t\tvar script = document.createElement('script'),\n\t\t\t\thead = document.head || document.getElementsByTagName('head')[0];\n\t\t\tif (browser.firefox)\n\t\t\t\tcode = '\\n' + code;\n\t\t\tscript.appendChild(document.createTextNode(\n\t\t\t\t'paper._execute = function(' + params + ') {' + code + '\\n}'\n\t\t\t));\n\t\t\thead.appendChild(script);\n\t\t\tfunc = paper._execute;\n\t\t\tdelete paper._execute;\n\t\t\thead.removeChild(script);\n\t\t} else {\n\t\t\tfunc = Function(params, code);\n\t\t}\n\t\tvar res = func.apply(scope, args) || {};\n\t\tBase.each(toolHandlers, function(key) {\n\t\t\tvar value = res[key];\n\t\t\tif (value)\n\t\t\t\ttool[key] = value;\n\t\t});\n\t\tif (view) {\n\t\t\tif (res.onResize)\n\t\t\t\tview.setOnResize(res.onResize);\n\t\t\tview.emit('resize', {\n\t\t\t\tsize: view.size,\n\t\t\t\tdelta: new Point()\n\t\t\t});\n\t\t\tif (res.onFrame)\n\t\t\t\tview.setOnFrame(res.onFrame);\n\t\t\tview.update();\n\t\t}\n\t}\n\n\tfunction loadScript(script) {\n\t\tif (/^text\\/(?:x-|)paperscript$/.test(script.type)\n\t\t\t\t&& PaperScope.getAttribute(script, 'ignore') !== 'true') {\n\t\t\tvar canvasId = PaperScope.getAttribute(script, 'canvas'),\n\t\t\t\tcanvas = document.getElementById(canvasId),\n\t\t\t\tsrc = script.src || script.getAttribute('data-src'),\n\t\t\t\tasync = PaperScope.hasAttribute(script, 'async'),\n\t\t\t\tscopeAttribute = 'data-paper-scope';\n\t\t\tif (!canvas)\n\t\t\t\tthrow new Error('Unable to find canvas with id \"'\n\t\t\t\t\t\t+ canvasId + '\"');\n\t\t\tvar scope = PaperScope.get(canvas.getAttribute(scopeAttribute))\n\t\t\t\t\t\t|| new PaperScope().setup(canvas);\n\t\t\tcanvas.setAttribute(scopeAttribute, scope._id);\n\t\t\tif (src) {\n\t\t\t\tHttp.request('get', src, function(code) {\n\t\t\t\t\texecute(code, scope, src);\n\t\t\t\t}, async);\n\t\t\t} else {\n\t\t\t\texecute(script.innerHTML, scope, script.baseURI);\n\t\t\t}\n\t\t\tscript.setAttribute('data-paper-ignore', 'true');\n\t\t\treturn scope;\n\t\t}\n\t}\n\n\tfunction loadAll() {\n\t\tBase.each(document.getElementsByTagName('script'), loadScript);\n\t}\n\n\tfunction load(script) {\n\t\treturn script ? loadScript(script) : loadAll();\n\t}\n\n\tif (document.readyState === 'complete') {\n\t\tsetTimeout(loadAll);\n\t} else {\n\t\tDomEvent.add(window, { load: loadAll });\n\t}\n\n\treturn {\n\t\tcompile: compile,\n\t\texecute: execute,\n\t\tload: load,\n\t\tparse: parse\n\t};\n\n}).call(this);\n\npaper = new (PaperScope.inject(Base.exports, {\n\tenumerable: true,\n\tBase: Base,\n\tNumerical: Numerical,\n\tKey: Key\n}))();\n\nif (typeof define === 'function' && define.amd) {\n\tdefine('paper', paper);\n} else if (typeof module === 'object' && module) {\n\tmodule.exports = paper;\n}\n\nreturn paper;\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/paper/dist/paper-full.js\n ** module id = 1\n ** module chunks = 0\n **/","import R from \"ramda\"\nimport Dialogue from \"./dialogue\"\n\nvar story = [\n\t{\n\t\t\"scene\": \"intro\",\n\t\t\"src\": \"vid/Intro.mp4\",\n\t\t\"next\": \"conflict\"\n\t},\t\n\t{\n\t\t\"scene\": \"conflict\",\n\t\t\"src\": \"vid/Background.mp4\",\n\t\t\"dialogue\": \"intro_dialog\",\n\t},\n\t{\n\t\t\"scene\": \"mech_force\",\n\t\t\"src\": \"vid/Meteor.mp4\",\n\t\t\"next\": \"mech_force_dialog\"\n\t},\n\t{\n\t\t\"scene\": \"mech_force_dialog\",\n\t\t\"src\": \"vid/Background.mp4\",\n\t\t\"dialogue\": \"asteroid_dialog\",\n\t},\n\t{\n\t\t\"scene\": \"compete_kind\",\n\t\t\"src\": \"vid/Background.mp4\",\n\t\t\"dialogue\": \"compete_kind_dialog\"\n\t},\n\t{\n\t\t\"scene\": \"compete_hard\",\n\t\t\"src\": \"vid/Background.mp4\",\n\t\t\"dialogue\": \"compete_hard_dialog\"\n\t},\n\t{\n\t\t\"scene\": \"electrical_density\",\n\t\t\"src\": \"vid/Cars.mp4\",\n\t\t\"next\": \"ed_dialog\"\n\n\t},\n\t{\n\t\t\"scene\": \"conductivity\",\n\t\t\"src\": \"vid/Phone.mp4\",\n\t\t\"next\": \"c_dialog\"\n\t},\n\t{\n\t\t\"scene\": \"ed_dialog\",\n\t\t\"src\": \"vid/Background.mp4\",\n\t\t\"dialogue\": \"ed_c_dialog\"\n\t},\t\n\t{\n\t\t\"scene\": \"c_dialog\",\n\t\t\"src\": \"vid/Background.mp4\",\n\t\t\"dialogue\": \"c_c_dialog\"\n\t},\n\t\t{\n\t\t\"scene\": \"electrical_density_2\",\n\t\t\"src\": \"vid/Cars.mp4\",\n\t\t\"next\": \"end1\"\n\n\t},\n\t{\n\t\t\"scene\": \"conductivity_2\",\n\t\t\"src\": \"vid/Phone.mp4\",\n\t\t\"next\": \"end1\"\n\t},\n\n\t{\n\t\t\"scene\": \"electrical_density_good\",\n\t\t\"src\": \"vid/Cars.mp4\",\n\t\t\"next\": \"end2\"\n\n\t},\n\t{\n\t\t\"scene\": \"conductivity_good\",\n\t\t\"src\": \"vid/Phone.mp4\",\n\t\t\"next\": \"good_mid\"\n\t},\n\n\t{\n\t\t\"scene\": \"good_mid\",\n\t\t\"src\": \"vid/Background.mp4\",\n\t\t\"dialogue\": \"good_dialog\"\n\t},\n\n\t{\n\t\t\"src\": \"vid/Background.mp4\",\n\t\t\"scene\": \"end1\",\n\t\t\"dialogue\": \"ending_dialog_1\"\n\t},\n\t{\n\t\t\"src\": \"vid/Background.mp4\",\n\t\t\"dialogue\": \"ending_dialog_2\",\n\t\t\"scene\": \"end2\"\n\t},\n\t{\n\t\t\"src\": \"vid/Background.mp4\",\n\t\t\"scene\": \"end_true\",\n\t\t\"next\": \"test\"\n\t},\n\t{\n\t\t\"src\": \"vid/Background.mp4\",\n\t\t\"scene\": \"test\"\n\t}\t\n]\n\n\n\nwindow.s = story\n\nvar cache = []\n\nfunction createVideo(element){\n\tvar item = R.find(R.propEq(\"src\", element.src))(cache)\n\tif(item != null){\n\t\telement.video = item.video\n\t}else{\n\t\tlet vid = document.createElement(\"video\")\n\t\tif(element.src == \"vid/Background.mp4\"){\n\t\t\tvid.loop = true;\n\t\t}\n\t\tvid.src = element.src;\n\t\tcache.push({src: element.src, video: vid})\n\t\telement.video = vid;\n\t}\n\t\n}\n\nexport default class Story {\n\tconstructor(){\n\t\tthis.story = story;\n\t\tthis.showDialogue = false;\n\t\tthis.dialogue = new Dialogue();\n\t\tthis.current = this.story[0];\n\t\tthis.story.forEach(createVideo)\n\t\tconsole.log(cache)\n\t}\n\n\tdefaultVideo(){\n\t\treturn R.find(R.propEq(\"src\", \"vid/Background.mp4\"))(cache)\n\t}\n\n\tscene(name){\n\t\treturn R.find(R.propEq(\"scene\", name))(this.story)\n\t}\n\n\texists(scene){\n\t\treturn this.scene(scene) != null\n\t}\n\n\tchoices(){\n\t\tif(this.current.dialogue != null){\n\t\t\tif(this.dialogue.hasChoices()){\n\t\t\t\treturn this.dialogue.choices()\n\t\t\t}else{\n\t\t\t\treturn this.dialogue.say()\n\t\t\t}\n\t\t}\n\t\tif(this.current.choice != null){\n\t\t\treturn this.current.choice.map(o => o.show)\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn []\n\t\t}\n\t}\n\n\thasChoices(){\n\t\treturn this.current.choice != null || this.dialogue.hasChoices()\n\t}\n\n\n\tsetHasDialogue(bool /* bool */){\n\t\tthis.showDialogue = bool\n\t}\n\n\thasDialogue(){\n\t\treturn this.showDialogue\n\t}\n\n\tneededVideos(){\n\t\tif(this.current.choice){\n\t\t\treturn this.current.choice.map((e) => this.scene(e.scene))\n\t\t}else{\n\t\t\treturn [ this.scene(this.current.next) ]\n\t\t}\n\t}\n\n\t//events for the scene\n\n\tonBefore(scene, fn){\n\t\tif(this.exists(scene)){\n\t\t\tthis.scene(scene).onBefore = fn\n\t\t}\n\t}\n\n\toffBefore(scene){\n\t\tif(this.exists(scene)){\n\t\t\tdelete this.scene(scene).onBefore\n\t\t}\n\t}\n\n\tonAfter(scene, fn){\n\t\tif(this.exists(scene)){\n\t\t\tthis.scene(scene).onAfter = fn\n\t\t}\n\t}\n\n\toffAfetr(scene){\n\t\tif(this.exists(scene)){\n\t\t\tdelete this.scene(scene).onAfter\n\t\t}\n\t}\n\n\n\n\tswitchTo(scene){\n\t\tif(scene != null){\n\t\t\tif(this.current.onAfter != null){ // calls onAfter just before switching the video\n\t\t\t\tthis.current.onAfter()\n\t\t\t}\n\n\t\t\tthis.current = this.scene(scene); // switch the video with the next one\n\n\t\t\tif(this.current.dialogue != null){\n\t\t\t\tthis.dialogue.select(this.current.dialogue)\n\t\t\t\tthis.showDialogue = true;\n\t\t\t}else{\n\t\t\t\tthis.showDialogue = false;\n\t\t\t}\n\n\t\t\tif(this.current.onBefore != null){ // call onBefore for the the next video \n\t\t\t\tthis.current.onBefore()\n\t\t\t}\n\n\n\t\t}\n\t}\n\n\tnext(choice){\n\t\tif(this.current.dialogue != null){\n\t\t\tvar scene = this.dialogue.next(choice)\n\t\t\tthis.switchTo(scene)\n\t\t\n\t\t}else{\n\t\t\tthis.switchTo(this.current.next)\n\n\t\t}\n\n\n\t}\n}\n\n\n/** WEBPACK FOOTER **\n ** ./js/story.js\n **/","//  Ramda v0.19.1\n//  https://github.com/ramda/ramda\n//  (c) 2013-2016 Scott Sauyet, Michael Hurley, and David Chambers\n//  Ramda may be freely distributed under the MIT license.\n\n;(function() {\n\n  'use strict';\n\n  /**\n     * A special placeholder value used to specify \"gaps\" within curried functions,\n     * allowing partial application of any combination of arguments, regardless of\n     * their positions.\n     *\n     * If `g` is a curried ternary function and `_` is `R.__`, the following are\n     * equivalent:\n     *\n     *   - `g(1, 2, 3)`\n     *   - `g(_, 2, 3)(1)`\n     *   - `g(_, _, 3)(1)(2)`\n     *   - `g(_, _, 3)(1, 2)`\n     *   - `g(_, 2, _)(1, 3)`\n     *   - `g(_, 2)(1)(3)`\n     *   - `g(_, 2)(1, 3)`\n     *   - `g(_, 2)(_, 3)(1)`\n     *\n     * @constant\n     * @memberOf R\n     * @since v0.6.0\n     * @category Function\n     * @example\n     *\n     *      var greet = R.replace('{name}', R.__, 'Hello, {name}!');\n     *      greet('Alice'); //=> 'Hello, Alice!'\n     */\n    var __ = { '@@functional/placeholder': true };\n\n    /* eslint-disable no-unused-vars */\n    var _arity = function _arity(n, fn) {\n        /* eslint-disable no-unused-vars */\n        switch (n) {\n        case 0:\n            return function () {\n                return fn.apply(this, arguments);\n            };\n        case 1:\n            return function (a0) {\n                return fn.apply(this, arguments);\n            };\n        case 2:\n            return function (a0, a1) {\n                return fn.apply(this, arguments);\n            };\n        case 3:\n            return function (a0, a1, a2) {\n                return fn.apply(this, arguments);\n            };\n        case 4:\n            return function (a0, a1, a2, a3) {\n                return fn.apply(this, arguments);\n            };\n        case 5:\n            return function (a0, a1, a2, a3, a4) {\n                return fn.apply(this, arguments);\n            };\n        case 6:\n            return function (a0, a1, a2, a3, a4, a5) {\n                return fn.apply(this, arguments);\n            };\n        case 7:\n            return function (a0, a1, a2, a3, a4, a5, a6) {\n                return fn.apply(this, arguments);\n            };\n        case 8:\n            return function (a0, a1, a2, a3, a4, a5, a6, a7) {\n                return fn.apply(this, arguments);\n            };\n        case 9:\n            return function (a0, a1, a2, a3, a4, a5, a6, a7, a8) {\n                return fn.apply(this, arguments);\n            };\n        case 10:\n            return function (a0, a1, a2, a3, a4, a5, a6, a7, a8, a9) {\n                return fn.apply(this, arguments);\n            };\n        default:\n            throw new Error('First argument to _arity must be a non-negative integer no greater than ten');\n        }\n    };\n\n    var _arrayFromIterator = function _arrayFromIterator(iter) {\n        var list = [];\n        var next;\n        while (!(next = iter.next()).done) {\n            list.push(next.value);\n        }\n        return list;\n    };\n\n    var _cloneRegExp = function _cloneRegExp(pattern) {\n        return new RegExp(pattern.source, (pattern.global ? 'g' : '') + (pattern.ignoreCase ? 'i' : '') + (pattern.multiline ? 'm' : '') + (pattern.sticky ? 'y' : '') + (pattern.unicode ? 'u' : ''));\n    };\n\n    var _complement = function _complement(f) {\n        return function () {\n            return !f.apply(this, arguments);\n        };\n    };\n\n    /**\n     * Private `concat` function to merge two array-like objects.\n     *\n     * @private\n     * @param {Array|Arguments} [set1=[]] An array-like object.\n     * @param {Array|Arguments} [set2=[]] An array-like object.\n     * @return {Array} A new, merged array.\n     * @example\n     *\n     *      _concat([4, 5, 6], [1, 2, 3]); //=> [4, 5, 6, 1, 2, 3]\n     */\n    var _concat = function _concat(set1, set2) {\n        set1 = set1 || [];\n        set2 = set2 || [];\n        var idx;\n        var len1 = set1.length;\n        var len2 = set2.length;\n        var result = [];\n        idx = 0;\n        while (idx < len1) {\n            result[result.length] = set1[idx];\n            idx += 1;\n        }\n        idx = 0;\n        while (idx < len2) {\n            result[result.length] = set2[idx];\n            idx += 1;\n        }\n        return result;\n    };\n\n    var _containsWith = function _containsWith(pred, x, list) {\n        var idx = 0;\n        var len = list.length;\n        while (idx < len) {\n            if (pred(x, list[idx])) {\n                return true;\n            }\n            idx += 1;\n        }\n        return false;\n    };\n\n    var _filter = function _filter(fn, list) {\n        var idx = 0;\n        var len = list.length;\n        var result = [];\n        while (idx < len) {\n            if (fn(list[idx])) {\n                result[result.length] = list[idx];\n            }\n            idx += 1;\n        }\n        return result;\n    };\n\n    var _forceReduced = function _forceReduced(x) {\n        return {\n            '@@transducer/value': x,\n            '@@transducer/reduced': true\n        };\n    };\n\n    var _has = function _has(prop, obj) {\n        return Object.prototype.hasOwnProperty.call(obj, prop);\n    };\n\n    var _identity = function _identity(x) {\n        return x;\n    };\n\n    var _isArguments = function () {\n        var toString = Object.prototype.toString;\n        return toString.call(arguments) === '[object Arguments]' ? function _isArguments(x) {\n            return toString.call(x) === '[object Arguments]';\n        } : function _isArguments(x) {\n            return _has('callee', x);\n        };\n    }();\n\n    /**\n     * Tests whether or not an object is an array.\n     *\n     * @private\n     * @param {*} val The object to test.\n     * @return {Boolean} `true` if `val` is an array, `false` otherwise.\n     * @example\n     *\n     *      _isArray([]); //=> true\n     *      _isArray(null); //=> false\n     *      _isArray({}); //=> false\n     */\n    var _isArray = Array.isArray || function _isArray(val) {\n        return val != null && val.length >= 0 && Object.prototype.toString.call(val) === '[object Array]';\n    };\n\n    /**\n     * Determine if the passed argument is an integer.\n     *\n     * @private\n     * @param {*} n\n     * @category Type\n     * @return {Boolean}\n     */\n    var _isInteger = Number.isInteger || function _isInteger(n) {\n        return n << 0 === n;\n    };\n\n    var _isNumber = function _isNumber(x) {\n        return Object.prototype.toString.call(x) === '[object Number]';\n    };\n\n    var _isObject = function _isObject(x) {\n        return Object.prototype.toString.call(x) === '[object Object]';\n    };\n\n    var _isPlaceholder = function _isPlaceholder(a) {\n        return a != null && typeof a === 'object' && a['@@functional/placeholder'] === true;\n    };\n\n    var _isRegExp = function _isRegExp(x) {\n        return Object.prototype.toString.call(x) === '[object RegExp]';\n    };\n\n    var _isString = function _isString(x) {\n        return Object.prototype.toString.call(x) === '[object String]';\n    };\n\n    var _isTransformer = function _isTransformer(obj) {\n        return typeof obj['@@transducer/step'] === 'function';\n    };\n\n    var _map = function _map(fn, functor) {\n        var idx = 0;\n        var len = functor.length;\n        var result = Array(len);\n        while (idx < len) {\n            result[idx] = fn(functor[idx]);\n            idx += 1;\n        }\n        return result;\n    };\n\n    var _of = function _of(x) {\n        return [x];\n    };\n\n    var _pipe = function _pipe(f, g) {\n        return function () {\n            return g.call(this, f.apply(this, arguments));\n        };\n    };\n\n    var _pipeP = function _pipeP(f, g) {\n        return function () {\n            var ctx = this;\n            return f.apply(ctx, arguments).then(function (x) {\n                return g.call(ctx, x);\n            });\n        };\n    };\n\n    // \\b matches word boundary; [\\b] matches backspace\n    var _quote = function _quote(s) {\n        var escaped = s.replace(/\\\\/g, '\\\\\\\\').replace(/[\\b]/g, '\\\\b')    // \\b matches word boundary; [\\b] matches backspace\n    .replace(/\\f/g, '\\\\f').replace(/\\n/g, '\\\\n').replace(/\\r/g, '\\\\r').replace(/\\t/g, '\\\\t').replace(/\\v/g, '\\\\v').replace(/\\0/g, '\\\\0');\n        return '\"' + escaped.replace(/\"/g, '\\\\\"') + '\"';\n    };\n\n    var _reduced = function _reduced(x) {\n        return x && x['@@transducer/reduced'] ? x : {\n            '@@transducer/value': x,\n            '@@transducer/reduced': true\n        };\n    };\n\n    /**\n     * An optimized, private array `slice` implementation.\n     *\n     * @private\n     * @param {Arguments|Array} args The array or arguments object to consider.\n     * @param {Number} [from=0] The array index to slice from, inclusive.\n     * @param {Number} [to=args.length] The array index to slice to, exclusive.\n     * @return {Array} A new, sliced array.\n     * @example\n     *\n     *      _slice([1, 2, 3, 4, 5], 1, 3); //=> [2, 3]\n     *\n     *      var firstThreeArgs = function(a, b, c, d) {\n     *        return _slice(arguments, 0, 3);\n     *      };\n     *      firstThreeArgs(1, 2, 3, 4); //=> [1, 2, 3]\n     */\n    var _slice = function _slice(args, from, to) {\n        switch (arguments.length) {\n        case 1:\n            return _slice(args, 0, args.length);\n        case 2:\n            return _slice(args, from, args.length);\n        default:\n            var list = [];\n            var idx = 0;\n            var len = Math.max(0, Math.min(args.length, to) - from);\n            while (idx < len) {\n                list[idx] = args[from + idx];\n                idx += 1;\n            }\n            return list;\n        }\n    };\n\n    /**\n     * Polyfill from <https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/toISOString>.\n     */\n    var _toISOString = function () {\n        var pad = function pad(n) {\n            return (n < 10 ? '0' : '') + n;\n        };\n        return typeof Date.prototype.toISOString === 'function' ? function _toISOString(d) {\n            return d.toISOString();\n        } : function _toISOString(d) {\n            return d.getUTCFullYear() + '-' + pad(d.getUTCMonth() + 1) + '-' + pad(d.getUTCDate()) + 'T' + pad(d.getUTCHours()) + ':' + pad(d.getUTCMinutes()) + ':' + pad(d.getUTCSeconds()) + '.' + (d.getUTCMilliseconds() / 1000).toFixed(3).slice(2, 5) + 'Z';\n        };\n    }();\n\n    var _xfBase = {\n        init: function () {\n            return this.xf['@@transducer/init']();\n        },\n        result: function (result) {\n            return this.xf['@@transducer/result'](result);\n        }\n    };\n\n    var _xwrap = function () {\n        function XWrap(fn) {\n            this.f = fn;\n        }\n        XWrap.prototype['@@transducer/init'] = function () {\n            throw new Error('init not implemented on XWrap');\n        };\n        XWrap.prototype['@@transducer/result'] = function (acc) {\n            return acc;\n        };\n        XWrap.prototype['@@transducer/step'] = function (acc, x) {\n            return this.f(acc, x);\n        };\n        return function _xwrap(fn) {\n            return new XWrap(fn);\n        };\n    }();\n\n    var _aperture = function _aperture(n, list) {\n        var idx = 0;\n        var limit = list.length - (n - 1);\n        var acc = new Array(limit >= 0 ? limit : 0);\n        while (idx < limit) {\n            acc[idx] = _slice(list, idx, idx + n);\n            idx += 1;\n        }\n        return acc;\n    };\n\n    /**\n     * Similar to hasMethod, this checks whether a function has a [methodname]\n     * function. If it isn't an array it will execute that function otherwise it\n     * will default to the ramda implementation.\n     *\n     * @private\n     * @param {Function} fn ramda implemtation\n     * @param {String} methodname property to check for a custom implementation\n     * @return {Object} Whatever the return value of the method is.\n     */\n    var _checkForMethod = function _checkForMethod(methodname, fn) {\n        return function () {\n            var length = arguments.length;\n            if (length === 0) {\n                return fn();\n            }\n            var obj = arguments[length - 1];\n            return _isArray(obj) || typeof obj[methodname] !== 'function' ? fn.apply(this, arguments) : obj[methodname].apply(obj, _slice(arguments, 0, length - 1));\n        };\n    };\n\n    /**\n     * Optimized internal one-arity curry function.\n     *\n     * @private\n     * @category Function\n     * @param {Function} fn The function to curry.\n     * @return {Function} The curried function.\n     */\n    var _curry1 = function _curry1(fn) {\n        return function f1(a) {\n            if (arguments.length === 0 || _isPlaceholder(a)) {\n                return f1;\n            } else {\n                return fn.apply(this, arguments);\n            }\n        };\n    };\n\n    /**\n     * Optimized internal two-arity curry function.\n     *\n     * @private\n     * @category Function\n     * @param {Function} fn The function to curry.\n     * @return {Function} The curried function.\n     */\n    var _curry2 = function _curry2(fn) {\n        return function f2(a, b) {\n            switch (arguments.length) {\n            case 0:\n                return f2;\n            case 1:\n                return _isPlaceholder(a) ? f2 : _curry1(function (_b) {\n                    return fn(a, _b);\n                });\n            default:\n                return _isPlaceholder(a) && _isPlaceholder(b) ? f2 : _isPlaceholder(a) ? _curry1(function (_a) {\n                    return fn(_a, b);\n                }) : _isPlaceholder(b) ? _curry1(function (_b) {\n                    return fn(a, _b);\n                }) : fn(a, b);\n            }\n        };\n    };\n\n    /**\n     * Optimized internal three-arity curry function.\n     *\n     * @private\n     * @category Function\n     * @param {Function} fn The function to curry.\n     * @return {Function} The curried function.\n     */\n    var _curry3 = function _curry3(fn) {\n        return function f3(a, b, c) {\n            switch (arguments.length) {\n            case 0:\n                return f3;\n            case 1:\n                return _isPlaceholder(a) ? f3 : _curry2(function (_b, _c) {\n                    return fn(a, _b, _c);\n                });\n            case 2:\n                return _isPlaceholder(a) && _isPlaceholder(b) ? f3 : _isPlaceholder(a) ? _curry2(function (_a, _c) {\n                    return fn(_a, b, _c);\n                }) : _isPlaceholder(b) ? _curry2(function (_b, _c) {\n                    return fn(a, _b, _c);\n                }) : _curry1(function (_c) {\n                    return fn(a, b, _c);\n                });\n            default:\n                return _isPlaceholder(a) && _isPlaceholder(b) && _isPlaceholder(c) ? f3 : _isPlaceholder(a) && _isPlaceholder(b) ? _curry2(function (_a, _b) {\n                    return fn(_a, _b, c);\n                }) : _isPlaceholder(a) && _isPlaceholder(c) ? _curry2(function (_a, _c) {\n                    return fn(_a, b, _c);\n                }) : _isPlaceholder(b) && _isPlaceholder(c) ? _curry2(function (_b, _c) {\n                    return fn(a, _b, _c);\n                }) : _isPlaceholder(a) ? _curry1(function (_a) {\n                    return fn(_a, b, c);\n                }) : _isPlaceholder(b) ? _curry1(function (_b) {\n                    return fn(a, _b, c);\n                }) : _isPlaceholder(c) ? _curry1(function (_c) {\n                    return fn(a, b, _c);\n                }) : fn(a, b, c);\n            }\n        };\n    };\n\n    /**\n     * Internal curryN function.\n     *\n     * @private\n     * @category Function\n     * @param {Number} length The arity of the curried function.\n     * @param {Array} received An array of arguments received thus far.\n     * @param {Function} fn The function to curry.\n     * @return {Function} The curried function.\n     */\n    var _curryN = function _curryN(length, received, fn) {\n        return function () {\n            var combined = [];\n            var argsIdx = 0;\n            var left = length;\n            var combinedIdx = 0;\n            while (combinedIdx < received.length || argsIdx < arguments.length) {\n                var result;\n                if (combinedIdx < received.length && (!_isPlaceholder(received[combinedIdx]) || argsIdx >= arguments.length)) {\n                    result = received[combinedIdx];\n                } else {\n                    result = arguments[argsIdx];\n                    argsIdx += 1;\n                }\n                combined[combinedIdx] = result;\n                if (!_isPlaceholder(result)) {\n                    left -= 1;\n                }\n                combinedIdx += 1;\n            }\n            return left <= 0 ? fn.apply(this, combined) : _arity(left, _curryN(length, combined, fn));\n        };\n    };\n\n    /**\n     * Returns a function that dispatches with different strategies based on the\n     * object in list position (last argument). If it is an array, executes [fn].\n     * Otherwise, if it has a function with [methodname], it will execute that\n     * function (functor case). Otherwise, if it is a transformer, uses transducer\n     * [xf] to return a new transformer (transducer case). Otherwise, it will\n     * default to executing [fn].\n     *\n     * @private\n     * @param {String} methodname property to check for a custom implementation\n     * @param {Function} xf transducer to initialize if object is transformer\n     * @param {Function} fn default ramda implementation\n     * @return {Function} A function that dispatches on object in list position\n     */\n    var _dispatchable = function _dispatchable(methodname, xf, fn) {\n        return function () {\n            var length = arguments.length;\n            if (length === 0) {\n                return fn();\n            }\n            var obj = arguments[length - 1];\n            if (!_isArray(obj)) {\n                var args = _slice(arguments, 0, length - 1);\n                if (typeof obj[methodname] === 'function') {\n                    return obj[methodname].apply(obj, args);\n                }\n                if (_isTransformer(obj)) {\n                    var transducer = xf.apply(null, args);\n                    return transducer(obj);\n                }\n            }\n            return fn.apply(this, arguments);\n        };\n    };\n\n    var _dropLastWhile = function dropLastWhile(pred, list) {\n        var idx = list.length - 1;\n        while (idx >= 0 && pred(list[idx])) {\n            idx -= 1;\n        }\n        return _slice(list, 0, idx + 1);\n    };\n\n    var _xall = function () {\n        function XAll(f, xf) {\n            this.xf = xf;\n            this.f = f;\n            this.all = true;\n        }\n        XAll.prototype['@@transducer/init'] = _xfBase.init;\n        XAll.prototype['@@transducer/result'] = function (result) {\n            if (this.all) {\n                result = this.xf['@@transducer/step'](result, true);\n            }\n            return this.xf['@@transducer/result'](result);\n        };\n        XAll.prototype['@@transducer/step'] = function (result, input) {\n            if (!this.f(input)) {\n                this.all = false;\n                result = _reduced(this.xf['@@transducer/step'](result, false));\n            }\n            return result;\n        };\n        return _curry2(function _xall(f, xf) {\n            return new XAll(f, xf);\n        });\n    }();\n\n    var _xany = function () {\n        function XAny(f, xf) {\n            this.xf = xf;\n            this.f = f;\n            this.any = false;\n        }\n        XAny.prototype['@@transducer/init'] = _xfBase.init;\n        XAny.prototype['@@transducer/result'] = function (result) {\n            if (!this.any) {\n                result = this.xf['@@transducer/step'](result, false);\n            }\n            return this.xf['@@transducer/result'](result);\n        };\n        XAny.prototype['@@transducer/step'] = function (result, input) {\n            if (this.f(input)) {\n                this.any = true;\n                result = _reduced(this.xf['@@transducer/step'](result, true));\n            }\n            return result;\n        };\n        return _curry2(function _xany(f, xf) {\n            return new XAny(f, xf);\n        });\n    }();\n\n    var _xaperture = function () {\n        function XAperture(n, xf) {\n            this.xf = xf;\n            this.pos = 0;\n            this.full = false;\n            this.acc = new Array(n);\n        }\n        XAperture.prototype['@@transducer/init'] = _xfBase.init;\n        XAperture.prototype['@@transducer/result'] = function (result) {\n            this.acc = null;\n            return this.xf['@@transducer/result'](result);\n        };\n        XAperture.prototype['@@transducer/step'] = function (result, input) {\n            this.store(input);\n            return this.full ? this.xf['@@transducer/step'](result, this.getCopy()) : result;\n        };\n        XAperture.prototype.store = function (input) {\n            this.acc[this.pos] = input;\n            this.pos += 1;\n            if (this.pos === this.acc.length) {\n                this.pos = 0;\n                this.full = true;\n            }\n        };\n        XAperture.prototype.getCopy = function () {\n            return _concat(_slice(this.acc, this.pos), _slice(this.acc, 0, this.pos));\n        };\n        return _curry2(function _xaperture(n, xf) {\n            return new XAperture(n, xf);\n        });\n    }();\n\n    var _xdrop = function () {\n        function XDrop(n, xf) {\n            this.xf = xf;\n            this.n = n;\n        }\n        XDrop.prototype['@@transducer/init'] = _xfBase.init;\n        XDrop.prototype['@@transducer/result'] = _xfBase.result;\n        XDrop.prototype['@@transducer/step'] = function (result, input) {\n            if (this.n > 0) {\n                this.n -= 1;\n                return result;\n            }\n            return this.xf['@@transducer/step'](result, input);\n        };\n        return _curry2(function _xdrop(n, xf) {\n            return new XDrop(n, xf);\n        });\n    }();\n\n    var _xdropLast = function () {\n        function XDropLast(n, xf) {\n            this.xf = xf;\n            this.pos = 0;\n            this.full = false;\n            this.acc = new Array(n);\n        }\n        XDropLast.prototype['@@transducer/init'] = _xfBase.init;\n        XDropLast.prototype['@@transducer/result'] = function (result) {\n            this.acc = null;\n            return this.xf['@@transducer/result'](result);\n        };\n        XDropLast.prototype['@@transducer/step'] = function (result, input) {\n            if (this.full) {\n                result = this.xf['@@transducer/step'](result, this.acc[this.pos]);\n            }\n            this.store(input);\n            return result;\n        };\n        XDropLast.prototype.store = function (input) {\n            this.acc[this.pos] = input;\n            this.pos += 1;\n            if (this.pos === this.acc.length) {\n                this.pos = 0;\n                this.full = true;\n            }\n        };\n        return _curry2(function _xdropLast(n, xf) {\n            return new XDropLast(n, xf);\n        });\n    }();\n\n    var _xdropRepeatsWith = function () {\n        function XDropRepeatsWith(pred, xf) {\n            this.xf = xf;\n            this.pred = pred;\n            this.lastValue = undefined;\n            this.seenFirstValue = false;\n        }\n        XDropRepeatsWith.prototype['@@transducer/init'] = function () {\n            return this.xf['@@transducer/init']();\n        };\n        XDropRepeatsWith.prototype['@@transducer/result'] = function (result) {\n            return this.xf['@@transducer/result'](result);\n        };\n        XDropRepeatsWith.prototype['@@transducer/step'] = function (result, input) {\n            var sameAsLast = false;\n            if (!this.seenFirstValue) {\n                this.seenFirstValue = true;\n            } else if (this.pred(this.lastValue, input)) {\n                sameAsLast = true;\n            }\n            this.lastValue = input;\n            return sameAsLast ? result : this.xf['@@transducer/step'](result, input);\n        };\n        return _curry2(function _xdropRepeatsWith(pred, xf) {\n            return new XDropRepeatsWith(pred, xf);\n        });\n    }();\n\n    var _xdropWhile = function () {\n        function XDropWhile(f, xf) {\n            this.xf = xf;\n            this.f = f;\n        }\n        XDropWhile.prototype['@@transducer/init'] = _xfBase.init;\n        XDropWhile.prototype['@@transducer/result'] = _xfBase.result;\n        XDropWhile.prototype['@@transducer/step'] = function (result, input) {\n            if (this.f) {\n                if (this.f(input)) {\n                    return result;\n                }\n                this.f = null;\n            }\n            return this.xf['@@transducer/step'](result, input);\n        };\n        return _curry2(function _xdropWhile(f, xf) {\n            return new XDropWhile(f, xf);\n        });\n    }();\n\n    var _xfilter = function () {\n        function XFilter(f, xf) {\n            this.xf = xf;\n            this.f = f;\n        }\n        XFilter.prototype['@@transducer/init'] = _xfBase.init;\n        XFilter.prototype['@@transducer/result'] = _xfBase.result;\n        XFilter.prototype['@@transducer/step'] = function (result, input) {\n            return this.f(input) ? this.xf['@@transducer/step'](result, input) : result;\n        };\n        return _curry2(function _xfilter(f, xf) {\n            return new XFilter(f, xf);\n        });\n    }();\n\n    var _xfind = function () {\n        function XFind(f, xf) {\n            this.xf = xf;\n            this.f = f;\n            this.found = false;\n        }\n        XFind.prototype['@@transducer/init'] = _xfBase.init;\n        XFind.prototype['@@transducer/result'] = function (result) {\n            if (!this.found) {\n                result = this.xf['@@transducer/step'](result, void 0);\n            }\n            return this.xf['@@transducer/result'](result);\n        };\n        XFind.prototype['@@transducer/step'] = function (result, input) {\n            if (this.f(input)) {\n                this.found = true;\n                result = _reduced(this.xf['@@transducer/step'](result, input));\n            }\n            return result;\n        };\n        return _curry2(function _xfind(f, xf) {\n            return new XFind(f, xf);\n        });\n    }();\n\n    var _xfindIndex = function () {\n        function XFindIndex(f, xf) {\n            this.xf = xf;\n            this.f = f;\n            this.idx = -1;\n            this.found = false;\n        }\n        XFindIndex.prototype['@@transducer/init'] = _xfBase.init;\n        XFindIndex.prototype['@@transducer/result'] = function (result) {\n            if (!this.found) {\n                result = this.xf['@@transducer/step'](result, -1);\n            }\n            return this.xf['@@transducer/result'](result);\n        };\n        XFindIndex.prototype['@@transducer/step'] = function (result, input) {\n            this.idx += 1;\n            if (this.f(input)) {\n                this.found = true;\n                result = _reduced(this.xf['@@transducer/step'](result, this.idx));\n            }\n            return result;\n        };\n        return _curry2(function _xfindIndex(f, xf) {\n            return new XFindIndex(f, xf);\n        });\n    }();\n\n    var _xfindLast = function () {\n        function XFindLast(f, xf) {\n            this.xf = xf;\n            this.f = f;\n        }\n        XFindLast.prototype['@@transducer/init'] = _xfBase.init;\n        XFindLast.prototype['@@transducer/result'] = function (result) {\n            return this.xf['@@transducer/result'](this.xf['@@transducer/step'](result, this.last));\n        };\n        XFindLast.prototype['@@transducer/step'] = function (result, input) {\n            if (this.f(input)) {\n                this.last = input;\n            }\n            return result;\n        };\n        return _curry2(function _xfindLast(f, xf) {\n            return new XFindLast(f, xf);\n        });\n    }();\n\n    var _xfindLastIndex = function () {\n        function XFindLastIndex(f, xf) {\n            this.xf = xf;\n            this.f = f;\n            this.idx = -1;\n            this.lastIdx = -1;\n        }\n        XFindLastIndex.prototype['@@transducer/init'] = _xfBase.init;\n        XFindLastIndex.prototype['@@transducer/result'] = function (result) {\n            return this.xf['@@transducer/result'](this.xf['@@transducer/step'](result, this.lastIdx));\n        };\n        XFindLastIndex.prototype['@@transducer/step'] = function (result, input) {\n            this.idx += 1;\n            if (this.f(input)) {\n                this.lastIdx = this.idx;\n            }\n            return result;\n        };\n        return _curry2(function _xfindLastIndex(f, xf) {\n            return new XFindLastIndex(f, xf);\n        });\n    }();\n\n    var _xmap = function () {\n        function XMap(f, xf) {\n            this.xf = xf;\n            this.f = f;\n        }\n        XMap.prototype['@@transducer/init'] = _xfBase.init;\n        XMap.prototype['@@transducer/result'] = _xfBase.result;\n        XMap.prototype['@@transducer/step'] = function (result, input) {\n            return this.xf['@@transducer/step'](result, this.f(input));\n        };\n        return _curry2(function _xmap(f, xf) {\n            return new XMap(f, xf);\n        });\n    }();\n\n    var _xtake = function () {\n        function XTake(n, xf) {\n            this.xf = xf;\n            this.n = n;\n        }\n        XTake.prototype['@@transducer/init'] = _xfBase.init;\n        XTake.prototype['@@transducer/result'] = _xfBase.result;\n        XTake.prototype['@@transducer/step'] = function (result, input) {\n            if (this.n === 0) {\n                return _reduced(result);\n            } else {\n                this.n -= 1;\n                return this.xf['@@transducer/step'](result, input);\n            }\n        };\n        return _curry2(function _xtake(n, xf) {\n            return new XTake(n, xf);\n        });\n    }();\n\n    var _xtakeWhile = function () {\n        function XTakeWhile(f, xf) {\n            this.xf = xf;\n            this.f = f;\n        }\n        XTakeWhile.prototype['@@transducer/init'] = _xfBase.init;\n        XTakeWhile.prototype['@@transducer/result'] = _xfBase.result;\n        XTakeWhile.prototype['@@transducer/step'] = function (result, input) {\n            return this.f(input) ? this.xf['@@transducer/step'](result, input) : _reduced(result);\n        };\n        return _curry2(function _xtakeWhile(f, xf) {\n            return new XTakeWhile(f, xf);\n        });\n    }();\n\n    /**\n     * Adds two numbers. Equivalent to `a + b` but curried.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.1.0\n     * @category Math\n     * @sig Number -> Number -> Number\n     * @param {Number} a\n     * @param {Number} b\n     * @return {Number}\n     * @see R.subtract\n     * @example\n     *\n     *      R.add(2, 3);       //=>  5\n     *      R.add(7)(10);      //=> 17\n     */\n    var add = _curry2(function add(a, b) {\n        return a + b;\n    });\n\n    /**\n     * Applies a function to the value at the given index of an array, returning a\n     * new copy of the array with the element at the given index replaced with the\n     * result of the function application.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.14.0\n     * @category List\n     * @sig (a -> a) -> Number -> [a] -> [a]\n     * @param {Function} fn The function to apply.\n     * @param {Number} idx The index.\n     * @param {Array|Arguments} list An array-like object whose value\n     *        at the supplied index will be replaced.\n     * @return {Array} A copy of the supplied array-like object with\n     *         the element at index `idx` replaced with the value\n     *         returned by applying `fn` to the existing element.\n     * @see R.update\n     * @example\n     *\n     *      R.adjust(R.add(10), 1, [0, 1, 2]);     //=> [0, 11, 2]\n     *      R.adjust(R.add(10))(1)([0, 1, 2]);     //=> [0, 11, 2]\n     */\n    var adjust = _curry3(function adjust(fn, idx, list) {\n        if (idx >= list.length || idx < -list.length) {\n            return list;\n        }\n        var start = idx < 0 ? list.length : 0;\n        var _idx = start + idx;\n        var _list = _concat(list);\n        _list[_idx] = fn(list[_idx]);\n        return _list;\n    });\n\n    /**\n     * Returns `true` if all elements of the list match the predicate, `false` if\n     * there are any that don't.\n     *\n     * Dispatches to the `all` method of the second argument, if present.\n     *\n     * Acts as a transducer if a transformer is given in list position.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.1.0\n     * @category List\n     * @sig (a -> Boolean) -> [a] -> Boolean\n     * @param {Function} fn The predicate function.\n     * @param {Array} list The array to consider.\n     * @return {Boolean} `true` if the predicate is satisfied by every element, `false`\n     *         otherwise.\n     * @see R.any, R.none, R.transduce\n     * @example\n     *\n     *      var lessThan2 = R.flip(R.lt)(2);\n     *      var lessThan3 = R.flip(R.lt)(3);\n     *      R.all(lessThan2)([1, 2]); //=> false\n     *      R.all(lessThan3)([1, 2]); //=> true\n     */\n    var all = _curry2(_dispatchable('all', _xall, function all(fn, list) {\n        var idx = 0;\n        while (idx < list.length) {\n            if (!fn(list[idx])) {\n                return false;\n            }\n            idx += 1;\n        }\n        return true;\n    }));\n\n    /**\n     * Returns a function that always returns the given value. Note that for\n     * non-primitives the value returned is a reference to the original value.\n     *\n     * This function is known as `const`, `constant`, or `K` (for K combinator) in\n     * other languages and libraries.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.1.0\n     * @category Function\n     * @sig a -> (* -> a)\n     * @param {*} val The value to wrap in a function\n     * @return {Function} A Function :: * -> val.\n     * @example\n     *\n     *      var t = R.always('Tee');\n     *      t(); //=> 'Tee'\n     */\n    var always = _curry1(function always(val) {\n        return function () {\n            return val;\n        };\n    });\n\n    /**\n     * Returns `true` if both arguments are `true`; `false` otherwise.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.1.0\n     * @category Logic\n     * @sig * -> * -> *\n     * @param {Boolean} a A boolean value\n     * @param {Boolean} b A boolean value\n     * @return {Boolean} `true` if both arguments are `true`, `false` otherwise\n     * @see R.both\n     * @example\n     *\n     *      R.and(true, true); //=> true\n     *      R.and(true, false); //=> false\n     *      R.and(false, true); //=> false\n     *      R.and(false, false); //=> false\n     */\n    var and = _curry2(function and(a, b) {\n        return a && b;\n    });\n\n    /**\n     * Returns `true` if at least one of elements of the list match the predicate,\n     * `false` otherwise.\n     *\n     * Dispatches to the `any` method of the second argument, if present.\n     *\n     * Acts as a transducer if a transformer is given in list position.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.1.0\n     * @category List\n     * @sig (a -> Boolean) -> [a] -> Boolean\n     * @param {Function} fn The predicate function.\n     * @param {Array} list The array to consider.\n     * @return {Boolean} `true` if the predicate is satisfied by at least one element, `false`\n     *         otherwise.\n     * @see R.all, R.none, R.transduce\n     * @example\n     *\n     *      var lessThan0 = R.flip(R.lt)(0);\n     *      var lessThan2 = R.flip(R.lt)(2);\n     *      R.any(lessThan0)([1, 2]); //=> false\n     *      R.any(lessThan2)([1, 2]); //=> true\n     */\n    var any = _curry2(_dispatchable('any', _xany, function any(fn, list) {\n        var idx = 0;\n        while (idx < list.length) {\n            if (fn(list[idx])) {\n                return true;\n            }\n            idx += 1;\n        }\n        return false;\n    }));\n\n    /**\n     * Returns a new list, composed of n-tuples of consecutive elements If `n` is\n     * greater than the length of the list, an empty list is returned.\n     *\n     * Dispatches to the `aperture` method of the second argument, if present.\n     *\n     * Acts as a transducer if a transformer is given in list position.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.12.0\n     * @category List\n     * @sig Number -> [a] -> [[a]]\n     * @param {Number} n The size of the tuples to create\n     * @param {Array} list The list to split into `n`-tuples\n     * @return {Array} The new list.\n     * @see R.transduce\n     * @example\n     *\n     *      R.aperture(2, [1, 2, 3, 4, 5]); //=> [[1, 2], [2, 3], [3, 4], [4, 5]]\n     *      R.aperture(3, [1, 2, 3, 4, 5]); //=> [[1, 2, 3], [2, 3, 4], [3, 4, 5]]\n     *      R.aperture(7, [1, 2, 3, 4, 5]); //=> []\n     */\n    var aperture = _curry2(_dispatchable('aperture', _xaperture, _aperture));\n\n    /**\n     * Returns a new list containing the contents of the given list, followed by\n     * the given element.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.1.0\n     * @category List\n     * @sig a -> [a] -> [a]\n     * @param {*} el The element to add to the end of the new list.\n     * @param {Array} list The list whose contents will be added to the beginning of the output\n     *        list.\n     * @return {Array} A new list containing the contents of the old list followed by `el`.\n     * @see R.prepend\n     * @example\n     *\n     *      R.append('tests', ['write', 'more']); //=> ['write', 'more', 'tests']\n     *      R.append('tests', []); //=> ['tests']\n     *      R.append(['tests'], ['write', 'more']); //=> ['write', 'more', ['tests']]\n     */\n    var append = _curry2(function append(el, list) {\n        return _concat(list, [el]);\n    });\n\n    /**\n     * Applies function `fn` to the argument list `args`. This is useful for\n     * creating a fixed-arity function from a variadic function. `fn` should be a\n     * bound function if context is significant.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.7.0\n     * @category Function\n     * @sig (*... -> a) -> [*] -> a\n     * @param {Function} fn\n     * @param {Array} args\n     * @return {*}\n     * @see R.call, R.unapply\n     * @example\n     *\n     *      var nums = [1, 2, 3, -99, 42, 6, 7];\n     *      R.apply(Math.max, nums); //=> 42\n     */\n    var apply = _curry2(function apply(fn, args) {\n        return fn.apply(this, args);\n    });\n\n    /**\n     * Makes a shallow clone of an object, setting or overriding the specified\n     * property with the given value. Note that this copies and flattens prototype\n     * properties onto the new object as well. All non-primitive properties are\n     * copied by reference.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.8.0\n     * @category Object\n     * @sig String -> a -> {k: v} -> {k: v}\n     * @param {String} prop the property name to set\n     * @param {*} val the new value\n     * @param {Object} obj the object to clone\n     * @return {Object} a new object similar to the original except for the specified property.\n     * @see R.dissoc\n     * @example\n     *\n     *      R.assoc('c', 3, {a: 1, b: 2}); //=> {a: 1, b: 2, c: 3}\n     */\n    var assoc = _curry3(function assoc(prop, val, obj) {\n        var result = {};\n        for (var p in obj) {\n            result[p] = obj[p];\n        }\n        result[prop] = val;\n        return result;\n    });\n\n    /**\n     * Makes a shallow clone of an object, setting or overriding the nodes required\n     * to create the given path, and placing the specific value at the tail end of\n     * that path. Note that this copies and flattens prototype properties onto the\n     * new object as well. All non-primitive properties are copied by reference.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.8.0\n     * @category Object\n     * @sig [String] -> a -> {k: v} -> {k: v}\n     * @param {Array} path the path to set\n     * @param {*} val the new value\n     * @param {Object} obj the object to clone\n     * @return {Object} a new object similar to the original except along the specified path.\n     * @see R.dissocPath\n     * @example\n     *\n     *      R.assocPath(['a', 'b', 'c'], 42, {a: {b: {c: 0}}}); //=> {a: {b: {c: 42}}}\n     */\n    var assocPath = _curry3(function assocPath(path, val, obj) {\n        switch (path.length) {\n        case 0:\n            return val;\n        case 1:\n            return assoc(path[0], val, obj);\n        default:\n            return assoc(path[0], assocPath(_slice(path, 1), val, Object(obj[path[0]])), obj);\n        }\n    });\n\n    /**\n     * Creates a function that is bound to a context.\n     * Note: `R.bind` does not provide the additional argument-binding capabilities of\n     * [Function.prototype.bind](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/bind).\n     *\n     * @func\n     * @memberOf R\n     * @since v0.6.0\n     * @category Function\n     * @category Object\n     * @sig (* -> *) -> {*} -> (* -> *)\n     * @param {Function} fn The function to bind to context\n     * @param {Object} thisObj The context to bind `fn` to\n     * @return {Function} A function that will execute in the context of `thisObj`.\n     * @see R.partial\n     */\n    var bind = _curry2(function bind(fn, thisObj) {\n        return _arity(fn.length, function () {\n            return fn.apply(thisObj, arguments);\n        });\n    });\n\n    /**\n     * A function wrapping calls to the two functions in an `&&` operation,\n     * returning the result of the first function if it is false-y and the result\n     * of the second function otherwise. Note that this is short-circuited,\n     * meaning that the second function will not be invoked if the first returns a\n     * false-y value.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.12.0\n     * @category Logic\n     * @sig (*... -> Boolean) -> (*... -> Boolean) -> (*... -> Boolean)\n     * @param {Function} f a predicate\n     * @param {Function} g another predicate\n     * @return {Function} a function that applies its arguments to `f` and `g` and `&&`s their outputs together.\n     * @see R.and\n     * @example\n     *\n     *      var gt10 = x => x > 10;\n     *      var even = x => x % 2 === 0;\n     *      var f = R.both(gt10, even);\n     *      f(100); //=> true\n     *      f(101); //=> false\n     */\n    var both = _curry2(function both(f, g) {\n        return function _both() {\n            return f.apply(this, arguments) && g.apply(this, arguments);\n        };\n    });\n\n    /**\n     * Makes a comparator function out of a function that reports whether the first\n     * element is less than the second.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.1.0\n     * @category Function\n     * @sig (a, b -> Boolean) -> (a, b -> Number)\n     * @param {Function} pred A predicate function of arity two.\n     * @return {Function} A Function :: a -> b -> Int that returns `-1` if a < b, `1` if b < a, otherwise `0`.\n     * @example\n     *\n     *      var cmp = R.comparator((a, b) => a.age < b.age);\n     *      var people = [\n     *        // ...\n     *      ];\n     *      R.sort(cmp, people);\n     */\n    var comparator = _curry1(function comparator(pred) {\n        return function (a, b) {\n            return pred(a, b) ? -1 : pred(b, a) ? 1 : 0;\n        };\n    });\n\n    /**\n     * Returns a function, `fn`, which encapsulates if/else-if/else logic.\n     * `R.cond` takes a list of [predicate, transform] pairs. All of the arguments\n     * to `fn` are applied to each of the predicates in turn until one returns a\n     * \"truthy\" value, at which point `fn` returns the result of applying its\n     * arguments to the corresponding transformer. If none of the predicates\n     * matches, `fn` returns undefined.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.6.0\n     * @category Logic\n     * @sig [[(*... -> Boolean),(*... -> *)]] -> (*... -> *)\n     * @param {Array} pairs\n     * @return {Function}\n     * @example\n     *\n     *      var fn = R.cond([\n     *        [R.equals(0),   R.always('water freezes at 0°C')],\n     *        [R.equals(100), R.always('water boils at 100°C')],\n     *        [R.T,           temp => 'nothing special happens at ' + temp + '°C']\n     *      ]);\n     *      fn(0); //=> 'water freezes at 0°C'\n     *      fn(50); //=> 'nothing special happens at 50°C'\n     *      fn(100); //=> 'water boils at 100°C'\n     */\n    var cond = _curry1(function cond(pairs) {\n        return function () {\n            var idx = 0;\n            while (idx < pairs.length) {\n                if (pairs[idx][0].apply(this, arguments)) {\n                    return pairs[idx][1].apply(this, arguments);\n                }\n                idx += 1;\n            }\n        };\n    });\n\n    /**\n     * Counts the elements of a list according to how many match each value of a\n     * key generated by the supplied function. Returns an object mapping the keys\n     * produced by `fn` to the number of occurrences in the list. Note that all\n     * keys are coerced to strings because of how JavaScript objects work.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.1.0\n     * @category Relation\n     * @sig (a -> String) -> [a] -> {*}\n     * @param {Function} fn The function used to map values to keys.\n     * @param {Array} list The list to count elements from.\n     * @return {Object} An object mapping keys to number of occurrences in the list.\n     * @example\n     *\n     *      var numbers = [1.0, 1.1, 1.2, 2.0, 3.0, 2.2];\n     *      var letters = R.split('', 'abcABCaaaBBc');\n     *      R.countBy(Math.floor)(numbers);    //=> {'1': 3, '2': 2, '3': 1}\n     *      R.countBy(R.toLower)(letters);   //=> {'a': 5, 'b': 4, 'c': 3}\n     */\n    var countBy = _curry2(function countBy(fn, list) {\n        var counts = {};\n        var len = list.length;\n        var idx = 0;\n        while (idx < len) {\n            var key = fn(list[idx]);\n            counts[key] = (_has(key, counts) ? counts[key] : 0) + 1;\n            idx += 1;\n        }\n        return counts;\n    });\n\n    /**\n     * Returns a curried equivalent of the provided function, with the specified\n     * arity. The curried function has two unusual capabilities. First, its\n     * arguments needn't be provided one at a time. If `g` is `R.curryN(3, f)`, the\n     * following are equivalent:\n     *\n     *   - `g(1)(2)(3)`\n     *   - `g(1)(2, 3)`\n     *   - `g(1, 2)(3)`\n     *   - `g(1, 2, 3)`\n     *\n     * Secondly, the special placeholder value `R.__` may be used to specify\n     * \"gaps\", allowing partial application of any combination of arguments,\n     * regardless of their positions. If `g` is as above and `_` is `R.__`, the\n     * following are equivalent:\n     *\n     *   - `g(1, 2, 3)`\n     *   - `g(_, 2, 3)(1)`\n     *   - `g(_, _, 3)(1)(2)`\n     *   - `g(_, _, 3)(1, 2)`\n     *   - `g(_, 2)(1)(3)`\n     *   - `g(_, 2)(1, 3)`\n     *   - `g(_, 2)(_, 3)(1)`\n     *\n     * @func\n     * @memberOf R\n     * @since v0.5.0\n     * @category Function\n     * @sig Number -> (* -> a) -> (* -> a)\n     * @param {Number} length The arity for the returned function.\n     * @param {Function} fn The function to curry.\n     * @return {Function} A new, curried function.\n     * @see R.curry\n     * @example\n     *\n     *      var sumArgs = (...args) => R.sum(args);\n     *\n     *      var curriedAddFourNumbers = R.curryN(4, sumArgs);\n     *      var f = curriedAddFourNumbers(1, 2);\n     *      var g = f(3);\n     *      g(4); //=> 10\n     */\n    var curryN = _curry2(function curryN(length, fn) {\n        if (length === 1) {\n            return _curry1(fn);\n        }\n        return _arity(length, _curryN(length, [], fn));\n    });\n\n    /**\n     * Decrements its argument.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.9.0\n     * @category Math\n     * @sig Number -> Number\n     * @param {Number} n\n     * @return {Number}\n     * @see R.inc\n     * @example\n     *\n     *      R.dec(42); //=> 41\n     */\n    var dec = add(-1);\n\n    /**\n     * Returns the second argument if it is not `null`, `undefined` or `NaN`\n     * otherwise the first argument is returned.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.10.0\n     * @category Logic\n     * @sig a -> b -> a | b\n     * @param {a} val The default value.\n     * @param {b} val The value to return if it is not null or undefined\n     * @return {*} The the second value or the default value\n     * @example\n     *\n     *      var defaultTo42 = R.defaultTo(42);\n     *\n     *      defaultTo42(null);  //=> 42\n     *      defaultTo42(undefined);  //=> 42\n     *      defaultTo42('Ramda');  //=> 'Ramda'\n     *      defaultTo42(parseInt('string')); //=> 42\n     */\n    var defaultTo = _curry2(function defaultTo(d, v) {\n        return v == null || v !== v ? d : v;\n    });\n\n    /**\n     * Finds the set (i.e. no duplicates) of all elements in the first list not\n     * contained in the second list. Duplication is determined according to the\n     * value returned by applying the supplied predicate to two list elements.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.1.0\n     * @category Relation\n     * @sig (a -> a -> Boolean) -> [*] -> [*] -> [*]\n     * @param {Function} pred A predicate used to test whether two items are equal.\n     * @param {Array} list1 The first list.\n     * @param {Array} list2 The second list.\n     * @return {Array} The elements in `list1` that are not in `list2`.\n     * @see R.difference\n     * @example\n     *\n     *      function cmp(x, y) => x.a === y.a;\n     *      var l1 = [{a: 1}, {a: 2}, {a: 3}];\n     *      var l2 = [{a: 3}, {a: 4}];\n     *      R.differenceWith(cmp, l1, l2); //=> [{a: 1}, {a: 2}]\n     */\n    var differenceWith = _curry3(function differenceWith(pred, first, second) {\n        var out = [];\n        var idx = 0;\n        var firstLen = first.length;\n        while (idx < firstLen) {\n            if (!_containsWith(pred, first[idx], second) && !_containsWith(pred, first[idx], out)) {\n                out.push(first[idx]);\n            }\n            idx += 1;\n        }\n        return out;\n    });\n\n    /**\n     * Returns a new object that does not contain a `prop` property.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.10.0\n     * @category Object\n     * @sig String -> {k: v} -> {k: v}\n     * @param {String} prop the name of the property to dissociate\n     * @param {Object} obj the object to clone\n     * @return {Object} a new object similar to the original but without the specified property\n     * @see R.assoc\n     * @example\n     *\n     *      R.dissoc('b', {a: 1, b: 2, c: 3}); //=> {a: 1, c: 3}\n     */\n    var dissoc = _curry2(function dissoc(prop, obj) {\n        var result = {};\n        for (var p in obj) {\n            if (p !== prop) {\n                result[p] = obj[p];\n            }\n        }\n        return result;\n    });\n\n    /**\n     * Makes a shallow clone of an object, omitting the property at the given path.\n     * Note that this copies and flattens prototype properties onto the new object\n     * as well. All non-primitive properties are copied by reference.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.11.0\n     * @category Object\n     * @sig [String] -> {k: v} -> {k: v}\n     * @param {Array} path the path to set\n     * @param {Object} obj the object to clone\n     * @return {Object} a new object without the property at path\n     * @see R.assocPath\n     * @example\n     *\n     *      R.dissocPath(['a', 'b', 'c'], {a: {b: {c: 42}}}); //=> {a: {b: {}}}\n     */\n    var dissocPath = _curry2(function dissocPath(path, obj) {\n        switch (path.length) {\n        case 0:\n            return obj;\n        case 1:\n            return dissoc(path[0], obj);\n        default:\n            var head = path[0];\n            var tail = _slice(path, 1);\n            return obj[head] == null ? obj : assoc(head, dissocPath(tail, obj[head]), obj);\n        }\n    });\n\n    /**\n     * Divides two numbers. Equivalent to `a / b`.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.1.0\n     * @category Math\n     * @sig Number -> Number -> Number\n     * @param {Number} a The first value.\n     * @param {Number} b The second value.\n     * @return {Number} The result of `a / b`.\n     * @see R.multiply\n     * @example\n     *\n     *      R.divide(71, 100); //=> 0.71\n     *\n     *      var half = R.divide(R.__, 2);\n     *      half(42); //=> 21\n     *\n     *      var reciprocal = R.divide(1);\n     *      reciprocal(4);   //=> 0.25\n     */\n    var divide = _curry2(function divide(a, b) {\n        return a / b;\n    });\n\n    /**\n     * Returns a new list containing the last `n` elements of a given list, passing\n     * each value to the supplied predicate function, skipping elements while the\n     * predicate function returns `true`. The predicate function is passed one\n     * argument: *(value)*.\n     *\n     * Dispatches to the `dropWhile` method of the second argument, if present.\n     *\n     * Acts as a transducer if a transformer is given in list position.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.9.0\n     * @category List\n     * @sig (a -> Boolean) -> [a] -> [a]\n     * @param {Function} fn The function called per iteration.\n     * @param {Array} list The collection to iterate over.\n     * @return {Array} A new array.\n     * @see R.takeWhile, R.transduce, R.addIndex\n     * @example\n     *\n     *      var lteTwo = x => x <= 2;\n     *\n     *      R.dropWhile(lteTwo, [1, 2, 3, 4, 3, 2, 1]); //=> [3, 4, 3, 2, 1]\n     */\n    var dropWhile = _curry2(_dispatchable('dropWhile', _xdropWhile, function dropWhile(pred, list) {\n        var idx = 0;\n        var len = list.length;\n        while (idx < len && pred(list[idx])) {\n            idx += 1;\n        }\n        return _slice(list, idx);\n    }));\n\n    /**\n     * A function wrapping calls to the two functions in an `||` operation,\n     * returning the result of the first function if it is truth-y and the result\n     * of the second function otherwise. Note that this is short-circuited,\n     * meaning that the second function will not be invoked if the first returns a\n     * truth-y value.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.12.0\n     * @category Logic\n     * @sig (*... -> Boolean) -> (*... -> Boolean) -> (*... -> Boolean)\n     * @param {Function} f a predicate\n     * @param {Function} g another predicate\n     * @return {Function} a function that applies its arguments to `f` and `g` and `||`s their outputs together.\n     * @see R.or\n     * @example\n     *\n     *      var gt10 = x => x > 10;\n     *      var even = x => x % 2 === 0;\n     *      var f = R.either(gt10, even);\n     *      f(101); //=> true\n     *      f(8); //=> true\n     */\n    var either = _curry2(function either(f, g) {\n        return function _either() {\n            return f.apply(this, arguments) || g.apply(this, arguments);\n        };\n    });\n\n    /**\n     * Returns the empty value of its argument's type. Ramda defines the empty\n     * value of Array (`[]`), Object (`{}`), String (`''`), and Arguments. Other\n     * types are supported if they define `<Type>.empty` and/or\n     * `<Type>.prototype.empty`.\n     *\n     * Dispatches to the `empty` method of the first argument, if present.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.3.0\n     * @category Function\n     * @sig a -> a\n     * @param {*} x\n     * @return {*}\n     * @example\n     *\n     *      R.empty(Just(42));      //=> Nothing()\n     *      R.empty([1, 2, 3]);     //=> []\n     *      R.empty('unicorns');    //=> ''\n     *      R.empty({x: 1, y: 2});  //=> {}\n     */\n    // else\n    var empty = _curry1(function empty(x) {\n        return x != null && typeof x.empty === 'function' ? x.empty() : x != null && x.constructor != null && typeof x.constructor.empty === 'function' ? x.constructor.empty() : _isArray(x) ? [] : _isString(x) ? '' : _isObject(x) ? {} : _isArguments(x) ? function () {\n            return arguments;\n        }() : // else\n        void 0;\n    });\n\n    /**\n     * Creates a new object by recursively evolving a shallow copy of `object`,\n     * according to the `transformation` functions. All non-primitive properties\n     * are copied by reference.\n     *\n     * A `transformation` function will not be invoked if its corresponding key\n     * does not exist in the evolved object.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.9.0\n     * @category Object\n     * @sig {k: (v -> v)} -> {k: v} -> {k: v}\n     * @param {Object} transformations The object specifying transformation functions to apply\n     *        to the object.\n     * @param {Object} object The object to be transformed.\n     * @return {Object} The transformed object.\n     * @example\n     *\n     *      var tomato  = {firstName: '  Tomato ', data: {elapsed: 100, remaining: 1400}, id:123};\n     *      var transformations = {\n     *        firstName: R.trim,\n     *        lastName: R.trim, // Will not get invoked.\n     *        data: {elapsed: R.add(1), remaining: R.add(-1)}\n     *      };\n     *      R.evolve(transformations, tomato); //=> {firstName: 'Tomato', data: {elapsed: 101, remaining: 1399}, id:123}\n     */\n    var evolve = _curry2(function evolve(transformations, object) {\n        var result = {};\n        var transformation, key, type;\n        for (key in object) {\n            transformation = transformations[key];\n            type = typeof transformation;\n            result[key] = type === 'function' ? transformation(object[key]) : type === 'object' ? evolve(transformations[key], object[key]) : object[key];\n        }\n        return result;\n    });\n\n    /**\n     * Returns the first element of the list which matches the predicate, or\n     * `undefined` if no element matches.\n     *\n     * Dispatches to the `find` method of the second argument, if present.\n     *\n     * Acts as a transducer if a transformer is given in list position.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.1.0\n     * @category List\n     * @sig (a -> Boolean) -> [a] -> a | undefined\n     * @param {Function} fn The predicate function used to determine if the element is the\n     *        desired one.\n     * @param {Array} list The array to consider.\n     * @return {Object} The element found, or `undefined`.\n     * @see R.transduce\n     * @example\n     *\n     *      var xs = [{a: 1}, {a: 2}, {a: 3}];\n     *      R.find(R.propEq('a', 2))(xs); //=> {a: 2}\n     *      R.find(R.propEq('a', 4))(xs); //=> undefined\n     */\n    var find = _curry2(_dispatchable('find', _xfind, function find(fn, list) {\n        var idx = 0;\n        var len = list.length;\n        while (idx < len) {\n            if (fn(list[idx])) {\n                return list[idx];\n            }\n            idx += 1;\n        }\n    }));\n\n    /**\n     * Returns the index of the first element of the list which matches the\n     * predicate, or `-1` if no element matches.\n     *\n     * Dispatches to the `findIndex` method of the second argument, if present.\n     *\n     * Acts as a transducer if a transformer is given in list position.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.1.1\n     * @category List\n     * @sig (a -> Boolean) -> [a] -> Number\n     * @param {Function} fn The predicate function used to determine if the element is the\n     * desired one.\n     * @param {Array} list The array to consider.\n     * @return {Number} The index of the element found, or `-1`.\n     * @see R.transduce\n     * @example\n     *\n     *      var xs = [{a: 1}, {a: 2}, {a: 3}];\n     *      R.findIndex(R.propEq('a', 2))(xs); //=> 1\n     *      R.findIndex(R.propEq('a', 4))(xs); //=> -1\n     */\n    var findIndex = _curry2(_dispatchable('findIndex', _xfindIndex, function findIndex(fn, list) {\n        var idx = 0;\n        var len = list.length;\n        while (idx < len) {\n            if (fn(list[idx])) {\n                return idx;\n            }\n            idx += 1;\n        }\n        return -1;\n    }));\n\n    /**\n     * Returns the last element of the list which matches the predicate, or\n     * `undefined` if no element matches.\n     *\n     * Dispatches to the `findLast` method of the second argument, if present.\n     *\n     * Acts as a transducer if a transformer is given in list position.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.1.1\n     * @category List\n     * @sig (a -> Boolean) -> [a] -> a | undefined\n     * @param {Function} fn The predicate function used to determine if the element is the\n     * desired one.\n     * @param {Array} list The array to consider.\n     * @return {Object} The element found, or `undefined`.\n     * @see R.transduce\n     * @example\n     *\n     *      var xs = [{a: 1, b: 0}, {a:1, b: 1}];\n     *      R.findLast(R.propEq('a', 1))(xs); //=> {a: 1, b: 1}\n     *      R.findLast(R.propEq('a', 4))(xs); //=> undefined\n     */\n    var findLast = _curry2(_dispatchable('findLast', _xfindLast, function findLast(fn, list) {\n        var idx = list.length - 1;\n        while (idx >= 0) {\n            if (fn(list[idx])) {\n                return list[idx];\n            }\n            idx -= 1;\n        }\n    }));\n\n    /**\n     * Returns the index of the last element of the list which matches the\n     * predicate, or `-1` if no element matches.\n     *\n     * Dispatches to the `findLastIndex` method of the second argument, if present.\n     *\n     * Acts as a transducer if a transformer is given in list position.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.1.1\n     * @category List\n     * @sig (a -> Boolean) -> [a] -> Number\n     * @param {Function} fn The predicate function used to determine if the element is the\n     * desired one.\n     * @param {Array} list The array to consider.\n     * @return {Number} The index of the element found, or `-1`.\n     * @see R.transduce\n     * @example\n     *\n     *      var xs = [{a: 1, b: 0}, {a:1, b: 1}];\n     *      R.findLastIndex(R.propEq('a', 1))(xs); //=> 1\n     *      R.findLastIndex(R.propEq('a', 4))(xs); //=> -1\n     */\n    var findLastIndex = _curry2(_dispatchable('findLastIndex', _xfindLastIndex, function findLastIndex(fn, list) {\n        var idx = list.length - 1;\n        while (idx >= 0) {\n            if (fn(list[idx])) {\n                return idx;\n            }\n            idx -= 1;\n        }\n        return -1;\n    }));\n\n    /**\n     * Iterate over an input `list`, calling a provided function `fn` for each\n     * element in the list.\n     *\n     * `fn` receives one argument: *(value)*.\n     *\n     * Note: `R.forEach` does not skip deleted or unassigned indices (sparse\n     * arrays), unlike the native `Array.prototype.forEach` method. For more\n     * details on this behavior, see:\n     * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach#Description\n     *\n     * Also note that, unlike `Array.prototype.forEach`, Ramda's `forEach` returns\n     * the original array. In some libraries this function is named `each`.\n     *\n     * Dispatches to the `forEach` method of the second argument, if present.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.1.1\n     * @category List\n     * @sig (a -> *) -> [a] -> [a]\n     * @param {Function} fn The function to invoke. Receives one argument, `value`.\n     * @param {Array} list The list to iterate over.\n     * @return {Array} The original list.\n     * @see R.addIndex\n     * @example\n     *\n     *      var printXPlusFive = x => console.log(x + 5);\n     *      R.forEach(printXPlusFive, [1, 2, 3]); //=> [1, 2, 3]\n     *      //-> 6\n     *      //-> 7\n     *      //-> 8\n     */\n    var forEach = _curry2(_checkForMethod('forEach', function forEach(fn, list) {\n        var len = list.length;\n        var idx = 0;\n        while (idx < len) {\n            fn(list[idx]);\n            idx += 1;\n        }\n        return list;\n    }));\n\n    /**\n     * Creates a new object out of a list key-value pairs.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.3.0\n     * @category List\n     * @sig [[k,v]] -> {k: v}\n     * @param {Array} pairs An array of two-element arrays that will be the keys and values of the output object.\n     * @return {Object} The object made by pairing up `keys` and `values`.\n     * @see R.toPairs, R.pair\n     * @example\n     *\n     *      R.fromPairs([['a', 1], ['b', 2],  ['c', 3]]); //=> {a: 1, b: 2, c: 3}\n     */\n    var fromPairs = _curry1(function fromPairs(pairs) {\n        var idx = 0;\n        var len = pairs.length;\n        var out = {};\n        while (idx < len) {\n            if (_isArray(pairs[idx]) && pairs[idx].length) {\n                out[pairs[idx][0]] = pairs[idx][1];\n            }\n            idx += 1;\n        }\n        return out;\n    });\n\n    /**\n     * Returns `true` if the first argument is greater than the second; `false`\n     * otherwise.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.1.0\n     * @category Relation\n     * @sig Ord a => a -> a -> Boolean\n     * @param {*} a\n     * @param {*} b\n     * @return {Boolean}\n     * @see R.lt\n     * @example\n     *\n     *      R.gt(2, 1); //=> true\n     *      R.gt(2, 2); //=> false\n     *      R.gt(2, 3); //=> false\n     *      R.gt('a', 'z'); //=> false\n     *      R.gt('z', 'a'); //=> true\n     */\n    var gt = _curry2(function gt(a, b) {\n        return a > b;\n    });\n\n    /**\n     * Returns `true` if the first argument is greater than or equal to the second;\n     * `false` otherwise.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.1.0\n     * @category Relation\n     * @sig Ord a => a -> a -> Boolean\n     * @param {Number} a\n     * @param {Number} b\n     * @return {Boolean}\n     * @see R.lte\n     * @example\n     *\n     *      R.gte(2, 1); //=> true\n     *      R.gte(2, 2); //=> true\n     *      R.gte(2, 3); //=> false\n     *      R.gte('a', 'z'); //=> false\n     *      R.gte('z', 'a'); //=> true\n     */\n    var gte = _curry2(function gte(a, b) {\n        return a >= b;\n    });\n\n    /**\n     * Returns whether or not an object has an own property with the specified name\n     *\n     * @func\n     * @memberOf R\n     * @since v0.7.0\n     * @category Object\n     * @sig s -> {s: x} -> Boolean\n     * @param {String} prop The name of the property to check for.\n     * @param {Object} obj The object to query.\n     * @return {Boolean} Whether the property exists.\n     * @example\n     *\n     *      var hasName = R.has('name');\n     *      hasName({name: 'alice'});   //=> true\n     *      hasName({name: 'bob'});     //=> true\n     *      hasName({});                //=> false\n     *\n     *      var point = {x: 0, y: 0};\n     *      var pointHas = R.has(R.__, point);\n     *      pointHas('x');  //=> true\n     *      pointHas('y');  //=> true\n     *      pointHas('z');  //=> false\n     */\n    var has = _curry2(_has);\n\n    /**\n     * Returns whether or not an object or its prototype chain has a property with\n     * the specified name\n     *\n     * @func\n     * @memberOf R\n     * @since v0.7.0\n     * @category Object\n     * @sig s -> {s: x} -> Boolean\n     * @param {String} prop The name of the property to check for.\n     * @param {Object} obj The object to query.\n     * @return {Boolean} Whether the property exists.\n     * @example\n     *\n     *      function Rectangle(width, height) {\n     *        this.width = width;\n     *        this.height = height;\n     *      }\n     *      Rectangle.prototype.area = function() {\n     *        return this.width * this.height;\n     *      };\n     *\n     *      var square = new Rectangle(2, 2);\n     *      R.hasIn('width', square);  //=> true\n     *      R.hasIn('area', square);  //=> true\n     */\n    var hasIn = _curry2(function hasIn(prop, obj) {\n        return prop in obj;\n    });\n\n    /**\n     * Returns true if its arguments are identical, false otherwise. Values are\n     * identical if they reference the same memory. `NaN` is identical to `NaN`;\n     * `0` and `-0` are not identical.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.15.0\n     * @category Relation\n     * @sig a -> a -> Boolean\n     * @param {*} a\n     * @param {*} b\n     * @return {Boolean}\n     * @example\n     *\n     *      var o = {};\n     *      R.identical(o, o); //=> true\n     *      R.identical(1, 1); //=> true\n     *      R.identical(1, '1'); //=> false\n     *      R.identical([], []); //=> false\n     *      R.identical(0, -0); //=> false\n     *      R.identical(NaN, NaN); //=> true\n     */\n    // SameValue algorithm\n    // Steps 1-5, 7-10\n    // Steps 6.b-6.e: +0 != -0\n    // Step 6.a: NaN == NaN\n    var identical = _curry2(function identical(a, b) {\n        // SameValue algorithm\n        if (a === b) {\n            // Steps 1-5, 7-10\n            // Steps 6.b-6.e: +0 != -0\n            return a !== 0 || 1 / a === 1 / b;\n        } else {\n            // Step 6.a: NaN == NaN\n            return a !== a && b !== b;\n        }\n    });\n\n    /**\n     * A function that does nothing but return the parameter supplied to it. Good\n     * as a default or placeholder function.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.1.0\n     * @category Function\n     * @sig a -> a\n     * @param {*} x The value to return.\n     * @return {*} The input value, `x`.\n     * @example\n     *\n     *      R.identity(1); //=> 1\n     *\n     *      var obj = {};\n     *      R.identity(obj) === obj; //=> true\n     */\n    var identity = _curry1(_identity);\n\n    /**\n     * Creates a function that will process either the `onTrue` or the `onFalse`\n     * function depending upon the result of the `condition` predicate.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.8.0\n     * @category Logic\n     * @sig (*... -> Boolean) -> (*... -> *) -> (*... -> *) -> (*... -> *)\n     * @param {Function} condition A predicate function\n     * @param {Function} onTrue A function to invoke when the `condition` evaluates to a truthy value.\n     * @param {Function} onFalse A function to invoke when the `condition` evaluates to a falsy value.\n     * @return {Function} A new unary function that will process either the `onTrue` or the `onFalse`\n     *                    function depending upon the result of the `condition` predicate.\n     * @see R.unless, R.when\n     * @example\n     *\n     *      var incCount = R.ifElse(\n     *        R.has('count'),\n     *        R.over(R.lensProp('count'), R.inc),\n     *        R.assoc('count', 1)\n     *      );\n     *      incCount({});           //=> { count: 1 }\n     *      incCount({ count: 1 }); //=> { count: 2 }\n     */\n    var ifElse = _curry3(function ifElse(condition, onTrue, onFalse) {\n        return curryN(Math.max(condition.length, onTrue.length, onFalse.length), function _ifElse() {\n            return condition.apply(this, arguments) ? onTrue.apply(this, arguments) : onFalse.apply(this, arguments);\n        });\n    });\n\n    /**\n     * Increments its argument.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.9.0\n     * @category Math\n     * @sig Number -> Number\n     * @param {Number} n\n     * @return {Number}\n     * @see R.dec\n     * @example\n     *\n     *      R.inc(42); //=> 43\n     */\n    var inc = add(1);\n\n    /**\n     * Inserts the supplied element into the list, at index `index`. _Note that\n     * this is not destructive_: it returns a copy of the list with the changes.\n     * <small>No lists have been harmed in the application of this function.</small>\n     *\n     * @func\n     * @memberOf R\n     * @since v0.2.2\n     * @category List\n     * @sig Number -> a -> [a] -> [a]\n     * @param {Number} index The position to insert the element\n     * @param {*} elt The element to insert into the Array\n     * @param {Array} list The list to insert into\n     * @return {Array} A new Array with `elt` inserted at `index`.\n     * @example\n     *\n     *      R.insert(2, 'x', [1,2,3,4]); //=> [1,2,'x',3,4]\n     */\n    var insert = _curry3(function insert(idx, elt, list) {\n        idx = idx < list.length && idx >= 0 ? idx : list.length;\n        var result = _slice(list);\n        result.splice(idx, 0, elt);\n        return result;\n    });\n\n    /**\n     * Inserts the sub-list into the list, at index `index`. _Note that this is not\n     * destructive_: it returns a copy of the list with the changes.\n     * <small>No lists have been harmed in the application of this function.</small>\n     *\n     * @func\n     * @memberOf R\n     * @since v0.9.0\n     * @category List\n     * @sig Number -> [a] -> [a] -> [a]\n     * @param {Number} index The position to insert the sub-list\n     * @param {Array} elts The sub-list to insert into the Array\n     * @param {Array} list The list to insert the sub-list into\n     * @return {Array} A new Array with `elts` inserted starting at `index`.\n     * @example\n     *\n     *      R.insertAll(2, ['x','y','z'], [1,2,3,4]); //=> [1,2,'x','y','z',3,4]\n     */\n    var insertAll = _curry3(function insertAll(idx, elts, list) {\n        idx = idx < list.length && idx >= 0 ? idx : list.length;\n        return _concat(_concat(_slice(list, 0, idx), elts), _slice(list, idx));\n    });\n\n    /**\n     * Creates a new list with the separator interposed between elements.\n     *\n     * Dispatches to the `intersperse` method of the second argument, if present.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.14.0\n     * @category List\n     * @sig a -> [a] -> [a]\n     * @param {*} separator The element to add to the list.\n     * @param {Array} list The list to be interposed.\n     * @return {Array} The new list.\n     * @example\n     *\n     *      R.intersperse('n', ['ba', 'a', 'a']); //=> ['ba', 'n', 'a', 'n', 'a']\n     */\n    var intersperse = _curry2(_checkForMethod('intersperse', function intersperse(separator, list) {\n        var out = [];\n        var idx = 0;\n        var length = list.length;\n        while (idx < length) {\n            if (idx === length - 1) {\n                out.push(list[idx]);\n            } else {\n                out.push(list[idx], separator);\n            }\n            idx += 1;\n        }\n        return out;\n    }));\n\n    /**\n     * See if an object (`val`) is an instance of the supplied constructor. This\n     * function will check up the inheritance chain, if any.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.3.0\n     * @category Type\n     * @sig (* -> {*}) -> a -> Boolean\n     * @param {Object} ctor A constructor\n     * @param {*} val The value to test\n     * @return {Boolean}\n     * @example\n     *\n     *      R.is(Object, {}); //=> true\n     *      R.is(Number, 1); //=> true\n     *      R.is(Object, 1); //=> false\n     *      R.is(String, 's'); //=> true\n     *      R.is(String, new String('')); //=> true\n     *      R.is(Object, new String('')); //=> true\n     *      R.is(Object, 's'); //=> false\n     *      R.is(Number, {}); //=> false\n     */\n    var is = _curry2(function is(Ctor, val) {\n        return val != null && val.constructor === Ctor || val instanceof Ctor;\n    });\n\n    /**\n     * Tests whether or not an object is similar to an array.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.5.0\n     * @category Type\n     * @category List\n     * @sig * -> Boolean\n     * @param {*} x The object to test.\n     * @return {Boolean} `true` if `x` has a numeric length property and extreme indices defined; `false` otherwise.\n     * @example\n     *\n     *      R.isArrayLike([]); //=> true\n     *      R.isArrayLike(true); //=> false\n     *      R.isArrayLike({}); //=> false\n     *      R.isArrayLike({length: 10}); //=> false\n     *      R.isArrayLike({0: 'zero', 9: 'nine', length: 10}); //=> true\n     */\n    var isArrayLike = _curry1(function isArrayLike(x) {\n        if (_isArray(x)) {\n            return true;\n        }\n        if (!x) {\n            return false;\n        }\n        if (typeof x !== 'object') {\n            return false;\n        }\n        if (x instanceof String) {\n            return false;\n        }\n        if (x.nodeType === 1) {\n            return !!x.length;\n        }\n        if (x.length === 0) {\n            return true;\n        }\n        if (x.length > 0) {\n            return x.hasOwnProperty(0) && x.hasOwnProperty(x.length - 1);\n        }\n        return false;\n    });\n\n    /**\n     * Checks if the input value is `null` or `undefined`.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.9.0\n     * @category Type\n     * @sig * -> Boolean\n     * @param {*} x The value to test.\n     * @return {Boolean} `true` if `x` is `undefined` or `null`, otherwise `false`.\n     * @example\n     *\n     *      R.isNil(null); //=> true\n     *      R.isNil(undefined); //=> true\n     *      R.isNil(0); //=> false\n     *      R.isNil([]); //=> false\n     */\n    var isNil = _curry1(function isNil(x) {\n        return x == null;\n    });\n\n    /**\n     * Returns a list containing the names of all the enumerable own properties of\n     * the supplied object.\n     * Note that the order of the output array is not guaranteed to be consistent\n     * across different JS platforms.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.1.0\n     * @category Object\n     * @sig {k: v} -> [k]\n     * @param {Object} obj The object to extract properties from\n     * @return {Array} An array of the object's own properties.\n     * @example\n     *\n     *      R.keys({a: 1, b: 2, c: 3}); //=> ['a', 'b', 'c']\n     */\n    // cover IE < 9 keys issues\n    // Safari bug\n    var keys = function () {\n        // cover IE < 9 keys issues\n        var hasEnumBug = !{ toString: null }.propertyIsEnumerable('toString');\n        var nonEnumerableProps = [\n            'constructor',\n            'valueOf',\n            'isPrototypeOf',\n            'toString',\n            'propertyIsEnumerable',\n            'hasOwnProperty',\n            'toLocaleString'\n        ];\n        // Safari bug\n        var hasArgsEnumBug = function () {\n            'use strict';\n            return arguments.propertyIsEnumerable('length');\n        }();\n        var contains = function contains(list, item) {\n            var idx = 0;\n            while (idx < list.length) {\n                if (list[idx] === item) {\n                    return true;\n                }\n                idx += 1;\n            }\n            return false;\n        };\n        return typeof Object.keys === 'function' && !hasArgsEnumBug ? _curry1(function keys(obj) {\n            return Object(obj) !== obj ? [] : Object.keys(obj);\n        }) : _curry1(function keys(obj) {\n            if (Object(obj) !== obj) {\n                return [];\n            }\n            var prop, nIdx;\n            var ks = [];\n            var checkArgsLength = hasArgsEnumBug && _isArguments(obj);\n            for (prop in obj) {\n                if (_has(prop, obj) && (!checkArgsLength || prop !== 'length')) {\n                    ks[ks.length] = prop;\n                }\n            }\n            if (hasEnumBug) {\n                nIdx = nonEnumerableProps.length - 1;\n                while (nIdx >= 0) {\n                    prop = nonEnumerableProps[nIdx];\n                    if (_has(prop, obj) && !contains(ks, prop)) {\n                        ks[ks.length] = prop;\n                    }\n                    nIdx -= 1;\n                }\n            }\n            return ks;\n        });\n    }();\n\n    /**\n     * Returns a list containing the names of all the properties of the supplied\n     * object, including prototype properties.\n     * Note that the order of the output array is not guaranteed to be consistent\n     * across different JS platforms.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.2.0\n     * @category Object\n     * @sig {k: v} -> [k]\n     * @param {Object} obj The object to extract properties from\n     * @return {Array} An array of the object's own and prototype properties.\n     * @example\n     *\n     *      var F = function() { this.x = 'X'; };\n     *      F.prototype.y = 'Y';\n     *      var f = new F();\n     *      R.keysIn(f); //=> ['x', 'y']\n     */\n    var keysIn = _curry1(function keysIn(obj) {\n        var prop;\n        var ks = [];\n        for (prop in obj) {\n            ks[ks.length] = prop;\n        }\n        return ks;\n    });\n\n    /**\n     * Returns the number of elements in the array by returning `list.length`.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.3.0\n     * @category List\n     * @sig [a] -> Number\n     * @param {Array} list The array to inspect.\n     * @return {Number} The length of the array.\n     * @example\n     *\n     *      R.length([]); //=> 0\n     *      R.length([1, 2, 3]); //=> 3\n     */\n    var length = _curry1(function length(list) {\n        return list != null && is(Number, list.length) ? list.length : NaN;\n    });\n\n    /**\n     * Returns `true` if the first argument is less than the second; `false`\n     * otherwise.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.1.0\n     * @category Relation\n     * @sig Ord a => a -> a -> Boolean\n     * @param {*} a\n     * @param {*} b\n     * @return {Boolean}\n     * @see R.gt\n     * @example\n     *\n     *      R.lt(2, 1); //=> false\n     *      R.lt(2, 2); //=> false\n     *      R.lt(2, 3); //=> true\n     *      R.lt('a', 'z'); //=> true\n     *      R.lt('z', 'a'); //=> false\n     */\n    var lt = _curry2(function lt(a, b) {\n        return a < b;\n    });\n\n    /**\n     * Returns `true` if the first argument is less than or equal to the second;\n     * `false` otherwise.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.1.0\n     * @category Relation\n     * @sig Ord a => a -> a -> Boolean\n     * @param {Number} a\n     * @param {Number} b\n     * @return {Boolean}\n     * @see R.gte\n     * @example\n     *\n     *      R.lte(2, 1); //=> false\n     *      R.lte(2, 2); //=> true\n     *      R.lte(2, 3); //=> true\n     *      R.lte('a', 'z'); //=> true\n     *      R.lte('z', 'a'); //=> false\n     */\n    var lte = _curry2(function lte(a, b) {\n        return a <= b;\n    });\n\n    /**\n     * The mapAccum function behaves like a combination of map and reduce; it\n     * applies a function to each element of a list, passing an accumulating\n     * parameter from left to right, and returning a final value of this\n     * accumulator together with the new list.\n     *\n     * The iterator function receives two arguments, *acc* and *value*, and should\n     * return a tuple *[acc, value]*.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.10.0\n     * @category List\n     * @sig (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])\n     * @param {Function} fn The function to be called on every element of the input `list`.\n     * @param {*} acc The accumulator value.\n     * @param {Array} list The list to iterate over.\n     * @return {*} The final, accumulated value.\n     * @see R.addIndex\n     * @example\n     *\n     *      var digits = ['1', '2', '3', '4'];\n     *      var append = (a, b) => [a + b, a + b];\n     *\n     *      R.mapAccum(append, 0, digits); //=> ['01234', ['01', '012', '0123', '01234']]\n     */\n    var mapAccum = _curry3(function mapAccum(fn, acc, list) {\n        var idx = 0;\n        var len = list.length;\n        var result = [];\n        var tuple = [acc];\n        while (idx < len) {\n            tuple = fn(tuple[0], list[idx]);\n            result[idx] = tuple[1];\n            idx += 1;\n        }\n        return [\n            tuple[0],\n            result\n        ];\n    });\n\n    /**\n     * The mapAccumRight function behaves like a combination of map and reduce; it\n     * applies a function to each element of a list, passing an accumulating\n     * parameter from right to left, and returning a final value of this\n     * accumulator together with the new list.\n     *\n     * Similar to `mapAccum`, except moves through the input list from the right to\n     * the left.\n     *\n     * The iterator function receives two arguments, *acc* and *value*, and should\n     * return a tuple *[acc, value]*.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.10.0\n     * @category List\n     * @sig (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])\n     * @param {Function} fn The function to be called on every element of the input `list`.\n     * @param {*} acc The accumulator value.\n     * @param {Array} list The list to iterate over.\n     * @return {*} The final, accumulated value.\n     * @see R.addIndex\n     * @example\n     *\n     *      var digits = ['1', '2', '3', '4'];\n     *      var append = (a, b) => [a + b, a + b];\n     *\n     *      R.mapAccumRight(append, 0, digits); //=> ['04321', ['04321', '0432', '043', '04']]\n     */\n    var mapAccumRight = _curry3(function mapAccumRight(fn, acc, list) {\n        var idx = list.length - 1;\n        var result = [];\n        var tuple = [acc];\n        while (idx >= 0) {\n            tuple = fn(tuple[0], list[idx]);\n            result[idx] = tuple[1];\n            idx -= 1;\n        }\n        return [\n            tuple[0],\n            result\n        ];\n    });\n\n    /**\n     * Tests a regular expression against a String. Note that this function will\n     * return an empty array when there are no matches. This differs from\n     * [`String.prototype.match`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/match)\n     * which returns `null` when there are no matches.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.1.0\n     * @category String\n     * @sig RegExp -> String -> [String | Undefined]\n     * @param {RegExp} rx A regular expression.\n     * @param {String} str The string to match against\n     * @return {Array} The list of matches or empty array.\n     * @see R.test\n     * @example\n     *\n     *      R.match(/([a-z]a)/g, 'bananas'); //=> ['ba', 'na', 'na']\n     *      R.match(/a/, 'b'); //=> []\n     *      R.match(/a/, null); //=> TypeError: null does not have a method named \"match\"\n     */\n    var match = _curry2(function match(rx, str) {\n        return str.match(rx) || [];\n    });\n\n    /**\n     * mathMod behaves like the modulo operator should mathematically, unlike the\n     * `%` operator (and by extension, R.modulo). So while \"-17 % 5\" is -2,\n     * mathMod(-17, 5) is 3. mathMod requires Integer arguments, and returns NaN\n     * when the modulus is zero or negative.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.3.0\n     * @category Math\n     * @sig Number -> Number -> Number\n     * @param {Number} m The dividend.\n     * @param {Number} p the modulus.\n     * @return {Number} The result of `b mod a`.\n     * @example\n     *\n     *      R.mathMod(-17, 5);  //=> 3\n     *      R.mathMod(17, 5);   //=> 2\n     *      R.mathMod(17, -5);  //=> NaN\n     *      R.mathMod(17, 0);   //=> NaN\n     *      R.mathMod(17.2, 5); //=> NaN\n     *      R.mathMod(17, 5.3); //=> NaN\n     *\n     *      var clock = R.mathMod(R.__, 12);\n     *      clock(15); //=> 3\n     *      clock(24); //=> 0\n     *\n     *      var seventeenMod = R.mathMod(17);\n     *      seventeenMod(3);  //=> 2\n     *      seventeenMod(4);  //=> 1\n     *      seventeenMod(10); //=> 7\n     */\n    var mathMod = _curry2(function mathMod(m, p) {\n        if (!_isInteger(m)) {\n            return NaN;\n        }\n        if (!_isInteger(p) || p < 1) {\n            return NaN;\n        }\n        return (m % p + p) % p;\n    });\n\n    /**\n     * Returns the larger of its two arguments.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.1.0\n     * @category Relation\n     * @sig Ord a => a -> a -> a\n     * @param {*} a\n     * @param {*} b\n     * @return {*}\n     * @see R.maxBy, R.min\n     * @example\n     *\n     *      R.max(789, 123); //=> 789\n     *      R.max('a', 'b'); //=> 'b'\n     */\n    var max = _curry2(function max(a, b) {\n        return b > a ? b : a;\n    });\n\n    /**\n     * Takes a function and two values, and returns whichever value produces the\n     * larger result when passed to the provided function.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.8.0\n     * @category Relation\n     * @sig Ord b => (a -> b) -> a -> a -> a\n     * @param {Function} f\n     * @param {*} a\n     * @param {*} b\n     * @return {*}\n     * @see R.max, R.minBy\n     * @example\n     *\n     *      //  square :: Number -> Number\n     *      var square = n => n * n;\n     *\n     *      R.maxBy(square, -3, 2); //=> -3\n     *\n     *      R.reduce(R.maxBy(square), 0, [3, -5, 4, 1, -2]); //=> -5\n     *      R.reduce(R.maxBy(square), 0, []); //=> 0\n     */\n    var maxBy = _curry3(function maxBy(f, a, b) {\n        return f(b) > f(a) ? b : a;\n    });\n\n    /**\n     * Creates a new object with the own properties of the two provided objects. If\n     * a key exists in both objects, the provided function is applied to the key\n     * and the values associated with the key in each object, with the result being\n     * used as the value associated with the key in the returned object. The key\n     * will be excluded from the returned object if the resulting value is\n     * `undefined`.\n     *\n     * @func\n     * @memberOf R\n     * @since 0.19.1\n     * @since 0.19.0\n     * @category Object\n     * @sig (String -> a -> a -> a) -> {a} -> {a} -> {a}\n     * @param {Function} fn\n     * @param {Object} l\n     * @param {Object} r\n     * @return {Object}\n     * @see R.merge, R.mergeWith\n     * @example\n     *\n     *      let concatValues = (k, l, r) => k == 'values' ? R.concat(l, r) : r\n     *      R.mergeWithKey(concatValues,\n     *                     { a: true, thing: 'foo', values: [10, 20] },\n     *                     { b: true, thing: 'bar', values: [15, 35] });\n     *      //=> { a: true, b: true, thing: 'bar', values: [10, 20, 15, 35] }\n     */\n    var mergeWithKey = _curry3(function mergeWithKey(fn, l, r) {\n        var result = {};\n        var k;\n        for (k in l) {\n            if (_has(k, l)) {\n                result[k] = _has(k, r) ? fn(k, l[k], r[k]) : l[k];\n            }\n        }\n        for (k in r) {\n            if (_has(k, r) && !_has(k, result)) {\n                result[k] = r[k];\n            }\n        }\n        return result;\n    });\n\n    /**\n     * Returns the smaller of its two arguments.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.1.0\n     * @category Relation\n     * @sig Ord a => a -> a -> a\n     * @param {*} a\n     * @param {*} b\n     * @return {*}\n     * @see R.minBy, R.max\n     * @example\n     *\n     *      R.min(789, 123); //=> 123\n     *      R.min('a', 'b'); //=> 'a'\n     */\n    var min = _curry2(function min(a, b) {\n        return b < a ? b : a;\n    });\n\n    /**\n     * Takes a function and two values, and returns whichever value produces the\n     * smaller result when passed to the provided function.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.8.0\n     * @category Relation\n     * @sig Ord b => (a -> b) -> a -> a -> a\n     * @param {Function} f\n     * @param {*} a\n     * @param {*} b\n     * @return {*}\n     * @see R.min, R.maxBy\n     * @example\n     *\n     *      //  square :: Number -> Number\n     *      var square = n => n * n;\n     *\n     *      R.minBy(square, -3, 2); //=> 2\n     *\n     *      R.reduce(R.minBy(square), Infinity, [3, -5, 4, 1, -2]); //=> 1\n     *      R.reduce(R.minBy(square), Infinity, []); //=> Infinity\n     */\n    var minBy = _curry3(function minBy(f, a, b) {\n        return f(b) < f(a) ? b : a;\n    });\n\n    /**\n     * Divides the second parameter by the first and returns the remainder. Note\n     * that this function preserves the JavaScript-style behavior for modulo. For\n     * mathematical modulo see `mathMod`.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.1.1\n     * @category Math\n     * @sig Number -> Number -> Number\n     * @param {Number} a The value to the divide.\n     * @param {Number} b The pseudo-modulus\n     * @return {Number} The result of `b % a`.\n     * @see R.mathMod\n     * @example\n     *\n     *      R.modulo(17, 3); //=> 2\n     *      // JS behavior:\n     *      R.modulo(-17, 3); //=> -2\n     *      R.modulo(17, -3); //=> 2\n     *\n     *      var isOdd = R.modulo(R.__, 2);\n     *      isOdd(42); //=> 0\n     *      isOdd(21); //=> 1\n     */\n    var modulo = _curry2(function modulo(a, b) {\n        return a % b;\n    });\n\n    /**\n     * Multiplies two numbers. Equivalent to `a * b` but curried.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.1.0\n     * @category Math\n     * @sig Number -> Number -> Number\n     * @param {Number} a The first value.\n     * @param {Number} b The second value.\n     * @return {Number} The result of `a * b`.\n     * @see R.divide\n     * @example\n     *\n     *      var double = R.multiply(2);\n     *      var triple = R.multiply(3);\n     *      double(3);       //=>  6\n     *      triple(4);       //=> 12\n     *      R.multiply(2, 5);  //=> 10\n     */\n    var multiply = _curry2(function multiply(a, b) {\n        return a * b;\n    });\n\n    /**\n     * Wraps a function of any arity (including nullary) in a function that accepts\n     * exactly `n` parameters. Any extraneous parameters will not be passed to the\n     * supplied function.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.1.0\n     * @category Function\n     * @sig Number -> (* -> a) -> (* -> a)\n     * @param {Number} n The desired arity of the new function.\n     * @param {Function} fn The function to wrap.\n     * @return {Function} A new function wrapping `fn`. The new function is guaranteed to be of\n     *         arity `n`.\n     * @example\n     *\n     *      var takesTwoArgs = (a, b) => [a, b];\n     *\n     *      takesTwoArgs.length; //=> 2\n     *      takesTwoArgs(1, 2); //=> [1, 2]\n     *\n     *      var takesOneArg = R.nAry(1, takesTwoArgs);\n     *      takesOneArg.length; //=> 1\n     *      // Only `n` arguments are passed to the wrapped function\n     *      takesOneArg(1, 2); //=> [1, undefined]\n     */\n    var nAry = _curry2(function nAry(n, fn) {\n        switch (n) {\n        case 0:\n            return function () {\n                return fn.call(this);\n            };\n        case 1:\n            return function (a0) {\n                return fn.call(this, a0);\n            };\n        case 2:\n            return function (a0, a1) {\n                return fn.call(this, a0, a1);\n            };\n        case 3:\n            return function (a0, a1, a2) {\n                return fn.call(this, a0, a1, a2);\n            };\n        case 4:\n            return function (a0, a1, a2, a3) {\n                return fn.call(this, a0, a1, a2, a3);\n            };\n        case 5:\n            return function (a0, a1, a2, a3, a4) {\n                return fn.call(this, a0, a1, a2, a3, a4);\n            };\n        case 6:\n            return function (a0, a1, a2, a3, a4, a5) {\n                return fn.call(this, a0, a1, a2, a3, a4, a5);\n            };\n        case 7:\n            return function (a0, a1, a2, a3, a4, a5, a6) {\n                return fn.call(this, a0, a1, a2, a3, a4, a5, a6);\n            };\n        case 8:\n            return function (a0, a1, a2, a3, a4, a5, a6, a7) {\n                return fn.call(this, a0, a1, a2, a3, a4, a5, a6, a7);\n            };\n        case 9:\n            return function (a0, a1, a2, a3, a4, a5, a6, a7, a8) {\n                return fn.call(this, a0, a1, a2, a3, a4, a5, a6, a7, a8);\n            };\n        case 10:\n            return function (a0, a1, a2, a3, a4, a5, a6, a7, a8, a9) {\n                return fn.call(this, a0, a1, a2, a3, a4, a5, a6, a7, a8, a9);\n            };\n        default:\n            throw new Error('First argument to nAry must be a non-negative integer no greater than ten');\n        }\n    });\n\n    /**\n     * Negates its argument.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.9.0\n     * @category Math\n     * @sig Number -> Number\n     * @param {Number} n\n     * @return {Number}\n     * @example\n     *\n     *      R.negate(42); //=> -42\n     */\n    var negate = _curry1(function negate(n) {\n        return -n;\n    });\n\n    /**\n     * Returns `true` if no elements of the list match the predicate, `false`\n     * otherwise.\n     *\n     * Dispatches to the `any` method of the second argument, if present.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.12.0\n     * @category List\n     * @sig (a -> Boolean) -> [a] -> Boolean\n     * @param {Function} fn The predicate function.\n     * @param {Array} list The array to consider.\n     * @return {Boolean} `true` if the predicate is not satisfied by every element, `false` otherwise.\n     * @see R.all, R.any\n     * @example\n     *\n     *      var isEven = n => n % 2 === 0;\n     *\n     *      R.none(isEven, [1, 3, 5, 7, 9, 11]); //=> true\n     *      R.none(isEven, [1, 3, 5, 7, 8, 11]); //=> false\n     */\n    var none = _curry2(_complement(_dispatchable('any', _xany, any)));\n\n    /**\n     * A function that returns the `!` of its argument. It will return `true` when\n     * passed false-y value, and `false` when passed a truth-y one.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.1.0\n     * @category Logic\n     * @sig * -> Boolean\n     * @param {*} a any value\n     * @return {Boolean} the logical inverse of passed argument.\n     * @see R.complement\n     * @example\n     *\n     *      R.not(true); //=> false\n     *      R.not(false); //=> true\n     *      R.not(0); => true\n     *      R.not(1); => false\n     */\n    var not = _curry1(function not(a) {\n        return !a;\n    });\n\n    /**\n     * Returns the nth element of the given list or string. If n is negative the\n     * element at index length + n is returned.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.1.0\n     * @category List\n     * @sig Number -> [a] -> a | Undefined\n     * @sig Number -> String -> String\n     * @param {Number} offset\n     * @param {*} list\n     * @return {*}\n     * @example\n     *\n     *      var list = ['foo', 'bar', 'baz', 'quux'];\n     *      R.nth(1, list); //=> 'bar'\n     *      R.nth(-1, list); //=> 'quux'\n     *      R.nth(-99, list); //=> undefined\n     *\n     *      R.nth('abc', 2); //=> 'c'\n     *      R.nth('abc', 3); //=> ''\n     */\n    var nth = _curry2(function nth(offset, list) {\n        var idx = offset < 0 ? list.length + offset : offset;\n        return _isString(list) ? list.charAt(idx) : list[idx];\n    });\n\n    /**\n     * Returns a function which returns its nth argument.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.9.0\n     * @category Function\n     * @sig Number -> *... -> *\n     * @param {Number} n\n     * @return {Function}\n     * @example\n     *\n     *      R.nthArg(1)('a', 'b', 'c'); //=> 'b'\n     *      R.nthArg(-1)('a', 'b', 'c'); //=> 'c'\n     */\n    var nthArg = _curry1(function nthArg(n) {\n        return function () {\n            return nth(n, arguments);\n        };\n    });\n\n    /**\n     * Creates an object containing a single key:value pair.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.18.0\n     * @category Object\n     * @sig String -> a -> {String:a}\n     * @param {String} key\n     * @param {*} val\n     * @return {Object}\n     * @see R.pair\n     * @example\n     *\n     *      var matchPhrases = R.compose(\n     *        R.objOf('must'),\n     *        R.map(R.objOf('match_phrase'))\n     *      );\n     *      matchPhrases(['foo', 'bar', 'baz']); //=> {must: [{match_phrase: 'foo'}, {match_phrase: 'bar'}, {match_phrase: 'baz'}]}\n     */\n    var objOf = _curry2(function objOf(key, val) {\n        var obj = {};\n        obj[key] = val;\n        return obj;\n    });\n\n    /**\n     * Returns a singleton array containing the value provided.\n     *\n     * Note this `of` is different from the ES6 `of`; See\n     * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/of\n     *\n     * @func\n     * @memberOf R\n     * @since v0.3.0\n     * @category Function\n     * @sig a -> [a]\n     * @param {*} x any value\n     * @return {Array} An array wrapping `x`.\n     * @example\n     *\n     *      R.of(null); //=> [null]\n     *      R.of([42]); //=> [[42]]\n     */\n    var of = _curry1(_of);\n\n    /**\n     * Accepts a function `fn` and returns a function that guards invocation of\n     * `fn` such that `fn` can only ever be called once, no matter how many times\n     * the returned function is invoked. The first value calculated is returned in\n     * subsequent invocations.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.1.0\n     * @category Function\n     * @sig (a... -> b) -> (a... -> b)\n     * @param {Function} fn The function to wrap in a call-only-once wrapper.\n     * @return {Function} The wrapped function.\n     * @example\n     *\n     *      var addOneOnce = R.once(x => x + 1);\n     *      addOneOnce(10); //=> 11\n     *      addOneOnce(addOneOnce(50)); //=> 11\n     */\n    var once = _curry1(function once(fn) {\n        var called = false;\n        var result;\n        return _arity(fn.length, function () {\n            if (called) {\n                return result;\n            }\n            called = true;\n            result = fn.apply(this, arguments);\n            return result;\n        });\n    });\n\n    /**\n     * Returns `true` if one or both of its arguments are `true`. Returns `false`\n     * if both arguments are `false`.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.1.0\n     * @category Logic\n     * @sig * -> * -> *\n     * @param {Boolean} a A boolean value\n     * @param {Boolean} b A boolean value\n     * @return {Boolean} `true` if one or both arguments are `true`, `false` otherwise\n     * @see R.either\n     * @example\n     *\n     *      R.or(true, true); //=> true\n     *      R.or(true, false); //=> true\n     *      R.or(false, true); //=> true\n     *      R.or(false, false); //=> false\n     */\n    var or = _curry2(function or(a, b) {\n        return a || b;\n    });\n\n    /**\n     * Returns the result of \"setting\" the portion of the given data structure\n     * focused by the given lens to the result of applying the given function to\n     * the focused value.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.16.0\n     * @category Object\n     * @typedefn Lens s a = Functor f => (a -> f a) -> s -> f s\n     * @sig Lens s a -> (a -> a) -> s -> s\n     * @param {Lens} lens\n     * @param {*} v\n     * @param {*} x\n     * @return {*}\n     * @see R.prop, R.lensIndex, R.lensProp\n     * @example\n     *\n     *      var headLens = R.lensIndex(0);\n     *\n     *      R.over(headLens, R.toUpper, ['foo', 'bar', 'baz']); //=> ['FOO', 'bar', 'baz']\n     */\n    var over = function () {\n        var Identity = function (x) {\n            return {\n                value: x,\n                map: function (f) {\n                    return Identity(f(x));\n                }\n            };\n        };\n        return _curry3(function over(lens, f, x) {\n            return lens(function (y) {\n                return Identity(f(y));\n            })(x).value;\n        });\n    }();\n\n    /**\n     * Takes two arguments, `fst` and `snd`, and returns `[fst, snd]`.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.18.0\n     * @category List\n     * @sig a -> b -> (a,b)\n     * @param {*} fst\n     * @param {*} snd\n     * @return {Array}\n     * @see R.createMapEntry, R.of\n     * @example\n     *\n     *      R.pair('foo', 'bar'); //=> ['foo', 'bar']\n     */\n    var pair = _curry2(function pair(fst, snd) {\n        return [\n            fst,\n            snd\n        ];\n    });\n\n    /**\n     * Retrieve the value at a given path.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.2.0\n     * @category Object\n     * @sig [String] -> {k: v} -> v | Undefined\n     * @param {Array} path The path to use.\n     * @param {Object} obj The object to retrieve the nested property from.\n     * @return {*} The data at `path`.\n     * @example\n     *\n     *      R.path(['a', 'b'], {a: {b: 2}}); //=> 2\n     *      R.path(['a', 'b'], {c: {b: 2}}); //=> undefined\n     */\n    var path = _curry2(function path(paths, obj) {\n        var val = obj;\n        var idx = 0;\n        while (idx < paths.length) {\n            if (val == null) {\n                return;\n            }\n            val = val[paths[idx]];\n            idx += 1;\n        }\n        return val;\n    });\n\n    /**\n     * If the given, non-null object has a value at the given path, returns the\n     * value at that path. Otherwise returns the provided default value.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.18.0\n     * @category Object\n     * @sig a -> [String] -> Object -> a\n     * @param {*} d The default value.\n     * @param {Array} p The path to use.\n     * @param {Object} obj The object to retrieve the nested property from.\n     * @return {*} The data at `path` of the supplied object or the default value.\n     * @example\n     *\n     *      R.pathOr('N/A', ['a', 'b'], {a: {b: 2}}); //=> 2\n     *      R.pathOr('N/A', ['a', 'b'], {c: {b: 2}}); //=> \"N/A\"\n     */\n    var pathOr = _curry3(function pathOr(d, p, obj) {\n        return defaultTo(d, path(p, obj));\n    });\n\n    /**\n     * Returns `true` if the specified object property at given path satisfies the\n     * given predicate; `false` otherwise.\n     *\n     * @func\n     * @memberOf R\n     * @since 0.19.1\n     * @since 0.19.0\n     * @category Logic\n     * @sig (a -> Boolean) -> [String] -> Object -> Boolean\n     * @param {Function} pred\n     * @param {Array} propPath\n     * @param {*} obj\n     * @return {Boolean}\n     * @see R.propSatisfies, R.path\n     * @example\n     *\n     *      R.pathSatisfies(y => y > 0, ['x', 'y'], {x: {y: 2}}); //=> true\n     */\n    var pathSatisfies = _curry3(function pathSatisfies(pred, propPath, obj) {\n        return propPath.length > 0 && pred(path(propPath, obj));\n    });\n\n    /**\n     * Returns a partial copy of an object containing only the keys specified. If\n     * the key does not exist, the property is ignored.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.1.0\n     * @category Object\n     * @sig [k] -> {k: v} -> {k: v}\n     * @param {Array} names an array of String property names to copy onto a new object\n     * @param {Object} obj The object to copy from\n     * @return {Object} A new object with only properties from `names` on it.\n     * @see R.omit, R.props\n     * @example\n     *\n     *      R.pick(['a', 'd'], {a: 1, b: 2, c: 3, d: 4}); //=> {a: 1, d: 4}\n     *      R.pick(['a', 'e', 'f'], {a: 1, b: 2, c: 3, d: 4}); //=> {a: 1}\n     */\n    var pick = _curry2(function pick(names, obj) {\n        var result = {};\n        var idx = 0;\n        while (idx < names.length) {\n            if (names[idx] in obj) {\n                result[names[idx]] = obj[names[idx]];\n            }\n            idx += 1;\n        }\n        return result;\n    });\n\n    /**\n     * Similar to `pick` except that this one includes a `key: undefined` pair for\n     * properties that don't exist.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.1.0\n     * @category Object\n     * @sig [k] -> {k: v} -> {k: v}\n     * @param {Array} names an array of String property names to copy onto a new object\n     * @param {Object} obj The object to copy from\n     * @return {Object} A new object with only properties from `names` on it.\n     * @see R.pick\n     * @example\n     *\n     *      R.pickAll(['a', 'd'], {a: 1, b: 2, c: 3, d: 4}); //=> {a: 1, d: 4}\n     *      R.pickAll(['a', 'e', 'f'], {a: 1, b: 2, c: 3, d: 4}); //=> {a: 1, e: undefined, f: undefined}\n     */\n    var pickAll = _curry2(function pickAll(names, obj) {\n        var result = {};\n        var idx = 0;\n        var len = names.length;\n        while (idx < len) {\n            var name = names[idx];\n            result[name] = obj[name];\n            idx += 1;\n        }\n        return result;\n    });\n\n    /**\n     * Returns a partial copy of an object containing only the keys that satisfy\n     * the supplied predicate.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.8.0\n     * @category Object\n     * @sig (v, k -> Boolean) -> {k: v} -> {k: v}\n     * @param {Function} pred A predicate to determine whether or not a key\n     *        should be included on the output object.\n     * @param {Object} obj The object to copy from\n     * @return {Object} A new object with only properties that satisfy `pred`\n     *         on it.\n     * @see R.pick, R.filter\n     * @example\n     *\n     *      var isUpperCase = (val, key) => key.toUpperCase() === key;\n     *      R.pickBy(isUpperCase, {a: 1, b: 2, A: 3, B: 4}); //=> {A: 3, B: 4}\n     */\n    var pickBy = _curry2(function pickBy(test, obj) {\n        var result = {};\n        for (var prop in obj) {\n            if (test(obj[prop], prop, obj)) {\n                result[prop] = obj[prop];\n            }\n        }\n        return result;\n    });\n\n    /**\n     * Returns a new list with the given element at the front, followed by the\n     * contents of the list.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.1.0\n     * @category List\n     * @sig a -> [a] -> [a]\n     * @param {*} el The item to add to the head of the output list.\n     * @param {Array} list The array to add to the tail of the output list.\n     * @return {Array} A new array.\n     * @see R.append\n     * @example\n     *\n     *      R.prepend('fee', ['fi', 'fo', 'fum']); //=> ['fee', 'fi', 'fo', 'fum']\n     */\n    var prepend = _curry2(function prepend(el, list) {\n        return _concat([el], list);\n    });\n\n    /**\n     * Returns a function that when supplied an object returns the indicated\n     * property of that object, if it exists.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.1.0\n     * @category Object\n     * @sig s -> {s: a} -> a | Undefined\n     * @param {String} p The property name\n     * @param {Object} obj The object to query\n     * @return {*} The value at `obj.p`.\n     * @example\n     *\n     *      R.prop('x', {x: 100}); //=> 100\n     *      R.prop('x', {}); //=> undefined\n     */\n    var prop = _curry2(function prop(p, obj) {\n        return obj[p];\n    });\n\n    /**\n     * If the given, non-null object has an own property with the specified name,\n     * returns the value of that property. Otherwise returns the provided default\n     * value.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.6.0\n     * @category Object\n     * @sig a -> String -> Object -> a\n     * @param {*} val The default value.\n     * @param {String} p The name of the property to return.\n     * @param {Object} obj The object to query.\n     * @return {*} The value of given property of the supplied object or the default value.\n     * @example\n     *\n     *      var alice = {\n     *        name: 'ALICE',\n     *        age: 101\n     *      };\n     *      var favorite = R.prop('favoriteLibrary');\n     *      var favoriteWithDefault = R.propOr('Ramda', 'favoriteLibrary');\n     *\n     *      favorite(alice);  //=> undefined\n     *      favoriteWithDefault(alice);  //=> 'Ramda'\n     */\n    var propOr = _curry3(function propOr(val, p, obj) {\n        return obj != null && _has(p, obj) ? obj[p] : val;\n    });\n\n    /**\n     * Returns `true` if the specified object property satisfies the given\n     * predicate; `false` otherwise.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.16.0\n     * @category Logic\n     * @sig (a -> Boolean) -> String -> {String: a} -> Boolean\n     * @param {Function} pred\n     * @param {String} name\n     * @param {*} obj\n     * @return {Boolean}\n     * @see R.propEq, R.propIs\n     * @example\n     *\n     *      R.propSatisfies(x => x > 0, 'x', {x: 1, y: 2}); //=> true\n     */\n    var propSatisfies = _curry3(function propSatisfies(pred, name, obj) {\n        return pred(obj[name]);\n    });\n\n    /**\n     * Acts as multiple `prop`: array of keys in, array of values out. Preserves\n     * order.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.1.0\n     * @category Object\n     * @sig [k] -> {k: v} -> [v]\n     * @param {Array} ps The property names to fetch\n     * @param {Object} obj The object to query\n     * @return {Array} The corresponding values or partially applied function.\n     * @example\n     *\n     *      R.props(['x', 'y'], {x: 1, y: 2}); //=> [1, 2]\n     *      R.props(['c', 'a', 'b'], {b: 2, a: 1}); //=> [undefined, 1, 2]\n     *\n     *      var fullName = R.compose(R.join(' '), R.props(['first', 'last']));\n     *      fullName({last: 'Bullet-Tooth', age: 33, first: 'Tony'}); //=> 'Tony Bullet-Tooth'\n     */\n    var props = _curry2(function props(ps, obj) {\n        var len = ps.length;\n        var out = [];\n        var idx = 0;\n        while (idx < len) {\n            out[idx] = obj[ps[idx]];\n            idx += 1;\n        }\n        return out;\n    });\n\n    /**\n     * Returns a list of numbers from `from` (inclusive) to `to` (exclusive).\n     *\n     * @func\n     * @memberOf R\n     * @since v0.1.0\n     * @category List\n     * @sig Number -> Number -> [Number]\n     * @param {Number} from The first number in the list.\n     * @param {Number} to One more than the last number in the list.\n     * @return {Array} The list of numbers in tthe set `[a, b)`.\n     * @example\n     *\n     *      R.range(1, 5);    //=> [1, 2, 3, 4]\n     *      R.range(50, 53);  //=> [50, 51, 52]\n     */\n    var range = _curry2(function range(from, to) {\n        if (!(_isNumber(from) && _isNumber(to))) {\n            throw new TypeError('Both arguments to range must be numbers');\n        }\n        var result = [];\n        var n = from;\n        while (n < to) {\n            result.push(n);\n            n += 1;\n        }\n        return result;\n    });\n\n    /**\n     * Returns a single item by iterating through the list, successively calling\n     * the iterator function and passing it an accumulator value and the current\n     * value from the array, and then passing the result to the next call.\n     *\n     * Similar to `reduce`, except moves through the input list from the right to\n     * the left.\n     *\n     * The iterator function receives two values: *(acc, value)*\n     *\n     * Note: `R.reduceRight` does not skip deleted or unassigned indices (sparse\n     * arrays), unlike the native `Array.prototype.reduce` method. For more details\n     * on this behavior, see:\n     * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduceRight#Description\n     *\n     * @func\n     * @memberOf R\n     * @since v0.1.0\n     * @category List\n     * @sig (a,b -> a) -> a -> [b] -> a\n     * @param {Function} fn The iterator function. Receives two values, the accumulator and the\n     *        current element from the array.\n     * @param {*} acc The accumulator value.\n     * @param {Array} list The list to iterate over.\n     * @return {*} The final, accumulated value.\n     * @see R.addIndex\n     * @example\n     *\n     *      var pairs = [ ['a', 1], ['b', 2], ['c', 3] ];\n     *      var flattenPairs = (acc, pair) => acc.concat(pair);\n     *\n     *      R.reduceRight(flattenPairs, [], pairs); //=> [ 'c', 3, 'b', 2, 'a', 1 ]\n     */\n    var reduceRight = _curry3(function reduceRight(fn, acc, list) {\n        var idx = list.length - 1;\n        while (idx >= 0) {\n            acc = fn(acc, list[idx]);\n            idx -= 1;\n        }\n        return acc;\n    });\n\n    /**\n     * Returns a value wrapped to indicate that it is the final value of the reduce\n     * and transduce functions. The returned value should be considered a black\n     * box: the internal structure is not guaranteed to be stable.\n     *\n     * Note: this optimization is unavailable to functions not explicitly listed\n     * above. For instance, it is not currently supported by reduceRight.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.15.0\n     * @category List\n     * @sig a -> *\n     * @param {*} x The final value of the reduce.\n     * @return {*} The wrapped value.\n     * @see R.reduce, R.transduce\n     * @example\n     *\n     *      R.reduce(\n     *        R.pipe(R.add, R.when(R.gte(R.__, 10), R.reduced)),\n     *        0,\n     *        [1, 2, 3, 4, 5]) // 10\n     */\n    var reduced = _curry1(_reduced);\n\n    /**\n     * Removes the sub-list of `list` starting at index `start` and containing\n     * `count` elements. _Note that this is not destructive_: it returns a copy of\n     * the list with the changes.\n     * <small>No lists have been harmed in the application of this function.</small>\n     *\n     * @func\n     * @memberOf R\n     * @since v0.2.2\n     * @category List\n     * @sig Number -> Number -> [a] -> [a]\n     * @param {Number} start The position to start removing elements\n     * @param {Number} count The number of elements to remove\n     * @param {Array} list The list to remove from\n     * @return {Array} A new Array with `count` elements from `start` removed.\n     * @example\n     *\n     *      R.remove(2, 3, [1,2,3,4,5,6,7,8]); //=> [1,2,6,7,8]\n     */\n    var remove = _curry3(function remove(start, count, list) {\n        return _concat(_slice(list, 0, Math.min(start, list.length)), _slice(list, Math.min(list.length, start + count)));\n    });\n\n    /**\n     * Replace a substring or regex match in a string with a replacement.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.7.0\n     * @category String\n     * @sig RegExp|String -> String -> String -> String\n     * @param {RegExp|String} pattern A regular expression or a substring to match.\n     * @param {String} replacement The string to replace the matches with.\n     * @param {String} str The String to do the search and replacement in.\n     * @return {String} The result.\n     * @example\n     *\n     *      R.replace('foo', 'bar', 'foo foo foo'); //=> 'bar foo foo'\n     *      R.replace(/foo/, 'bar', 'foo foo foo'); //=> 'bar foo foo'\n     *\n     *      // Use the \"g\" (global) flag to replace all occurrences:\n     *      R.replace(/foo/g, 'bar', 'foo foo foo'); //=> 'bar bar bar'\n     */\n    var replace = _curry3(function replace(regex, replacement, str) {\n        return str.replace(regex, replacement);\n    });\n\n    /**\n     * Returns a new list or string with the elements or characters in reverse\n     * order.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.1.0\n     * @category List\n     * @sig [a] -> [a]\n     * @sig String -> String\n     * @param {Array|String} list\n     * @return {Array|String}\n     * @example\n     *\n     *      R.reverse([1, 2, 3]);  //=> [3, 2, 1]\n     *      R.reverse([1, 2]);     //=> [2, 1]\n     *      R.reverse([1]);        //=> [1]\n     *      R.reverse([]);         //=> []\n     *\n     *      R.reverse('abc');      //=> 'cba'\n     *      R.reverse('ab');       //=> 'ba'\n     *      R.reverse('a');        //=> 'a'\n     *      R.reverse('');         //=> ''\n     */\n    var reverse = _curry1(function reverse(list) {\n        return _isString(list) ? list.split('').reverse().join('') : _slice(list).reverse();\n    });\n\n    /**\n     * Scan is similar to reduce, but returns a list of successively reduced values\n     * from the left\n     *\n     * @func\n     * @memberOf R\n     * @since v0.10.0\n     * @category List\n     * @sig (a,b -> a) -> a -> [b] -> [a]\n     * @param {Function} fn The iterator function. Receives two values, the accumulator and the\n     *        current element from the array\n     * @param {*} acc The accumulator value.\n     * @param {Array} list The list to iterate over.\n     * @return {Array} A list of all intermediately reduced values.\n     * @example\n     *\n     *      var numbers = [1, 2, 3, 4];\n     *      var factorials = R.scan(R.multiply, 1, numbers); //=> [1, 1, 2, 6, 24]\n     */\n    var scan = _curry3(function scan(fn, acc, list) {\n        var idx = 0;\n        var len = list.length;\n        var result = [acc];\n        while (idx < len) {\n            acc = fn(acc, list[idx]);\n            result[idx + 1] = acc;\n            idx += 1;\n        }\n        return result;\n    });\n\n    /**\n     * Returns the result of \"setting\" the portion of the given data structure\n     * focused by the given lens to the given value.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.16.0\n     * @category Object\n     * @typedefn Lens s a = Functor f => (a -> f a) -> s -> f s\n     * @sig Lens s a -> a -> s -> s\n     * @param {Lens} lens\n     * @param {*} v\n     * @param {*} x\n     * @return {*}\n     * @see R.prop, R.lensIndex, R.lensProp\n     * @example\n     *\n     *      var xLens = R.lensProp('x');\n     *\n     *      R.set(xLens, 4, {x: 1, y: 2});  //=> {x: 4, y: 2}\n     *      R.set(xLens, 8, {x: 1, y: 2});  //=> {x: 8, y: 2}\n     */\n    var set = _curry3(function set(lens, v, x) {\n        return over(lens, always(v), x);\n    });\n\n    /**\n     * Returns the elements of the given list or string (or object with a `slice`\n     * method) from `fromIndex` (inclusive) to `toIndex` (exclusive).\n     *\n     * Dispatches to the `slice` method of the third argument, if present.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.1.4\n     * @category List\n     * @sig Number -> Number -> [a] -> [a]\n     * @sig Number -> Number -> String -> String\n     * @param {Number} fromIndex The start index (inclusive).\n     * @param {Number} toIndex The end index (exclusive).\n     * @param {*} list\n     * @return {*}\n     * @example\n     *\n     *      R.slice(1, 3, ['a', 'b', 'c', 'd']);        //=> ['b', 'c']\n     *      R.slice(1, Infinity, ['a', 'b', 'c', 'd']); //=> ['b', 'c', 'd']\n     *      R.slice(0, -1, ['a', 'b', 'c', 'd']);       //=> ['a', 'b', 'c']\n     *      R.slice(-3, -1, ['a', 'b', 'c', 'd']);      //=> ['b', 'c']\n     *      R.slice(0, 3, 'ramda');                     //=> 'ram'\n     */\n    var slice = _curry3(_checkForMethod('slice', function slice(fromIndex, toIndex, list) {\n        return Array.prototype.slice.call(list, fromIndex, toIndex);\n    }));\n\n    /**\n     * Returns a copy of the list, sorted according to the comparator function,\n     * which should accept two values at a time and return a negative number if the\n     * first value is smaller, a positive number if it's larger, and zero if they\n     * are equal. Please note that this is a **copy** of the list. It does not\n     * modify the original.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.1.0\n     * @category List\n     * @sig (a,a -> Number) -> [a] -> [a]\n     * @param {Function} comparator A sorting function :: a -> b -> Int\n     * @param {Array} list The list to sort\n     * @return {Array} a new array with its elements sorted by the comparator function.\n     * @example\n     *\n     *      var diff = function(a, b) { return a - b; };\n     *      R.sort(diff, [4,2,7,5]); //=> [2, 4, 5, 7]\n     */\n    var sort = _curry2(function sort(comparator, list) {\n        return _slice(list).sort(comparator);\n    });\n\n    /**\n     * Sorts the list according to the supplied function.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.1.0\n     * @category Relation\n     * @sig Ord b => (a -> b) -> [a] -> [a]\n     * @param {Function} fn\n     * @param {Array} list The list to sort.\n     * @return {Array} A new list sorted by the keys generated by `fn`.\n     * @example\n     *\n     *      var sortByFirstItem = R.sortBy(R.prop(0));\n     *      var sortByNameCaseInsensitive = R.sortBy(R.compose(R.toLower, R.prop('name')));\n     *      var pairs = [[-1, 1], [-2, 2], [-3, 3]];\n     *      sortByFirstItem(pairs); //=> [[-3, 3], [-2, 2], [-1, 1]]\n     *      var alice = {\n     *        name: 'ALICE',\n     *        age: 101\n     *      };\n     *      var bob = {\n     *        name: 'Bob',\n     *        age: -10\n     *      };\n     *      var clara = {\n     *        name: 'clara',\n     *        age: 314.159\n     *      };\n     *      var people = [clara, bob, alice];\n     *      sortByNameCaseInsensitive(people); //=> [alice, bob, clara]\n     */\n    var sortBy = _curry2(function sortBy(fn, list) {\n        return _slice(list).sort(function (a, b) {\n            var aa = fn(a);\n            var bb = fn(b);\n            return aa < bb ? -1 : aa > bb ? 1 : 0;\n        });\n    });\n\n    /**\n     * Splits a given list or string at a given index.\n     *\n     * @func\n     * @memberOf R\n     * @since 0.19.1\n     * @since 0.19.0\n     * @category List\n     * @sig Number -> [a] -> [[a], [a]]\n     * @sig Number -> String -> [String, String]\n     * @param {Number} index The index where the array/string is split.\n     * @param {Array|String} array The array/string to be split.\n     * @return {Array}\n     * @example\n     *\n     *      R.splitAt(1, [1, 2, 3]);          //=> [[1], [2, 3]]\n     *      R.splitAt(5, 'hello world');      //=> ['hello', ' world']\n     *      R.splitAt(-1, 'foobar');          //=> ['fooba', 'r']\n     */\n    var splitAt = _curry2(function splitAt(index, array) {\n        return [\n            slice(0, index, array),\n            slice(index, length(array), array)\n        ];\n    });\n\n    /**\n     * Splits a collection into slices of the specified length.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.16.0\n     * @category List\n     * @sig Number -> [a] -> [[a]]\n     * @sig Number -> String -> [String]\n     * @param {Number} n\n     * @param {Array} list\n     * @return {Array}\n     * @example\n     *\n     *      R.splitEvery(3, [1, 2, 3, 4, 5, 6, 7]); //=> [[1, 2, 3], [4, 5, 6], [7]]\n     *      R.splitEvery(3, 'foobarbaz'); //=> ['foo', 'bar', 'baz']\n     */\n    var splitEvery = _curry2(function splitEvery(n, list) {\n        if (n <= 0) {\n            throw new Error('First argument to splitEvery must be a positive integer');\n        }\n        var result = [];\n        var idx = 0;\n        while (idx < list.length) {\n            result.push(slice(idx, idx += n, list));\n        }\n        return result;\n    });\n\n    /**\n     * Takes a list and a predicate and returns a pair of lists with the following properties:\n     *\n     *  - the result of concatenating the two output lists is equivalent to the input list;\n     *  - none of the elements of the first output list satisfies the predicate; and\n     *  - if the second output list is non-empty, its first element satisfies the predicate.\n     *\n     * @func\n     * @memberOf R\n     * @since 0.19.1\n     * @since 0.19.0\n     * @category List\n     * @sig (a -> Boolean) -> [a] -> [[a], [a]]\n     * @param {Function} pred The predicate that determines where the array is split.\n     * @param {Array} list The array to be split.\n     * @return {Array}\n     * @example\n     *\n     *      R.splitWhen(R.equals(2), [1, 2, 3, 1, 2, 3]);   //=> [[1], [2, 3, 1, 2, 3]]\n     */\n    var splitWhen = _curry2(function splitWhen(pred, list) {\n        var idx = 0;\n        var len = list.length;\n        var prefix = [];\n        while (idx < len && !pred(list[idx])) {\n            prefix.push(list[idx]);\n            idx += 1;\n        }\n        return [\n            prefix,\n            _slice(list, idx)\n        ];\n    });\n\n    /**\n     * Subtracts two numbers. Equivalent to `a - b` but curried.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.1.0\n     * @category Math\n     * @sig Number -> Number -> Number\n     * @param {Number} a The first value.\n     * @param {Number} b The second value.\n     * @return {Number} The result of `a - b`.\n     * @see R.add\n     * @example\n     *\n     *      R.subtract(10, 8); //=> 2\n     *\n     *      var minus5 = R.subtract(R.__, 5);\n     *      minus5(17); //=> 12\n     *\n     *      var complementaryAngle = R.subtract(90);\n     *      complementaryAngle(30); //=> 60\n     *      complementaryAngle(72); //=> 18\n     */\n    var subtract = _curry2(function subtract(a, b) {\n        return a - b;\n    });\n\n    /**\n     * Returns all but the first element of the given list or string (or object\n     * with a `tail` method).\n     *\n     * Dispatches to the `slice` method of the first argument, if present.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.1.0\n     * @category List\n     * @sig [a] -> [a]\n     * @sig String -> String\n     * @param {*} list\n     * @return {*}\n     * @see R.head, R.init, R.last\n     * @example\n     *\n     *      R.tail([1, 2, 3]);  //=> [2, 3]\n     *      R.tail([1, 2]);     //=> [2]\n     *      R.tail([1]);        //=> []\n     *      R.tail([]);         //=> []\n     *\n     *      R.tail('abc');  //=> 'bc'\n     *      R.tail('ab');   //=> 'b'\n     *      R.tail('a');    //=> ''\n     *      R.tail('');     //=> ''\n     */\n    var tail = _checkForMethod('tail', slice(1, Infinity));\n\n    /**\n     * Returns the first `n` elements of the given list, string, or\n     * transducer/transformer (or object with a `take` method).\n     *\n     * Dispatches to the `take` method of the second argument, if present.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.1.0\n     * @category List\n     * @sig Number -> [a] -> [a]\n     * @sig Number -> String -> String\n     * @param {Number} n\n     * @param {*} list\n     * @return {*}\n     * @see R.drop\n     * @example\n     *\n     *      R.take(1, ['foo', 'bar', 'baz']); //=> ['foo']\n     *      R.take(2, ['foo', 'bar', 'baz']); //=> ['foo', 'bar']\n     *      R.take(3, ['foo', 'bar', 'baz']); //=> ['foo', 'bar', 'baz']\n     *      R.take(4, ['foo', 'bar', 'baz']); //=> ['foo', 'bar', 'baz']\n     *      R.take(3, 'ramda');               //=> 'ram'\n     *\n     *      var personnel = [\n     *        'Dave Brubeck',\n     *        'Paul Desmond',\n     *        'Eugene Wright',\n     *        'Joe Morello',\n     *        'Gerry Mulligan',\n     *        'Bob Bates',\n     *        'Joe Dodge',\n     *        'Ron Crotty'\n     *      ];\n     *\n     *      var takeFive = R.take(5);\n     *      takeFive(personnel);\n     *      //=> ['Dave Brubeck', 'Paul Desmond', 'Eugene Wright', 'Joe Morello', 'Gerry Mulligan']\n     */\n    var take = _curry2(_dispatchable('take', _xtake, function take(n, xs) {\n        return slice(0, n < 0 ? Infinity : n, xs);\n    }));\n\n    /**\n     * Returns a new list containing the last `n` elements of a given list, passing\n     * each value to the supplied predicate function, and terminating when the\n     * predicate function returns `false`. Excludes the element that caused the\n     * predicate function to fail. The predicate function is passed one argument:\n     * *(value)*.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.16.0\n     * @category List\n     * @sig (a -> Boolean) -> [a] -> [a]\n     * @param {Function} fn The function called per iteration.\n     * @param {Array} list The collection to iterate over.\n     * @return {Array} A new array.\n     * @see R.dropLastWhile, R.addIndex\n     * @example\n     *\n     *      var isNotOne = x => x !== 1;\n     *\n     *      R.takeLastWhile(isNotOne, [1, 2, 3, 4]); //=> [2, 3, 4]\n     */\n    var takeLastWhile = _curry2(function takeLastWhile(fn, list) {\n        var idx = list.length - 1;\n        while (idx >= 0 && fn(list[idx])) {\n            idx -= 1;\n        }\n        return _slice(list, idx + 1, Infinity);\n    });\n\n    /**\n     * Returns a new list containing the first `n` elements of a given list,\n     * passing each value to the supplied predicate function, and terminating when\n     * the predicate function returns `false`. Excludes the element that caused the\n     * predicate function to fail. The predicate function is passed one argument:\n     * *(value)*.\n     *\n     * Dispatches to the `takeWhile` method of the second argument, if present.\n     *\n     * Acts as a transducer if a transformer is given in list position.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.1.0\n     * @category List\n     * @sig (a -> Boolean) -> [a] -> [a]\n     * @param {Function} fn The function called per iteration.\n     * @param {Array} list The collection to iterate over.\n     * @return {Array} A new array.\n     * @see R.dropWhile, R.transduce, R.addIndex\n     * @example\n     *\n     *      var isNotFour = x => x !== 4;\n     *\n     *      R.takeWhile(isNotFour, [1, 2, 3, 4, 3, 2, 1]); //=> [1, 2, 3]\n     */\n    var takeWhile = _curry2(_dispatchable('takeWhile', _xtakeWhile, function takeWhile(fn, list) {\n        var idx = 0;\n        var len = list.length;\n        while (idx < len && fn(list[idx])) {\n            idx += 1;\n        }\n        return _slice(list, 0, idx);\n    }));\n\n    /**\n     * Runs the given function with the supplied object, then returns the object.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.1.0\n     * @category Function\n     * @sig (a -> *) -> a -> a\n     * @param {Function} fn The function to call with `x`. The return value of `fn` will be thrown away.\n     * @param {*} x\n     * @return {*} `x`.\n     * @example\n     *\n     *      var sayX = x => console.log('x is ' + x);\n     *      R.tap(sayX, 100); //=> 100\n     *      //-> 'x is 100'\n     */\n    var tap = _curry2(function tap(fn, x) {\n        fn(x);\n        return x;\n    });\n\n    /**\n     * Calls an input function `n` times, returning an array containing the results\n     * of those function calls.\n     *\n     * `fn` is passed one argument: The current value of `n`, which begins at `0`\n     * and is gradually incremented to `n - 1`.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.2.3\n     * @category List\n     * @sig (Number -> a) -> Number -> [a]\n     * @param {Function} fn The function to invoke. Passed one argument, the current value of `n`.\n     * @param {Number} n A value between `0` and `n - 1`. Increments after each function call.\n     * @return {Array} An array containing the return values of all calls to `fn`.\n     * @example\n     *\n     *      R.times(R.identity, 5); //=> [0, 1, 2, 3, 4]\n     */\n    var times = _curry2(function times(fn, n) {\n        var len = Number(n);\n        var idx = 0;\n        var list;\n        if (len < 0 || isNaN(len)) {\n            throw new RangeError('n must be a non-negative number');\n        }\n        list = new Array(len);\n        while (idx < len) {\n            list[idx] = fn(idx);\n            idx += 1;\n        }\n        return list;\n    });\n\n    /**\n     * Converts an object into an array of key, value arrays. Only the object's\n     * own properties are used.\n     * Note that the order of the output array is not guaranteed to be consistent\n     * across different JS platforms.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.4.0\n     * @category Object\n     * @sig {String: *} -> [[String,*]]\n     * @param {Object} obj The object to extract from\n     * @return {Array} An array of key, value arrays from the object's own properties.\n     * @see R.fromPairs\n     * @example\n     *\n     *      R.toPairs({a: 1, b: 2, c: 3}); //=> [['a', 1], ['b', 2], ['c', 3]]\n     */\n    var toPairs = _curry1(function toPairs(obj) {\n        var pairs = [];\n        for (var prop in obj) {\n            if (_has(prop, obj)) {\n                pairs[pairs.length] = [\n                    prop,\n                    obj[prop]\n                ];\n            }\n        }\n        return pairs;\n    });\n\n    /**\n     * Converts an object into an array of key, value arrays. The object's own\n     * properties and prototype properties are used. Note that the order of the\n     * output array is not guaranteed to be consistent across different JS\n     * platforms.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.4.0\n     * @category Object\n     * @sig {String: *} -> [[String,*]]\n     * @param {Object} obj The object to extract from\n     * @return {Array} An array of key, value arrays from the object's own\n     *         and prototype properties.\n     * @example\n     *\n     *      var F = function() { this.x = 'X'; };\n     *      F.prototype.y = 'Y';\n     *      var f = new F();\n     *      R.toPairsIn(f); //=> [['x','X'], ['y','Y']]\n     */\n    var toPairsIn = _curry1(function toPairsIn(obj) {\n        var pairs = [];\n        for (var prop in obj) {\n            pairs[pairs.length] = [\n                prop,\n                obj[prop]\n            ];\n        }\n        return pairs;\n    });\n\n    /**\n     * Transposes the rows and columns of a 2D list.\n     * When passed a list of `n` lists of length `x`,\n     * returns a list of `x` lists of length `n`.\n     *\n     *\n     * @func\n     * @memberOf R\n     * @since 0.19.1\n     * @since 0.19.0\n     * @category List\n     * @sig [[a]] -> [[a]]\n     * @param {Array} list A 2D list\n     * @return {Array} A 2D list\n     * @example\n     *\n     *      R.transpose([[1, 'a'], [2, 'b'], [3, 'c']]) //=> [[1, 2, 3], ['a', 'b', 'c']]\n     *      R.transpose([[1, 2, 3], ['a', 'b', 'c']]) //=> [[1, 'a'], [2, 'b'], [3, 'c']]\n     *\n     * If some of the rows are shorter than the following rows, their elements are skipped:\n     *\n     *      R.transpose([[10, 11], [20], [], [30, 31, 32]]) //=> [[10, 20, 30], [11, 31], [32]]\n     */\n    var transpose = _curry1(function transpose(outerlist) {\n        var i = 0;\n        var result = [];\n        while (i < outerlist.length) {\n            var innerlist = outerlist[i];\n            var j = 0;\n            while (j < innerlist.length) {\n                if (typeof result[j] === 'undefined') {\n                    result[j] = [];\n                }\n                result[j].push(innerlist[j]);\n                j += 1;\n            }\n            i += 1;\n        }\n        return result;\n    });\n\n    /**\n     * Removes (strips) whitespace from both ends of the string.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.6.0\n     * @category String\n     * @sig String -> String\n     * @param {String} str The string to trim.\n     * @return {String} Trimmed version of `str`.\n     * @example\n     *\n     *      R.trim('   xyz  '); //=> 'xyz'\n     *      R.map(R.trim, R.split(',', 'x, y, z')); //=> ['x', 'y', 'z']\n     */\n    var trim = function () {\n        var ws = '\\t\\n\\x0B\\f\\r \\xA0\\u1680\\u180E\\u2000\\u2001\\u2002\\u2003' + '\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200A\\u202F\\u205F\\u3000\\u2028' + '\\u2029\\uFEFF';\n        var zeroWidth = '\\u200B';\n        var hasProtoTrim = typeof String.prototype.trim === 'function';\n        if (!hasProtoTrim || (ws.trim() || !zeroWidth.trim())) {\n            return _curry1(function trim(str) {\n                var beginRx = new RegExp('^[' + ws + '][' + ws + ']*');\n                var endRx = new RegExp('[' + ws + '][' + ws + ']*$');\n                return str.replace(beginRx, '').replace(endRx, '');\n            });\n        } else {\n            return _curry1(function trim(str) {\n                return str.trim();\n            });\n        }\n    }();\n\n    /**\n     * Gives a single-word string description of the (native) type of a value,\n     * returning such answers as 'Object', 'Number', 'Array', or 'Null'. Does not\n     * attempt to distinguish user Object types any further, reporting them all as\n     * 'Object'.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.8.0\n     * @category Type\n     * @sig (* -> {*}) -> String\n     * @param {*} val The value to test\n     * @return {String}\n     * @example\n     *\n     *      R.type({}); //=> \"Object\"\n     *      R.type(1); //=> \"Number\"\n     *      R.type(false); //=> \"Boolean\"\n     *      R.type('s'); //=> \"String\"\n     *      R.type(null); //=> \"Null\"\n     *      R.type([]); //=> \"Array\"\n     *      R.type(/[A-z]/); //=> \"RegExp\"\n     */\n    var type = _curry1(function type(val) {\n        return val === null ? 'Null' : val === undefined ? 'Undefined' : Object.prototype.toString.call(val).slice(8, -1);\n    });\n\n    /**\n     * Takes a function `fn`, which takes a single array argument, and returns a\n     * function which:\n     *\n     *   - takes any number of positional arguments;\n     *   - passes these arguments to `fn` as an array; and\n     *   - returns the result.\n     *\n     * In other words, R.unapply derives a variadic function from a function which\n     * takes an array. R.unapply is the inverse of R.apply.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.8.0\n     * @category Function\n     * @sig ([*...] -> a) -> (*... -> a)\n     * @param {Function} fn\n     * @return {Function}\n     * @see R.apply\n     * @example\n     *\n     *      R.unapply(JSON.stringify)(1, 2, 3); //=> '[1,2,3]'\n     */\n    var unapply = _curry1(function unapply(fn) {\n        return function () {\n            return fn(_slice(arguments));\n        };\n    });\n\n    /**\n     * Wraps a function of any arity (including nullary) in a function that accepts\n     * exactly 1 parameter. Any extraneous parameters will not be passed to the\n     * supplied function.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.2.0\n     * @category Function\n     * @sig (* -> b) -> (a -> b)\n     * @param {Function} fn The function to wrap.\n     * @return {Function} A new function wrapping `fn`. The new function is guaranteed to be of\n     *         arity 1.\n     * @example\n     *\n     *      var takesTwoArgs = function(a, b) {\n     *        return [a, b];\n     *      };\n     *      takesTwoArgs.length; //=> 2\n     *      takesTwoArgs(1, 2); //=> [1, 2]\n     *\n     *      var takesOneArg = R.unary(takesTwoArgs);\n     *      takesOneArg.length; //=> 1\n     *      // Only 1 argument is passed to the wrapped function\n     *      takesOneArg(1, 2); //=> [1, undefined]\n     */\n    var unary = _curry1(function unary(fn) {\n        return nAry(1, fn);\n    });\n\n    /**\n     * Returns a function of arity `n` from a (manually) curried function.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.14.0\n     * @category Function\n     * @sig Number -> (a -> b) -> (a -> c)\n     * @param {Number} length The arity for the returned function.\n     * @param {Function} fn The function to uncurry.\n     * @return {Function} A new function.\n     * @see R.curry\n     * @example\n     *\n     *      var addFour = a => b => c => d => a + b + c + d;\n     *\n     *      var uncurriedAddFour = R.uncurryN(4, addFour);\n     *      uncurriedAddFour(1, 2, 3, 4); //=> 10\n     */\n    var uncurryN = _curry2(function uncurryN(depth, fn) {\n        return curryN(depth, function () {\n            var currentDepth = 1;\n            var value = fn;\n            var idx = 0;\n            var endIdx;\n            while (currentDepth <= depth && typeof value === 'function') {\n                endIdx = currentDepth === depth ? arguments.length : idx + value.length;\n                value = value.apply(this, _slice(arguments, idx, endIdx));\n                currentDepth += 1;\n                idx = endIdx;\n            }\n            return value;\n        });\n    });\n\n    /**\n     * Builds a list from a seed value. Accepts an iterator function, which returns\n     * either false to stop iteration or an array of length 2 containing the value\n     * to add to the resulting list and the seed to be used in the next call to the\n     * iterator function.\n     *\n     * The iterator function receives one argument: *(seed)*.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.10.0\n     * @category List\n     * @sig (a -> [b]) -> * -> [b]\n     * @param {Function} fn The iterator function. receives one argument, `seed`, and returns\n     *        either false to quit iteration or an array of length two to proceed. The element\n     *        at index 0 of this array will be added to the resulting array, and the element\n     *        at index 1 will be passed to the next call to `fn`.\n     * @param {*} seed The seed value.\n     * @return {Array} The final list.\n     * @example\n     *\n     *      var f = n => n > 50 ? false : [-n, n + 10];\n     *      R.unfold(f, 10); //=> [-10, -20, -30, -40, -50]\n     */\n    var unfold = _curry2(function unfold(fn, seed) {\n        var pair = fn(seed);\n        var result = [];\n        while (pair && pair.length) {\n            result[result.length] = pair[0];\n            pair = fn(pair[1]);\n        }\n        return result;\n    });\n\n    /**\n     * Returns a new list containing only one copy of each element in the original\n     * list, based upon the value returned by applying the supplied predicate to\n     * two list elements. Prefers the first item if two items compare equal based\n     * on the predicate.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.2.0\n     * @category List\n     * @sig (a, a -> Boolean) -> [a] -> [a]\n     * @param {Function} pred A predicate used to test whether two items are equal.\n     * @param {Array} list The array to consider.\n     * @return {Array} The list of unique items.\n     * @example\n     *\n     *      var strEq = R.eqBy(String);\n     *      R.uniqWith(strEq)([1, '1', 2, 1]); //=> [1, 2]\n     *      R.uniqWith(strEq)([{}, {}]);       //=> [{}]\n     *      R.uniqWith(strEq)([1, '1', 1]);    //=> [1]\n     *      R.uniqWith(strEq)(['1', 1, 1]);    //=> ['1']\n     */\n    var uniqWith = _curry2(function uniqWith(pred, list) {\n        var idx = 0;\n        var len = list.length;\n        var result = [];\n        var item;\n        while (idx < len) {\n            item = list[idx];\n            if (!_containsWith(pred, item, result)) {\n                result[result.length] = item;\n            }\n            idx += 1;\n        }\n        return result;\n    });\n\n    /**\n     * Tests the final argument by passing it to the given predicate function. If\n     * the predicate is not satisfied, the function will return the result of\n     * calling the `whenFalseFn` function with the same argument. If the predicate\n     * is satisfied, the argument is returned as is.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.18.0\n     * @category Logic\n     * @sig (a -> Boolean) -> (a -> a) -> a -> a\n     * @param {Function} pred        A predicate function\n     * @param {Function} whenFalseFn A function to invoke when the `pred` evaluates\n     *                               to a falsy value.\n     * @param {*}        x           An object to test with the `pred` function and\n     *                               pass to `whenFalseFn` if necessary.\n     * @return {*} Either `x` or the result of applying `x` to `whenFalseFn`.\n     * @see R.ifElse, R.when\n     * @example\n     *\n     *      // coerceArray :: (a|[a]) -> [a]\n     *      var coerceArray = R.unless(R.isArrayLike, R.of);\n     *      coerceArray([1, 2, 3]); //=> [1, 2, 3]\n     *      coerceArray(1);         //=> [1]\n     */\n    var unless = _curry3(function unless(pred, whenFalseFn, x) {\n        return pred(x) ? x : whenFalseFn(x);\n    });\n\n    /**\n     * Returns a new copy of the array with the element at the provided index\n     * replaced with the given value.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.14.0\n     * @category List\n     * @sig Number -> a -> [a] -> [a]\n     * @param {Number} idx The index to update.\n     * @param {*} x The value to exist at the given index of the returned array.\n     * @param {Array|Arguments} list The source array-like object to be updated.\n     * @return {Array} A copy of `list` with the value at index `idx` replaced with `x`.\n     * @see R.adjust\n     * @example\n     *\n     *      R.update(1, 11, [0, 1, 2]);     //=> [0, 11, 2]\n     *      R.update(1)(11)([0, 1, 2]);     //=> [0, 11, 2]\n     */\n    var update = _curry3(function update(idx, x, list) {\n        return adjust(always(x), idx, list);\n    });\n\n    /**\n     * Accepts a function `fn` and a list of transformer functions and returns a\n     * new curried function. When the new function is invoked, it calls the\n     * function `fn` with parameters consisting of the result of calling each\n     * supplied handler on successive arguments to the new function.\n     *\n     * If more arguments are passed to the returned function than transformer\n     * functions, those arguments are passed directly to `fn` as additional\n     * parameters. If you expect additional arguments that don't need to be\n     * transformed, although you can ignore them, it's best to pass an identity\n     * function so that the new function reports the correct arity.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.1.0\n     * @category Function\n     * @sig (x1 -> x2 -> ... -> z) -> [(a -> x1), (b -> x2), ...] -> (a -> b -> ... -> z)\n     * @param {Function} fn The function to wrap.\n     * @param {Array} transformers A list of transformer functions\n     * @return {Function} The wrapped function.\n     * @example\n     *\n     *      R.useWith(Math.pow, [R.identity, R.identity])(3, 4); //=> 81\n     *      R.useWith(Math.pow, [R.identity, R.identity])(3)(4); //=> 81\n     *      R.useWith(Math.pow, [R.dec, R.inc])(3, 4); //=> 32\n     *      R.useWith(Math.pow, [R.dec, R.inc])(3)(4); //=> 32\n     */\n    var useWith = _curry2(function useWith(fn, transformers) {\n        return curryN(transformers.length, function () {\n            var args = [];\n            var idx = 0;\n            while (idx < transformers.length) {\n                args.push(transformers[idx].call(this, arguments[idx]));\n                idx += 1;\n            }\n            return fn.apply(this, args.concat(_slice(arguments, transformers.length)));\n        });\n    });\n\n    /**\n     * Returns a list of all the enumerable own properties of the supplied object.\n     * Note that the order of the output array is not guaranteed across different\n     * JS platforms.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.1.0\n     * @category Object\n     * @sig {k: v} -> [v]\n     * @param {Object} obj The object to extract values from\n     * @return {Array} An array of the values of the object's own properties.\n     * @example\n     *\n     *      R.values({a: 1, b: 2, c: 3}); //=> [1, 2, 3]\n     */\n    var values = _curry1(function values(obj) {\n        var props = keys(obj);\n        var len = props.length;\n        var vals = [];\n        var idx = 0;\n        while (idx < len) {\n            vals[idx] = obj[props[idx]];\n            idx += 1;\n        }\n        return vals;\n    });\n\n    /**\n     * Returns a list of all the properties, including prototype properties, of the\n     * supplied object.\n     * Note that the order of the output array is not guaranteed to be consistent\n     * across different JS platforms.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.2.0\n     * @category Object\n     * @sig {k: v} -> [v]\n     * @param {Object} obj The object to extract values from\n     * @return {Array} An array of the values of the object's own and prototype properties.\n     * @example\n     *\n     *      var F = function() { this.x = 'X'; };\n     *      F.prototype.y = 'Y';\n     *      var f = new F();\n     *      R.valuesIn(f); //=> ['X', 'Y']\n     */\n    var valuesIn = _curry1(function valuesIn(obj) {\n        var prop;\n        var vs = [];\n        for (prop in obj) {\n            vs[vs.length] = obj[prop];\n        }\n        return vs;\n    });\n\n    /**\n     * Returns a \"view\" of the given data structure, determined by the given lens.\n     * The lens's focus determines which portion of the data structure is visible.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.16.0\n     * @category Object\n     * @typedefn Lens s a = Functor f => (a -> f a) -> s -> f s\n     * @sig Lens s a -> s -> a\n     * @param {Lens} lens\n     * @param {*} x\n     * @return {*}\n     * @see R.prop, R.lensIndex, R.lensProp\n     * @example\n     *\n     *      var xLens = R.lensProp('x');\n     *\n     *      R.view(xLens, {x: 1, y: 2});  //=> 1\n     *      R.view(xLens, {x: 4, y: 2});  //=> 4\n     */\n    var view = function () {\n        var Const = function (x) {\n            return {\n                value: x,\n                map: function () {\n                    return this;\n                }\n            };\n        };\n        return _curry2(function view(lens, x) {\n            return lens(Const)(x).value;\n        });\n    }();\n\n    /**\n     * Tests the final argument by passing it to the given predicate function. If\n     * the predicate is satisfied, the function will return the result of calling\n     * the `whenTrueFn` function with the same argument. If the predicate is not\n     * satisfied, the argument is returned as is.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.18.0\n     * @category Logic\n     * @sig (a -> Boolean) -> (a -> a) -> a -> a\n     * @param {Function} pred       A predicate function\n     * @param {Function} whenTrueFn A function to invoke when the `condition`\n     *                              evaluates to a truthy value.\n     * @param {*}        x          An object to test with the `pred` function and\n     *                              pass to `whenTrueFn` if necessary.\n     * @return {*} Either `x` or the result of applying `x` to `whenTrueFn`.\n     * @see R.ifElse, R.unless\n     * @example\n     *\n     *      // truncate :: String -> String\n     *      var truncate = R.when(\n     *        R.propSatisfies(R.gt(R.__, 10), 'length'),\n     *        R.pipe(R.take(10), R.append('…'), R.join(''))\n     *      );\n     *      truncate('12345');         //=> '12345'\n     *      truncate('0123456789ABC'); //=> '0123456789…'\n     */\n    var when = _curry3(function when(pred, whenTrueFn, x) {\n        return pred(x) ? whenTrueFn(x) : x;\n    });\n\n    /**\n     * Takes a spec object and a test object; returns true if the test satisfies\n     * the spec. Each of the spec's own properties must be a predicate function.\n     * Each predicate is applied to the value of the corresponding property of the\n     * test object. `where` returns true if all the predicates return true, false\n     * otherwise.\n     *\n     * `where` is well suited to declaratively expressing constraints for other\n     * functions such as `filter` and `find`.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.1.1\n     * @category Object\n     * @sig {String: (* -> Boolean)} -> {String: *} -> Boolean\n     * @param {Object} spec\n     * @param {Object} testObj\n     * @return {Boolean}\n     * @example\n     *\n     *      // pred :: Object -> Boolean\n     *      var pred = R.where({\n     *        a: R.equals('foo'),\n     *        b: R.complement(R.equals('bar')),\n     *        x: R.gt(_, 10),\n     *        y: R.lt(_, 20)\n     *      });\n     *\n     *      pred({a: 'foo', b: 'xxx', x: 11, y: 19}); //=> true\n     *      pred({a: 'xxx', b: 'xxx', x: 11, y: 19}); //=> false\n     *      pred({a: 'foo', b: 'bar', x: 11, y: 19}); //=> false\n     *      pred({a: 'foo', b: 'xxx', x: 10, y: 19}); //=> false\n     *      pred({a: 'foo', b: 'xxx', x: 11, y: 20}); //=> false\n     */\n    var where = _curry2(function where(spec, testObj) {\n        for (var prop in spec) {\n            if (_has(prop, spec) && !spec[prop](testObj[prop])) {\n                return false;\n            }\n        }\n        return true;\n    });\n\n    /**\n     * Wrap a function inside another to allow you to make adjustments to the\n     * parameters, or do other processing either before the internal function is\n     * called or with its results.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.1.0\n     * @category Function\n     * @sig (a... -> b) -> ((a... -> b) -> a... -> c) -> (a... -> c)\n     * @param {Function} fn The function to wrap.\n     * @param {Function} wrapper The wrapper function.\n     * @return {Function} The wrapped function.\n     * @example\n     *\n     *      var greet = name => 'Hello ' + name;\n     *\n     *      var shoutedGreet = R.wrap(greet, (gr, name) => gr(name).toUpperCase());\n     *\n     *      shoutedGreet(\"Kathy\"); //=> \"HELLO KATHY\"\n     *\n     *      var shortenedGreet = R.wrap(greet, function(gr, name) {\n     *        return gr(name.substring(0, 3));\n     *      });\n     *      shortenedGreet(\"Robert\"); //=> \"Hello Rob\"\n     */\n    var wrap = _curry2(function wrap(fn, wrapper) {\n        return curryN(fn.length, function () {\n            return wrapper.apply(this, _concat([fn], arguments));\n        });\n    });\n\n    /**\n     * Creates a new list out of the two supplied by creating each possible pair\n     * from the lists.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.1.0\n     * @category List\n     * @sig [a] -> [b] -> [[a,b]]\n     * @param {Array} as The first list.\n     * @param {Array} bs The second list.\n     * @return {Array} The list made by combining each possible pair from\n     *         `as` and `bs` into pairs (`[a, b]`).\n     * @example\n     *\n     *      R.xprod([1, 2], ['a', 'b']); //=> [[1, 'a'], [1, 'b'], [2, 'a'], [2, 'b']]\n     */\n    // = xprodWith(prepend); (takes about 3 times as long...)\n    var xprod = _curry2(function xprod(a, b) {\n        // = xprodWith(prepend); (takes about 3 times as long...)\n        var idx = 0;\n        var ilen = a.length;\n        var j;\n        var jlen = b.length;\n        var result = [];\n        while (idx < ilen) {\n            j = 0;\n            while (j < jlen) {\n                result[result.length] = [\n                    a[idx],\n                    b[j]\n                ];\n                j += 1;\n            }\n            idx += 1;\n        }\n        return result;\n    });\n\n    /**\n     * Creates a new list out of the two supplied by pairing up equally-positioned\n     * items from both lists. The returned list is truncated to the length of the\n     * shorter of the two input lists.\n     * Note: `zip` is equivalent to `zipWith(function(a, b) { return [a, b] })`.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.1.0\n     * @category List\n     * @sig [a] -> [b] -> [[a,b]]\n     * @param {Array} list1 The first array to consider.\n     * @param {Array} list2 The second array to consider.\n     * @return {Array} The list made by pairing up same-indexed elements of `list1` and `list2`.\n     * @example\n     *\n     *      R.zip([1, 2, 3], ['a', 'b', 'c']); //=> [[1, 'a'], [2, 'b'], [3, 'c']]\n     */\n    var zip = _curry2(function zip(a, b) {\n        var rv = [];\n        var idx = 0;\n        var len = Math.min(a.length, b.length);\n        while (idx < len) {\n            rv[idx] = [\n                a[idx],\n                b[idx]\n            ];\n            idx += 1;\n        }\n        return rv;\n    });\n\n    /**\n     * Creates a new object out of a list of keys and a list of values.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.3.0\n     * @category List\n     * @sig [String] -> [*] -> {String: *}\n     * @param {Array} keys The array that will be properties on the output object.\n     * @param {Array} values The list of values on the output object.\n     * @return {Object} The object made by pairing up same-indexed elements of `keys` and `values`.\n     * @example\n     *\n     *      R.zipObj(['a', 'b', 'c'], [1, 2, 3]); //=> {a: 1, b: 2, c: 3}\n     */\n    var zipObj = _curry2(function zipObj(keys, values) {\n        var idx = 0;\n        var len = keys.length;\n        var out = {};\n        while (idx < len) {\n            out[keys[idx]] = values[idx];\n            idx += 1;\n        }\n        return out;\n    });\n\n    /**\n     * Creates a new list out of the two supplied by applying the function to each\n     * equally-positioned pair in the lists. The returned list is truncated to the\n     * length of the shorter of the two input lists.\n     *\n     * @function\n     * @memberOf R\n     * @since v0.1.0\n     * @category List\n     * @sig (a,b -> c) -> [a] -> [b] -> [c]\n     * @param {Function} fn The function used to combine the two elements into one value.\n     * @param {Array} list1 The first array to consider.\n     * @param {Array} list2 The second array to consider.\n     * @return {Array} The list made by combining same-indexed elements of `list1` and `list2`\n     *         using `fn`.\n     * @example\n     *\n     *      var f = (x, y) => {\n     *        // ...\n     *      };\n     *      R.zipWith(f, [1, 2, 3], ['a', 'b', 'c']);\n     *      //=> [f(1, 'a'), f(2, 'b'), f(3, 'c')]\n     */\n    var zipWith = _curry3(function zipWith(fn, a, b) {\n        var rv = [];\n        var idx = 0;\n        var len = Math.min(a.length, b.length);\n        while (idx < len) {\n            rv[idx] = fn(a[idx], b[idx]);\n            idx += 1;\n        }\n        return rv;\n    });\n\n    /**\n     * A function that always returns `false`. Any passed in parameters are ignored.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.9.0\n     * @category Function\n     * @sig * -> Boolean\n     * @param {*}\n     * @return {Boolean}\n     * @see R.always, R.T\n     * @example\n     *\n     *      R.F(); //=> false\n     */\n    var F = always(false);\n\n    /**\n     * A function that always returns `true`. Any passed in parameters are ignored.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.9.0\n     * @category Function\n     * @sig * -> Boolean\n     * @param {*}\n     * @return {Boolean}\n     * @see R.always, R.F\n     * @example\n     *\n     *      R.T(); //=> true\n     */\n    var T = always(true);\n\n    /**\n     * Copies an object.\n     *\n     * @private\n     * @param {*} value The value to be copied\n     * @param {Array} refFrom Array containing the source references\n     * @param {Array} refTo Array containing the copied source references\n     * @return {*} The copied value.\n     */\n    var _clone = function _clone(value, refFrom, refTo) {\n        var copy = function copy(copiedValue) {\n            var len = refFrom.length;\n            var idx = 0;\n            while (idx < len) {\n                if (value === refFrom[idx]) {\n                    return refTo[idx];\n                }\n                idx += 1;\n            }\n            refFrom[idx + 1] = value;\n            refTo[idx + 1] = copiedValue;\n            for (var key in value) {\n                copiedValue[key] = _clone(value[key], refFrom, refTo);\n            }\n            return copiedValue;\n        };\n        switch (type(value)) {\n        case 'Object':\n            return copy({});\n        case 'Array':\n            return copy([]);\n        case 'Date':\n            return new Date(value.valueOf());\n        case 'RegExp':\n            return _cloneRegExp(value);\n        default:\n            return value;\n        }\n    };\n\n    var _createPartialApplicator = function _createPartialApplicator(concat) {\n        return _curry2(function (fn, args) {\n            return _arity(Math.max(0, fn.length - args.length), function () {\n                return fn.apply(this, concat(args, arguments));\n            });\n        });\n    };\n\n    var _dropLast = function dropLast(n, xs) {\n        return take(n < xs.length ? xs.length - n : 0, xs);\n    };\n\n    // Values of other types are only equal if identical.\n    var _equals = function _equals(a, b, stackA, stackB) {\n        if (identical(a, b)) {\n            return true;\n        }\n        if (type(a) !== type(b)) {\n            return false;\n        }\n        if (a == null || b == null) {\n            return false;\n        }\n        if (typeof a.equals === 'function' || typeof b.equals === 'function') {\n            return typeof a.equals === 'function' && a.equals(b) && typeof b.equals === 'function' && b.equals(a);\n        }\n        switch (type(a)) {\n        case 'Arguments':\n        case 'Array':\n        case 'Object':\n            break;\n        case 'Boolean':\n        case 'Number':\n        case 'String':\n            if (!(typeof a === typeof b && identical(a.valueOf(), b.valueOf()))) {\n                return false;\n            }\n            break;\n        case 'Date':\n            if (!identical(a.valueOf(), b.valueOf())) {\n                return false;\n            }\n            break;\n        case 'Error':\n            return a.name === b.name && a.message === b.message;\n        case 'RegExp':\n            if (!(a.source === b.source && a.global === b.global && a.ignoreCase === b.ignoreCase && a.multiline === b.multiline && a.sticky === b.sticky && a.unicode === b.unicode)) {\n                return false;\n            }\n            break;\n        case 'Map':\n        case 'Set':\n            if (!_equals(_arrayFromIterator(a.entries()), _arrayFromIterator(b.entries()), stackA, stackB)) {\n                return false;\n            }\n            break;\n        case 'Int8Array':\n        case 'Uint8Array':\n        case 'Uint8ClampedArray':\n        case 'Int16Array':\n        case 'Uint16Array':\n        case 'Int32Array':\n        case 'Uint32Array':\n        case 'Float32Array':\n        case 'Float64Array':\n            break;\n        case 'ArrayBuffer':\n            break;\n        default:\n            // Values of other types are only equal if identical.\n            return false;\n        }\n        var keysA = keys(a);\n        if (keysA.length !== keys(b).length) {\n            return false;\n        }\n        var idx = stackA.length - 1;\n        while (idx >= 0) {\n            if (stackA[idx] === a) {\n                return stackB[idx] === b;\n            }\n            idx -= 1;\n        }\n        stackA.push(a);\n        stackB.push(b);\n        idx = keysA.length - 1;\n        while (idx >= 0) {\n            var key = keysA[idx];\n            if (!(_has(key, b) && _equals(b[key], a[key], stackA, stackB))) {\n                return false;\n            }\n            idx -= 1;\n        }\n        stackA.pop();\n        stackB.pop();\n        return true;\n    };\n\n    /**\n     * `_makeFlat` is a helper function that returns a one-level or fully recursive\n     * function based on the flag passed in.\n     *\n     * @private\n     */\n    var _makeFlat = function _makeFlat(recursive) {\n        return function flatt(list) {\n            var value, jlen, j;\n            var result = [];\n            var idx = 0;\n            var ilen = list.length;\n            while (idx < ilen) {\n                if (isArrayLike(list[idx])) {\n                    value = recursive ? flatt(list[idx]) : list[idx];\n                    j = 0;\n                    jlen = value.length;\n                    while (j < jlen) {\n                        result[result.length] = value[j];\n                        j += 1;\n                    }\n                } else {\n                    result[result.length] = list[idx];\n                }\n                idx += 1;\n            }\n            return result;\n        };\n    };\n\n    var _reduce = function () {\n        function _arrayReduce(xf, acc, list) {\n            var idx = 0;\n            var len = list.length;\n            while (idx < len) {\n                acc = xf['@@transducer/step'](acc, list[idx]);\n                if (acc && acc['@@transducer/reduced']) {\n                    acc = acc['@@transducer/value'];\n                    break;\n                }\n                idx += 1;\n            }\n            return xf['@@transducer/result'](acc);\n        }\n        function _iterableReduce(xf, acc, iter) {\n            var step = iter.next();\n            while (!step.done) {\n                acc = xf['@@transducer/step'](acc, step.value);\n                if (acc && acc['@@transducer/reduced']) {\n                    acc = acc['@@transducer/value'];\n                    break;\n                }\n                step = iter.next();\n            }\n            return xf['@@transducer/result'](acc);\n        }\n        function _methodReduce(xf, acc, obj) {\n            return xf['@@transducer/result'](obj.reduce(bind(xf['@@transducer/step'], xf), acc));\n        }\n        var symIterator = typeof Symbol !== 'undefined' ? Symbol.iterator : '@@iterator';\n        return function _reduce(fn, acc, list) {\n            if (typeof fn === 'function') {\n                fn = _xwrap(fn);\n            }\n            if (isArrayLike(list)) {\n                return _arrayReduce(fn, acc, list);\n            }\n            if (typeof list.reduce === 'function') {\n                return _methodReduce(fn, acc, list);\n            }\n            if (list[symIterator] != null) {\n                return _iterableReduce(fn, acc, list[symIterator]());\n            }\n            if (typeof list.next === 'function') {\n                return _iterableReduce(fn, acc, list);\n            }\n            throw new TypeError('reduce: list must be array or iterable');\n        };\n    }();\n\n    var _xdropLastWhile = function () {\n        function XDropLastWhile(fn, xf) {\n            this.f = fn;\n            this.retained = [];\n            this.xf = xf;\n        }\n        XDropLastWhile.prototype['@@transducer/init'] = _xfBase.init;\n        XDropLastWhile.prototype['@@transducer/result'] = function (result) {\n            this.retained = null;\n            return this.xf['@@transducer/result'](result);\n        };\n        XDropLastWhile.prototype['@@transducer/step'] = function (result, input) {\n            return this.f(input) ? this.retain(result, input) : this.flush(result, input);\n        };\n        XDropLastWhile.prototype.flush = function (result, input) {\n            result = _reduce(this.xf['@@transducer/step'], result, this.retained);\n            this.retained = [];\n            return this.xf['@@transducer/step'](result, input);\n        };\n        XDropLastWhile.prototype.retain = function (result, input) {\n            this.retained.push(input);\n            return result;\n        };\n        return _curry2(function _xdropLastWhile(fn, xf) {\n            return new XDropLastWhile(fn, xf);\n        });\n    }();\n\n    var _xgroupBy = function () {\n        function XGroupBy(f, xf) {\n            this.xf = xf;\n            this.f = f;\n            this.inputs = {};\n        }\n        XGroupBy.prototype['@@transducer/init'] = _xfBase.init;\n        XGroupBy.prototype['@@transducer/result'] = function (result) {\n            var key;\n            for (key in this.inputs) {\n                if (_has(key, this.inputs)) {\n                    result = this.xf['@@transducer/step'](result, this.inputs[key]);\n                    if (result['@@transducer/reduced']) {\n                        result = result['@@transducer/value'];\n                        break;\n                    }\n                }\n            }\n            this.inputs = null;\n            return this.xf['@@transducer/result'](result);\n        };\n        XGroupBy.prototype['@@transducer/step'] = function (result, input) {\n            var key = this.f(input);\n            this.inputs[key] = this.inputs[key] || [\n                key,\n                []\n            ];\n            this.inputs[key][1] = append(input, this.inputs[key][1]);\n            return result;\n        };\n        return _curry2(function _xgroupBy(f, xf) {\n            return new XGroupBy(f, xf);\n        });\n    }();\n\n    /**\n     * Creates a new list iteration function from an existing one by adding two new\n     * parameters to its callback function: the current index, and the entire list.\n     *\n     * This would turn, for instance, Ramda's simple `map` function into one that\n     * more closely resembles `Array.prototype.map`. Note that this will only work\n     * for functions in which the iteration callback function is the first\n     * parameter, and where the list is the last parameter. (This latter might be\n     * unimportant if the list parameter is not used.)\n     *\n     * @func\n     * @memberOf R\n     * @since v0.15.0\n     * @category Function\n     * @category List\n     * @sig ((a ... -> b) ... -> [a] -> *) -> (a ..., Int, [a] -> b) ... -> [a] -> *)\n     * @param {Function} fn A list iteration function that does not pass index or list to its callback\n     * @return {Function} An altered list iteration function that passes (item, index, list) to its callback\n     * @example\n     *\n     *      var mapIndexed = R.addIndex(R.map);\n     *      mapIndexed((val, idx) => idx + '-' + val, ['f', 'o', 'o', 'b', 'a', 'r']);\n     *      //=> ['0-f', '1-o', '2-o', '3-b', '4-a', '5-r']\n     */\n    var addIndex = _curry1(function addIndex(fn) {\n        return curryN(fn.length, function () {\n            var idx = 0;\n            var origFn = arguments[0];\n            var list = arguments[arguments.length - 1];\n            var args = _slice(arguments);\n            args[0] = function () {\n                var result = origFn.apply(this, _concat(arguments, [\n                    idx,\n                    list\n                ]));\n                idx += 1;\n                return result;\n            };\n            return fn.apply(this, args);\n        });\n    });\n\n    /**\n     * Wraps a function of any arity (including nullary) in a function that accepts\n     * exactly 2 parameters. Any extraneous parameters will not be passed to the\n     * supplied function.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.2.0\n     * @category Function\n     * @sig (* -> c) -> (a, b -> c)\n     * @param {Function} fn The function to wrap.\n     * @return {Function} A new function wrapping `fn`. The new function is guaranteed to be of\n     *         arity 2.\n     * @example\n     *\n     *      var takesThreeArgs = function(a, b, c) {\n     *        return [a, b, c];\n     *      };\n     *      takesThreeArgs.length; //=> 3\n     *      takesThreeArgs(1, 2, 3); //=> [1, 2, 3]\n     *\n     *      var takesTwoArgs = R.binary(takesThreeArgs);\n     *      takesTwoArgs.length; //=> 2\n     *      // Only 2 arguments are passed to the wrapped function\n     *      takesTwoArgs(1, 2, 3); //=> [1, 2, undefined]\n     */\n    var binary = _curry1(function binary(fn) {\n        return nAry(2, fn);\n    });\n\n    /**\n     * Creates a deep copy of the value which may contain (nested) `Array`s and\n     * `Object`s, `Number`s, `String`s, `Boolean`s and `Date`s. `Function`s are not\n     * copied, but assigned by their reference.\n     *\n     * Dispatches to a `clone` method if present.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.1.0\n     * @category Object\n     * @sig {*} -> {*}\n     * @param {*} value The object or array to clone\n     * @return {*} A new object or array.\n     * @example\n     *\n     *      var objects = [{}, {}, {}];\n     *      var objectsClone = R.clone(objects);\n     *      objects[0] === objectsClone[0]; //=> false\n     */\n    var clone = _curry1(function clone(value) {\n        return value != null && typeof value.clone === 'function' ? value.clone() : _clone(value, [], []);\n    });\n\n    /**\n     * Returns a curried equivalent of the provided function. The curried function\n     * has two unusual capabilities. First, its arguments needn't be provided one\n     * at a time. If `f` is a ternary function and `g` is `R.curry(f)`, the\n     * following are equivalent:\n     *\n     *   - `g(1)(2)(3)`\n     *   - `g(1)(2, 3)`\n     *   - `g(1, 2)(3)`\n     *   - `g(1, 2, 3)`\n     *\n     * Secondly, the special placeholder value `R.__` may be used to specify\n     * \"gaps\", allowing partial application of any combination of arguments,\n     * regardless of their positions. If `g` is as above and `_` is `R.__`, the\n     * following are equivalent:\n     *\n     *   - `g(1, 2, 3)`\n     *   - `g(_, 2, 3)(1)`\n     *   - `g(_, _, 3)(1)(2)`\n     *   - `g(_, _, 3)(1, 2)`\n     *   - `g(_, 2)(1)(3)`\n     *   - `g(_, 2)(1, 3)`\n     *   - `g(_, 2)(_, 3)(1)`\n     *\n     * @func\n     * @memberOf R\n     * @since v0.1.0\n     * @category Function\n     * @sig (* -> a) -> (* -> a)\n     * @param {Function} fn The function to curry.\n     * @return {Function} A new, curried function.\n     * @see R.curryN\n     * @example\n     *\n     *      var addFourNumbers = (a, b, c, d) => a + b + c + d;\n     *\n     *      var curriedAddFourNumbers = R.curry(addFourNumbers);\n     *      var f = curriedAddFourNumbers(1, 2);\n     *      var g = f(3);\n     *      g(4); //=> 10\n     */\n    var curry = _curry1(function curry(fn) {\n        return curryN(fn.length, fn);\n    });\n\n    /**\n     * Returns all but the first `n` elements of the given list, string, or\n     * transducer/transformer (or object with a `drop` method).\n     *\n     * Dispatches to the `drop` method of the second argument, if present.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.1.0\n     * @category List\n     * @sig Number -> [a] -> [a]\n     * @sig Number -> String -> String\n     * @param {Number} n\n     * @param {*} list\n     * @return {*}\n     * @see R.take, R.transduce\n     * @example\n     *\n     *      R.drop(1, ['foo', 'bar', 'baz']); //=> ['bar', 'baz']\n     *      R.drop(2, ['foo', 'bar', 'baz']); //=> ['baz']\n     *      R.drop(3, ['foo', 'bar', 'baz']); //=> []\n     *      R.drop(4, ['foo', 'bar', 'baz']); //=> []\n     *      R.drop(3, 'ramda');               //=> 'da'\n     */\n    var drop = _curry2(_dispatchable('drop', _xdrop, function drop(n, xs) {\n        return slice(Math.max(0, n), Infinity, xs);\n    }));\n\n    /**\n     * Returns a list containing all but the last `n` elements of the given `list`.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.16.0\n     * @category List\n     * @sig Number -> [a] -> [a]\n     * @sig Number -> String -> String\n     * @param {Number} n The number of elements of `xs` to skip.\n     * @param {Array} xs The collection to consider.\n     * @return {Array}\n     * @see R.takeLast\n     * @example\n     *\n     *      R.dropLast(1, ['foo', 'bar', 'baz']); //=> ['foo', 'bar']\n     *      R.dropLast(2, ['foo', 'bar', 'baz']); //=> ['foo']\n     *      R.dropLast(3, ['foo', 'bar', 'baz']); //=> []\n     *      R.dropLast(4, ['foo', 'bar', 'baz']); //=> []\n     *      R.dropLast(3, 'ramda');               //=> 'ra'\n     */\n    var dropLast = _curry2(_dispatchable('dropLast', _xdropLast, _dropLast));\n\n    /**\n     * Returns a new list containing all but last the`n` elements of a given list,\n     * passing each value from the right to the supplied predicate function,\n     * skipping elements while the predicate function returns `true`. The predicate\n     * function is passed one argument: (value)*.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.16.0\n     * @category List\n     * @sig (a -> Boolean) -> [a] -> [a]\n     * @param {Function} fn The function called per iteration.\n     * @param {Array} list The collection to iterate over.\n     * @return {Array} A new array.\n     * @see R.takeLastWhile, R.addIndex\n     * @example\n     *\n     *      var lteThree = x => x <= 3;\n     *\n     *      R.dropLastWhile(lteThree, [1, 2, 3, 4, 3, 2, 1]); //=> [1, 2, 3, 4]\n     */\n    var dropLastWhile = _curry2(_dispatchable('dropLastWhile', _xdropLastWhile, _dropLastWhile));\n\n    /**\n     * Returns `true` if its arguments are equivalent, `false` otherwise. Handles\n     * cyclical data structures.\n     *\n     * Dispatches symmetrically to the `equals` methods of both arguments, if\n     * present.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.15.0\n     * @category Relation\n     * @sig a -> b -> Boolean\n     * @param {*} a\n     * @param {*} b\n     * @return {Boolean}\n     * @example\n     *\n     *      R.equals(1, 1); //=> true\n     *      R.equals(1, '1'); //=> false\n     *      R.equals([1, 2, 3], [1, 2, 3]); //=> true\n     *\n     *      var a = {}; a.v = a;\n     *      var b = {}; b.v = b;\n     *      R.equals(a, b); //=> true\n     */\n    var equals = _curry2(function equals(a, b) {\n        return _equals(a, b, [], []);\n    });\n\n    /**\n     * Takes a predicate and a \"filterable\", and returns a new filterable of the\n     * same type containing the members of the given filterable which satisfy the\n     * given predicate.\n     *\n     * Dispatches to the `filter` method of the second argument, if present.\n     *\n     * Acts as a transducer if a transformer is given in list position.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.1.0\n     * @category List\n     * @sig Filterable f => (a -> Boolean) -> f a -> f a\n     * @param {Function} pred\n     * @param {Array} filterable\n     * @return {Array}\n     * @see R.reject, R.transduce, R.addIndex\n     * @example\n     *\n     *      var isEven = n => n % 2 === 0;\n     *\n     *      R.filter(isEven, [1, 2, 3, 4]); //=> [2, 4]\n     *\n     *      R.filter(isEven, {a: 1, b: 2, c: 3, d: 4}); //=> {b: 2, d: 4}\n     */\n    // else\n    var filter = _curry2(_dispatchable('filter', _xfilter, function (pred, filterable) {\n        return _isObject(filterable) ? _reduce(function (acc, key) {\n            if (pred(filterable[key])) {\n                acc[key] = filterable[key];\n            }\n            return acc;\n        }, {}, keys(filterable)) : // else\n        _filter(pred, filterable);\n    }));\n\n    /**\n     * Returns a new list by pulling every item out of it (and all its sub-arrays)\n     * and putting them in a new array, depth-first.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.1.0\n     * @category List\n     * @sig [a] -> [b]\n     * @param {Array} list The array to consider.\n     * @return {Array} The flattened list.\n     * @see R.unnest\n     * @example\n     *\n     *      R.flatten([1, 2, [3, 4], 5, [6, [7, 8, [9, [10, 11], 12]]]]);\n     *      //=> [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]\n     */\n    var flatten = _curry1(_makeFlat(true));\n\n    /**\n     * Returns a new function much like the supplied one, except that the first two\n     * arguments' order is reversed.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.1.0\n     * @category Function\n     * @sig (a -> b -> c -> ... -> z) -> (b -> a -> c -> ... -> z)\n     * @param {Function} fn The function to invoke with its first two parameters reversed.\n     * @return {*} The result of invoking `fn` with its first two parameters' order reversed.\n     * @example\n     *\n     *      var mergeThree = (a, b, c) => [].concat(a, b, c);\n     *\n     *      mergeThree(1, 2, 3); //=> [1, 2, 3]\n     *\n     *      R.flip(mergeThree)(1, 2, 3); //=> [2, 1, 3]\n     */\n    var flip = _curry1(function flip(fn) {\n        return curry(function (a, b) {\n            var args = _slice(arguments);\n            args[0] = b;\n            args[1] = a;\n            return fn.apply(this, args);\n        });\n    });\n\n    /**\n     * Splits a list into sub-lists stored in an object, based on the result of\n     * calling a String-returning function on each element, and grouping the\n     * results according to values returned.\n     *\n     * Dispatches to the `groupBy` method of the second argument, if present.\n     *\n     * Acts as a transducer if a transformer is given in list position.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.1.0\n     * @category List\n     * @sig (a -> String) -> [a] -> {String: [a]}\n     * @param {Function} fn Function :: a -> String\n     * @param {Array} list The array to group\n     * @return {Object} An object with the output of `fn` for keys, mapped to arrays of elements\n     *         that produced that key when passed to `fn`.\n     * @see R.transduce\n     * @example\n     *\n     *      var byGrade = R.groupBy(function(student) {\n     *        var score = student.score;\n     *        return score < 65 ? 'F' :\n     *               score < 70 ? 'D' :\n     *               score < 80 ? 'C' :\n     *               score < 90 ? 'B' : 'A';\n     *      });\n     *      var students = [{name: 'Abby', score: 84},\n     *                      {name: 'Eddy', score: 58},\n     *                      // ...\n     *                      {name: 'Jack', score: 69}];\n     *      byGrade(students);\n     *      // {\n     *      //   'A': [{name: 'Dianne', score: 99}],\n     *      //   'B': [{name: 'Abby', score: 84}]\n     *      //   // ...,\n     *      //   'F': [{name: 'Eddy', score: 58}]\n     *      // }\n     */\n    var groupBy = _curry2(_dispatchable('groupBy', _xgroupBy, function groupBy(fn, list) {\n        return _reduce(function (acc, elt) {\n            var key = fn(elt);\n            acc[key] = append(elt, acc[key] || (acc[key] = []));\n            return acc;\n        }, {}, list);\n    }));\n\n    /**\n     * Returns the first element of the given list or string. In some libraries\n     * this function is named `first`.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.1.0\n     * @category List\n     * @sig [a] -> a | Undefined\n     * @sig String -> String\n     * @param {Array|String} list\n     * @return {*}\n     * @see R.tail, R.init, R.last\n     * @example\n     *\n     *      R.head(['fi', 'fo', 'fum']); //=> 'fi'\n     *      R.head([]); //=> undefined\n     *\n     *      R.head('abc'); //=> 'a'\n     *      R.head(''); //=> ''\n     */\n    var head = nth(0);\n\n    /**\n     * Given a function that generates a key, turns a list of objects into an\n     * object indexing the objects by the given key. Note that if multiple\n     * objects generate the same value for the indexing key only the last value\n     * will be included in the generated object.\n     *\n     * @func\n     * @memberOf R\n     * @since 0.19.1\n     * @since 0.19.0\n     * @category List\n     * @sig (a -> String) -> [{k: v}] -> {k: {k: v}}\n     * @param {Function} fn Function :: a -> String\n     * @param {Array} array The array of objects to index\n     * @return {Object} An object indexing each array element by the given property.\n     * @example\n     *\n     *      var list = [{id: 'xyz', title: 'A'}, {id: 'abc', title: 'B'}];\n     *      R.indexBy(R.prop('id'), list);\n     *      //=> {abc: {id: 'abc', title: 'B'}, xyz: {id: 'xyz', title: 'A'}}\n     */\n    var indexBy = _curry2(function indexBy(fn, list) {\n        return _reduce(function (acc, elem) {\n            var key = fn(elem);\n            acc[key] = elem;\n            return acc;\n        }, {}, list);\n    });\n\n    /**\n     * Returns all but the last element of the given list or string.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.9.0\n     * @category List\n     * @sig [a] -> [a]\n     * @sig String -> String\n     * @param {*} list\n     * @return {*}\n     * @see R.last, R.head, R.tail\n     * @example\n     *\n     *      R.init([1, 2, 3]);  //=> [1, 2]\n     *      R.init([1, 2]);     //=> [1]\n     *      R.init([1]);        //=> []\n     *      R.init([]);         //=> []\n     *\n     *      R.init('abc');  //=> 'ab'\n     *      R.init('ab');   //=> 'a'\n     *      R.init('a');    //=> ''\n     *      R.init('');     //=> ''\n     */\n    var init = slice(0, -1);\n\n    /**\n     * Combines two lists into a set (i.e. no duplicates) composed of those\n     * elements common to both lists. Duplication is determined according to the\n     * value returned by applying the supplied predicate to two list elements.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.1.0\n     * @category Relation\n     * @sig (a -> a -> Boolean) -> [*] -> [*] -> [*]\n     * @param {Function} pred A predicate function that determines whether\n     *        the two supplied elements are equal.\n     * @param {Array} list1 One list of items to compare\n     * @param {Array} list2 A second list of items to compare\n     * @return {Array} A new list containing those elements common to both lists.\n     * @see R.intersection\n     * @example\n     *\n     *      var buffaloSpringfield = [\n     *        {id: 824, name: 'Richie Furay'},\n     *        {id: 956, name: 'Dewey Martin'},\n     *        {id: 313, name: 'Bruce Palmer'},\n     *        {id: 456, name: 'Stephen Stills'},\n     *        {id: 177, name: 'Neil Young'}\n     *      ];\n     *      var csny = [\n     *        {id: 204, name: 'David Crosby'},\n     *        {id: 456, name: 'Stephen Stills'},\n     *        {id: 539, name: 'Graham Nash'},\n     *        {id: 177, name: 'Neil Young'}\n     *      ];\n     *\n     *      R.intersectionWith(R.eqBy(R.prop('id')), buffaloSpringfield, csny);\n     *      //=> [{id: 456, name: 'Stephen Stills'}, {id: 177, name: 'Neil Young'}]\n     */\n    var intersectionWith = _curry3(function intersectionWith(pred, list1, list2) {\n        var results = [];\n        var idx = 0;\n        while (idx < list1.length) {\n            if (_containsWith(pred, list1[idx], list2)) {\n                results[results.length] = list1[idx];\n            }\n            idx += 1;\n        }\n        return uniqWith(pred, results);\n    });\n\n    /**\n     * Same as R.invertObj, however this accounts for objects with duplicate values\n     * by putting the values into an array.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.9.0\n     * @category Object\n     * @sig {s: x} -> {x: [ s, ... ]}\n     * @param {Object} obj The object or array to invert\n     * @return {Object} out A new object with keys\n     * in an array.\n     * @example\n     *\n     *      var raceResultsByFirstName = {\n     *        first: 'alice',\n     *        second: 'jake',\n     *        third: 'alice',\n     *      };\n     *      R.invert(raceResultsByFirstName);\n     *      //=> { 'alice': ['first', 'third'], 'jake':['second'] }\n     */\n    var invert = _curry1(function invert(obj) {\n        var props = keys(obj);\n        var len = props.length;\n        var idx = 0;\n        var out = {};\n        while (idx < len) {\n            var key = props[idx];\n            var val = obj[key];\n            var list = _has(val, out) ? out[val] : out[val] = [];\n            list[list.length] = key;\n            idx += 1;\n        }\n        return out;\n    });\n\n    /**\n     * Returns a new object with the keys of the given object as values, and the\n     * values of the given object, which are coerced to strings, as keys. Note\n     * that the last key found is preferred when handling the same value.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.9.0\n     * @category Object\n     * @sig {s: x} -> {x: s}\n     * @param {Object} obj The object or array to invert\n     * @return {Object} out A new object\n     * @example\n     *\n     *      var raceResults = {\n     *        first: 'alice',\n     *        second: 'jake'\n     *      };\n     *      R.invertObj(raceResults);\n     *      //=> { 'alice': 'first', 'jake':'second' }\n     *\n     *      // Alternatively:\n     *      var raceResults = ['alice', 'jake'];\n     *      R.invertObj(raceResults);\n     *      //=> { 'alice': '0', 'jake':'1' }\n     */\n    var invertObj = _curry1(function invertObj(obj) {\n        var props = keys(obj);\n        var len = props.length;\n        var idx = 0;\n        var out = {};\n        while (idx < len) {\n            var key = props[idx];\n            out[obj[key]] = key;\n            idx += 1;\n        }\n        return out;\n    });\n\n    /**\n     * Returns `true` if the given value is its type's empty value; `false`\n     * otherwise.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.1.0\n     * @category Logic\n     * @sig a -> Boolean\n     * @param {*} x\n     * @return {Boolean}\n     * @see R.empty\n     * @example\n     *\n     *      R.isEmpty([1, 2, 3]);   //=> false\n     *      R.isEmpty([]);          //=> true\n     *      R.isEmpty('');          //=> true\n     *      R.isEmpty(null);        //=> false\n     *      R.isEmpty({});          //=> true\n     *      R.isEmpty({length: 0}); //=> false\n     */\n    var isEmpty = _curry1(function isEmpty(x) {\n        return x != null && equals(x, empty(x));\n    });\n\n    /**\n     * Returns the last element of the given list or string.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.1.4\n     * @category List\n     * @sig [a] -> a | Undefined\n     * @sig String -> String\n     * @param {*} list\n     * @return {*}\n     * @see R.init, R.head, R.tail\n     * @example\n     *\n     *      R.last(['fi', 'fo', 'fum']); //=> 'fum'\n     *      R.last([]); //=> undefined\n     *\n     *      R.last('abc'); //=> 'c'\n     *      R.last(''); //=> ''\n     */\n    var last = nth(-1);\n\n    /**\n     * Returns the position of the last occurrence of an item in an array, or -1 if\n     * the item is not included in the array. `R.equals` is used to determine\n     * equality.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.1.0\n     * @category List\n     * @sig a -> [a] -> Number\n     * @param {*} target The item to find.\n     * @param {Array} xs The array to search in.\n     * @return {Number} the index of the target, or -1 if the target is not found.\n     * @see R.indexOf\n     * @example\n     *\n     *      R.lastIndexOf(3, [-1,3,3,0,1,2,3,4]); //=> 6\n     *      R.lastIndexOf(10, [1,2,3,4]); //=> -1\n     */\n    var lastIndexOf = _curry2(function lastIndexOf(target, xs) {\n        if (typeof xs.lastIndexOf === 'function' && !_isArray(xs)) {\n            return xs.lastIndexOf(target);\n        } else {\n            var idx = xs.length - 1;\n            while (idx >= 0) {\n                if (equals(xs[idx], target)) {\n                    return idx;\n                }\n                idx -= 1;\n            }\n            return -1;\n        }\n    });\n\n    /**\n     * Takes a function and\n     * a [functor](https://github.com/fantasyland/fantasy-land#functor),\n     * applies the function to each of the functor's values, and returns\n     * a functor of the same shape.\n     *\n     * Ramda provides suitable `map` implementations for `Array` and `Object`,\n     * so this function may be applied to `[1, 2, 3]` or `{x: 1, y: 2, z: 3}`.\n     *\n     * Dispatches to the `map` method of the second argument, if present.\n     *\n     * Acts as a transducer if a transformer is given in list position.\n     *\n     * Also treats functions as functors and will compose them together.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.1.0\n     * @category List\n     * @sig Functor f => (a -> b) -> f a -> f b\n     * @param {Function} fn The function to be called on every element of the input `list`.\n     * @param {Array} list The list to be iterated over.\n     * @return {Array} The new list.\n     * @see R.transduce, R.addIndex\n     * @example\n     *\n     *      var double = x => x * 2;\n     *\n     *      R.map(double, [1, 2, 3]); //=> [2, 4, 6]\n     *\n     *      R.map(double, {x: 1, y: 2, z: 3}); //=> {x: 2, y: 4, z: 6}\n     */\n    var map = _curry2(_dispatchable('map', _xmap, function map(fn, functor) {\n        switch (Object.prototype.toString.call(functor)) {\n        case '[object Function]':\n            return curryN(functor.length, function () {\n                return fn.call(this, functor.apply(this, arguments));\n            });\n        case '[object Object]':\n            return _reduce(function (acc, key) {\n                acc[key] = fn(functor[key]);\n                return acc;\n            }, {}, keys(functor));\n        default:\n            return _map(fn, functor);\n        }\n    }));\n\n    /**\n     * An Object-specific version of `map`. The function is applied to three\n     * arguments: *(value, key, obj)*. If only the value is significant, use\n     * `map` instead.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.9.0\n     * @category Object\n     * @sig ((*, String, Object) -> *) -> Object -> Object\n     * @param {Function} fn\n     * @param {Object} obj\n     * @return {Object}\n     * @see R.map\n     * @example\n     *\n     *      var values = { x: 1, y: 2, z: 3 };\n     *      var prependKeyAndDouble = (num, key, obj) => key + (num * 2);\n     *\n     *      R.mapObjIndexed(prependKeyAndDouble, values); //=> { x: 'x2', y: 'y4', z: 'z6' }\n     */\n    var mapObjIndexed = _curry2(function mapObjIndexed(fn, obj) {\n        return _reduce(function (acc, key) {\n            acc[key] = fn(obj[key], key, obj);\n            return acc;\n        }, {}, keys(obj));\n    });\n\n    /**\n     * Creates a new object with the own properties of the two provided objects. If\n     * a key exists in both objects, the provided function is applied to the values\n     * associated with the key in each object, with the result being used as the\n     * value associated with the key in the returned object. The key will be\n     * excluded from the returned object if the resulting value is `undefined`.\n     *\n     * @func\n     * @memberOf R\n     * @since 0.19.1\n     * @since 0.19.0\n     * @category Object\n     * @sig (a -> a -> a) -> {a} -> {a} -> {a}\n     * @param {Function} fn\n     * @param {Object} l\n     * @param {Object} r\n     * @return {Object}\n     * @see R.merge, R.mergeWithKey\n     * @example\n     *\n     *      R.mergeWith(R.concat,\n     *                  { a: true, values: [10, 20] },\n     *                  { b: true, values: [15, 35] });\n     *      //=> { a: true, b: true, values: [10, 20, 15, 35] }\n     */\n    var mergeWith = _curry3(function mergeWith(fn, l, r) {\n        return mergeWithKey(function (_, _l, _r) {\n            return fn(_l, _r);\n        }, l, r);\n    });\n\n    /**\n     * Takes a function `f` and a list of arguments, and returns a function `g`.\n     * When applied, `g` returns the result of applying `f` to the arguments\n     * provided initially followed by the arguments provided to `g`.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.10.0\n     * @category Function\n     * @sig ((a, b, c, ..., n) -> x) -> [a, b, c, ...] -> ((d, e, f, ..., n) -> x)\n     * @param {Function} f\n     * @param {Array} args\n     * @return {Function}\n     * @see R.partialRight\n     * @example\n     *\n     *      var multiply = (a, b) => a * b;\n     *      var double = R.partial(multiply, [2]);\n     *      double(2); //=> 4\n     *\n     *      var greet = (salutation, title, firstName, lastName) =>\n     *        salutation + ', ' + title + ' ' + firstName + ' ' + lastName + '!';\n     *\n     *      var sayHello = R.partial(greet, ['Hello']);\n     *      var sayHelloToMs = R.partial(sayHello, ['Ms.']);\n     *      sayHelloToMs('Jane', 'Jones'); //=> 'Hello, Ms. Jane Jones!'\n     */\n    var partial = _createPartialApplicator(_concat);\n\n    /**\n     * Takes a function `f` and a list of arguments, and returns a function `g`.\n     * When applied, `g` returns the result of applying `f` to the arguments\n     * provided to `g` followed by the arguments provided initially.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.10.0\n     * @category Function\n     * @sig ((a, b, c, ..., n) -> x) -> [d, e, f, ..., n] -> ((a, b, c, ...) -> x)\n     * @param {Function} f\n     * @param {Array} args\n     * @return {Function}\n     * @see R.partial\n     * @example\n     *\n     *      var greet = (salutation, title, firstName, lastName) =>\n     *        salutation + ', ' + title + ' ' + firstName + ' ' + lastName + '!';\n     *\n     *      var greetMsJaneJones = R.partialRight(greet, ['Ms.', 'Jane', 'Jones']);\n     *\n     *      greetMsJaneJones('Hello'); //=> 'Hello, Ms. Jane Jones!'\n     */\n    var partialRight = _createPartialApplicator(flip(_concat));\n\n    /**\n     * Takes a predicate and a list and returns the pair of lists of elements which\n     * do and do not satisfy the predicate, respectively.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.1.4\n     * @category List\n     * @sig (a -> Boolean) -> [a] -> [[a],[a]]\n     * @param {Function} pred A predicate to determine which array the element belongs to.\n     * @param {Array} list The array to partition.\n     * @return {Array} A nested array, containing first an array of elements that satisfied the predicate,\n     *         and second an array of elements that did not satisfy.\n     * @see R.filter, R.reject\n     * @example\n     *\n     *      R.partition(R.contains('s'), ['sss', 'ttt', 'foo', 'bars']);\n     *      //=> [ [ 'sss', 'bars' ],  [ 'ttt', 'foo' ] ]\n     */\n    var partition = _curry2(function partition(pred, list) {\n        return _reduce(function (acc, elt) {\n            var xs = acc[pred(elt) ? 0 : 1];\n            xs[xs.length] = elt;\n            return acc;\n        }, [\n            [],\n            []\n        ], list);\n    });\n\n    /**\n     * Determines whether a nested path on an object has a specific value, in\n     * `R.equals` terms. Most likely used to filter a list.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.7.0\n     * @category Relation\n     * @sig [String] -> * -> {String: *} -> Boolean\n     * @param {Array} path The path of the nested property to use\n     * @param {*} val The value to compare the nested property with\n     * @param {Object} obj The object to check the nested property in\n     * @return {Boolean} `true` if the value equals the nested object property,\n     *         `false` otherwise.\n     * @example\n     *\n     *      var user1 = { address: { zipCode: 90210 } };\n     *      var user2 = { address: { zipCode: 55555 } };\n     *      var user3 = { name: 'Bob' };\n     *      var users = [ user1, user2, user3 ];\n     *      var isFamous = R.pathEq(['address', 'zipCode'], 90210);\n     *      R.filter(isFamous, users); //=> [ user1 ]\n     */\n    var pathEq = _curry3(function pathEq(_path, val, obj) {\n        return equals(path(_path, obj), val);\n    });\n\n    /**\n     * Returns a new list by plucking the same named property off all objects in\n     * the list supplied.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.1.0\n     * @category List\n     * @sig k -> [{k: v}] -> [v]\n     * @param {Number|String} key The key name to pluck off of each object.\n     * @param {Array} list The array to consider.\n     * @return {Array} The list of values for the given key.\n     * @see R.props\n     * @example\n     *\n     *      R.pluck('a')([{a: 1}, {a: 2}]); //=> [1, 2]\n     *      R.pluck(0)([[1, 2], [3, 4]]);   //=> [1, 3]\n     */\n    var pluck = _curry2(function pluck(p, list) {\n        return map(prop(p), list);\n    });\n\n    /**\n     * Reasonable analog to SQL `select` statement.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.1.0\n     * @category Object\n     * @category Relation\n     * @sig [k] -> [{k: v}] -> [{k: v}]\n     * @param {Array} props The property names to project\n     * @param {Array} objs The objects to query\n     * @return {Array} An array of objects with just the `props` properties.\n     * @example\n     *\n     *      var abby = {name: 'Abby', age: 7, hair: 'blond', grade: 2};\n     *      var fred = {name: 'Fred', age: 12, hair: 'brown', grade: 7};\n     *      var kids = [abby, fred];\n     *      R.project(['name', 'grade'], kids); //=> [{name: 'Abby', grade: 2}, {name: 'Fred', grade: 7}]\n     */\n    // passing `identity` gives correct arity\n    var project = useWith(_map, [\n        pickAll,\n        identity\n    ]);\n\n    /**\n     * Returns `true` if the specified object property is equal, in `R.equals`\n     * terms, to the given value; `false` otherwise.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.1.0\n     * @category Relation\n     * @sig String -> a -> Object -> Boolean\n     * @param {String} name\n     * @param {*} val\n     * @param {*} obj\n     * @return {Boolean}\n     * @see R.equals, R.propSatisfies\n     * @example\n     *\n     *      var abby = {name: 'Abby', age: 7, hair: 'blond'};\n     *      var fred = {name: 'Fred', age: 12, hair: 'brown'};\n     *      var rusty = {name: 'Rusty', age: 10, hair: 'brown'};\n     *      var alois = {name: 'Alois', age: 15, disposition: 'surly'};\n     *      var kids = [abby, fred, rusty, alois];\n     *      var hasBrownHair = R.propEq('hair', 'brown');\n     *      R.filter(hasBrownHair, kids); //=> [fred, rusty]\n     */\n    var propEq = _curry3(function propEq(name, val, obj) {\n        return propSatisfies(equals(val), name, obj);\n    });\n\n    /**\n     * Returns `true` if the specified object property is of the given type;\n     * `false` otherwise.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.16.0\n     * @category Type\n     * @sig Type -> String -> Object -> Boolean\n     * @param {Function} type\n     * @param {String} name\n     * @param {*} obj\n     * @return {Boolean}\n     * @see R.is, R.propSatisfies\n     * @example\n     *\n     *      R.propIs(Number, 'x', {x: 1, y: 2});  //=> true\n     *      R.propIs(Number, 'x', {x: 'foo'});    //=> false\n     *      R.propIs(Number, 'x', {});            //=> false\n     */\n    var propIs = _curry3(function propIs(type, name, obj) {\n        return propSatisfies(is(type), name, obj);\n    });\n\n    /**\n     * Returns a single item by iterating through the list, successively calling\n     * the iterator function and passing it an accumulator value and the current\n     * value from the array, and then passing the result to the next call.\n     *\n     * The iterator function receives two values: *(acc, value)*. It may use\n     * `R.reduced` to shortcut the iteration.\n     *\n     * Note: `R.reduce` does not skip deleted or unassigned indices (sparse\n     * arrays), unlike the native `Array.prototype.reduce` method. For more details\n     * on this behavior, see:\n     * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce#Description\n     *\n     * Dispatches to the `reduce` method of the third argument, if present.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.1.0\n     * @category List\n     * @sig ((a, b) -> a) -> a -> [b] -> a\n     * @param {Function} fn The iterator function. Receives two values, the accumulator and the\n     *        current element from the array.\n     * @param {*} acc The accumulator value.\n     * @param {Array} list The list to iterate over.\n     * @return {*} The final, accumulated value.\n     * @see R.reduced, R.addIndex\n     * @example\n     *\n     *      var numbers = [1, 2, 3];\n     *      var add = (a, b) => a + b;\n     *\n     *      R.reduce(add, 10, numbers); //=> 16\n     */\n    var reduce = _curry3(_reduce);\n\n    /**\n     * The complement of `filter`.\n     *\n     * Acts as a transducer if a transformer is given in list position.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.1.0\n     * @category List\n     * @sig Filterable f => (a -> Boolean) -> f a -> f a\n     * @param {Function} pred\n     * @param {Array} filterable\n     * @return {Array}\n     * @see R.filter, R.transduce, R.addIndex\n     * @example\n     *\n     *      var isOdd = (n) => n % 2 === 1;\n     *\n     *      R.reject(isOdd, [1, 2, 3, 4]); //=> [2, 4]\n     *\n     *      R.reject(isOdd, {a: 1, b: 2, c: 3, d: 4}); //=> {b: 2, d: 4}\n     */\n    var reject = _curry2(function reject(pred, filterable) {\n        return filter(_complement(pred), filterable);\n    });\n\n    /**\n     * Returns a fixed list of size `n` containing a specified identical value.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.1.1\n     * @category List\n     * @sig a -> n -> [a]\n     * @param {*} value The value to repeat.\n     * @param {Number} n The desired size of the output list.\n     * @return {Array} A new array containing `n` `value`s.\n     * @example\n     *\n     *      R.repeat('hi', 5); //=> ['hi', 'hi', 'hi', 'hi', 'hi']\n     *\n     *      var obj = {};\n     *      var repeatedObjs = R.repeat(obj, 5); //=> [{}, {}, {}, {}, {}]\n     *      repeatedObjs[0] === repeatedObjs[1]; //=> true\n     */\n    var repeat = _curry2(function repeat(value, n) {\n        return times(always(value), n);\n    });\n\n    /**\n     * Adds together all the elements of a list.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.1.0\n     * @category Math\n     * @sig [Number] -> Number\n     * @param {Array} list An array of numbers\n     * @return {Number} The sum of all the numbers in the list.\n     * @see R.reduce\n     * @example\n     *\n     *      R.sum([2,4,6,8,100,1]); //=> 121\n     */\n    var sum = reduce(add, 0);\n\n    /**\n     * Returns a new list containing the last `n` elements of the given list.\n     * If `n > list.length`, returns a list of `list.length` elements.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.16.0\n     * @category List\n     * @sig Number -> [a] -> [a]\n     * @sig Number -> String -> String\n     * @param {Number} n The number of elements to return.\n     * @param {Array} xs The collection to consider.\n     * @return {Array}\n     * @see R.dropLast\n     * @example\n     *\n     *      R.takeLast(1, ['foo', 'bar', 'baz']); //=> ['baz']\n     *      R.takeLast(2, ['foo', 'bar', 'baz']); //=> ['bar', 'baz']\n     *      R.takeLast(3, ['foo', 'bar', 'baz']); //=> ['foo', 'bar', 'baz']\n     *      R.takeLast(4, ['foo', 'bar', 'baz']); //=> ['foo', 'bar', 'baz']\n     *      R.takeLast(3, 'ramda');               //=> 'mda'\n     */\n    var takeLast = _curry2(function takeLast(n, xs) {\n        return drop(n >= 0 ? xs.length - n : 0, xs);\n    });\n\n    /**\n     * Initializes a transducer using supplied iterator function. Returns a single\n     * item by iterating through the list, successively calling the transformed\n     * iterator function and passing it an accumulator value and the current value\n     * from the array, and then passing the result to the next call.\n     *\n     * The iterator function receives two values: *(acc, value)*. It will be\n     * wrapped as a transformer to initialize the transducer. A transformer can be\n     * passed directly in place of an iterator function. In both cases, iteration\n     * may be stopped early with the `R.reduced` function.\n     *\n     * A transducer is a function that accepts a transformer and returns a\n     * transformer and can be composed directly.\n     *\n     * A transformer is an an object that provides a 2-arity reducing iterator\n     * function, step, 0-arity initial value function, init, and 1-arity result\n     * extraction function, result. The step function is used as the iterator\n     * function in reduce. The result function is used to convert the final\n     * accumulator into the return type and in most cases is R.identity. The init\n     * function can be used to provide an initial accumulator, but is ignored by\n     * transduce.\n     *\n     * The iteration is performed with R.reduce after initializing the transducer.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.12.0\n     * @category List\n     * @sig (c -> c) -> (a,b -> a) -> a -> [b] -> a\n     * @param {Function} xf The transducer function. Receives a transformer and returns a transformer.\n     * @param {Function} fn The iterator function. Receives two values, the accumulator and the\n     *        current element from the array. Wrapped as transformer, if necessary, and used to\n     *        initialize the transducer\n     * @param {*} acc The initial accumulator value.\n     * @param {Array} list The list to iterate over.\n     * @return {*} The final, accumulated value.\n     * @see R.reduce, R.reduced, R.into\n     * @example\n     *\n     *      var numbers = [1, 2, 3, 4];\n     *      var transducer = R.compose(R.map(R.add(1)), R.take(2));\n     *\n     *      R.transduce(transducer, R.flip(R.append), [], numbers); //=> [2, 3]\n     */\n    var transduce = curryN(4, function transduce(xf, fn, acc, list) {\n        return _reduce(xf(typeof fn === 'function' ? _xwrap(fn) : fn), acc, list);\n    });\n\n    /**\n     * Combines two lists into a set (i.e. no duplicates) composed of the elements\n     * of each list. Duplication is determined according to the value returned by\n     * applying the supplied predicate to two list elements.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.1.0\n     * @category Relation\n     * @sig (a -> a -> Boolean) -> [*] -> [*] -> [*]\n     * @param {Function} pred A predicate used to test whether two items are equal.\n     * @param {Array} list1 The first list.\n     * @param {Array} list2 The second list.\n     * @return {Array} The first and second lists concatenated, with\n     *         duplicates removed.\n     * @see R.union\n     * @example\n     *\n     *      var l1 = [{a: 1}, {a: 2}];\n     *      var l2 = [{a: 1}, {a: 4}];\n     *      R.unionWith(R.eqBy(R.prop('a')), l1, l2); //=> [{a: 1}, {a: 2}, {a: 4}]\n     */\n    var unionWith = _curry3(function unionWith(pred, list1, list2) {\n        return uniqWith(pred, _concat(list1, list2));\n    });\n\n    /**\n     * Takes a spec object and a test object; returns true if the test satisfies\n     * the spec, false otherwise. An object satisfies the spec if, for each of the\n     * spec's own properties, accessing that property of the object gives the same\n     * value (in `R.equals` terms) as accessing that property of the spec.\n     *\n     * `whereEq` is a specialization of [`where`](#where).\n     *\n     * @func\n     * @memberOf R\n     * @since v0.14.0\n     * @category Object\n     * @sig {String: *} -> {String: *} -> Boolean\n     * @param {Object} spec\n     * @param {Object} testObj\n     * @return {Boolean}\n     * @see R.where\n     * @example\n     *\n     *      // pred :: Object -> Boolean\n     *      var pred = R.whereEq({a: 1, b: 2});\n     *\n     *      pred({a: 1});              //=> false\n     *      pred({a: 1, b: 2});        //=> true\n     *      pred({a: 1, b: 2, c: 3});  //=> true\n     *      pred({a: 1, b: 1});        //=> false\n     */\n    var whereEq = _curry2(function whereEq(spec, testObj) {\n        return where(map(equals, spec), testObj);\n    });\n\n    var _flatCat = function () {\n        var preservingReduced = function (xf) {\n            return {\n                '@@transducer/init': _xfBase.init,\n                '@@transducer/result': function (result) {\n                    return xf['@@transducer/result'](result);\n                },\n                '@@transducer/step': function (result, input) {\n                    var ret = xf['@@transducer/step'](result, input);\n                    return ret['@@transducer/reduced'] ? _forceReduced(ret) : ret;\n                }\n            };\n        };\n        return function _xcat(xf) {\n            var rxf = preservingReduced(xf);\n            return {\n                '@@transducer/init': _xfBase.init,\n                '@@transducer/result': function (result) {\n                    return rxf['@@transducer/result'](result);\n                },\n                '@@transducer/step': function (result, input) {\n                    return !isArrayLike(input) ? _reduce(rxf, result, [input]) : _reduce(rxf, result, input);\n                }\n            };\n        };\n    }();\n\n    // Array.prototype.indexOf doesn't exist below IE9\n    // manually crawl the list to distinguish between +0 and -0\n    // NaN\n    // non-zero numbers can utilise Set\n    // all these types can utilise Set\n    // null can utilise Set\n    // anything else not covered above, defer to R.equals\n    var _indexOf = function _indexOf(list, a, idx) {\n        var inf, item;\n        // Array.prototype.indexOf doesn't exist below IE9\n        if (typeof list.indexOf === 'function') {\n            switch (typeof a) {\n            case 'number':\n                if (a === 0) {\n                    // manually crawl the list to distinguish between +0 and -0\n                    inf = 1 / a;\n                    while (idx < list.length) {\n                        item = list[idx];\n                        if (item === 0 && 1 / item === inf) {\n                            return idx;\n                        }\n                        idx += 1;\n                    }\n                    return -1;\n                } else if (a !== a) {\n                    // NaN\n                    while (idx < list.length) {\n                        item = list[idx];\n                        if (typeof item === 'number' && item !== item) {\n                            return idx;\n                        }\n                        idx += 1;\n                    }\n                    return -1;\n                }\n                // non-zero numbers can utilise Set\n                return list.indexOf(a, idx);\n            // all these types can utilise Set\n            case 'string':\n            case 'boolean':\n            case 'function':\n            case 'undefined':\n                return list.indexOf(a, idx);\n            case 'object':\n                if (a === null) {\n                    // null can utilise Set\n                    return list.indexOf(a, idx);\n                }\n            }\n        }\n        // anything else not covered above, defer to R.equals\n        while (idx < list.length) {\n            if (equals(list[idx], a)) {\n                return idx;\n            }\n            idx += 1;\n        }\n        return -1;\n    };\n\n    var _xchain = _curry2(function _xchain(f, xf) {\n        return map(f, _flatCat(xf));\n    });\n\n    /**\n     * Takes a list of predicates and returns a predicate that returns true for a\n     * given list of arguments if every one of the provided predicates is satisfied\n     * by those arguments.\n     *\n     * The function returned is a curried function whose arity matches that of the\n     * highest-arity predicate.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.9.0\n     * @category Logic\n     * @sig [(*... -> Boolean)] -> (*... -> Boolean)\n     * @param {Array} preds\n     * @return {Function}\n     * @see R.anyPass\n     * @example\n     *\n     *      var isQueen = R.propEq('rank', 'Q');\n     *      var isSpade = R.propEq('suit', '♠︎');\n     *      var isQueenOfSpades = R.allPass([isQueen, isSpade]);\n     *\n     *      isQueenOfSpades({rank: 'Q', suit: '♣︎'}); //=> false\n     *      isQueenOfSpades({rank: 'Q', suit: '♠︎'}); //=> true\n     */\n    var allPass = _curry1(function allPass(preds) {\n        return curryN(reduce(max, 0, pluck('length', preds)), function () {\n            var idx = 0;\n            var len = preds.length;\n            while (idx < len) {\n                if (!preds[idx].apply(this, arguments)) {\n                    return false;\n                }\n                idx += 1;\n            }\n            return true;\n        });\n    });\n\n    /**\n     * Returns `true` if all elements are unique, in `R.equals` terms, otherwise\n     * `false`.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.18.0\n     * @category List\n     * @sig [a] -> Boolean\n     * @param {Array} list The array to consider.\n     * @return {Boolean} `true` if all elements are unique, else `false`.\n     * @example\n     *\n     *      R.allUniq(['1', 1]); //=> true\n     *      R.allUniq([1, 1]);   //=> false\n     *      R.allUniq([[42], [42]]); //=> false\n     */\n    var allUniq = _curry1(function allUniq(list) {\n        var len = list.length;\n        var idx = 0;\n        while (idx < len) {\n            if (_indexOf(list, list[idx], idx + 1) >= 0) {\n                return false;\n            }\n            idx += 1;\n        }\n        return true;\n    });\n\n    /**\n     * Takes a list of predicates and returns a predicate that returns true for a\n     * given list of arguments if at least one of the provided predicates is\n     * satisfied by those arguments.\n     *\n     * The function returned is a curried function whose arity matches that of the\n     * highest-arity predicate.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.9.0\n     * @category Logic\n     * @sig [(*... -> Boolean)] -> (*... -> Boolean)\n     * @param {Array} preds\n     * @return {Function}\n     * @see R.allPass\n     * @example\n     *\n     *      var gte = R.anyPass([R.gt, R.equals]);\n     *\n     *      gte(3, 2); //=> true\n     *      gte(2, 2); //=> true\n     *      gte(2, 3); //=> false\n     */\n    var anyPass = _curry1(function anyPass(preds) {\n        return curryN(reduce(max, 0, pluck('length', preds)), function () {\n            var idx = 0;\n            var len = preds.length;\n            while (idx < len) {\n                if (preds[idx].apply(this, arguments)) {\n                    return true;\n                }\n                idx += 1;\n            }\n            return false;\n        });\n    });\n\n    /**\n     * ap applies a list of functions to a list of values.\n     *\n     * Dispatches to the `ap` method of the second argument, if present. Also\n     * treats functions as applicatives.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.3.0\n     * @category Function\n     * @sig [f] -> [a] -> [f a]\n     * @param {Array} fns An array of functions\n     * @param {Array} vs An array of values\n     * @return {Array} An array of results of applying each of `fns` to all of `vs` in turn.\n     * @example\n     *\n     *      R.ap([R.multiply(2), R.add(3)], [1,2,3]); //=> [2, 4, 6, 4, 5, 6]\n     */\n    // else\n    var ap = _curry2(function ap(applicative, fn) {\n        return typeof applicative.ap === 'function' ? applicative.ap(fn) : typeof applicative === 'function' ? curryN(Math.max(applicative.length, fn.length), function () {\n            return applicative.apply(this, arguments)(fn.apply(this, arguments));\n        }) : // else\n        _reduce(function (acc, f) {\n            return _concat(acc, map(f, fn));\n        }, [], applicative);\n    });\n\n    /**\n     * Returns the result of calling its first argument with the remaining\n     * arguments. This is occasionally useful as a converging function for\n     * `R.converge`: the left branch can produce a function while the right branch\n     * produces a value to be passed to that function as an argument.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.9.0\n     * @category Function\n     * @sig (*... -> a),*... -> a\n     * @param {Function} fn The function to apply to the remaining arguments.\n     * @param {...*} args Any number of positional arguments.\n     * @return {*}\n     * @see R.apply\n     * @example\n     *\n     *      var indentN = R.pipe(R.times(R.always(' ')),\n     *                           R.join(''),\n     *                           R.replace(/^(?!$)/gm));\n     *\n     *      var format = R.converge(R.call, [\n     *                                  R.pipe(R.prop('indent'), indentN),\n     *                                  R.prop('value')\n     *                              ]);\n     *\n     *      format({indent: 2, value: 'foo\\nbar\\nbaz\\n'}); //=> '  foo\\n  bar\\n  baz\\n'\n     */\n    var call = curry(function call(fn) {\n        return fn.apply(this, _slice(arguments, 1));\n    });\n\n    /**\n     * `chain` maps a function over a list and concatenates the results. `chain`\n     * is also known as `flatMap` in some libraries\n     *\n     * Dispatches to the `chain` method of the second argument, if present.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.3.0\n     * @category List\n     * @sig (a -> [b]) -> [a] -> [b]\n     * @param {Function} fn\n     * @param {Array} list\n     * @return {Array}\n     * @example\n     *\n     *      var duplicate = n => [n, n];\n     *      R.chain(duplicate, [1, 2, 3]); //=> [1, 1, 2, 2, 3, 3]\n     */\n    var chain = _curry2(_dispatchable('chain', _xchain, function chain(fn, monad) {\n        if (typeof monad === 'function') {\n            return function () {\n                return monad.call(this, fn.apply(this, arguments)).apply(this, arguments);\n            };\n        }\n        return _makeFlat(false)(map(fn, monad));\n    }));\n\n    /**\n     * Turns a list of Functors into a Functor of a list, applying a mapping\n     * function to the elements of the list along the way.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.8.0\n     * @category List\n     * @sig Functor f => (a -> f b) -> (x -> f x) -> [a] -> f [b]\n     * @param {Function} fn The transformation function\n     * @param {Function} of A function that returns the data type to return\n     * @param {Array} list An array of functors of the same type\n     * @return {*}\n     * @see R.traverse\n     * @deprecated since v0.19.0\n     * @example\n     *\n     *      var add10 = R.map(R.add(10));\n     *      R.commuteMap(add10, R.of, [[1], [2, 3]]);   //=> [[11, 12], [11, 13]]\n     *      R.commuteMap(add10, R.of, [[1, 2], [3]]);   //=> [[11, 13], [12, 13]]\n     *      R.commuteMap(add10, R.of, [[1], [2], [3]]); //=> [[11, 12, 13]]\n     *      R.commuteMap(add10, Maybe.of, [Just(1), Just(2), Just(3)]);   //=> Just([11, 12, 13])\n     *      R.commuteMap(add10, Maybe.of, [Just(1), Just(2), Nothing()]); //=> Nothing()\n     *\n     *      var fetch = url => Future((rej, res) => http.get(url, res).on('error', rej));\n     *      R.commuteMap(fetch, Future.of, [\n     *        'http://ramdajs.com',\n     *        'http://github.com/ramda'\n     *      ]); //=> Future([IncomingMessage, IncomingMessage])\n     */\n    var commuteMap = _curry3(function commuteMap(fn, of, list) {\n        function consF(acc, x) {\n            return ap(map(prepend, fn(x)), acc);\n        }\n        return reduceRight(consF, of([]), list);\n    });\n\n    /**\n     * Wraps a constructor function inside a curried function that can be called\n     * with the same arguments and returns the same type. The arity of the function\n     * returned is specified to allow using variadic constructor functions.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.4.0\n     * @category Function\n     * @sig Number -> (* -> {*}) -> (* -> {*})\n     * @param {Number} n The arity of the constructor function.\n     * @param {Function} Fn The constructor function to wrap.\n     * @return {Function} A wrapped, curried constructor function.\n     * @example\n     *\n     *      // Variadic constructor function\n     *      var Widget = () => {\n     *        this.children = Array.prototype.slice.call(arguments);\n     *        // ...\n     *      };\n     *      Widget.prototype = {\n     *        // ...\n     *      };\n     *      var allConfigs = [\n     *        // ...\n     *      ];\n     *      R.map(R.constructN(1, Widget), allConfigs); // a list of Widgets\n     */\n    var constructN = _curry2(function constructN(n, Fn) {\n        if (n > 10) {\n            throw new Error('Constructor with greater than ten arguments');\n        }\n        if (n === 0) {\n            return function () {\n                return new Fn();\n            };\n        }\n        return curry(nAry(n, function ($0, $1, $2, $3, $4, $5, $6, $7, $8, $9) {\n            switch (arguments.length) {\n            case 1:\n                return new Fn($0);\n            case 2:\n                return new Fn($0, $1);\n            case 3:\n                return new Fn($0, $1, $2);\n            case 4:\n                return new Fn($0, $1, $2, $3);\n            case 5:\n                return new Fn($0, $1, $2, $3, $4);\n            case 6:\n                return new Fn($0, $1, $2, $3, $4, $5);\n            case 7:\n                return new Fn($0, $1, $2, $3, $4, $5, $6);\n            case 8:\n                return new Fn($0, $1, $2, $3, $4, $5, $6, $7);\n            case 9:\n                return new Fn($0, $1, $2, $3, $4, $5, $6, $7, $8);\n            case 10:\n                return new Fn($0, $1, $2, $3, $4, $5, $6, $7, $8, $9);\n            }\n        }));\n    });\n\n    /**\n     * Accepts a converging function and a list of branching functions and returns\n     * a new function. When invoked, this new function is applied to some\n     * arguments, each branching function is applied to those same arguments. The\n     * results of each branching function are passed as arguments to the converging\n     * function to produce the return value.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.4.2\n     * @category Function\n     * @sig (x1 -> x2 -> ... -> z) -> [(a -> b -> ... -> x1), (a -> b -> ... -> x2), ...] -> (a -> b -> ... -> z)\n     * @param {Function} after A function. `after` will be invoked with the return values of\n     *        `fn1` and `fn2` as its arguments.\n     * @param {Array} functions A list of functions.\n     * @return {Function} A new function.\n     * @example\n     *\n     *      var add = (a, b) => a + b;\n     *      var multiply = (a, b) => a * b;\n     *      var subtract = (a, b) => a - b;\n     *\n     *      //≅ multiply( add(1, 2), subtract(1, 2) );\n     *      R.converge(multiply, [add, subtract])(1, 2); //=> -3\n     *\n     *      var add3 = (a, b, c) => a + b + c;\n     *      R.converge(add3, [multiply, add, subtract])(1, 2); //=> 4\n     */\n    var converge = _curry2(function converge(after, fns) {\n        return curryN(Math.max.apply(Math, pluck('length', fns)), function () {\n            var args = arguments;\n            var context = this;\n            return after.apply(context, _map(function (fn) {\n                return fn.apply(context, args);\n            }, fns));\n        });\n    });\n\n    /**\n     * Returns a new list without any consecutively repeating elements. Equality is\n     * determined by applying the supplied predicate two consecutive elements. The\n     * first element in a series of equal element is the one being preserved.\n     *\n     * Dispatches to the `dropRepeatsWith` method of the second argument, if present.\n     *\n     * Acts as a transducer if a transformer is given in list position.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.14.0\n     * @category List\n     * @sig (a, a -> Boolean) -> [a] -> [a]\n     * @param {Function} pred A predicate used to test whether two items are equal.\n     * @param {Array} list The array to consider.\n     * @return {Array} `list` without repeating elements.\n     * @see R.transduce\n     * @example\n     *\n     *      var lengthEq = (x, y) => Math.abs(x) === Math.abs(y);\n     *      var l = [1, -1, 1, 3, 4, -4, -4, -5, 5, 3, 3];\n     *      R.dropRepeatsWith(R.eqBy(Math.abs), l); //=> [1, 3, 4, -5, 3]\n     */\n    var dropRepeatsWith = _curry2(_dispatchable('dropRepeatsWith', _xdropRepeatsWith, function dropRepeatsWith(pred, list) {\n        var result = [];\n        var idx = 1;\n        var len = list.length;\n        if (len !== 0) {\n            result[0] = list[0];\n            while (idx < len) {\n                if (!pred(last(result), list[idx])) {\n                    result[result.length] = list[idx];\n                }\n                idx += 1;\n            }\n        }\n        return result;\n    }));\n\n    /**\n     * Takes a function and two values in its domain and returns `true` if the\n     * values map to the same value in the codomain; `false` otherwise.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.18.0\n     * @category Relation\n     * @sig (a -> b) -> a -> a -> Boolean\n     * @param {Function} f\n     * @param {*} x\n     * @param {*} y\n     * @return {Boolean}\n     * @example\n     *\n     *      R.eqBy(Math.abs, 5, -5); //=> true\n     */\n    var eqBy = _curry3(function eqBy(f, x, y) {\n        return equals(f(x), f(y));\n    });\n\n    /**\n     * Reports whether two objects have the same value, in `R.equals` terms, for\n     * the specified property. Useful as a curried predicate.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.1.0\n     * @category Object\n     * @sig k -> {k: v} -> {k: v} -> Boolean\n     * @param {String} prop The name of the property to compare\n     * @param {Object} obj1\n     * @param {Object} obj2\n     * @return {Boolean}\n     *\n     * @example\n     *\n     *      var o1 = { a: 1, b: 2, c: 3, d: 4 };\n     *      var o2 = { a: 10, b: 20, c: 3, d: 40 };\n     *      R.eqProps('a', o1, o2); //=> false\n     *      R.eqProps('c', o1, o2); //=> true\n     */\n    var eqProps = _curry3(function eqProps(prop, obj1, obj2) {\n        return equals(obj1[prop], obj2[prop]);\n    });\n\n    /**\n     * Returns the position of the first occurrence of an item in an array, or -1\n     * if the item is not included in the array. `R.equals` is used to determine\n     * equality.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.1.0\n     * @category List\n     * @sig a -> [a] -> Number\n     * @param {*} target The item to find.\n     * @param {Array} xs The array to search in.\n     * @return {Number} the index of the target, or -1 if the target is not found.\n     * @see R.lastIndexOf\n     * @example\n     *\n     *      R.indexOf(3, [1,2,3,4]); //=> 2\n     *      R.indexOf(10, [1,2,3,4]); //=> -1\n     */\n    var indexOf = _curry2(function indexOf(target, xs) {\n        return typeof xs.indexOf === 'function' && !_isArray(xs) ? xs.indexOf(target) : _indexOf(xs, target, 0);\n    });\n\n    /**\n     * juxt applies a list of functions to a list of values.\n     *\n     * @func\n     * @memberOf R\n     * @since 0.19.1\n     * @since 0.19.0\n     * @category Function\n     * @sig [(a, b, ..., m) -> n] -> ((a, b, ..., m) -> [n])\n     * @param {Array} fns An array of functions\n     * @return {Function} A function that returns a list of values after applying each of the original `fns` to its parameters.\n     * @example\n     *\n     *      var range = R.juxt([Math.min, Math.max]);\n     *      range(3, 4, 9, -3); //=> [-3, 9]\n     */\n    var juxt = _curry1(function juxt(fns) {\n        return function () {\n            return map(apply(__, arguments), fns);\n        };\n    });\n\n    /**\n     * Returns a lens for the given getter and setter functions. The getter \"gets\"\n     * the value of the focus; the setter \"sets\" the value of the focus. The setter\n     * should not mutate the data structure.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.8.0\n     * @category Object\n     * @typedefn Lens s a = Functor f => (a -> f a) -> s -> f s\n     * @sig (s -> a) -> ((a, s) -> s) -> Lens s a\n     * @param {Function} getter\n     * @param {Function} setter\n     * @return {Lens}\n     * @see R.view, R.set, R.over, R.lensIndex, R.lensProp\n     * @example\n     *\n     *      var xLens = R.lens(R.prop('x'), R.assoc('x'));\n     *\n     *      R.view(xLens, {x: 1, y: 2});            //=> 1\n     *      R.set(xLens, 4, {x: 1, y: 2});          //=> {x: 4, y: 2}\n     *      R.over(xLens, R.negate, {x: 1, y: 2});  //=> {x: -1, y: 2}\n     */\n    var lens = _curry2(function lens(getter, setter) {\n        return function (f) {\n            return function (s) {\n                return map(function (v) {\n                    return setter(v, s);\n                }, f(getter(s)));\n            };\n        };\n    });\n\n    /**\n     * Returns a lens whose focus is the specified index.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.14.0\n     * @category Object\n     * @typedefn Lens s a = Functor f => (a -> f a) -> s -> f s\n     * @sig Number -> Lens s a\n     * @param {Number} n\n     * @return {Lens}\n     * @see R.view, R.set, R.over\n     * @example\n     *\n     *      var headLens = R.lensIndex(0);\n     *\n     *      R.view(headLens, ['a', 'b', 'c']);            //=> 'a'\n     *      R.set(headLens, 'x', ['a', 'b', 'c']);        //=> ['x', 'b', 'c']\n     *      R.over(headLens, R.toUpper, ['a', 'b', 'c']); //=> ['A', 'b', 'c']\n     */\n    var lensIndex = _curry1(function lensIndex(n) {\n        return lens(nth(n), update(n));\n    });\n\n    /**\n     * Returns a lens whose focus is the specified path.\n     *\n     * @func\n     * @memberOf R\n     * @since 0.19.1\n     * @since 0.19.0\n     * @category Object\n     * @typedefn Lens s a = Functor f => (a -> f a) -> s -> f s\n     * @sig [String] -> Lens s a\n     * @param {Array} path The path to use.\n     * @return {Lens}\n     * @see R.view, R.set, R.over\n     * @example\n     *\n     *      var xyLens = R.lensPath(['x', 'y']);\n     *\n     *      R.view(xyLens, {x: {y: 2, z: 3}});            //=> 2\n     *      R.set(xyLens, 4, {x: {y: 2, z: 3}});          //=> {x: {y: 4, z: 3}}\n     *      R.over(xyLens, R.negate, {x: {y: 2, z: 3}});  //=> {x: {y: -2, z: 3}}\n     */\n    var lensPath = _curry1(function lensPath(p) {\n        return lens(path(p), assocPath(p));\n    });\n\n    /**\n     * Returns a lens whose focus is the specified property.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.14.0\n     * @category Object\n     * @typedefn Lens s a = Functor f => (a -> f a) -> s -> f s\n     * @sig String -> Lens s a\n     * @param {String} k\n     * @return {Lens}\n     * @see R.view, R.set, R.over\n     * @example\n     *\n     *      var xLens = R.lensProp('x');\n     *\n     *      R.view(xLens, {x: 1, y: 2});            //=> 1\n     *      R.set(xLens, 4, {x: 1, y: 2});          //=> {x: 4, y: 2}\n     *      R.over(xLens, R.negate, {x: 1, y: 2});  //=> {x: -1, y: 2}\n     */\n    var lensProp = _curry1(function lensProp(k) {\n        return lens(prop(k), assoc(k));\n    });\n\n    /**\n     * \"lifts\" a function to be the specified arity, so that it may \"map over\" that\n     * many lists (or other objects that satisfies the [FantasyLand Apply spec](https://github.com/fantasyland/fantasy-land#apply)).\n     *\n     * @func\n     * @memberOf R\n     * @since v0.7.0\n     * @category Function\n     * @sig Number -> (*... -> *) -> ([*]... -> [*])\n     * @param {Function} fn The function to lift into higher context\n     * @return {Function} The lifted function.\n     * @see R.lift\n     * @example\n     *\n     *      var madd3 = R.liftN(3, R.curryN(3, (...args) => R.sum(args)));\n     *      madd3([1,2,3], [1,2,3], [1]); //=> [3, 4, 5, 4, 5, 6, 5, 6, 7]\n     */\n    var liftN = _curry2(function liftN(arity, fn) {\n        var lifted = curryN(arity, fn);\n        return curryN(arity, function () {\n            return _reduce(ap, map(lifted, arguments[0]), _slice(arguments, 1));\n        });\n    });\n\n    /**\n     * Returns the mean of the given list of numbers.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.14.0\n     * @category Math\n     * @sig [Number] -> Number\n     * @param {Array} list\n     * @return {Number}\n     * @example\n     *\n     *      R.mean([2, 7, 9]); //=> 6\n     *      R.mean([]); //=> NaN\n     */\n    var mean = _curry1(function mean(list) {\n        return sum(list) / list.length;\n    });\n\n    /**\n     * Returns the median of the given list of numbers.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.14.0\n     * @category Math\n     * @sig [Number] -> Number\n     * @param {Array} list\n     * @return {Number}\n     * @example\n     *\n     *      R.median([2, 9, 7]); //=> 7\n     *      R.median([7, 2, 10, 9]); //=> 8\n     *      R.median([]); //=> NaN\n     */\n    var median = _curry1(function median(list) {\n        var len = list.length;\n        if (len === 0) {\n            return NaN;\n        }\n        var width = 2 - len % 2;\n        var idx = (len - width) / 2;\n        return mean(_slice(list).sort(function (a, b) {\n            return a < b ? -1 : a > b ? 1 : 0;\n        }).slice(idx, idx + width));\n    });\n\n    /**\n     * Create a new object with the own properties of the first object merged with\n     * the own properties of the second object. If a key exists in both objects,\n     * the value from the second object will be used.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.1.0\n     * @category Object\n     * @sig {k: v} -> {k: v} -> {k: v}\n     * @param {Object} l\n     * @param {Object} r\n     * @return {Object}\n     * @see R.mergeWith, R.mergeWithKey\n     * @example\n     *\n     *      R.merge({ 'name': 'fred', 'age': 10 }, { 'age': 40 });\n     *      //=> { 'name': 'fred', 'age': 40 }\n     *\n     *      var resetToDefault = R.merge(R.__, {x: 0});\n     *      resetToDefault({x: 5, y: 2}); //=> {x: 0, y: 2}\n     */\n    var merge = mergeWith(function (l, r) {\n        return r;\n    });\n\n    /**\n     * Merges a list of objects together into one object.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.10.0\n     * @category List\n     * @sig [{k: v}] -> {k: v}\n     * @param {Array} list An array of objects\n     * @return {Object} A merged object.\n     * @see R.reduce\n     * @example\n     *\n     *      R.mergeAll([{foo:1},{bar:2},{baz:3}]); //=> {foo:1,bar:2,baz:3}\n     *      R.mergeAll([{foo:1},{foo:2},{bar:2}]); //=> {foo:2,bar:2}\n     */\n    var mergeAll = _curry1(function mergeAll(list) {\n        return reduce(merge, {}, list);\n    });\n\n    /**\n     * Performs left-to-right function composition. The leftmost function may have\n     * any arity; the remaining functions must be unary.\n     *\n     * In some libraries this function is named `sequence`.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.1.0\n     * @category Function\n     * @sig (((a, b, ..., n) -> o), (o -> p), ..., (x -> y), (y -> z)) -> ((a, b, ..., n) -> z)\n     * @param {...Function} functions\n     * @return {Function}\n     * @see R.compose\n     * @example\n     *\n     *      var f = R.pipe(Math.pow, R.negate, R.inc);\n     *\n     *      f(3, 4); // -(3^4) + 1\n     */\n    var pipe = function pipe() {\n        if (arguments.length === 0) {\n            throw new Error('pipe requires at least one argument');\n        }\n        return _arity(arguments[0].length, reduce(_pipe, arguments[0], tail(arguments)));\n    };\n\n    /**\n     * Performs left-to-right composition of one or more Promise-returning\n     * functions. The leftmost function may have any arity; the remaining functions\n     * must be unary.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.10.0\n     * @category Function\n     * @sig ((a -> Promise b), (b -> Promise c), ..., (y -> Promise z)) -> (a -> Promise z)\n     * @param {...Function} functions\n     * @return {Function}\n     * @see R.composeP\n     * @example\n     *\n     *      //  followersForUser :: String -> Promise [User]\n     *      var followersForUser = R.pipeP(db.getUserById, db.getFollowers);\n     */\n    var pipeP = function pipeP() {\n        if (arguments.length === 0) {\n            throw new Error('pipeP requires at least one argument');\n        }\n        return _arity(arguments[0].length, reduce(_pipeP, arguments[0], tail(arguments)));\n    };\n\n    /**\n     * Multiplies together all the elements of a list.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.1.0\n     * @category Math\n     * @sig [Number] -> Number\n     * @param {Array} list An array of numbers\n     * @return {Number} The product of all the numbers in the list.\n     * @see R.reduce\n     * @example\n     *\n     *      R.product([2,4,6,8,100,1]); //=> 38400\n     */\n    var product = reduce(multiply, 1);\n\n    /**\n     * Transforms a [Traversable](https://github.com/fantasyland/fantasy-land#traversable)\n     * of [Applicative](https://github.com/fantasyland/fantasy-land#applicative) into an\n     * Applicative of Traversable.\n     *\n     * Dispatches to the `sequence` method of the second argument, if present.\n     *\n     * @func\n     * @memberOf R\n     * @since 0.19.1\n     * @since 0.19.0\n     * @category List\n     * @sig (Applicative f, Traversable t) => (a -> f a) -> t (f a) -> f (t a)\n     * @param {Function} of\n     * @param {*} traversable\n     * @return {*}\n     * @see R.traverse\n     * @example\n     *\n     *      R.sequence(Maybe.of, [Just(1), Just(2), Just(3)]);   //=> Just([1, 2, 3])\n     *      R.sequence(Maybe.of, [Just(1), Just(2), Nothing()]); //=> Nothing()\n     *\n     *      R.sequence(R.of, Just([1, 2, 3])); //=> [Just(1), Just(2), Just(3)]\n     *      R.sequence(R.of, Nothing());       //=> [Nothing()]\n     */\n    var sequence = _curry2(function sequence(of, traversable) {\n        return typeof traversable.sequence === 'function' ? traversable.sequence(of) : reduceRight(function (acc, x) {\n            return ap(map(prepend, x), acc);\n        }, of([]), traversable);\n    });\n\n    /**\n     * Maps an [Applicative](https://github.com/fantasyland/fantasy-land#applicative)-returning\n     * function over a [Traversable](https://github.com/fantasyland/fantasy-land#traversable),\n     * then uses [`sequence`](#sequence) to transform the resulting Traversable of Applicative\n     * into an Applicative of Traversable.\n     *\n     * Dispatches to the `sequence` method of the third argument, if present.\n     *\n     * @func\n     * @memberOf R\n     * @since 0.19.1\n     * @since 0.19.0\n     * @category List\n     * @sig (Applicative f, Traversable t) => (a -> f a) -> (a -> f b) -> t a -> f (t b)\n     * @param {Function} of\n     * @param {Function} f\n     * @param {*} traversable\n     * @return {*}\n     * @see R.sequence\n     * @example\n     *\n     *      R.traverse(Maybe.of, R.negate, [Just(1), Just(2), Just(3)]);   //=> Just([-1, -2, -3])\n     *      R.traverse(Maybe.of, R.negate, [Just(1), Just(2), Nothing()]); //=> Nothing()\n     *\n     *      R.traverse(R.of, R.negate, Just([1, 2, 3])); //=> [Just(-1), Just(-2), Just(-3)]\n     *      R.traverse(R.of, R.negate, Nothing());       //=> [Nothing()]\n     */\n    var traverse = _curry3(function traverse(of, f, traversable) {\n        return sequence(of, map(f, traversable));\n    });\n\n    /**\n     * Shorthand for `R.chain(R.identity)`, which removes one level of nesting from\n     * any [Chain](https://github.com/fantasyland/fantasy-land#chain).\n     *\n     * @func\n     * @memberOf R\n     * @since v0.3.0\n     * @category List\n     * @sig Chain c => c (c a) -> c a\n     * @param {*} list\n     * @return {*}\n     * @see R.flatten, R.chain\n     * @example\n     *\n     *      R.unnest([1, [2], [[3]]]); //=> [1, 2, [3]]\n     *      R.unnest([[1, 2], [3, 4], [5, 6]]); //=> [1, 2, 3, 4, 5, 6]\n     */\n    var unnest = chain(_identity);\n\n    var _contains = function _contains(a, list) {\n        return _indexOf(list, a, 0) >= 0;\n    };\n\n    var _stepCat = function () {\n        var _stepCatArray = {\n            '@@transducer/init': Array,\n            '@@transducer/step': function (xs, x) {\n                return _concat(xs, [x]);\n            },\n            '@@transducer/result': _identity\n        };\n        var _stepCatString = {\n            '@@transducer/init': String,\n            '@@transducer/step': function (a, b) {\n                return a + b;\n            },\n            '@@transducer/result': _identity\n        };\n        var _stepCatObject = {\n            '@@transducer/init': Object,\n            '@@transducer/step': function (result, input) {\n                return merge(result, isArrayLike(input) ? objOf(input[0], input[1]) : input);\n            },\n            '@@transducer/result': _identity\n        };\n        return function _stepCat(obj) {\n            if (_isTransformer(obj)) {\n                return obj;\n            }\n            if (isArrayLike(obj)) {\n                return _stepCatArray;\n            }\n            if (typeof obj === 'string') {\n                return _stepCatString;\n            }\n            if (typeof obj === 'object') {\n                return _stepCatObject;\n            }\n            throw new Error('Cannot create transformer for ' + obj);\n        };\n    }();\n\n    //  mapPairs :: (Object, [String]) -> [String]\n    var _toString = function _toString(x, seen) {\n        var recur = function recur(y) {\n            var xs = seen.concat([x]);\n            return _contains(y, xs) ? '<Circular>' : _toString(y, xs);\n        };\n        //  mapPairs :: (Object, [String]) -> [String]\n        var mapPairs = function (obj, keys) {\n            return _map(function (k) {\n                return _quote(k) + ': ' + recur(obj[k]);\n            }, keys.slice().sort());\n        };\n        switch (Object.prototype.toString.call(x)) {\n        case '[object Arguments]':\n            return '(function() { return arguments; }(' + _map(recur, x).join(', ') + '))';\n        case '[object Array]':\n            return '[' + _map(recur, x).concat(mapPairs(x, reject(function (k) {\n                return /^\\d+$/.test(k);\n            }, keys(x)))).join(', ') + ']';\n        case '[object Boolean]':\n            return typeof x === 'object' ? 'new Boolean(' + recur(x.valueOf()) + ')' : x.toString();\n        case '[object Date]':\n            return 'new Date(' + (isNaN(x.valueOf()) ? recur(NaN) : _quote(_toISOString(x))) + ')';\n        case '[object Null]':\n            return 'null';\n        case '[object Number]':\n            return typeof x === 'object' ? 'new Number(' + recur(x.valueOf()) + ')' : 1 / x === -Infinity ? '-0' : x.toString(10);\n        case '[object String]':\n            return typeof x === 'object' ? 'new String(' + recur(x.valueOf()) + ')' : _quote(x);\n        case '[object Undefined]':\n            return 'undefined';\n        default:\n            if (typeof x.toString === 'function') {\n                var repr = x.toString();\n                if (repr !== '[object Object]') {\n                    return repr;\n                }\n            }\n            return '{' + mapPairs(x, keys(x)).join(', ') + '}';\n        }\n    };\n\n    /**\n     * Turns a list of Functors into a Functor of a list.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.8.0\n     * @category List\n     * @sig Functor f => (x -> f x) -> [f a] -> f [a]\n     * @param {Function} of A function that returns the data type to return\n     * @param {Array} list An array of functors of the same type\n     * @return {*}\n     * @see R.sequence\n     * @deprecated since v0.19.0\n     * @example\n     *\n     *      R.commute(R.of, [[1], [2, 3]]);   //=> [[1, 2], [1, 3]]\n     *      R.commute(R.of, [[1, 2], [3]]);   //=> [[1, 3], [2, 3]]\n     *      R.commute(R.of, [[1], [2], [3]]); //=> [[1, 2, 3]]\n     *      R.commute(Maybe.of, [Just(1), Just(2), Just(3)]);   //=> Just([1, 2, 3])\n     *      R.commute(Maybe.of, [Just(1), Just(2), Nothing()]); //=> Nothing()\n     */\n    var commute = commuteMap(identity);\n\n    /**\n     * Performs right-to-left function composition. The rightmost function may have\n     * any arity; the remaining functions must be unary.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.1.0\n     * @category Function\n     * @sig ((y -> z), (x -> y), ..., (o -> p), ((a, b, ..., n) -> o)) -> ((a, b, ..., n) -> z)\n     * @param {...Function} functions\n     * @return {Function}\n     * @see R.pipe\n     * @example\n     *\n     *      var f = R.compose(R.inc, R.negate, Math.pow);\n     *\n     *      f(3, 4); // -(3^4) + 1\n     */\n    var compose = function compose() {\n        if (arguments.length === 0) {\n            throw new Error('compose requires at least one argument');\n        }\n        return pipe.apply(this, reverse(arguments));\n    };\n\n    /**\n     * Returns the right-to-left Kleisli composition of the provided functions,\n     * each of which must return a value of a type supported by [`chain`](#chain).\n     *\n     * `R.composeK(h, g, f)` is equivalent to `R.compose(R.chain(h), R.chain(g), R.chain(f))`.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.16.0\n     * @category Function\n     * @sig Chain m => ((y -> m z), (x -> m y), ..., (a -> m b)) -> (m a -> m z)\n     * @param {...Function}\n     * @return {Function}\n     * @see R.pipeK\n     * @example\n     *\n     *      //  parseJson :: String -> Maybe *\n     *      //  get :: String -> Object -> Maybe *\n     *\n     *      //  getStateCode :: Maybe String -> Maybe String\n     *      var getStateCode = R.composeK(\n     *        R.compose(Maybe.of, R.toUpper),\n     *        get('state'),\n     *        get('address'),\n     *        get('user'),\n     *        parseJson\n     *      );\n     *\n     *      getStateCode(Maybe.of('{\"user\":{\"address\":{\"state\":\"ny\"}}}'));\n     *      //=> Just('NY')\n     *      getStateCode(Maybe.of('[Invalid JSON]'));\n     *      //=> Nothing()\n     */\n    var composeK = function composeK() {\n        return compose.apply(this, prepend(identity, map(chain, arguments)));\n    };\n\n    /**\n     * Performs right-to-left composition of one or more Promise-returning\n     * functions. The rightmost function may have any arity; the remaining\n     * functions must be unary.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.10.0\n     * @category Function\n     * @sig ((y -> Promise z), (x -> Promise y), ..., (a -> Promise b)) -> (a -> Promise z)\n     * @param {...Function} functions\n     * @return {Function}\n     * @see R.pipeP\n     * @example\n     *\n     *      //  followersForUser :: String -> Promise [User]\n     *      var followersForUser = R.composeP(db.getFollowers, db.getUserById);\n     */\n    var composeP = function composeP() {\n        if (arguments.length === 0) {\n            throw new Error('composeP requires at least one argument');\n        }\n        return pipeP.apply(this, reverse(arguments));\n    };\n\n    /**\n     * Wraps a constructor function inside a curried function that can be called\n     * with the same arguments and returns the same type.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.1.0\n     * @category Function\n     * @sig (* -> {*}) -> (* -> {*})\n     * @param {Function} Fn The constructor function to wrap.\n     * @return {Function} A wrapped, curried constructor function.\n     * @example\n     *\n     *      // Constructor function\n     *      var Widget = config => {\n     *        // ...\n     *      };\n     *      Widget.prototype = {\n     *        // ...\n     *      };\n     *      var allConfigs = [\n     *        // ...\n     *      ];\n     *      R.map(R.construct(Widget), allConfigs); // a list of Widgets\n     */\n    var construct = _curry1(function construct(Fn) {\n        return constructN(Fn.length, Fn);\n    });\n\n    /**\n     * Returns `true` if the specified value is equal, in `R.equals` terms, to at\n     * least one element of the given list; `false` otherwise.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.1.0\n     * @category List\n     * @sig a -> [a] -> Boolean\n     * @param {Object} a The item to compare against.\n     * @param {Array} list The array to consider.\n     * @return {Boolean} `true` if the item is in the list, `false` otherwise.\n     * @see R.any\n     * @example\n     *\n     *      R.contains(3, [1, 2, 3]); //=> true\n     *      R.contains(4, [1, 2, 3]); //=> false\n     *      R.contains([42], [[42]]); //=> true\n     */\n    var contains = _curry2(_contains);\n\n    /**\n     * Finds the set (i.e. no duplicates) of all elements in the first list not\n     * contained in the second list.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.1.0\n     * @category Relation\n     * @sig [*] -> [*] -> [*]\n     * @param {Array} list1 The first list.\n     * @param {Array} list2 The second list.\n     * @return {Array} The elements in `list1` that are not in `list2`.\n     * @see R.differenceWith\n     * @example\n     *\n     *      R.difference([1,2,3,4], [7,6,5,4,3]); //=> [1,2]\n     *      R.difference([7,6,5,4,3], [1,2,3,4]); //=> [7,6,5]\n     */\n    var difference = _curry2(function difference(first, second) {\n        var out = [];\n        var idx = 0;\n        var firstLen = first.length;\n        while (idx < firstLen) {\n            if (!_contains(first[idx], second) && !_contains(first[idx], out)) {\n                out[out.length] = first[idx];\n            }\n            idx += 1;\n        }\n        return out;\n    });\n\n    /**\n     * Returns a new list without any consecutively repeating elements. `R.equals`\n     * is used to determine equality.\n     *\n     * Dispatches to the `dropRepeats` method of the first argument, if present.\n     *\n     * Acts as a transducer if a transformer is given in list position.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.14.0\n     * @category List\n     * @sig [a] -> [a]\n     * @param {Array} list The array to consider.\n     * @return {Array} `list` without repeating elements.\n     * @see R.transduce\n     * @example\n     *\n     *     R.dropRepeats([1, 1, 1, 2, 3, 4, 4, 2, 2]); //=> [1, 2, 3, 4, 2]\n     */\n    var dropRepeats = _curry1(_dispatchable('dropRepeats', _xdropRepeatsWith(equals), dropRepeatsWith(equals)));\n\n    /**\n     * Transforms the items of the list with the transducer and appends the\n     * transformed items to the accumulator using an appropriate iterator function\n     * based on the accumulator type.\n     *\n     * The accumulator can be an array, string, object or a transformer. Iterated\n     * items will be appended to arrays and concatenated to strings. Objects will\n     * be merged directly or 2-item arrays will be merged as key, value pairs.\n     *\n     * The accumulator can also be a transformer object that provides a 2-arity\n     * reducing iterator function, step, 0-arity initial value function, init, and\n     * 1-arity result extraction function result. The step function is used as the\n     * iterator function in reduce. The result function is used to convert the\n     * final accumulator into the return type and in most cases is R.identity. The\n     * init function is used to provide the initial accumulator.\n     *\n     * The iteration is performed with R.reduce after initializing the transducer.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.12.0\n     * @category List\n     * @sig a -> (b -> b) -> [c] -> a\n     * @param {*} acc The initial accumulator value.\n     * @param {Function} xf The transducer function. Receives a transformer and returns a transformer.\n     * @param {Array} list The list to iterate over.\n     * @return {*} The final, accumulated value.\n     * @example\n     *\n     *      var numbers = [1, 2, 3, 4];\n     *      var transducer = R.compose(R.map(R.add(1)), R.take(2));\n     *\n     *      R.into([], transducer, numbers); //=> [2, 3]\n     *\n     *      var intoArray = R.into([]);\n     *      intoArray(transducer, numbers); //=> [2, 3]\n     */\n    var into = _curry3(function into(acc, xf, list) {\n        return _isTransformer(acc) ? _reduce(xf(acc), acc['@@transducer/init'](), list) : _reduce(xf(_stepCat(acc)), acc, list);\n    });\n\n    /**\n     * \"lifts\" a function of arity > 1 so that it may \"map over\" an Array or other\n     * object that satisfies the [FantasyLand Apply spec](https://github.com/fantasyland/fantasy-land#apply).\n     *\n     * @func\n     * @memberOf R\n     * @since v0.7.0\n     * @category Function\n     * @sig (*... -> *) -> ([*]... -> [*])\n     * @param {Function} fn The function to lift into higher context\n     * @return {Function} The lifted function.\n     * @see R.liftN\n     * @example\n     *\n     *      var madd3 = R.lift(R.curry((a, b, c) => a + b + c));\n     *\n     *      madd3([1,2,3], [1,2,3], [1]); //=> [3, 4, 5, 4, 5, 6, 5, 6, 7]\n     *\n     *      var madd5 = R.lift(R.curry((a, b, c, d, e) => a + b + c + d + e));\n     *\n     *      madd5([1,2], [3], [4, 5], [6], [7, 8]); //=> [21, 22, 22, 23, 22, 23, 23, 24]\n     */\n    var lift = _curry1(function lift(fn) {\n        return liftN(fn.length, fn);\n    });\n\n    /**\n     * Returns a partial copy of an object omitting the keys specified.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.1.0\n     * @category Object\n     * @sig [String] -> {String: *} -> {String: *}\n     * @param {Array} names an array of String property names to omit from the new object\n     * @param {Object} obj The object to copy from\n     * @return {Object} A new object with properties from `names` not on it.\n     * @see R.pick\n     * @example\n     *\n     *      R.omit(['a', 'd'], {a: 1, b: 2, c: 3, d: 4}); //=> {b: 2, c: 3}\n     */\n    var omit = _curry2(function omit(names, obj) {\n        var result = {};\n        for (var prop in obj) {\n            if (!_contains(prop, names)) {\n                result[prop] = obj[prop];\n            }\n        }\n        return result;\n    });\n\n    /**\n     * Returns the left-to-right Kleisli composition of the provided functions,\n     * each of which must return a value of a type supported by [`chain`](#chain).\n     *\n     * `R.pipeK(f, g, h)` is equivalent to `R.pipe(R.chain(f), R.chain(g), R.chain(h))`.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.16.0\n     * @category Function\n     * @sig Chain m => ((a -> m b), (b -> m c), ..., (y -> m z)) -> (m a -> m z)\n     * @param {...Function}\n     * @return {Function}\n     * @see R.composeK\n     * @example\n     *\n     *      //  parseJson :: String -> Maybe *\n     *      //  get :: String -> Object -> Maybe *\n     *\n     *      //  getStateCode :: Maybe String -> Maybe String\n     *      var getStateCode = R.pipeK(\n     *        parseJson,\n     *        get('user'),\n     *        get('address'),\n     *        get('state'),\n     *        R.compose(Maybe.of, R.toUpper)\n     *      );\n     *\n     *      getStateCode(Maybe.of('{\"user\":{\"address\":{\"state\":\"ny\"}}}'));\n     *      //=> Just('NY')\n     *      getStateCode(Maybe.of('[Invalid JSON]'));\n     *      //=> Nothing()\n     */\n    var pipeK = function pipeK() {\n        return composeK.apply(this, reverse(arguments));\n    };\n\n    /**\n     * Returns the string representation of the given value. `eval`'ing the output\n     * should result in a value equivalent to the input value. Many of the built-in\n     * `toString` methods do not satisfy this requirement.\n     *\n     * If the given value is an `[object Object]` with a `toString` method other\n     * than `Object.prototype.toString`, this method is invoked with no arguments\n     * to produce the return value. This means user-defined constructor functions\n     * can provide a suitable `toString` method. For example:\n     *\n     *     function Point(x, y) {\n     *       this.x = x;\n     *       this.y = y;\n     *     }\n     *\n     *     Point.prototype.toString = function() {\n     *       return 'new Point(' + this.x + ', ' + this.y + ')';\n     *     };\n     *\n     *     R.toString(new Point(1, 2)); //=> 'new Point(1, 2)'\n     *\n     * @func\n     * @memberOf R\n     * @since v0.14.0\n     * @category String\n     * @sig * -> String\n     * @param {*} val\n     * @return {String}\n     * @example\n     *\n     *      R.toString(42); //=> '42'\n     *      R.toString('abc'); //=> '\"abc\"'\n     *      R.toString([1, 2, 3]); //=> '[1, 2, 3]'\n     *      R.toString({foo: 1, bar: 2, baz: 3}); //=> '{\"bar\": 2, \"baz\": 3, \"foo\": 1}'\n     *      R.toString(new Date('2001-02-03T04:05:06Z')); //=> 'new Date(\"2001-02-03T04:05:06.000Z\")'\n     */\n    var toString = _curry1(function toString(val) {\n        return _toString(val, []);\n    });\n\n    /**\n     * Returns a new list containing only one copy of each element in the original\n     * list, based upon the value returned by applying the supplied function to\n     * each list element. Prefers the first item if the supplied function produces\n     * the same value on two items. `R.equals` is used for comparison.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.16.0\n     * @category List\n     * @sig (a -> b) -> [a] -> [a]\n     * @param {Function} fn A function used to produce a value to use during comparisons.\n     * @param {Array} list The array to consider.\n     * @return {Array} The list of unique items.\n     * @example\n     *\n     *      R.uniqBy(Math.abs, [-1, -5, 2, 10, 1, 2]); //=> [-1, -5, 2, 10]\n     */\n    /* globals Set */\n    // distinguishing between +0 and -0 is not supported by Set\n    /* falls through */\n    // these types can all utilise Set\n    // prevent scan for null by tracking as a boolean\n    /* falls through */\n    // scan through all previously applied items\n    var uniqBy = _curry2(/* globals Set */\n    typeof Set === 'undefined' ? function uniqBy(fn, list) {\n        var idx = 0;\n        var applied = [];\n        var result = [];\n        var appliedItem, item;\n        while (idx < list.length) {\n            item = list[idx];\n            appliedItem = fn(item);\n            if (!_contains(appliedItem, applied)) {\n                result.push(item);\n                applied.push(appliedItem);\n            }\n            idx += 1;\n        }\n        return result;\n    } : function uniqBySet(fn, list) {\n        var set = new Set();\n        var applied = [];\n        var prevSetSize = 0;\n        var result = [];\n        var nullExists = false;\n        var negZeroExists = false;\n        var idx = 0;\n        var appliedItem, item, newSetSize;\n        while (idx < list.length) {\n            item = list[idx];\n            appliedItem = fn(item);\n            switch (typeof appliedItem) {\n            case 'number':\n                // distinguishing between +0 and -0 is not supported by Set\n                if (appliedItem === 0 && !negZeroExists && 1 / appliedItem === -Infinity) {\n                    negZeroExists = true;\n                    result.push(item);\n                    break;\n                }\n            /* falls through */\n            case 'string':\n            case 'boolean':\n            case 'function':\n            case 'undefined':\n                // these types can all utilise Set\n                set.add(appliedItem);\n                newSetSize = set.size;\n                if (newSetSize > prevSetSize) {\n                    result.push(item);\n                    prevSetSize = newSetSize;\n                }\n                break;\n            case 'object':\n                if (appliedItem === null) {\n                    if (!nullExists) {\n                        // prevent scan for null by tracking as a boolean\n                        nullExists = true;\n                        result.push(null);\n                    }\n                    break;\n                }\n            /* falls through */\n            default:\n                // scan through all previously applied items\n                if (!_contains(appliedItem, applied)) {\n                    applied.push(appliedItem);\n                    result.push(item);\n                }\n            }\n            idx += 1;\n        }\n        return result;\n    });\n\n    /**\n     * Returns a new list without values in the first argument.\n     * `R.equals` is used to determine equality.\n     *\n     * Acts as a transducer if a transformer is given in list position.\n     *\n     * @func\n     * @memberOf R\n     * @since 0.19.1\n     * @since 0.19.0\n     * @category List\n     * @sig [a] -> [a] -> [a]\n     * @param {Array} list1 The values to be removed from `list2`.\n     * @param {Array} list2 The array to remove values from.\n     * @return {Array} The new array without values in `list1`.\n     * @see R.transduce\n     * @example\n     *\n     *      R.without([1, 2], [1, 2, 1, 3, 4]); //=> [3, 4]\n     */\n    var without = _curry2(function (xs, list) {\n        return reject(flip(_contains)(xs), list);\n    });\n\n    /**\n     * Takes a function `f` and returns a function `g` such that:\n     *\n     *   - applying `g` to zero or more arguments will give __true__ if applying\n     *     the same arguments to `f` gives a logical __false__ value; and\n     *\n     *   - applying `g` to zero or more arguments will give __false__ if applying\n     *     the same arguments to `f` gives a logical __true__ value.\n     *\n     * `R.complement` will work on all other functors as well.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.12.0\n     * @category Logic\n     * @sig (*... -> *) -> (*... -> Boolean)\n     * @param {Function} f\n     * @return {Function}\n     * @see R.not\n     * @example\n     *\n     *      var isEven = n => n % 2 === 0;\n     *      var isOdd = R.complement(isEven);\n     *      isOdd(21); //=> true\n     *      isOdd(42); //=> false\n     */\n    var complement = lift(not);\n\n    /**\n     * Turns a named method with a specified arity into a function that can be\n     * called directly supplied with arguments and a target object.\n     *\n     * The returned function is curried and accepts `arity + 1` parameters where\n     * the final parameter is the target object.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.1.0\n     * @category Function\n     * @sig Number -> String -> (a -> b -> ... -> n -> Object -> *)\n     * @param {Number} arity Number of arguments the returned function should take\n     *        before the target object.\n     * @param {String} method Name of the method to call.\n     * @return {Function} A new curried function.\n     * @example\n     *\n     *      var sliceFrom = R.invoker(1, 'slice');\n     *      sliceFrom(6, 'abcdefghijklm'); //=> 'ghijklm'\n     *      var sliceFrom6 = R.invoker(2, 'slice')(6);\n     *      sliceFrom6(8, 'abcdefghijklm'); //=> 'gh'\n     */\n    var invoker = _curry2(function invoker(arity, method) {\n        return curryN(arity + 1, function () {\n            var target = arguments[arity];\n            if (target != null && is(Function, target[method])) {\n                return target[method].apply(target, _slice(arguments, 0, arity));\n            }\n            throw new TypeError(toString(target) + ' does not have a method named \"' + method + '\"');\n        });\n    });\n\n    /**\n     * Returns a string made by inserting the `separator` between each element and\n     * concatenating all the elements into a single string.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.1.0\n     * @category List\n     * @sig String -> [a] -> String\n     * @param {Number|String} separator The string used to separate the elements.\n     * @param {Array} xs The elements to join into a string.\n     * @return {String} str The string made by concatenating `xs` with `separator`.\n     * @see R.split\n     * @example\n     *\n     *      var spacer = R.join(' ');\n     *      spacer(['a', 2, 3.4]);   //=> 'a 2 3.4'\n     *      R.join('|', [1, 2, 3]);    //=> '1|2|3'\n     */\n    var join = invoker(1, 'join');\n\n    /**\n     * Creates a new function that, when invoked, caches the result of calling `fn`\n     * for a given argument set and returns the result. Subsequent calls to the\n     * memoized `fn` with the same argument set will not result in an additional\n     * call to `fn`; instead, the cached result for that set of arguments will be\n     * returned.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.1.0\n     * @category Function\n     * @sig (*... -> a) -> (*... -> a)\n     * @param {Function} fn The function to memoize.\n     * @return {Function} Memoized version of `fn`.\n     * @example\n     *\n     *      var count = 0;\n     *      var factorial = R.memoize(n => {\n     *        count += 1;\n     *        return R.product(R.range(1, n + 1));\n     *      });\n     *      factorial(5); //=> 120\n     *      factorial(5); //=> 120\n     *      factorial(5); //=> 120\n     *      count; //=> 1\n     */\n    var memoize = _curry1(function memoize(fn) {\n        var cache = {};\n        return _arity(fn.length, function () {\n            var key = toString(arguments);\n            if (!_has(key, cache)) {\n                cache[key] = fn.apply(this, arguments);\n            }\n            return cache[key];\n        });\n    });\n\n    /**\n     * Splits a string into an array of strings based on the given\n     * separator.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.1.0\n     * @category String\n     * @sig (String | RegExp) -> String -> [String]\n     * @param {String|RegExp} sep The pattern.\n     * @param {String} str The string to separate into an array.\n     * @return {Array} The array of strings from `str` separated by `str`.\n     * @see R.join\n     * @example\n     *\n     *      var pathComponents = R.split('/');\n     *      R.tail(pathComponents('/usr/local/bin/node')); //=> ['usr', 'local', 'bin', 'node']\n     *\n     *      R.split('.', 'a.b.c.xyz.d'); //=> ['a', 'b', 'c', 'xyz', 'd']\n     */\n    var split = invoker(1, 'split');\n\n    /**\n     * Determines whether a given string matches a given regular expression.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.12.0\n     * @category String\n     * @sig RegExp -> String -> Boolean\n     * @param {RegExp} pattern\n     * @param {String} str\n     * @return {Boolean}\n     * @see R.match\n     * @example\n     *\n     *      R.test(/^x/, 'xyz'); //=> true\n     *      R.test(/^y/, 'xyz'); //=> false\n     */\n    var test = _curry2(function test(pattern, str) {\n        if (!_isRegExp(pattern)) {\n            throw new TypeError('\\u2018test\\u2019 requires a value of type RegExp as its first argument; received ' + toString(pattern));\n        }\n        return _cloneRegExp(pattern).test(str);\n    });\n\n    /**\n     * The lower case version of a string.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.9.0\n     * @category String\n     * @sig String -> String\n     * @param {String} str The string to lower case.\n     * @return {String} The lower case version of `str`.\n     * @see R.toUpper\n     * @example\n     *\n     *      R.toLower('XYZ'); //=> 'xyz'\n     */\n    var toLower = invoker(0, 'toLowerCase');\n\n    /**\n     * The upper case version of a string.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.9.0\n     * @category String\n     * @sig String -> String\n     * @param {String} str The string to upper case.\n     * @return {String} The upper case version of `str`.\n     * @see R.toLower\n     * @example\n     *\n     *      R.toUpper('abc'); //=> 'ABC'\n     */\n    var toUpper = invoker(0, 'toUpperCase');\n\n    /**\n     * Returns a new list containing only one copy of each element in the original\n     * list. `R.equals` is used to determine equality.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.1.0\n     * @category List\n     * @sig [a] -> [a]\n     * @param {Array} list The array to consider.\n     * @return {Array} The list of unique items.\n     * @example\n     *\n     *      R.uniq([1, 1, 2, 1]); //=> [1, 2]\n     *      R.uniq([1, '1']);     //=> [1, '1']\n     *      R.uniq([[42], [42]]); //=> [[42]]\n     */\n    var uniq = uniqBy(identity);\n\n    /**\n     * Returns the result of concatenating the given lists or strings.\n     *\n     * Dispatches to the `concat` method of the second argument, if present.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.1.0\n     * @category List\n     * @sig [a] -> [a] -> [a]\n     * @sig String -> String -> String\n     * @param {Array|String} a\n     * @param {Array|String} b\n     * @return {Array|String}\n     *\n     * @example\n     *\n     *      R.concat([], []); //=> []\n     *      R.concat([4, 5, 6], [1, 2, 3]); //=> [4, 5, 6, 1, 2, 3]\n     *      R.concat('ABC', 'DEF'); // 'ABCDEF'\n     */\n    var concat = flip(invoker(1, 'concat'));\n\n    /**\n     * Combines two lists into a set (i.e. no duplicates) composed of those\n     * elements common to both lists.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.1.0\n     * @category Relation\n     * @sig [*] -> [*] -> [*]\n     * @param {Array} list1 The first list.\n     * @param {Array} list2 The second list.\n     * @return {Array} The list of elements found in both `list1` and `list2`.\n     * @see R.intersectionWith\n     * @example\n     *\n     *      R.intersection([1,2,3,4], [7,6,5,4,3]); //=> [4, 3]\n     */\n    var intersection = _curry2(function intersection(list1, list2) {\n        return uniq(_filter(flip(_contains)(list1), list2));\n    });\n\n    /**\n     * Finds the set (i.e. no duplicates) of all elements contained in the first or\n     * second list, but not both.\n     *\n     * @func\n     * @memberOf R\n     * @since 0.19.1\n     * @since 0.19.0\n     * @category Relation\n     * @sig [*] -> [*] -> [*]\n     * @param {Array} list1 The first list.\n     * @param {Array} list2 The second list.\n     * @return {Array} The elements in `list1` or `list2`, but not both.\n     * @see R.symmetricDifferenceWith\n     * @example\n     *\n     *      R.symmetricDifference([1,2,3,4], [7,6,5,4,3]); //=> [1,2,7,6,5]\n     *      R.symmetricDifference([7,6,5,4,3], [1,2,3,4]); //=> [7,6,5,1,2]\n     */\n    var symmetricDifference = _curry2(function symmetricDifference(list1, list2) {\n        return concat(difference(list1, list2), difference(list2, list1));\n    });\n\n    /**\n     * Finds the set (i.e. no duplicates) of all elements contained in the first or\n     * second list, but not both. Duplication is determined according to the value\n     * returned by applying the supplied predicate to two list elements.\n     *\n     * @func\n     * @memberOf R\n     * @since 0.19.1\n     * @since 0.19.0\n     * @category Relation\n     * @sig (a -> a -> Boolean) -> [a] -> [a] -> [a]\n     * @param {Function} pred A predicate used to test whether two items are equal.\n     * @param {Array} list1 The first list.\n     * @param {Array} list2 The second list.\n     * @return {Array} The elements in `list1` or `list2`, but not both.\n     * @see R.symmetricDifference\n     * @example\n     *\n     *      var eqA = R.eqBy(R.prop('a'));\n     *      var l1 = [{a: 1}, {a: 2}, {a: 3}, {a: 4}];\n     *      var l2 = [{a: 3}, {a: 4}, {a: 5}, {a: 6}];\n     *      R.symmetricDifferenceWith(eqA, l1, l2); //=> [{a: 1}, {a: 2}, {a: 5}, {a: 6}]\n     */\n    var symmetricDifferenceWith = _curry3(function symmetricDifferenceWith(pred, list1, list2) {\n        return concat(differenceWith(pred, list1, list2), differenceWith(pred, list2, list1));\n    });\n\n    /**\n     * Combines two lists into a set (i.e. no duplicates) composed of the elements\n     * of each list.\n     *\n     * @func\n     * @memberOf R\n     * @since v0.1.0\n     * @category Relation\n     * @sig [*] -> [*] -> [*]\n     * @param {Array} as The first list.\n     * @param {Array} bs The second list.\n     * @return {Array} The first and second lists concatenated, with\n     *         duplicates removed.\n     * @example\n     *\n     *      R.union([1, 2, 3], [2, 3, 4]); //=> [1, 2, 3, 4]\n     */\n    var union = _curry2(compose(uniq, _concat));\n\n    var R = {\n        F: F,\n        T: T,\n        __: __,\n        add: add,\n        addIndex: addIndex,\n        adjust: adjust,\n        all: all,\n        allPass: allPass,\n        allUniq: allUniq,\n        always: always,\n        and: and,\n        any: any,\n        anyPass: anyPass,\n        ap: ap,\n        aperture: aperture,\n        append: append,\n        apply: apply,\n        assoc: assoc,\n        assocPath: assocPath,\n        binary: binary,\n        bind: bind,\n        both: both,\n        call: call,\n        chain: chain,\n        clone: clone,\n        commute: commute,\n        commuteMap: commuteMap,\n        comparator: comparator,\n        complement: complement,\n        compose: compose,\n        composeK: composeK,\n        composeP: composeP,\n        concat: concat,\n        cond: cond,\n        construct: construct,\n        constructN: constructN,\n        contains: contains,\n        converge: converge,\n        countBy: countBy,\n        curry: curry,\n        curryN: curryN,\n        dec: dec,\n        defaultTo: defaultTo,\n        difference: difference,\n        differenceWith: differenceWith,\n        dissoc: dissoc,\n        dissocPath: dissocPath,\n        divide: divide,\n        drop: drop,\n        dropLast: dropLast,\n        dropLastWhile: dropLastWhile,\n        dropRepeats: dropRepeats,\n        dropRepeatsWith: dropRepeatsWith,\n        dropWhile: dropWhile,\n        either: either,\n        empty: empty,\n        eqBy: eqBy,\n        eqProps: eqProps,\n        equals: equals,\n        evolve: evolve,\n        filter: filter,\n        find: find,\n        findIndex: findIndex,\n        findLast: findLast,\n        findLastIndex: findLastIndex,\n        flatten: flatten,\n        flip: flip,\n        forEach: forEach,\n        fromPairs: fromPairs,\n        groupBy: groupBy,\n        gt: gt,\n        gte: gte,\n        has: has,\n        hasIn: hasIn,\n        head: head,\n        identical: identical,\n        identity: identity,\n        ifElse: ifElse,\n        inc: inc,\n        indexBy: indexBy,\n        indexOf: indexOf,\n        init: init,\n        insert: insert,\n        insertAll: insertAll,\n        intersection: intersection,\n        intersectionWith: intersectionWith,\n        intersperse: intersperse,\n        into: into,\n        invert: invert,\n        invertObj: invertObj,\n        invoker: invoker,\n        is: is,\n        isArrayLike: isArrayLike,\n        isEmpty: isEmpty,\n        isNil: isNil,\n        join: join,\n        juxt: juxt,\n        keys: keys,\n        keysIn: keysIn,\n        last: last,\n        lastIndexOf: lastIndexOf,\n        length: length,\n        lens: lens,\n        lensIndex: lensIndex,\n        lensPath: lensPath,\n        lensProp: lensProp,\n        lift: lift,\n        liftN: liftN,\n        lt: lt,\n        lte: lte,\n        map: map,\n        mapAccum: mapAccum,\n        mapAccumRight: mapAccumRight,\n        mapObjIndexed: mapObjIndexed,\n        match: match,\n        mathMod: mathMod,\n        max: max,\n        maxBy: maxBy,\n        mean: mean,\n        median: median,\n        memoize: memoize,\n        merge: merge,\n        mergeAll: mergeAll,\n        mergeWith: mergeWith,\n        mergeWithKey: mergeWithKey,\n        min: min,\n        minBy: minBy,\n        modulo: modulo,\n        multiply: multiply,\n        nAry: nAry,\n        negate: negate,\n        none: none,\n        not: not,\n        nth: nth,\n        nthArg: nthArg,\n        objOf: objOf,\n        of: of,\n        omit: omit,\n        once: once,\n        or: or,\n        over: over,\n        pair: pair,\n        partial: partial,\n        partialRight: partialRight,\n        partition: partition,\n        path: path,\n        pathEq: pathEq,\n        pathOr: pathOr,\n        pathSatisfies: pathSatisfies,\n        pick: pick,\n        pickAll: pickAll,\n        pickBy: pickBy,\n        pipe: pipe,\n        pipeK: pipeK,\n        pipeP: pipeP,\n        pluck: pluck,\n        prepend: prepend,\n        product: product,\n        project: project,\n        prop: prop,\n        propEq: propEq,\n        propIs: propIs,\n        propOr: propOr,\n        propSatisfies: propSatisfies,\n        props: props,\n        range: range,\n        reduce: reduce,\n        reduceRight: reduceRight,\n        reduced: reduced,\n        reject: reject,\n        remove: remove,\n        repeat: repeat,\n        replace: replace,\n        reverse: reverse,\n        scan: scan,\n        sequence: sequence,\n        set: set,\n        slice: slice,\n        sort: sort,\n        sortBy: sortBy,\n        split: split,\n        splitAt: splitAt,\n        splitEvery: splitEvery,\n        splitWhen: splitWhen,\n        subtract: subtract,\n        sum: sum,\n        symmetricDifference: symmetricDifference,\n        symmetricDifferenceWith: symmetricDifferenceWith,\n        tail: tail,\n        take: take,\n        takeLast: takeLast,\n        takeLastWhile: takeLastWhile,\n        takeWhile: takeWhile,\n        tap: tap,\n        test: test,\n        times: times,\n        toLower: toLower,\n        toPairs: toPairs,\n        toPairsIn: toPairsIn,\n        toString: toString,\n        toUpper: toUpper,\n        transduce: transduce,\n        transpose: transpose,\n        traverse: traverse,\n        trim: trim,\n        type: type,\n        unapply: unapply,\n        unary: unary,\n        uncurryN: uncurryN,\n        unfold: unfold,\n        union: union,\n        unionWith: unionWith,\n        uniq: uniq,\n        uniqBy: uniqBy,\n        uniqWith: uniqWith,\n        unless: unless,\n        unnest: unnest,\n        update: update,\n        useWith: useWith,\n        values: values,\n        valuesIn: valuesIn,\n        view: view,\n        when: when,\n        where: where,\n        whereEq: whereEq,\n        without: without,\n        wrap: wrap,\n        xprod: xprod,\n        zip: zip,\n        zipObj: zipObj,\n        zipWith: zipWith\n    };\n  /* eslint-env amd */\n\n  /* TEST_ENTRY_POINT */\n\n  if (typeof exports === 'object') {\n    module.exports = R;\n  } else if (typeof define === 'function' && define.amd) {\n    define(function() { return R; });\n  } else {\n    this.R = R;\n  }\n\n}.call(this));\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/ramda/dist/ramda.js\n ** module id = 8\n ** module chunks = 0\n **/","import R from \"ramda\"\n\nvar participants = [\n\t\"Graphene\",\n\t\"Carbon\"\n]\n\nvar dialogue = [\n\t{\n\t\tname: \"intro_dialog\",\n\t\tarray: [\n\t\t\t{ //loc: 0\n\t\t\t\t//say: \"Loerm ipsum\"\n\t\t\t\twho: \"Карбон\",\n\t\t\t\tsay: \"Кой си ти?\",\n\t\t\t\tloc: 1\n\t\t\t},\n\t\t\t{ //loc: 1\n\t\t\t\twho: \"Графен\",\n\t\t\t\tsay: \"Аз съм материал създаден от един ред въглеродни атоми и имам уникални свойства!\",\n\t\t\t\tloc: 2\n\t\t\t},\n\t\t\t{ //loc: 2\n\t\t\t\twho: \"Карбон\",\n\t\t\t\tsay: \"Хаха, за много по-полезен ли се мислиш?\",\n\t\t\t\tloc: 3\n\t\t\t},\n\t\t\t{ //loc: 3\n\t\t\t\twho: \"Графен\",\n\t\t\t\tanswer: [\n\t\t\t\t\t{ say: \"Покажи свойствата си.\", loc: 4 },\n\t\t\t\t\t{ say: \"Опитай да решиш всичко с думи.\", loc: 6 /* scene: \"use_words\" */},\n\t\t\t\t\t{ say: \"Игнорирай го.\", loc: 9}\n\t\t\t\t]\n\t\t\t},\n\t\t\t{ //loc: 4\n\t\t\t\twho: \"Графен\",\n\t\t\t\tsay: \"Да.\",\n\t\t\t\tloc: 5\n\t\t\t},\n\t\t\t{ //loc: 5\n\t\t\t\twho: \"Карбон\",\n\t\t\t\tsay: \"Не мисля, че е възможно да имаш по-добри характеристики от моите.\",\n\t\t\t\tloc: 13\n\t\t\t},\n\t\t\t{ //loc: 6\n\t\t\t\twho: \"Графен\",\n\t\t\t\tsay: \"Няма смисъл да спорим.\",\n\t\t\t\tloc: 7\n\n\t\t\t},\t\t\t\n\t\t\t{ //loc: 7\n\t\t\t\twho: \"Карбон\",\n\t\t\t\tsay: \"Да прав си!\",\n\t\t\t\tloc: 8\n\t\t\t},\n\t\t\t{ //loc: 8\n\t\t\t\twho: \"Графен\",\t\t\t\t\n\t\t\t\tanswer: [\n\t\t\t\t\t{ say: \"Остави го да говори.\", loc: 16},\n\t\t\t\t\t{ say: \"Все пак му покажи възможностите си.\", loc: 18}\n\t\t\t\t]\n\t\t\t},\n\t\t\t{ //loc: 9\n\t\t\t\twho: \"Карбон\",\n\t\t\t\tsay: \"Защо ме игнорираш, да не ме имаш за много по-слаб?\",\n\t\t\t\tloc: 10\n\t\t\t},\n\t\t\t{ //loc: 10\n\t\t\t\twho: \"Карбон\",\n\t\t\t\tsay: \"Сигурно те е страх, че не можеш да покажеш нищо кой знае какво!?\",\n\t\t\t\tloc: 11\n\t\t\t},\n\t\t\t{ //loc: 11\n\t\t\t\twho: \"Графен\",\n\t\t\t\tsay: \"Не искам да навлизам в излишни конфликти.\",\n\t\t\t\tloc: 12\n\t\t\t},\n\t\t\t{  //loc: 12\n\t\t\t\twho: \"Карбон\",\n\t\t\t\tsay: \"Така ли? Покажи ми какво можеш тогава.\",\n\t\t\t\tloc: 13 //\"conductivity\"\n\t\t\t},\n\t\t\t{ //loc: 13\n\t\t\t\twho: \"Графен\",\n\t\t\t\tsay:  \"С моята невероятната здравина от 1100 GPa, ще спра метеорита летящ към земята.\", //\"Сега не е времето за това!! Виж метеорит е на път да се разбие в земята, трябва да го спрем!!!\",\n\t\t\t\tloc: 14\n\t\t\t},\n\t\t\t{  //loc: 14\n\t\t\t\twho: \"Карбон\",\n\t\t\t\tsay: \"Не ми трябваш, аз мога да се справя сам.\",\n\t\t\t\tscene: \"mech_force\"\n\t\t\t},\n\t\t\t{ //loc: 15\n\t\t\t\twho: \"Графен\",\n\t\t\t\tsay: \"...\",\n\t\t\t\tscene: \"mech_force\"\n\t\t\t},\n\t\t\t{ //loc: 16\n\t\t\t\twho: \"Карбон\",\n\t\t\t\tsay: \"Почуствах се застрашен. Не искам да повярвам, че има по-полезна вариация на въглерода от мен.\",\n\t\t\t\tloc: 17\n\t\t\t},\t\t\t\n\t\t\t{ //loc: 17\n\t\t\t\twho: \"Карбон\",\n\t\t\t\tsay: \"Аз съм здрав, лек и всичко което някой би искал.\",\n\t\t\t\tloc: 18\n\t\t\t},\n\t\t\t{ //loc: 18\n\t\t\t\twho: \"Графен\",\n\t\t\t\tsay: \"Ами да, но е факт, че аз съм по-електропроводим, здрав и с по-голяма енергийна плътност\",\n\t\t\t\tloc: 19\n\t\t\t},\n\t\t\t{ //loc: 19\n\t\t\t\twho: \"Карбон\",\n\t\t\t\tsay: \"Разбира се!\",\n\t\t\t\tloc: 20\n\t\t\t},\n\t\t\t{ //loc: 20\n\t\t\t\twho: \"Графен\",\n\t\t\t\tsay: \"Например благодарение на моята електропроводимост от\\n 1738 siemens/m мога да заредя телефон за секунди!\",\n\t\t\t\tscene: \"conductivity_good\" \n\t\t\t},\n\t\t\t{ //loc: 21\n\t\t\t\twho: \"Графен\",\n\t\t\t\tsay: \"С моята невероятната здравина от 1100 GPa ще спра метеорита летящ към земята!\",\n\t\t\t\tloc: 13 \n\t\t\t},\n\t\t]\n\t},\n\t{\n\t\tname: \"asteroid_dialog\",\n\t\tarray: [\n\t\t\t{ //loc: 0\n\t\t\t\twho: \"Карбон\",\n\t\t\t\tsay: \"Просто изкара късмет, че нямах време да направя стената по-голяма.\",\n\t\t\t\tloc: 1\n\t\t\t},\n\t\t\t{\n\t\t\t\twho: \"Графен\",\n\t\t\t\tsay: \"Дали? Или просто аз съм по-здравия?\",\n\t\t\t\tloc: 2\n\t\t\t},\n\t\t\t{ //loc: 2\n\t\t\t\twho: \"Карбон\",\n\t\t\t\tsay: \"Да видим другите ти свойства тогава.\",\n\t\t\t\tloc: 3\n\t\t\t},\n\t\t\t{ //loc: 3\n\t\t\t\twho: \"Графен\",\n\t\t\t\tsay: \"Както пожелаеш.\",\n\t\t\t\tscene: \"compete_hard\" \n\t\t\t}\n\t\t]\n\t},\n\t{\n\t\tname: \"compete_hard_dialog\",\n\t\tarray: [\n\t\t\t{ //loc: 0\n\t\t\t\twho: \"Карбон\",\n\t\t\t\tsay: \"Чакам. \",\n\t\t\t\tloc: 1\n\t\t\t},\n\t\t\t{ //loc: 1\n\t\t\t\twho: \"Графен\",\t\t\n\t\t\t\tanswer: [\n\t\t\t\t\t{ say: \"Покажи - електропроводимост\\n от 1738 siemens/m.\", loc: 2 },\n\t\t\t\t\t{ say: \"Покажи - енергийна плътност\\n от 75 F/g и 31·9 Wh/kg.\", loc: 3 }\n\t\t\t\t]\n\t\t\t},\n\t\t\t{ //loc: 2\n\t\t\t\twho: \"Графен\",\n\t\t\t\tsay: \"Ето виж!\",\n\t\t\t\tscene: \"conductivity\"\n\t\t\t},\n\t\t\t{ //loc: 3\n\t\t\t\twho: \"Графен\",\n\t\t\t\tsay: \"A знаеше ли, че бaтерия и акумулатор, направена с моята помощ,\\n издържа в пъти повече от нормална батерия?\",\n\t\t\t\tscene: \"electrical_density\"\n\t\t\t}\n\n\t\t]\n\t},\n\t\t{\n\t\tname: \"good_dialog\",\n\t\tarray: [\n\t\t\t{ //loc: 0\n\t\t\t\twho: \"Графен\",\n\t\t\t\tsay: \"A също така, бaтерия и акумулатор, направена с моята помощ,\\n издържа в пъти повече от нормална батерия.\",\n\t\t\t\tscene: \"electrical_density_good\"\n\t\t\t}\n\n\t\t]\n\t},\n\t{\n\t\tname: \"ed_c_dialog\",\n\t\tarray: [\n\t\t\t{ //loc: 0\n\t\t\t\twho: \"Графен\",\n\t\t\t\tsay: \"А виж какво мога, благодарение на моята електропроводимост от 1738 siemens/m.\",\n\t\t\t\tscene: \"conductivity_2\"\n\t\t\t},\n\t\t]\n\t},\n\t{\n\t\tname: \"c_c_dialog\",\n\t\tarray: [\n\t\t\t{ //loc: 0\n\t\t\t\twho: \"Графен\",\n\t\t\t\tsay: \"А виж какво мога, благодарение на моята енергийна плътност от 75 F/g и 31·9 Wh/kg.\\n Заради нея, могат да се направят много по издържливи батерии и акумулатори.\",\n\t\t\t\tscene: \"electrical_density_2\"\n\t\t\t},\n\t\t]\n\t},\n\t{\n\t\tname: \"ending_dialog_1\",\n\t\tarray: [\n\t\t\t{\n\t\t\t\twho: \"Карбон\",\n\t\t\t\tsay: \"Добре признавам, че си по-полезен в повечето ситуации!\",\n\t\t\t\tscene: \"end_true\"\n\t\t\t}\n\t\t]\n\t},\n\t{\n\t\tname: \"ending_dialog_2\",\n\t\tarray: [\n\t\t\t{\n\t\t\t\twho: \"Карбон\",\n\t\t\t\tsay: \"Разбирам и признавам, че си по-полезен!\",\n\t\t\t\tscene: \"end_true\"\n\t\t\t}\n\t\t]\n\t}\n\n]\n\n\nwindow.d = dialogue\n\nexport default class Dialogue {\n\tconstructor(){\n\t\tthis.dialogue = dialogue;\n\t}\n\n\tselect(name){\n\t\tthis.currentDialogue = R.find(R.propEq(\"name\", name))(this.dialogue)\n\t\tthis.currentPhrase = this.currentDialogue.array[0]\n\t}\n\n\tphrase(loc){\n\t\treturn this.currentDialogue.array[loc];\n\t}\n\n\n\tchoices(){\n\t\treturn this.currentPhrase.answer.map(o => o.say);\n\t}\n\n\thasChoices(){\n\t\tif(this.currentPhrase){\n\t\t\treturn this.currentPhrase.answer != null\n\t\t}\n\t\treturn false\n\t}\n\n\tsay(){\n\t\treturn this.currentPhrase\n\t}\n\n\thasNext(){\n\t\treturn this.loc < (this.currentDialogue.array.length() - 1)\n\t}\n\n\tnext(choice){\n\t\tif(this.currentPhrase.answer){\n\t\t\tif(arguments.length > 0){\n\t\t\t\tif(choice <= this.currentPhrase.answer.length){\n\t\t\t\t\tif(this.currentPhrase.answer[choice].scene){\n\t\t\t\t\t\treturn this.currentPhrase.answer[choice].scene\n\t\t\t\t\t}\n\t\t\t\t\tthis.loc = this.currentPhrase.answer[choice].loc\n\t\t\t\t\tthis.currentPhrase = this.phrase(this.currentPhrase.answer[choice].loc);\n\n\t\t\t\t}else{\n\t\t\t\t\tthrow \"This answer does not exists\"\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tthrow \"This transition to the next phrase requires an argument\"\n\t\t\t}\n\t\t}else if(this.currentPhrase.loc){\n\t\t\tthis.loc = this.currentPhrase.loc\n\t\t\tthis.currentPhrase = this.phrase(this.currentPhrase.loc);\n\t\t}else if(this.currentPhrase.scene){\n\t\t\treturn this.currentPhrase.scene\n\t\t}\n\t\t\n\t\tconsole.log(this.loc)\n\n\n\t}\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./js/dialogue.js\n **/","/*! Kefir.js v3.2.1\n *  https://github.com/rpominov/kefir\n */\n\n(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :\n  typeof define === 'function' && define.amd ? define(['exports'], factory) :\n  (factory((global.Kefir = global.Kefir || {})));\n}(this, function (exports) { 'use strict';\n\n  function createObj(proto) {\n    var F = function () {};\n    F.prototype = proto;\n    return new F();\n  }\n\n  function extend(target /*, mixin1, mixin2...*/) {\n    var length = arguments.length,\n        i = undefined,\n        prop = undefined;\n    for (i = 1; i < length; i++) {\n      for (prop in arguments[i]) {\n        target[prop] = arguments[i][prop];\n      }\n    }\n    return target;\n  }\n\n  function inherit(Child, Parent /*, mixin1, mixin2...*/) {\n    var length = arguments.length,\n        i = undefined;\n    Child.prototype = createObj(Parent.prototype);\n    Child.prototype.constructor = Child;\n    for (i = 2; i < length; i++) {\n      extend(Child.prototype, arguments[i]);\n    }\n    return Child;\n  }\n\n  var NOTHING = ['<nothing>'];\n  var END = 'end';\n  var VALUE = 'value';\n  var ERROR = 'error';\n  var ANY = 'any';\n\n  function concat(a, b) {\n    var result = undefined,\n        length = undefined,\n        i = undefined,\n        j = undefined;\n    if (a.length === 0) {\n      return b;\n    }\n    if (b.length === 0) {\n      return a;\n    }\n    j = 0;\n    result = new Array(a.length + b.length);\n    length = a.length;\n    for (i = 0; i < length; i++, j++) {\n      result[j] = a[i];\n    }\n    length = b.length;\n    for (i = 0; i < length; i++, j++) {\n      result[j] = b[i];\n    }\n    return result;\n  }\n\n  function find(arr, value) {\n    var length = arr.length,\n        i = undefined;\n    for (i = 0; i < length; i++) {\n      if (arr[i] === value) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  function findByPred(arr, pred) {\n    var length = arr.length,\n        i = undefined;\n    for (i = 0; i < length; i++) {\n      if (pred(arr[i])) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  function cloneArray(input) {\n    var length = input.length,\n        result = new Array(length),\n        i = undefined;\n    for (i = 0; i < length; i++) {\n      result[i] = input[i];\n    }\n    return result;\n  }\n\n  function remove(input, index) {\n    var length = input.length,\n        result = undefined,\n        i = undefined,\n        j = undefined;\n    if (index >= 0 && index < length) {\n      if (length === 1) {\n        return [];\n      } else {\n        result = new Array(length - 1);\n        for (i = 0, j = 0; i < length; i++) {\n          if (i !== index) {\n            result[j] = input[i];\n            j++;\n          }\n        }\n        return result;\n      }\n    } else {\n      return input;\n    }\n  }\n\n  function map(input, fn) {\n    var length = input.length,\n        result = new Array(length),\n        i = undefined;\n    for (i = 0; i < length; i++) {\n      result[i] = fn(input[i]);\n    }\n    return result;\n  }\n\n  function forEach(arr, fn) {\n    var length = arr.length,\n        i = undefined;\n    for (i = 0; i < length; i++) {\n      fn(arr[i]);\n    }\n  }\n\n  function fillArray(arr, value) {\n    var length = arr.length,\n        i = undefined;\n    for (i = 0; i < length; i++) {\n      arr[i] = value;\n    }\n  }\n\n  function contains(arr, value) {\n    return find(arr, value) !== -1;\n  }\n\n  function slide(cur, next, max) {\n    var length = Math.min(max, cur.length + 1),\n        offset = cur.length - length + 1,\n        result = new Array(length),\n        i = undefined;\n    for (i = offset; i < length; i++) {\n      result[i - offset] = cur[i];\n    }\n    result[length - 1] = next;\n    return result;\n  }\n\n  function callSubscriber(type, fn, event) {\n    if (type === ANY) {\n      fn(event);\n    } else if (type === event.type) {\n      if (type === VALUE || type === ERROR) {\n        fn(event.value);\n      } else {\n        fn();\n      }\n    }\n  }\n\n  function Dispatcher() {\n    this._items = [];\n    this._inLoop = 0;\n    this._removedItems = null;\n  }\n\n  extend(Dispatcher.prototype, {\n    add: function (type, fn) {\n      this._items = concat(this._items, [{ type: type, fn: fn }]);\n      return this._items.length;\n    },\n    remove: function (type, fn) {\n      var index = findByPred(this._items, function (x) {\n        return x.type === type && x.fn === fn;\n      });\n\n      // if we're currently in a notification loop,\n      // remember this subscriber was removed\n      if (this._inLoop !== 0 && index !== -1) {\n        if (this._removedItems === null) {\n          this._removedItems = [];\n        }\n        this._removedItems.push(this._items[index]);\n      }\n\n      this._items = remove(this._items, index);\n      return this._items.length;\n    },\n    dispatch: function (event) {\n      this._inLoop++;\n      for (var i = 0, items = this._items; i < items.length; i++) {\n\n        // cleanup was called\n        if (this._items === null) {\n          break;\n        }\n\n        // this subscriber was removed\n        if (this._removedItems !== null && contains(this._removedItems, items[i])) {\n          continue;\n        }\n\n        callSubscriber(items[i].type, items[i].fn, event);\n      }\n      this._inLoop--;\n      if (this._inLoop === 0) {\n        this._removedItems = null;\n      }\n    },\n    cleanup: function () {\n      this._items = null;\n    }\n  });\n\n  function Observable() {\n    this._dispatcher = new Dispatcher();\n    this._active = false;\n    this._alive = true;\n    this._activating = false;\n    this._logHandlers = null;\n  }\n\n  extend(Observable.prototype, {\n\n    _name: 'observable',\n\n    _onActivation: function () {},\n    _onDeactivation: function () {},\n    _setActive: function (active) {\n      if (this._active !== active) {\n        this._active = active;\n        if (active) {\n          this._activating = true;\n          this._onActivation();\n          this._activating = false;\n        } else {\n          this._onDeactivation();\n        }\n      }\n    },\n    _clear: function () {\n      this._setActive(false);\n      this._dispatcher.cleanup();\n      this._dispatcher = null;\n      this._logHandlers = null;\n    },\n    _emit: function (type, x) {\n      switch (type) {\n        case VALUE:\n          return this._emitValue(x);\n        case ERROR:\n          return this._emitError(x);\n        case END:\n          return this._emitEnd();\n      }\n    },\n    _emitValue: function (value) {\n      if (this._alive) {\n        this._dispatcher.dispatch({ type: VALUE, value: value });\n      }\n    },\n    _emitError: function (value) {\n      if (this._alive) {\n        this._dispatcher.dispatch({ type: ERROR, value: value });\n      }\n    },\n    _emitEnd: function () {\n      if (this._alive) {\n        this._alive = false;\n        this._dispatcher.dispatch({ type: END });\n        this._clear();\n      }\n    },\n    _on: function (type, fn) {\n      if (this._alive) {\n        this._dispatcher.add(type, fn);\n        this._setActive(true);\n      } else {\n        callSubscriber(type, fn, { type: END });\n      }\n      return this;\n    },\n    _off: function (type, fn) {\n      if (this._alive) {\n        var count = this._dispatcher.remove(type, fn);\n        if (count === 0) {\n          this._setActive(false);\n        }\n      }\n      return this;\n    },\n    onValue: function (fn) {\n      return this._on(VALUE, fn);\n    },\n    onError: function (fn) {\n      return this._on(ERROR, fn);\n    },\n    onEnd: function (fn) {\n      return this._on(END, fn);\n    },\n    onAny: function (fn) {\n      return this._on(ANY, fn);\n    },\n    offValue: function (fn) {\n      return this._off(VALUE, fn);\n    },\n    offError: function (fn) {\n      return this._off(ERROR, fn);\n    },\n    offEnd: function (fn) {\n      return this._off(END, fn);\n    },\n    offAny: function (fn) {\n      return this._off(ANY, fn);\n    },\n\n\n    // A and B must be subclasses of Stream and Property (order doesn't matter)\n    _ofSameType: function (A, B) {\n      return A.prototype.getType() === this.getType() ? A : B;\n    },\n    setName: function (sourceObs /* optional */, selfName) {\n      this._name = selfName ? sourceObs._name + '.' + selfName : sourceObs;\n      return this;\n    },\n    log: function () {\n      var name = arguments.length <= 0 || arguments[0] === undefined ? this.toString() : arguments[0];\n\n\n      var isCurrent = undefined;\n      var handler = function (event) {\n        var type = '<' + event.type + (isCurrent ? ':current' : '') + '>';\n        if (event.type === END) {\n          console.log(name, type);\n        } else {\n          console.log(name, type, event.value);\n        }\n      };\n\n      if (this._alive) {\n        if (!this._logHandlers) {\n          this._logHandlers = [];\n        }\n        this._logHandlers.push({ name: name, handler: handler });\n      }\n\n      isCurrent = true;\n      this.onAny(handler);\n      isCurrent = false;\n\n      return this;\n    },\n    offLog: function () {\n      var name = arguments.length <= 0 || arguments[0] === undefined ? this.toString() : arguments[0];\n\n\n      if (this._logHandlers) {\n        var handlerIndex = findByPred(this._logHandlers, function (obj) {\n          return obj.name === name;\n        });\n        if (handlerIndex !== -1) {\n          this.offAny(this._logHandlers[handlerIndex].handler);\n          this._logHandlers.splice(handlerIndex, 1);\n        }\n      }\n\n      return this;\n    }\n  });\n\n  // extend() can't handle `toString` in IE8\n  Observable.prototype.toString = function () {\n    return '[' + this._name + ']';\n  };\n\n  function Stream() {\n    Observable.call(this);\n  }\n\n  inherit(Stream, Observable, {\n\n    _name: 'stream',\n\n    getType: function () {\n      return 'stream';\n    }\n  });\n\n  function Property() {\n    Observable.call(this);\n    this._currentEvent = null;\n  }\n\n  inherit(Property, Observable, {\n\n    _name: 'property',\n\n    _emitValue: function (value) {\n      if (this._alive) {\n        this._currentEvent = { type: VALUE, value: value };\n        if (!this._activating) {\n          this._dispatcher.dispatch({ type: VALUE, value: value });\n        }\n      }\n    },\n    _emitError: function (value) {\n      if (this._alive) {\n        this._currentEvent = { type: ERROR, value: value };\n        if (!this._activating) {\n          this._dispatcher.dispatch({ type: ERROR, value: value });\n        }\n      }\n    },\n    _emitEnd: function () {\n      if (this._alive) {\n        this._alive = false;\n        if (!this._activating) {\n          this._dispatcher.dispatch({ type: END });\n        }\n        this._clear();\n      }\n    },\n    _on: function (type, fn) {\n      if (this._alive) {\n        this._dispatcher.add(type, fn);\n        this._setActive(true);\n      }\n      if (this._currentEvent !== null) {\n        callSubscriber(type, fn, this._currentEvent);\n      }\n      if (!this._alive) {\n        callSubscriber(type, fn, { type: END });\n      }\n      return this;\n    },\n    getType: function () {\n      return 'property';\n    }\n  });\n\n  var neverS = new Stream();\n  neverS._emitEnd();\n  neverS._name = 'never';\n\n  function never() {\n    return neverS;\n  }\n\n  function timeBased(mixin) {\n\n    function AnonymousStream(wait, options) {\n      var _this = this;\n\n      Stream.call(this);\n      this._wait = wait;\n      this._intervalId = null;\n      this._$onTick = function () {\n        return _this._onTick();\n      };\n      this._init(options);\n    }\n\n    inherit(AnonymousStream, Stream, {\n      _init: function () {},\n      _free: function () {},\n      _onTick: function () {},\n      _onActivation: function () {\n        this._intervalId = setInterval(this._$onTick, this._wait);\n      },\n      _onDeactivation: function () {\n        if (this._intervalId !== null) {\n          clearInterval(this._intervalId);\n          this._intervalId = null;\n        }\n      },\n      _clear: function () {\n        Stream.prototype._clear.call(this);\n        this._$onTick = null;\n        this._free();\n      }\n    }, mixin);\n\n    return AnonymousStream;\n  }\n\n  var S = timeBased({\n\n    _name: 'later',\n\n    _init: function (_ref) {\n      var x = _ref.x;\n\n      this._x = x;\n    },\n    _free: function () {\n      this._x = null;\n    },\n    _onTick: function () {\n      this._emitValue(this._x);\n      this._emitEnd();\n    }\n  });\n\n  function later(wait, x) {\n    return new S(wait, { x: x });\n  }\n\n  var S$1 = timeBased({\n\n    _name: 'interval',\n\n    _init: function (_ref) {\n      var x = _ref.x;\n\n      this._x = x;\n    },\n    _free: function () {\n      this._x = null;\n    },\n    _onTick: function () {\n      this._emitValue(this._x);\n    }\n  });\n\n  function interval(wait, x) {\n    return new S$1(wait, { x: x });\n  }\n\n  var S$2 = timeBased({\n\n    _name: 'sequentially',\n\n    _init: function (_ref) {\n      var xs = _ref.xs;\n\n      this._xs = cloneArray(xs);\n    },\n    _free: function () {\n      this._xs = null;\n    },\n    _onTick: function () {\n      if (this._xs.length === 1) {\n        this._emitValue(this._xs[0]);\n        this._emitEnd();\n      } else {\n        this._emitValue(this._xs.shift());\n      }\n    }\n  });\n\n  function sequentially(wait, xs) {\n    return xs.length === 0 ? never() : new S$2(wait, { xs: xs });\n  }\n\n  var S$3 = timeBased({\n\n    _name: 'fromPoll',\n\n    _init: function (_ref) {\n      var fn = _ref.fn;\n\n      this._fn = fn;\n    },\n    _free: function () {\n      this._fn = null;\n    },\n    _onTick: function () {\n      var fn = this._fn;\n      this._emitValue(fn());\n    }\n  });\n\n  function fromPoll(wait, fn) {\n    return new S$3(wait, { fn: fn });\n  }\n\n  function emitter(obs) {\n\n    function value(x) {\n      obs._emitValue(x);\n      return obs._active;\n    }\n\n    function error(x) {\n      obs._emitError(x);\n      return obs._active;\n    }\n\n    function end() {\n      obs._emitEnd();\n      return obs._active;\n    }\n\n    function event(e) {\n      obs._emit(e.type, e.value);\n      return obs._active;\n    }\n\n    return { value: value, error: error, end: end, event: event, emit: value, emitEvent: event };\n  }\n\n  var S$4 = timeBased({\n\n    _name: 'withInterval',\n\n    _init: function (_ref) {\n      var fn = _ref.fn;\n\n      this._fn = fn;\n      this._emitter = emitter(this);\n    },\n    _free: function () {\n      this._fn = null;\n      this._emitter = null;\n    },\n    _onTick: function () {\n      var fn = this._fn;\n      fn(this._emitter);\n    }\n  });\n\n  function withInterval(wait, fn) {\n    return new S$4(wait, { fn: fn });\n  }\n\n  function S$5(fn) {\n    Stream.call(this);\n    this._fn = fn;\n    this._unsubscribe = null;\n  }\n\n  inherit(S$5, Stream, {\n\n    _name: 'stream',\n\n    _onActivation: function () {\n      var fn = this._fn;\n      var unsubscribe = fn(emitter(this));\n      this._unsubscribe = typeof unsubscribe === 'function' ? unsubscribe : null;\n\n      // fix https://github.com/rpominov/kefir/issues/35\n      if (!this._active) {\n        this._callUnsubscribe();\n      }\n    },\n    _callUnsubscribe: function () {\n      if (this._unsubscribe !== null) {\n        this._unsubscribe();\n        this._unsubscribe = null;\n      }\n    },\n    _onDeactivation: function () {\n      this._callUnsubscribe();\n    },\n    _clear: function () {\n      Stream.prototype._clear.call(this);\n      this._fn = null;\n    }\n  });\n\n  function stream(fn) {\n    return new S$5(fn);\n  }\n\n  function fromCallback(callbackConsumer) {\n\n    var called = false;\n\n    return stream(function (emitter) {\n\n      if (!called) {\n        callbackConsumer(function (x) {\n          emitter.emit(x);\n          emitter.end();\n        });\n        called = true;\n      }\n    }).setName('fromCallback');\n  }\n\n  function fromNodeCallback(callbackConsumer) {\n\n    var called = false;\n\n    return stream(function (emitter) {\n\n      if (!called) {\n        callbackConsumer(function (error, x) {\n          if (error) {\n            emitter.error(error);\n          } else {\n            emitter.emit(x);\n          }\n          emitter.end();\n        });\n        called = true;\n      }\n    }).setName('fromNodeCallback');\n  }\n\n  function spread(fn, length) {\n    switch (length) {\n      case 0:\n        return function () {\n          return fn();\n        };\n      case 1:\n        return function (a) {\n          return fn(a[0]);\n        };\n      case 2:\n        return function (a) {\n          return fn(a[0], a[1]);\n        };\n      case 3:\n        return function (a) {\n          return fn(a[0], a[1], a[2]);\n        };\n      case 4:\n        return function (a) {\n          return fn(a[0], a[1], a[2], a[3]);\n        };\n      default:\n        return function (a) {\n          return fn.apply(null, a);\n        };\n    }\n  }\n\n  function apply(fn, c, a) {\n    var aLength = a ? a.length : 0;\n    if (c == null) {\n      switch (aLength) {\n        case 0:\n          return fn();\n        case 1:\n          return fn(a[0]);\n        case 2:\n          return fn(a[0], a[1]);\n        case 3:\n          return fn(a[0], a[1], a[2]);\n        case 4:\n          return fn(a[0], a[1], a[2], a[3]);\n        default:\n          return fn.apply(null, a);\n      }\n    } else {\n      switch (aLength) {\n        case 0:\n          return fn.call(c);\n        default:\n          return fn.apply(c, a);\n      }\n    }\n  }\n\n  function fromSubUnsub(sub, unsub, transformer /* Function | falsey */) {\n    return stream(function (emitter) {\n\n      var handler = transformer ? function () {\n        emitter.emit(apply(transformer, this, arguments));\n      } : function (x) {\n        emitter.emit(x);\n      };\n\n      sub(handler);\n      return function () {\n        return unsub(handler);\n      };\n    }).setName('fromSubUnsub');\n  }\n\n  var pairs = [['addEventListener', 'removeEventListener'], ['addListener', 'removeListener'], ['on', 'off']];\n\n  function fromEvents(target, eventName, transformer) {\n    var sub = undefined,\n        unsub = undefined;\n\n    for (var i = 0; i < pairs.length; i++) {\n      if (typeof target[pairs[i][0]] === 'function' && typeof target[pairs[i][1]] === 'function') {\n        sub = pairs[i][0];\n        unsub = pairs[i][1];\n        break;\n      }\n    }\n\n    if (sub === undefined) {\n      throw new Error('target don\\'t support any of ' + 'addEventListener/removeEventListener, addListener/removeListener, on/off method pair');\n    }\n\n    return fromSubUnsub(function (handler) {\n      return target[sub](eventName, handler);\n    }, function (handler) {\n      return target[unsub](eventName, handler);\n    }, transformer).setName('fromEvents');\n  }\n\n  // HACK:\n  //   We don't call parent Class constructor, but instead putting all necessary\n  //   properties into prototype to simulate ended Property\n  //   (see Propperty and Observable classes).\n\n  function P(value) {\n    this._currentEvent = { type: 'value', value: value, current: true };\n  }\n\n  inherit(P, Property, {\n    _name: 'constant',\n    _active: false,\n    _activating: false,\n    _alive: false,\n    _dispatcher: null,\n    _logHandlers: null\n  });\n\n  function constant(x) {\n    return new P(x);\n  }\n\n  // HACK:\n  //   We don't call parent Class constructor, but instead putting all necessary\n  //   properties into prototype to simulate ended Property\n  //   (see Propperty and Observable classes).\n\n  function P$1(value) {\n    this._currentEvent = { type: 'error', value: value, current: true };\n  }\n\n  inherit(P$1, Property, {\n    _name: 'constantError',\n    _active: false,\n    _activating: false,\n    _alive: false,\n    _dispatcher: null,\n    _logHandlers: null\n  });\n\n  function constantError(x) {\n    return new P$1(x);\n  }\n\n  function createConstructor(BaseClass, name) {\n    return function AnonymousObservable(source, options) {\n      var _this = this;\n\n      BaseClass.call(this);\n      this._source = source;\n      this._name = source._name + '.' + name;\n      this._init(options);\n      this._$handleAny = function (event) {\n        return _this._handleAny(event);\n      };\n    };\n  }\n\n  function createClassMethods(BaseClass) {\n    return {\n      _init: function () {},\n      _free: function () {},\n      _handleValue: function (x) {\n        this._emitValue(x);\n      },\n      _handleError: function (x) {\n        this._emitError(x);\n      },\n      _handleEnd: function () {\n        this._emitEnd();\n      },\n      _handleAny: function (event) {\n        switch (event.type) {\n          case VALUE:\n            return this._handleValue(event.value);\n          case ERROR:\n            return this._handleError(event.value);\n          case END:\n            return this._handleEnd();\n        }\n      },\n      _onActivation: function () {\n        this._source.onAny(this._$handleAny);\n      },\n      _onDeactivation: function () {\n        this._source.offAny(this._$handleAny);\n      },\n      _clear: function () {\n        BaseClass.prototype._clear.call(this);\n        this._source = null;\n        this._$handleAny = null;\n        this._free();\n      }\n    };\n  }\n\n  function createStream(name, mixin) {\n    var S = createConstructor(Stream, name);\n    inherit(S, Stream, createClassMethods(Stream), mixin);\n    return S;\n  }\n\n  function createProperty(name, mixin) {\n    var P = createConstructor(Property, name);\n    inherit(P, Property, createClassMethods(Property), mixin);\n    return P;\n  }\n\n  var P$2 = createProperty('toProperty', {\n    _init: function (_ref) {\n      var fn = _ref.fn;\n\n      this._getInitialCurrent = fn;\n    },\n    _onActivation: function () {\n      if (this._getInitialCurrent !== null) {\n        var getInitial = this._getInitialCurrent;\n        this._emitValue(getInitial());\n      }\n      this._source.onAny(this._$handleAny); // copied from patterns/one-source\n    }\n  });\n\n  function toProperty(obs) {\n    var fn = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];\n\n    if (fn !== null && typeof fn !== 'function') {\n      throw new Error('You should call toProperty() with a function or no arguments.');\n    }\n    return new P$2(obs, { fn: fn });\n  }\n\n  var S$6 = createStream('changes', {\n    _handleValue: function (x) {\n      if (!this._activating) {\n        this._emitValue(x);\n      }\n    },\n    _handleError: function (x) {\n      if (!this._activating) {\n        this._emitError(x);\n      }\n    }\n  });\n\n  function changes(obs) {\n    return new S$6(obs);\n  }\n\n  function fromPromise(promise) {\n\n    var called = false;\n\n    var result = stream(function (emitter) {\n      if (!called) {\n        var onValue = function (x) {\n          emitter.emit(x);\n          emitter.end();\n        };\n        var onError = function (x) {\n          emitter.error(x);\n          emitter.end();\n        };\n        var _promise = promise.then(onValue, onError);\n\n        // prevent libraries like 'Q' or 'when' from swallowing exceptions\n        if (_promise && typeof _promise.done === 'function') {\n          _promise.done();\n        }\n\n        called = true;\n      }\n    });\n\n    return toProperty(result, null).setName('fromPromise');\n  }\n\n  function getGlodalPromise() {\n    if (typeof Promise === 'function') {\n      return Promise;\n    } else {\n      throw new Error('There isn\\'t default Promise, use shim or parameter');\n    }\n  }\n\n  function toPromise (obs) {\n    var Promise = arguments.length <= 1 || arguments[1] === undefined ? getGlodalPromise() : arguments[1];\n\n    var last = null;\n    return new Promise(function (resolve, reject) {\n      obs.onAny(function (event) {\n        if (event.type === END && last !== null) {\n          (last.type === VALUE ? resolve : reject)(last.value);\n          last = null;\n        } else {\n          last = event;\n        }\n      });\n    });\n  }\n\n  function symbol_ (key) {\n    if (typeof Symbol !== 'undefined' && Symbol[key]) {\n      return Symbol[key];\n    } else if (typeof Symbol !== 'undefined' && typeof Symbol.for === 'function') {\n      return Symbol.for(key);\n    } else {\n      return '@@' + key;\n    }\n  }\n\n  var symbol = symbol_('observable');\n\n  function fromESObservable(_observable) {\n    var observable = _observable[symbol] ? _observable[symbol]() : _observable;\n    return stream(function (emitter) {\n      var unsub = observable.subscribe({\n        error: function (error) {\n          emitter.error(error);\n          emitter.end();\n        },\n        next: function (value) {\n          emitter.emit(value);\n        },\n        complete: function () {\n          emitter.end();\n        }\n      });\n\n      if (unsub.unsubscribe) {\n        return function () {\n          unsub.unsubscribe();\n        };\n      } else {\n        return unsub;\n      }\n    }).setName('fromESObservable');\n  }\n\n  function ESObservable(observable) {\n    this._observable = observable.takeErrors(1);\n  }\n\n  extend(ESObservable.prototype, {\n    subscribe: function (observer) {\n      var _this = this;\n\n      var fn = function (event) {\n        if (event.type === VALUE && observer.next) {\n          observer.next(event.value);\n        } else if (event.type === ERROR && observer.error) {\n          observer.error(event.value);\n        } else if (event.type === END && observer.complete) {\n          observer.complete(event.value);\n        }\n      };\n\n      this._observable.onAny(fn);\n      return function () {\n        return _this._observable.offAny(fn);\n      };\n    }\n  });\n\n  function toESObservable() {\n    return new ESObservable(this);\n  }\n\n  var mixin = {\n    _init: function (_ref) {\n      var fn = _ref.fn;\n\n      this._fn = fn;\n    },\n    _free: function () {\n      this._fn = null;\n    },\n    _handleValue: function (x) {\n      var fn = this._fn;\n      this._emitValue(fn(x));\n    }\n  };\n\n  var S$7 = createStream('map', mixin);\n  var P$3 = createProperty('map', mixin);\n\n  var id = function (x) {\n    return x;\n  };\n\n  function map$1(obs) {\n    var fn = arguments.length <= 1 || arguments[1] === undefined ? id : arguments[1];\n\n    return new (obs._ofSameType(S$7, P$3))(obs, { fn: fn });\n  }\n\n  var mixin$1 = {\n    _init: function (_ref) {\n      var fn = _ref.fn;\n\n      this._fn = fn;\n    },\n    _free: function () {\n      this._fn = null;\n    },\n    _handleValue: function (x) {\n      var fn = this._fn;\n      if (fn(x)) {\n        this._emitValue(x);\n      }\n    }\n  };\n\n  var S$8 = createStream('filter', mixin$1);\n  var P$4 = createProperty('filter', mixin$1);\n\n  var id$1 = function (x) {\n    return x;\n  };\n\n  function filter(obs) {\n    var fn = arguments.length <= 1 || arguments[1] === undefined ? id$1 : arguments[1];\n\n    return new (obs._ofSameType(S$8, P$4))(obs, { fn: fn });\n  }\n\n  var mixin$2 = {\n    _init: function (_ref) {\n      var n = _ref.n;\n\n      this._n = n;\n      if (n <= 0) {\n        this._emitEnd();\n      }\n    },\n    _handleValue: function (x) {\n      this._n--;\n      this._emitValue(x);\n      if (this._n === 0) {\n        this._emitEnd();\n      }\n    }\n  };\n\n  var S$9 = createStream('take', mixin$2);\n  var P$5 = createProperty('take', mixin$2);\n\n  function take(obs, n) {\n    return new (obs._ofSameType(S$9, P$5))(obs, { n: n });\n  }\n\n  var mixin$3 = {\n    _init: function (_ref) {\n      var n = _ref.n;\n\n      this._n = n;\n      if (n <= 0) {\n        this._emitEnd();\n      }\n    },\n    _handleError: function (x) {\n      this._n--;\n      this._emitError(x);\n      if (this._n === 0) {\n        this._emitEnd();\n      }\n    }\n  };\n\n  var S$10 = createStream('takeErrors', mixin$3);\n  var P$6 = createProperty('takeErrors', mixin$3);\n\n  function takeErrors(obs, n) {\n    return new (obs._ofSameType(S$10, P$6))(obs, { n: n });\n  }\n\n  var mixin$4 = {\n    _init: function (_ref) {\n      var fn = _ref.fn;\n\n      this._fn = fn;\n    },\n    _free: function () {\n      this._fn = null;\n    },\n    _handleValue: function (x) {\n      var fn = this._fn;\n      if (fn(x)) {\n        this._emitValue(x);\n      } else {\n        this._emitEnd();\n      }\n    }\n  };\n\n  var S$11 = createStream('takeWhile', mixin$4);\n  var P$7 = createProperty('takeWhile', mixin$4);\n\n  var id$2 = function (x) {\n    return x;\n  };\n\n  function takeWhile(obs) {\n    var fn = arguments.length <= 1 || arguments[1] === undefined ? id$2 : arguments[1];\n\n    return new (obs._ofSameType(S$11, P$7))(obs, { fn: fn });\n  }\n\n  var mixin$5 = {\n    _init: function () {\n      this._lastValue = NOTHING;\n    },\n    _free: function () {\n      this._lastValue = null;\n    },\n    _handleValue: function (x) {\n      this._lastValue = x;\n    },\n    _handleEnd: function () {\n      if (this._lastValue !== NOTHING) {\n        this._emitValue(this._lastValue);\n      }\n      this._emitEnd();\n    }\n  };\n\n  var S$12 = createStream('last', mixin$5);\n  var P$8 = createProperty('last', mixin$5);\n\n  function last(obs) {\n    return new (obs._ofSameType(S$12, P$8))(obs);\n  }\n\n  var mixin$6 = {\n    _init: function (_ref) {\n      var n = _ref.n;\n\n      this._n = Math.max(0, n);\n    },\n    _handleValue: function (x) {\n      if (this._n === 0) {\n        this._emitValue(x);\n      } else {\n        this._n--;\n      }\n    }\n  };\n\n  var S$13 = createStream('skip', mixin$6);\n  var P$9 = createProperty('skip', mixin$6);\n\n  function skip(obs, n) {\n    return new (obs._ofSameType(S$13, P$9))(obs, { n: n });\n  }\n\n  var mixin$7 = {\n    _init: function (_ref) {\n      var fn = _ref.fn;\n\n      this._fn = fn;\n    },\n    _free: function () {\n      this._fn = null;\n    },\n    _handleValue: function (x) {\n      var fn = this._fn;\n      if (this._fn !== null && !fn(x)) {\n        this._fn = null;\n      }\n      if (this._fn === null) {\n        this._emitValue(x);\n      }\n    }\n  };\n\n  var S$14 = createStream('skipWhile', mixin$7);\n  var P$10 = createProperty('skipWhile', mixin$7);\n\n  var id$3 = function (x) {\n    return x;\n  };\n\n  function skipWhile(obs) {\n    var fn = arguments.length <= 1 || arguments[1] === undefined ? id$3 : arguments[1];\n\n    return new (obs._ofSameType(S$14, P$10))(obs, { fn: fn });\n  }\n\n  var mixin$8 = {\n    _init: function (_ref) {\n      var fn = _ref.fn;\n\n      this._fn = fn;\n      this._prev = NOTHING;\n    },\n    _free: function () {\n      this._fn = null;\n      this._prev = null;\n    },\n    _handleValue: function (x) {\n      var fn = this._fn;\n      if (this._prev === NOTHING || !fn(this._prev, x)) {\n        this._prev = x;\n        this._emitValue(x);\n      }\n    }\n  };\n\n  var S$15 = createStream('skipDuplicates', mixin$8);\n  var P$11 = createProperty('skipDuplicates', mixin$8);\n\n  var eq = function (a, b) {\n    return a === b;\n  };\n\n  function skipDuplicates(obs) {\n    var fn = arguments.length <= 1 || arguments[1] === undefined ? eq : arguments[1];\n\n    return new (obs._ofSameType(S$15, P$11))(obs, { fn: fn });\n  }\n\n  var mixin$9 = {\n    _init: function (_ref) {\n      var fn = _ref.fn;\n      var seed = _ref.seed;\n\n      this._fn = fn;\n      this._prev = seed;\n    },\n    _free: function () {\n      this._prev = null;\n      this._fn = null;\n    },\n    _handleValue: function (x) {\n      if (this._prev !== NOTHING) {\n        var fn = this._fn;\n        this._emitValue(fn(this._prev, x));\n      }\n      this._prev = x;\n    }\n  };\n\n  var S$16 = createStream('diff', mixin$9);\n  var P$12 = createProperty('diff', mixin$9);\n\n  function defaultFn(a, b) {\n    return [a, b];\n  }\n\n  function diff(obs, fn) {\n    var seed = arguments.length <= 2 || arguments[2] === undefined ? NOTHING : arguments[2];\n\n    return new (obs._ofSameType(S$16, P$12))(obs, { fn: fn || defaultFn, seed: seed });\n  }\n\n  var P$13 = createProperty('scan', {\n    _init: function (_ref) {\n      var fn = _ref.fn;\n      var seed = _ref.seed;\n\n      this._fn = fn;\n      this._seed = seed;\n      if (seed !== NOTHING) {\n        this._emitValue(seed);\n      }\n    },\n    _free: function () {\n      this._fn = null;\n      this._seed = null;\n    },\n    _handleValue: function (x) {\n      var fn = this._fn;\n      if (this._currentEvent === null || this._currentEvent.type === ERROR) {\n        this._emitValue(this._seed === NOTHING ? x : fn(this._seed, x));\n      } else {\n        this._emitValue(fn(this._currentEvent.value, x));\n      }\n    }\n  });\n\n  function scan(obs, fn) {\n    var seed = arguments.length <= 2 || arguments[2] === undefined ? NOTHING : arguments[2];\n\n    return new P$13(obs, { fn: fn, seed: seed });\n  }\n\n  var mixin$10 = {\n    _init: function (_ref) {\n      var fn = _ref.fn;\n\n      this._fn = fn;\n    },\n    _free: function () {\n      this._fn = null;\n    },\n    _handleValue: function (x) {\n      var fn = this._fn;\n      var xs = fn(x);\n      for (var i = 0; i < xs.length; i++) {\n        this._emitValue(xs[i]);\n      }\n    }\n  };\n\n  var S$17 = createStream('flatten', mixin$10);\n\n  var id$4 = function (x) {\n    return x;\n  };\n\n  function flatten(obs) {\n    var fn = arguments.length <= 1 || arguments[1] === undefined ? id$4 : arguments[1];\n\n    return new S$17(obs, { fn: fn });\n  }\n\n  var END_MARKER = {};\n\n  var mixin$11 = {\n    _init: function (_ref) {\n      var _this = this;\n\n      var wait = _ref.wait;\n\n      this._wait = Math.max(0, wait);\n      this._buff = [];\n      this._$shiftBuff = function () {\n        var value = _this._buff.shift();\n        if (value === END_MARKER) {\n          _this._emitEnd();\n        } else {\n          _this._emitValue(value);\n        }\n      };\n    },\n    _free: function () {\n      this._buff = null;\n      this._$shiftBuff = null;\n    },\n    _handleValue: function (x) {\n      if (this._activating) {\n        this._emitValue(x);\n      } else {\n        this._buff.push(x);\n        setTimeout(this._$shiftBuff, this._wait);\n      }\n    },\n    _handleEnd: function () {\n      if (this._activating) {\n        this._emitEnd();\n      } else {\n        this._buff.push(END_MARKER);\n        setTimeout(this._$shiftBuff, this._wait);\n      }\n    }\n  };\n\n  var S$18 = createStream('delay', mixin$11);\n  var P$14 = createProperty('delay', mixin$11);\n\n  function delay(obs, wait) {\n    return new (obs._ofSameType(S$18, P$14))(obs, { wait: wait });\n  }\n\n  var now = Date.now ? function () {\n    return Date.now();\n  } : function () {\n    return new Date().getTime();\n  };\n\n  var mixin$12 = {\n    _init: function (_ref) {\n      var _this = this;\n\n      var wait = _ref.wait;\n      var leading = _ref.leading;\n      var trailing = _ref.trailing;\n\n      this._wait = Math.max(0, wait);\n      this._leading = leading;\n      this._trailing = trailing;\n      this._trailingValue = null;\n      this._timeoutId = null;\n      this._endLater = false;\n      this._lastCallTime = 0;\n      this._$trailingCall = function () {\n        return _this._trailingCall();\n      };\n    },\n    _free: function () {\n      this._trailingValue = null;\n      this._$trailingCall = null;\n    },\n    _handleValue: function (x) {\n      if (this._activating) {\n        this._emitValue(x);\n      } else {\n        var curTime = now();\n        if (this._lastCallTime === 0 && !this._leading) {\n          this._lastCallTime = curTime;\n        }\n        var remaining = this._wait - (curTime - this._lastCallTime);\n        if (remaining <= 0) {\n          this._cancelTrailing();\n          this._lastCallTime = curTime;\n          this._emitValue(x);\n        } else if (this._trailing) {\n          this._cancelTrailing();\n          this._trailingValue = x;\n          this._timeoutId = setTimeout(this._$trailingCall, remaining);\n        }\n      }\n    },\n    _handleEnd: function () {\n      if (this._activating) {\n        this._emitEnd();\n      } else {\n        if (this._timeoutId) {\n          this._endLater = true;\n        } else {\n          this._emitEnd();\n        }\n      }\n    },\n    _cancelTrailing: function () {\n      if (this._timeoutId !== null) {\n        clearTimeout(this._timeoutId);\n        this._timeoutId = null;\n      }\n    },\n    _trailingCall: function () {\n      this._emitValue(this._trailingValue);\n      this._timeoutId = null;\n      this._trailingValue = null;\n      this._lastCallTime = !this._leading ? 0 : now();\n      if (this._endLater) {\n        this._emitEnd();\n      }\n    }\n  };\n\n  var S$19 = createStream('throttle', mixin$12);\n  var P$15 = createProperty('throttle', mixin$12);\n\n  function throttle(obs, wait) {\n    var _ref2 = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];\n\n    var _ref2$leading = _ref2.leading;\n    var leading = _ref2$leading === undefined ? true : _ref2$leading;\n    var _ref2$trailing = _ref2.trailing;\n    var trailing = _ref2$trailing === undefined ? true : _ref2$trailing;\n\n    return new (obs._ofSameType(S$19, P$15))(obs, { wait: wait, leading: leading, trailing: trailing });\n  }\n\n  var mixin$13 = {\n    _init: function (_ref) {\n      var _this = this;\n\n      var wait = _ref.wait;\n      var immediate = _ref.immediate;\n\n      this._wait = Math.max(0, wait);\n      this._immediate = immediate;\n      this._lastAttempt = 0;\n      this._timeoutId = null;\n      this._laterValue = null;\n      this._endLater = false;\n      this._$later = function () {\n        return _this._later();\n      };\n    },\n    _free: function () {\n      this._laterValue = null;\n      this._$later = null;\n    },\n    _handleValue: function (x) {\n      if (this._activating) {\n        this._emitValue(x);\n      } else {\n        this._lastAttempt = now();\n        if (this._immediate && !this._timeoutId) {\n          this._emitValue(x);\n        }\n        if (!this._timeoutId) {\n          this._timeoutId = setTimeout(this._$later, this._wait);\n        }\n        if (!this._immediate) {\n          this._laterValue = x;\n        }\n      }\n    },\n    _handleEnd: function () {\n      if (this._activating) {\n        this._emitEnd();\n      } else {\n        if (this._timeoutId && !this._immediate) {\n          this._endLater = true;\n        } else {\n          this._emitEnd();\n        }\n      }\n    },\n    _later: function () {\n      var last = now() - this._lastAttempt;\n      if (last < this._wait && last >= 0) {\n        this._timeoutId = setTimeout(this._$later, this._wait - last);\n      } else {\n        this._timeoutId = null;\n        if (!this._immediate) {\n          this._emitValue(this._laterValue);\n          this._laterValue = null;\n        }\n        if (this._endLater) {\n          this._emitEnd();\n        }\n      }\n    }\n  };\n\n  var S$20 = createStream('debounce', mixin$13);\n  var P$16 = createProperty('debounce', mixin$13);\n\n  function debounce(obs, wait) {\n    var _ref2 = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];\n\n    var _ref2$immediate = _ref2.immediate;\n    var immediate = _ref2$immediate === undefined ? false : _ref2$immediate;\n\n    return new (obs._ofSameType(S$20, P$16))(obs, { wait: wait, immediate: immediate });\n  }\n\n  var mixin$14 = {\n    _init: function (_ref) {\n      var fn = _ref.fn;\n\n      this._fn = fn;\n    },\n    _free: function () {\n      this._fn = null;\n    },\n    _handleError: function (x) {\n      var fn = this._fn;\n      this._emitError(fn(x));\n    }\n  };\n\n  var S$21 = createStream('mapErrors', mixin$14);\n  var P$17 = createProperty('mapErrors', mixin$14);\n\n  var id$5 = function (x) {\n    return x;\n  };\n\n  function mapErrors(obs) {\n    var fn = arguments.length <= 1 || arguments[1] === undefined ? id$5 : arguments[1];\n\n    return new (obs._ofSameType(S$21, P$17))(obs, { fn: fn });\n  }\n\n  var mixin$15 = {\n    _init: function (_ref) {\n      var fn = _ref.fn;\n\n      this._fn = fn;\n    },\n    _free: function () {\n      this._fn = null;\n    },\n    _handleError: function (x) {\n      var fn = this._fn;\n      if (fn(x)) {\n        this._emitError(x);\n      }\n    }\n  };\n\n  var S$22 = createStream('filterErrors', mixin$15);\n  var P$18 = createProperty('filterErrors', mixin$15);\n\n  var id$6 = function (x) {\n    return x;\n  };\n\n  function filterErrors(obs) {\n    var fn = arguments.length <= 1 || arguments[1] === undefined ? id$6 : arguments[1];\n\n    return new (obs._ofSameType(S$22, P$18))(obs, { fn: fn });\n  }\n\n  var mixin$16 = {\n    _handleValue: function () {}\n  };\n\n  var S$23 = createStream('ignoreValues', mixin$16);\n  var P$19 = createProperty('ignoreValues', mixin$16);\n\n  function ignoreValues(obs) {\n    return new (obs._ofSameType(S$23, P$19))(obs);\n  }\n\n  var mixin$17 = {\n    _handleError: function () {}\n  };\n\n  var S$24 = createStream('ignoreErrors', mixin$17);\n  var P$20 = createProperty('ignoreErrors', mixin$17);\n\n  function ignoreErrors(obs) {\n    return new (obs._ofSameType(S$24, P$20))(obs);\n  }\n\n  var mixin$18 = {\n    _handleEnd: function () {}\n  };\n\n  var S$25 = createStream('ignoreEnd', mixin$18);\n  var P$21 = createProperty('ignoreEnd', mixin$18);\n\n  function ignoreEnd(obs) {\n    return new (obs._ofSameType(S$25, P$21))(obs);\n  }\n\n  var mixin$19 = {\n    _init: function (_ref) {\n      var fn = _ref.fn;\n\n      this._fn = fn;\n    },\n    _free: function () {\n      this._fn = null;\n    },\n    _handleEnd: function () {\n      var fn = this._fn;\n      this._emitValue(fn());\n      this._emitEnd();\n    }\n  };\n\n  var S$26 = createStream('beforeEnd', mixin$19);\n  var P$22 = createProperty('beforeEnd', mixin$19);\n\n  function beforeEnd(obs, fn) {\n    return new (obs._ofSameType(S$26, P$22))(obs, { fn: fn });\n  }\n\n  var mixin$20 = {\n    _init: function (_ref) {\n      var min = _ref.min;\n      var max = _ref.max;\n\n      this._max = max;\n      this._min = min;\n      this._buff = [];\n    },\n    _free: function () {\n      this._buff = null;\n    },\n    _handleValue: function (x) {\n      this._buff = slide(this._buff, x, this._max);\n      if (this._buff.length >= this._min) {\n        this._emitValue(this._buff);\n      }\n    }\n  };\n\n  var S$27 = createStream('slidingWindow', mixin$20);\n  var P$23 = createProperty('slidingWindow', mixin$20);\n\n  function slidingWindow(obs, max) {\n    var min = arguments.length <= 2 || arguments[2] === undefined ? 0 : arguments[2];\n\n    return new (obs._ofSameType(S$27, P$23))(obs, { min: min, max: max });\n  }\n\n  var mixin$21 = {\n    _init: function (_ref) {\n      var fn = _ref.fn;\n      var flushOnEnd = _ref.flushOnEnd;\n\n      this._fn = fn;\n      this._flushOnEnd = flushOnEnd;\n      this._buff = [];\n    },\n    _free: function () {\n      this._buff = null;\n    },\n    _flush: function () {\n      if (this._buff !== null && this._buff.length !== 0) {\n        this._emitValue(this._buff);\n        this._buff = [];\n      }\n    },\n    _handleValue: function (x) {\n      this._buff.push(x);\n      var fn = this._fn;\n      if (!fn(x)) {\n        this._flush();\n      }\n    },\n    _handleEnd: function () {\n      if (this._flushOnEnd) {\n        this._flush();\n      }\n      this._emitEnd();\n    }\n  };\n\n  var S$28 = createStream('bufferWhile', mixin$21);\n  var P$24 = createProperty('bufferWhile', mixin$21);\n\n  var id$7 = function (x) {\n    return x;\n  };\n\n  function bufferWhile(obs, fn) {\n    var _ref2 = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];\n\n    var _ref2$flushOnEnd = _ref2.flushOnEnd;\n    var flushOnEnd = _ref2$flushOnEnd === undefined ? true : _ref2$flushOnEnd;\n\n    return new (obs._ofSameType(S$28, P$24))(obs, { fn: fn || id$7, flushOnEnd: flushOnEnd });\n  }\n\n  var mixin$22 = {\n    _init: function (_ref) {\n      var count = _ref.count;\n      var flushOnEnd = _ref.flushOnEnd;\n\n      this._count = count;\n      this._flushOnEnd = flushOnEnd;\n      this._buff = [];\n    },\n    _free: function () {\n      this._buff = null;\n    },\n    _flush: function () {\n      if (this._buff !== null && this._buff.length !== 0) {\n        this._emitValue(this._buff);\n        this._buff = [];\n      }\n    },\n    _handleValue: function (x) {\n      this._buff.push(x);\n      if (this._buff.length >= this._count) {\n        this._flush();\n      }\n    },\n    _handleEnd: function () {\n      if (this._flushOnEnd) {\n        this._flush();\n      }\n      this._emitEnd();\n    }\n  };\n\n  var S$29 = createStream('bufferWithCount', mixin$22);\n  var P$25 = createProperty('bufferWithCount', mixin$22);\n\n  function bufferWhile$1(obs, count) {\n    var _ref2 = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];\n\n    var _ref2$flushOnEnd = _ref2.flushOnEnd;\n    var flushOnEnd = _ref2$flushOnEnd === undefined ? true : _ref2$flushOnEnd;\n\n    return new (obs._ofSameType(S$29, P$25))(obs, { count: count, flushOnEnd: flushOnEnd });\n  }\n\n  var mixin$23 = {\n    _init: function (_ref) {\n      var _this = this;\n\n      var wait = _ref.wait;\n      var count = _ref.count;\n      var flushOnEnd = _ref.flushOnEnd;\n\n      this._wait = wait;\n      this._count = count;\n      this._flushOnEnd = flushOnEnd;\n      this._intervalId = null;\n      this._$onTick = function () {\n        return _this._flush();\n      };\n      this._buff = [];\n    },\n    _free: function () {\n      this._$onTick = null;\n      this._buff = null;\n    },\n    _flush: function () {\n      if (this._buff !== null) {\n        this._emitValue(this._buff);\n        this._buff = [];\n      }\n    },\n    _handleValue: function (x) {\n      this._buff.push(x);\n      if (this._buff.length >= this._count) {\n        clearInterval(this._intervalId);\n        this._flush();\n        this._intervalId = setInterval(this._$onTick, this._wait);\n      }\n    },\n    _handleEnd: function () {\n      if (this._flushOnEnd && this._buff.length !== 0) {\n        this._flush();\n      }\n      this._emitEnd();\n    },\n    _onActivation: function () {\n      this._source.onAny(this._$handleAny); // copied from patterns/one-source\n      this._intervalId = setInterval(this._$onTick, this._wait);\n    },\n    _onDeactivation: function () {\n      if (this._intervalId !== null) {\n        clearInterval(this._intervalId);\n        this._intervalId = null;\n      }\n      this._source.offAny(this._$handleAny); // copied from patterns/one-source\n    }\n  };\n\n  var S$30 = createStream('bufferWithTimeOrCount', mixin$23);\n  var P$26 = createProperty('bufferWithTimeOrCount', mixin$23);\n\n  function bufferWithTimeOrCount(obs, wait, count) {\n    var _ref2 = arguments.length <= 3 || arguments[3] === undefined ? {} : arguments[3];\n\n    var _ref2$flushOnEnd = _ref2.flushOnEnd;\n    var flushOnEnd = _ref2$flushOnEnd === undefined ? true : _ref2$flushOnEnd;\n\n    return new (obs._ofSameType(S$30, P$26))(obs, { wait: wait, count: count, flushOnEnd: flushOnEnd });\n  }\n\n  function xformForObs(obs) {\n    return {\n      '@@transducer/step': function (res, input) {\n        obs._emitValue(input);\n        return null;\n      },\n      '@@transducer/result': function () {\n        obs._emitEnd();\n        return null;\n      }\n    };\n  }\n\n  var mixin$24 = {\n    _init: function (_ref) {\n      var transducer = _ref.transducer;\n\n      this._xform = transducer(xformForObs(this));\n    },\n    _free: function () {\n      this._xform = null;\n    },\n    _handleValue: function (x) {\n      if (this._xform['@@transducer/step'](null, x) !== null) {\n        this._xform['@@transducer/result'](null);\n      }\n    },\n    _handleEnd: function () {\n      this._xform['@@transducer/result'](null);\n    }\n  };\n\n  var S$31 = createStream('transduce', mixin$24);\n  var P$27 = createProperty('transduce', mixin$24);\n\n  function transduce(obs, transducer) {\n    return new (obs._ofSameType(S$31, P$27))(obs, { transducer: transducer });\n  }\n\n  var mixin$25 = {\n    _init: function (_ref) {\n      var fn = _ref.fn;\n\n      this._handler = fn;\n      this._emitter = emitter(this);\n    },\n    _free: function () {\n      this._handler = null;\n      this._emitter = null;\n    },\n    _handleAny: function (event) {\n      this._handler(this._emitter, event);\n    }\n  };\n\n  var S$32 = createStream('withHandler', mixin$25);\n  var P$28 = createProperty('withHandler', mixin$25);\n\n  function withHandler(obs, fn) {\n    return new (obs._ofSameType(S$32, P$28))(obs, { fn: fn });\n  }\n\n  function defaultErrorsCombinator(errors) {\n    var latestError = undefined;\n    for (var i = 0; i < errors.length; i++) {\n      if (errors[i] !== undefined) {\n        if (latestError === undefined || latestError.index < errors[i].index) {\n          latestError = errors[i];\n        }\n      }\n    }\n    return latestError.error;\n  }\n\n  function Combine(active, passive, combinator) {\n    var _this = this;\n\n    Stream.call(this);\n    this._activeCount = active.length;\n    this._sources = concat(active, passive);\n    this._combinator = combinator ? spread(combinator, this._sources.length) : function (x) {\n      return x;\n    };\n    this._aliveCount = 0;\n    this._latestValues = new Array(this._sources.length);\n    this._latestErrors = new Array(this._sources.length);\n    fillArray(this._latestValues, NOTHING);\n    this._emitAfterActivation = false;\n    this._endAfterActivation = false;\n    this._latestErrorIndex = 0;\n\n    this._$handlers = [];\n\n    var _loop = function (i) {\n      _this._$handlers.push(function (event) {\n        return _this._handleAny(i, event);\n      });\n    };\n\n    for (var i = 0; i < this._sources.length; i++) {\n      _loop(i);\n    }\n  }\n\n  inherit(Combine, Stream, {\n\n    _name: 'combine',\n\n    _onActivation: function () {\n      this._aliveCount = this._activeCount;\n\n      // we need to suscribe to _passive_ sources before _active_\n      // (see https://github.com/rpominov/kefir/issues/98)\n      for (var i = this._activeCount; i < this._sources.length; i++) {\n        this._sources[i].onAny(this._$handlers[i]);\n      }\n      for (var i = 0; i < this._activeCount; i++) {\n        this._sources[i].onAny(this._$handlers[i]);\n      }\n\n      if (this._emitAfterActivation) {\n        this._emitAfterActivation = false;\n        this._emitIfFull();\n      }\n      if (this._endAfterActivation) {\n        this._emitEnd();\n      }\n    },\n    _onDeactivation: function () {\n      var length = this._sources.length,\n          i = undefined;\n      for (i = 0; i < length; i++) {\n        this._sources[i].offAny(this._$handlers[i]);\n      }\n    },\n    _emitIfFull: function () {\n      var hasAllValues = true;\n      var hasErrors = false;\n      var length = this._latestValues.length;\n      var valuesCopy = new Array(length);\n      var errorsCopy = new Array(length);\n\n      for (var i = 0; i < length; i++) {\n        valuesCopy[i] = this._latestValues[i];\n        errorsCopy[i] = this._latestErrors[i];\n\n        if (valuesCopy[i] === NOTHING) {\n          hasAllValues = false;\n        }\n\n        if (errorsCopy[i] !== undefined) {\n          hasErrors = true;\n        }\n      }\n\n      if (hasAllValues) {\n        var combinator = this._combinator;\n        this._emitValue(combinator(valuesCopy));\n      }\n      if (hasErrors) {\n        this._emitError(defaultErrorsCombinator(errorsCopy));\n      }\n    },\n    _handleAny: function (i, event) {\n\n      if (event.type === VALUE || event.type === ERROR) {\n\n        if (event.type === VALUE) {\n          this._latestValues[i] = event.value;\n          this._latestErrors[i] = undefined;\n        }\n        if (event.type === ERROR) {\n          this._latestValues[i] = NOTHING;\n          this._latestErrors[i] = {\n            index: this._latestErrorIndex++,\n            error: event.value\n          };\n        }\n\n        if (i < this._activeCount) {\n          if (this._activating) {\n            this._emitAfterActivation = true;\n          } else {\n            this._emitIfFull();\n          }\n        }\n      } else {\n        // END\n\n        if (i < this._activeCount) {\n          this._aliveCount--;\n          if (this._aliveCount === 0) {\n            if (this._activating) {\n              this._endAfterActivation = true;\n            } else {\n              this._emitEnd();\n            }\n          }\n        }\n      }\n    },\n    _clear: function () {\n      Stream.prototype._clear.call(this);\n      this._sources = null;\n      this._latestValues = null;\n      this._latestErrors = null;\n      this._combinator = null;\n      this._$handlers = null;\n    }\n  });\n\n  function combine(active) {\n    var passive = arguments.length <= 1 || arguments[1] === undefined ? [] : arguments[1];\n    var combinator = arguments[2];\n\n    if (typeof passive === 'function') {\n      combinator = passive;\n      passive = [];\n    }\n    return active.length === 0 ? never() : new Combine(active, passive, combinator);\n  }\n\n  var isArray = Array.isArray || function (xs) {\n    return Object.prototype.toString.call(xs) === '[object Array]';\n  };\n\n  function Zip(sources, combinator) {\n    var _this = this;\n\n    Stream.call(this);\n\n    this._buffers = map(sources, function (source) {\n      return isArray(source) ? cloneArray(source) : [];\n    });\n    this._sources = map(sources, function (source) {\n      return isArray(source) ? never() : source;\n    });\n\n    this._combinator = combinator ? spread(combinator, this._sources.length) : function (x) {\n      return x;\n    };\n    this._aliveCount = 0;\n\n    this._$handlers = [];\n\n    var _loop = function (i) {\n      _this._$handlers.push(function (event) {\n        return _this._handleAny(i, event);\n      });\n    };\n\n    for (var i = 0; i < this._sources.length; i++) {\n      _loop(i);\n    }\n  }\n\n  inherit(Zip, Stream, {\n\n    _name: 'zip',\n\n    _onActivation: function () {\n\n      // if all sources are arrays\n      while (this._isFull()) {\n        this._emit();\n      }\n\n      var length = this._sources.length;\n      this._aliveCount = length;\n      for (var i = 0; i < length && this._active; i++) {\n        this._sources[i].onAny(this._$handlers[i]);\n      }\n    },\n    _onDeactivation: function () {\n      for (var i = 0; i < this._sources.length; i++) {\n        this._sources[i].offAny(this._$handlers[i]);\n      }\n    },\n    _emit: function () {\n      var values = new Array(this._buffers.length);\n      for (var i = 0; i < this._buffers.length; i++) {\n        values[i] = this._buffers[i].shift();\n      }\n      var combinator = this._combinator;\n      this._emitValue(combinator(values));\n    },\n    _isFull: function () {\n      for (var i = 0; i < this._buffers.length; i++) {\n        if (this._buffers[i].length === 0) {\n          return false;\n        }\n      }\n      return true;\n    },\n    _handleAny: function (i, event) {\n      if (event.type === VALUE) {\n        this._buffers[i].push(event.value);\n        if (this._isFull()) {\n          this._emit();\n        }\n      }\n      if (event.type === ERROR) {\n        this._emitError(event.value);\n      }\n      if (event.type === END) {\n        this._aliveCount--;\n        if (this._aliveCount === 0) {\n          this._emitEnd();\n        }\n      }\n    },\n    _clear: function () {\n      Stream.prototype._clear.call(this);\n      this._sources = null;\n      this._buffers = null;\n      this._combinator = null;\n      this._$handlers = null;\n    }\n  });\n\n  function zip(observables, combinator /* Function | falsey */) {\n    return observables.length === 0 ? never() : new Zip(observables, combinator);\n  }\n\n  var id$8 = function (x) {\n    return x;\n  };\n\n  function AbstractPool() {\n    var _this = this;\n\n    var _ref = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\n\n    var _ref$queueLim = _ref.queueLim;\n    var queueLim = _ref$queueLim === undefined ? 0 : _ref$queueLim;\n    var _ref$concurLim = _ref.concurLim;\n    var concurLim = _ref$concurLim === undefined ? -1 : _ref$concurLim;\n    var _ref$drop = _ref.drop;\n    var drop = _ref$drop === undefined ? 'new' : _ref$drop;\n\n    Stream.call(this);\n\n    this._queueLim = queueLim < 0 ? -1 : queueLim;\n    this._concurLim = concurLim < 0 ? -1 : concurLim;\n    this._drop = drop;\n    this._queue = [];\n    this._curSources = [];\n    this._$handleSubAny = function (event) {\n      return _this._handleSubAny(event);\n    };\n    this._$endHandlers = [];\n    this._currentlyAdding = null;\n\n    if (this._concurLim === 0) {\n      this._emitEnd();\n    }\n  }\n\n  inherit(AbstractPool, Stream, {\n\n    _name: 'abstractPool',\n\n    _add: function (obj, toObs /* Function | falsey */) {\n      toObs = toObs || id$8;\n      if (this._concurLim === -1 || this._curSources.length < this._concurLim) {\n        this._addToCur(toObs(obj));\n      } else {\n        if (this._queueLim === -1 || this._queue.length < this._queueLim) {\n          this._addToQueue(toObs(obj));\n        } else if (this._drop === 'old') {\n          this._removeOldest();\n          this._add(obj, toObs);\n        }\n      }\n    },\n    _addAll: function (obss) {\n      var _this2 = this;\n\n      forEach(obss, function (obs) {\n        return _this2._add(obs);\n      });\n    },\n    _remove: function (obs) {\n      if (this._removeCur(obs) === -1) {\n        this._removeQueue(obs);\n      }\n    },\n    _addToQueue: function (obs) {\n      this._queue = concat(this._queue, [obs]);\n    },\n    _addToCur: function (obs) {\n      if (this._active) {\n\n        // HACK:\n        //\n        // We have two optimizations for cases when `obs` is ended. We don't want\n        // to add such observable to the list, but only want to emit events\n        // from it (if it has some).\n        //\n        // Instead of this hacks, we could just did following,\n        // but it would be 5-8 times slower:\n        //\n        //     this._curSources = concat(this._curSources, [obs]);\n        //     this._subscribe(obs);\n        //\n\n        // #1\n        // This one for cases when `obs` already ended\n        // e.g., Kefir.constant() or Kefir.never()\n        if (!obs._alive) {\n          if (obs._currentEvent) {\n            this._emit(obs._currentEvent.type, obs._currentEvent.value);\n          }\n          return;\n        }\n\n        // #2\n        // This one is for cases when `obs` going to end synchronously on\n        // first subscriber e.g., Kefir.stream(em => {em.emit(1); em.end()})\n        this._currentlyAdding = obs;\n        obs.onAny(this._$handleSubAny);\n        this._currentlyAdding = null;\n        if (obs._alive) {\n          this._curSources = concat(this._curSources, [obs]);\n          if (this._active) {\n            this._subToEnd(obs);\n          }\n        }\n      } else {\n        this._curSources = concat(this._curSources, [obs]);\n      }\n    },\n    _subToEnd: function (obs) {\n      var _this3 = this;\n\n      var onEnd = function () {\n        return _this3._removeCur(obs);\n      };\n      this._$endHandlers.push({ obs: obs, handler: onEnd });\n      obs.onEnd(onEnd);\n    },\n    _subscribe: function (obs) {\n      obs.onAny(this._$handleSubAny);\n\n      // it can become inactive in responce of subscribing to `obs.onAny` above\n      if (this._active) {\n        this._subToEnd(obs);\n      }\n    },\n    _unsubscribe: function (obs) {\n      obs.offAny(this._$handleSubAny);\n\n      var onEndI = findByPred(this._$endHandlers, function (obj) {\n        return obj.obs === obs;\n      });\n      if (onEndI !== -1) {\n        obs.offEnd(this._$endHandlers[onEndI].handler);\n        this._$endHandlers.splice(onEndI, 1);\n      }\n    },\n    _handleSubAny: function (event) {\n      if (event.type === VALUE) {\n        this._emitValue(event.value);\n      } else if (event.type === ERROR) {\n        this._emitError(event.value);\n      }\n    },\n    _removeQueue: function (obs) {\n      var index = find(this._queue, obs);\n      this._queue = remove(this._queue, index);\n      return index;\n    },\n    _removeCur: function (obs) {\n      if (this._active) {\n        this._unsubscribe(obs);\n      }\n      var index = find(this._curSources, obs);\n      this._curSources = remove(this._curSources, index);\n      if (index !== -1) {\n        if (this._queue.length !== 0) {\n          this._pullQueue();\n        } else if (this._curSources.length === 0) {\n          this._onEmpty();\n        }\n      }\n      return index;\n    },\n    _removeOldest: function () {\n      this._removeCur(this._curSources[0]);\n    },\n    _pullQueue: function () {\n      if (this._queue.length !== 0) {\n        this._queue = cloneArray(this._queue);\n        this._addToCur(this._queue.shift());\n      }\n    },\n    _onActivation: function () {\n      for (var i = 0, sources = this._curSources; i < sources.length && this._active; i++) {\n        this._subscribe(sources[i]);\n      }\n    },\n    _onDeactivation: function () {\n      for (var i = 0, sources = this._curSources; i < sources.length; i++) {\n        this._unsubscribe(sources[i]);\n      }\n      if (this._currentlyAdding !== null) {\n        this._unsubscribe(this._currentlyAdding);\n      }\n    },\n    _isEmpty: function () {\n      return this._curSources.length === 0;\n    },\n    _onEmpty: function () {},\n    _clear: function () {\n      Stream.prototype._clear.call(this);\n      this._queue = null;\n      this._curSources = null;\n      this._$handleSubAny = null;\n      this._$endHandlers = null;\n    }\n  });\n\n  function Merge(sources) {\n    AbstractPool.call(this);\n    this._addAll(sources);\n    this._initialised = true;\n  }\n\n  inherit(Merge, AbstractPool, {\n\n    _name: 'merge',\n\n    _onEmpty: function () {\n      if (this._initialised) {\n        this._emitEnd();\n      }\n    }\n  });\n\n  function merge(observables) {\n    return observables.length === 0 ? never() : new Merge(observables);\n  }\n\n  function S$33(generator) {\n    var _this = this;\n\n    Stream.call(this);\n    this._generator = generator;\n    this._source = null;\n    this._inLoop = false;\n    this._iteration = 0;\n    this._$handleAny = function (event) {\n      return _this._handleAny(event);\n    };\n  }\n\n  inherit(S$33, Stream, {\n\n    _name: 'repeat',\n\n    _handleAny: function (event) {\n      if (event.type === END) {\n        this._source = null;\n        this._getSource();\n      } else {\n        this._emit(event.type, event.value);\n      }\n    },\n    _getSource: function () {\n      if (!this._inLoop) {\n        this._inLoop = true;\n        var generator = this._generator;\n        while (this._source === null && this._alive && this._active) {\n          this._source = generator(this._iteration++);\n          if (this._source) {\n            this._source.onAny(this._$handleAny);\n          } else {\n            this._emitEnd();\n          }\n        }\n        this._inLoop = false;\n      }\n    },\n    _onActivation: function () {\n      if (this._source) {\n        this._source.onAny(this._$handleAny);\n      } else {\n        this._getSource();\n      }\n    },\n    _onDeactivation: function () {\n      if (this._source) {\n        this._source.offAny(this._$handleAny);\n      }\n    },\n    _clear: function () {\n      Stream.prototype._clear.call(this);\n      this._generator = null;\n      this._source = null;\n      this._$handleAny = null;\n    }\n  });\n\n  function repeat (generator) {\n    return new S$33(generator);\n  }\n\n  function concat$1(observables) {\n    return repeat(function (index) {\n      return observables.length > index ? observables[index] : false;\n    }).setName('concat');\n  }\n\n  function Pool() {\n    AbstractPool.call(this);\n  }\n\n  inherit(Pool, AbstractPool, {\n\n    _name: 'pool',\n\n    plug: function (obs) {\n      this._add(obs);\n      return this;\n    },\n    unplug: function (obs) {\n      this._remove(obs);\n      return this;\n    }\n  });\n\n  function FlatMap(source, fn, options) {\n    var _this = this;\n\n    AbstractPool.call(this, options);\n    this._source = source;\n    this._fn = fn;\n    this._mainEnded = false;\n    this._lastCurrent = null;\n    this._$handleMain = function (event) {\n      return _this._handleMain(event);\n    };\n  }\n\n  inherit(FlatMap, AbstractPool, {\n    _onActivation: function () {\n      AbstractPool.prototype._onActivation.call(this);\n      if (this._active) {\n        this._source.onAny(this._$handleMain);\n      }\n    },\n    _onDeactivation: function () {\n      AbstractPool.prototype._onDeactivation.call(this);\n      this._source.offAny(this._$handleMain);\n      this._hadNoEvSinceDeact = true;\n    },\n    _handleMain: function (event) {\n\n      if (event.type === VALUE) {\n        // Is latest value before deactivation survived, and now is 'current' on this activation?\n        // We don't want to handle such values, to prevent to constantly add\n        // same observale on each activation/deactivation when our main source\n        // is a `Kefir.conatant()` for example.\n        var sameCurr = this._activating && this._hadNoEvSinceDeact && this._lastCurrent === event.value;\n        if (!sameCurr) {\n          this._add(event.value, this._fn);\n        }\n        this._lastCurrent = event.value;\n        this._hadNoEvSinceDeact = false;\n      }\n\n      if (event.type === ERROR) {\n        this._emitError(event.value);\n      }\n\n      if (event.type === END) {\n        if (this._isEmpty()) {\n          this._emitEnd();\n        } else {\n          this._mainEnded = true;\n        }\n      }\n    },\n    _onEmpty: function () {\n      if (this._mainEnded) {\n        this._emitEnd();\n      }\n    },\n    _clear: function () {\n      AbstractPool.prototype._clear.call(this);\n      this._source = null;\n      this._lastCurrent = null;\n      this._$handleMain = null;\n    }\n  });\n\n  function FlatMapErrors(source, fn) {\n    FlatMap.call(this, source, fn);\n  }\n\n  inherit(FlatMapErrors, FlatMap, {\n\n    // Same as in FlatMap, only VALUE/ERROR flipped\n\n    _handleMain: function (event) {\n\n      if (event.type === ERROR) {\n        var sameCurr = this._activating && this._hadNoEvSinceDeact && this._lastCurrent === event.value;\n        if (!sameCurr) {\n          this._add(event.value, this._fn);\n        }\n        this._lastCurrent = event.value;\n        this._hadNoEvSinceDeact = false;\n      }\n\n      if (event.type === VALUE) {\n        this._emitValue(event.value);\n      }\n\n      if (event.type === END) {\n        if (this._isEmpty()) {\n          this._emitEnd();\n        } else {\n          this._mainEnded = true;\n        }\n      }\n    }\n  });\n\n  function createConstructor$1(BaseClass, name) {\n    return function AnonymousObservable(primary, secondary, options) {\n      var _this = this;\n\n      BaseClass.call(this);\n      this._primary = primary;\n      this._secondary = secondary;\n      this._name = primary._name + '.' + name;\n      this._lastSecondary = NOTHING;\n      this._$handleSecondaryAny = function (event) {\n        return _this._handleSecondaryAny(event);\n      };\n      this._$handlePrimaryAny = function (event) {\n        return _this._handlePrimaryAny(event);\n      };\n      this._init(options);\n    };\n  }\n\n  function createClassMethods$1(BaseClass) {\n    return {\n      _init: function () {},\n      _free: function () {},\n      _handlePrimaryValue: function (x) {\n        this._emitValue(x);\n      },\n      _handlePrimaryError: function (x) {\n        this._emitError(x);\n      },\n      _handlePrimaryEnd: function () {\n        this._emitEnd();\n      },\n      _handleSecondaryValue: function (x) {\n        this._lastSecondary = x;\n      },\n      _handleSecondaryError: function (x) {\n        this._emitError(x);\n      },\n      _handleSecondaryEnd: function () {},\n      _handlePrimaryAny: function (event) {\n        switch (event.type) {\n          case VALUE:\n            return this._handlePrimaryValue(event.value);\n          case ERROR:\n            return this._handlePrimaryError(event.value);\n          case END:\n            return this._handlePrimaryEnd(event.value);\n        }\n      },\n      _handleSecondaryAny: function (event) {\n        switch (event.type) {\n          case VALUE:\n            return this._handleSecondaryValue(event.value);\n          case ERROR:\n            return this._handleSecondaryError(event.value);\n          case END:\n            this._handleSecondaryEnd(event.value);\n            this._removeSecondary();\n        }\n      },\n      _removeSecondary: function () {\n        if (this._secondary !== null) {\n          this._secondary.offAny(this._$handleSecondaryAny);\n          this._$handleSecondaryAny = null;\n          this._secondary = null;\n        }\n      },\n      _onActivation: function () {\n        if (this._secondary !== null) {\n          this._secondary.onAny(this._$handleSecondaryAny);\n        }\n        if (this._active) {\n          this._primary.onAny(this._$handlePrimaryAny);\n        }\n      },\n      _onDeactivation: function () {\n        if (this._secondary !== null) {\n          this._secondary.offAny(this._$handleSecondaryAny);\n        }\n        this._primary.offAny(this._$handlePrimaryAny);\n      },\n      _clear: function () {\n        BaseClass.prototype._clear.call(this);\n        this._primary = null;\n        this._secondary = null;\n        this._lastSecondary = null;\n        this._$handleSecondaryAny = null;\n        this._$handlePrimaryAny = null;\n        this._free();\n      }\n    };\n  }\n\n  function createStream$1(name, mixin) {\n    var S = createConstructor$1(Stream, name);\n    inherit(S, Stream, createClassMethods$1(Stream), mixin);\n    return S;\n  }\n\n  function createProperty$1(name, mixin) {\n    var P = createConstructor$1(Property, name);\n    inherit(P, Property, createClassMethods$1(Property), mixin);\n    return P;\n  }\n\n  var mixin$26 = {\n    _handlePrimaryValue: function (x) {\n      if (this._lastSecondary !== NOTHING && this._lastSecondary) {\n        this._emitValue(x);\n      }\n    },\n    _handleSecondaryEnd: function () {\n      if (this._lastSecondary === NOTHING || !this._lastSecondary) {\n        this._emitEnd();\n      }\n    }\n  };\n\n  var S$34 = createStream$1('filterBy', mixin$26);\n  var P$29 = createProperty$1('filterBy', mixin$26);\n\n  function filterBy(primary, secondary) {\n    return new (primary._ofSameType(S$34, P$29))(primary, secondary);\n  }\n\n  var id2 = function (_, x) {\n    return x;\n  };\n\n  function sampledBy(passive, active, combinator) {\n    var _combinator = combinator ? function (a, b) {\n      return combinator(b, a);\n    } : id2;\n    return combine([active], [passive], _combinator).setName(passive, 'sampledBy');\n  }\n\n  var mixin$27 = {\n    _handlePrimaryValue: function (x) {\n      if (this._lastSecondary !== NOTHING) {\n        this._emitValue(x);\n      }\n    },\n    _handleSecondaryEnd: function () {\n      if (this._lastSecondary === NOTHING) {\n        this._emitEnd();\n      }\n    }\n  };\n\n  var S$35 = createStream$1('skipUntilBy', mixin$27);\n  var P$30 = createProperty$1('skipUntilBy', mixin$27);\n\n  function skipUntilBy(primary, secondary) {\n    return new (primary._ofSameType(S$35, P$30))(primary, secondary);\n  }\n\n  var mixin$28 = {\n    _handleSecondaryValue: function () {\n      this._emitEnd();\n    }\n  };\n\n  var S$36 = createStream$1('takeUntilBy', mixin$28);\n  var P$31 = createProperty$1('takeUntilBy', mixin$28);\n\n  function takeUntilBy(primary, secondary) {\n    return new (primary._ofSameType(S$36, P$31))(primary, secondary);\n  }\n\n  var mixin$29 = {\n    _init: function () {\n      var _ref = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\n\n      var _ref$flushOnEnd = _ref.flushOnEnd;\n      var flushOnEnd = _ref$flushOnEnd === undefined ? true : _ref$flushOnEnd;\n\n      this._buff = [];\n      this._flushOnEnd = flushOnEnd;\n    },\n    _free: function () {\n      this._buff = null;\n    },\n    _flush: function () {\n      if (this._buff !== null) {\n        this._emitValue(this._buff);\n        this._buff = [];\n      }\n    },\n    _handlePrimaryEnd: function () {\n      if (this._flushOnEnd) {\n        this._flush();\n      }\n      this._emitEnd();\n    },\n    _onActivation: function () {\n      this._primary.onAny(this._$handlePrimaryAny);\n      if (this._alive && this._secondary !== null) {\n        this._secondary.onAny(this._$handleSecondaryAny);\n      }\n    },\n    _handlePrimaryValue: function (x) {\n      this._buff.push(x);\n    },\n    _handleSecondaryValue: function () {\n      this._flush();\n    },\n    _handleSecondaryEnd: function () {\n      if (!this._flushOnEnd) {\n        this._emitEnd();\n      }\n    }\n  };\n\n  var S$37 = createStream$1('bufferBy', mixin$29);\n  var P$32 = createProperty$1('bufferBy', mixin$29);\n\n  function bufferBy(primary, secondary, options /* optional */) {\n    return new (primary._ofSameType(S$37, P$32))(primary, secondary, options);\n  }\n\n  var mixin$30 = {\n    _init: function () {\n      var _ref = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\n\n      var _ref$flushOnEnd = _ref.flushOnEnd;\n      var flushOnEnd = _ref$flushOnEnd === undefined ? true : _ref$flushOnEnd;\n      var _ref$flushOnChange = _ref.flushOnChange;\n      var flushOnChange = _ref$flushOnChange === undefined ? false : _ref$flushOnChange;\n\n      this._buff = [];\n      this._flushOnEnd = flushOnEnd;\n      this._flushOnChange = flushOnChange;\n    },\n    _free: function () {\n      this._buff = null;\n    },\n    _flush: function () {\n      if (this._buff !== null) {\n        this._emitValue(this._buff);\n        this._buff = [];\n      }\n    },\n    _handlePrimaryEnd: function () {\n      if (this._flushOnEnd) {\n        this._flush();\n      }\n      this._emitEnd();\n    },\n    _handlePrimaryValue: function (x) {\n      this._buff.push(x);\n      if (this._lastSecondary !== NOTHING && !this._lastSecondary) {\n        this._flush();\n      }\n    },\n    _handleSecondaryEnd: function () {\n      if (!this._flushOnEnd && (this._lastSecondary === NOTHING || this._lastSecondary)) {\n        this._emitEnd();\n      }\n    },\n    _handleSecondaryValue: function (x) {\n      if (this._flushOnChange && !x) {\n        this._flush();\n      }\n\n      // from default _handleSecondaryValue\n      this._lastSecondary = x;\n    }\n  };\n\n  var S$38 = createStream$1('bufferWhileBy', mixin$30);\n  var P$33 = createProperty$1('bufferWhileBy', mixin$30);\n\n  function bufferWhileBy(primary, secondary, options /* optional */) {\n    return new (primary._ofSameType(S$38, P$33))(primary, secondary, options);\n  }\n\n  var f = function () {\n    return false;\n  };\n  var t = function () {\n    return true;\n  };\n\n  function awaiting(a, b) {\n    var result = merge([map$1(a, t), map$1(b, f)]);\n    result = skipDuplicates(result);\n    result = toProperty(result, f);\n    return result.setName(a, 'awaiting');\n  }\n\n  var mixin$31 = {\n    _init: function (_ref) {\n      var fn = _ref.fn;\n\n      this._fn = fn;\n    },\n    _free: function () {\n      this._fn = null;\n    },\n    _handleValue: function (x) {\n      var fn = this._fn;\n      var result = fn(x);\n      if (result.convert) {\n        this._emitError(result.error);\n      } else {\n        this._emitValue(x);\n      }\n    }\n  };\n\n  var S$39 = createStream('valuesToErrors', mixin$31);\n  var P$34 = createProperty('valuesToErrors', mixin$31);\n\n  var defFn = function (x) {\n    return { convert: true, error: x };\n  };\n\n  function valuesToErrors(obs) {\n    var fn = arguments.length <= 1 || arguments[1] === undefined ? defFn : arguments[1];\n\n    return new (obs._ofSameType(S$39, P$34))(obs, { fn: fn });\n  }\n\n  var mixin$32 = {\n    _init: function (_ref) {\n      var fn = _ref.fn;\n\n      this._fn = fn;\n    },\n    _free: function () {\n      this._fn = null;\n    },\n    _handleError: function (x) {\n      var fn = this._fn;\n      var result = fn(x);\n      if (result.convert) {\n        this._emitValue(result.value);\n      } else {\n        this._emitError(x);\n      }\n    }\n  };\n\n  var S$40 = createStream('errorsToValues', mixin$32);\n  var P$35 = createProperty('errorsToValues', mixin$32);\n\n  var defFn$1 = function (x) {\n    return { convert: true, value: x };\n  };\n\n  function errorsToValues(obs) {\n    var fn = arguments.length <= 1 || arguments[1] === undefined ? defFn$1 : arguments[1];\n\n    return new (obs._ofSameType(S$40, P$35))(obs, { fn: fn });\n  }\n\n  var mixin$33 = {\n    _handleError: function (x) {\n      this._emitError(x);\n      this._emitEnd();\n    }\n  };\n\n  var S$41 = createStream('endOnError', mixin$33);\n  var P$36 = createProperty('endOnError', mixin$33);\n\n  function endOnError(obs) {\n    return new (obs._ofSameType(S$41, P$36))(obs);\n  }\n\n  Observable.prototype.toProperty = function (fn) {\n    return toProperty(this, fn);\n  };\n\n  Observable.prototype.changes = function () {\n    return changes(this);\n  };\n\n  Observable.prototype.toPromise = function (Promise) {\n    return toPromise(this, Promise);\n  };\n\n  Observable.prototype.toESObservable = toESObservable;\n  Observable.prototype[symbol_('observable')] = toESObservable;\n\n  Observable.prototype.map = function (fn) {\n    return map$1(this, fn);\n  };\n\n  Observable.prototype.filter = function (fn) {\n    return filter(this, fn);\n  };\n\n  Observable.prototype.take = function (n) {\n    return take(this, n);\n  };\n\n  Observable.prototype.takeErrors = function (n) {\n    return takeErrors(this, n);\n  };\n\n  Observable.prototype.takeWhile = function (fn) {\n    return takeWhile(this, fn);\n  };\n\n  Observable.prototype.last = function () {\n    return last(this);\n  };\n\n  Observable.prototype.skip = function (n) {\n    return skip(this, n);\n  };\n\n  Observable.prototype.skipWhile = function (fn) {\n    return skipWhile(this, fn);\n  };\n\n  Observable.prototype.skipDuplicates = function (fn) {\n    return skipDuplicates(this, fn);\n  };\n\n  Observable.prototype.diff = function (fn, seed) {\n    return diff(this, fn, seed);\n  };\n\n  Observable.prototype.scan = function (fn, seed) {\n    return scan(this, fn, seed);\n  };\n\n  Observable.prototype.flatten = function (fn) {\n    return flatten(this, fn);\n  };\n\n  Observable.prototype.delay = function (wait) {\n    return delay(this, wait);\n  };\n\n  Observable.prototype.throttle = function (wait, options) {\n    return throttle(this, wait, options);\n  };\n\n  Observable.prototype.debounce = function (wait, options) {\n    return debounce(this, wait, options);\n  };\n\n  Observable.prototype.mapErrors = function (fn) {\n    return mapErrors(this, fn);\n  };\n\n  Observable.prototype.filterErrors = function (fn) {\n    return filterErrors(this, fn);\n  };\n\n  Observable.prototype.ignoreValues = function () {\n    return ignoreValues(this);\n  };\n\n  Observable.prototype.ignoreErrors = function () {\n    return ignoreErrors(this);\n  };\n\n  Observable.prototype.ignoreEnd = function () {\n    return ignoreEnd(this);\n  };\n\n  Observable.prototype.beforeEnd = function (fn) {\n    return beforeEnd(this, fn);\n  };\n\n  Observable.prototype.slidingWindow = function (max, min) {\n    return slidingWindow(this, max, min);\n  };\n\n  Observable.prototype.bufferWhile = function (fn, options) {\n    return bufferWhile(this, fn, options);\n  };\n\n  Observable.prototype.bufferWithCount = function (count, options) {\n    return bufferWhile$1(this, count, options);\n  };\n\n  Observable.prototype.bufferWithTimeOrCount = function (wait, count, options) {\n    return bufferWithTimeOrCount(this, wait, count, options);\n  };\n\n  Observable.prototype.transduce = function (transducer) {\n    return transduce(this, transducer);\n  };\n\n  Observable.prototype.withHandler = function (fn) {\n    return withHandler(this, fn);\n  };\n\n  Observable.prototype.combine = function (other, combinator) {\n    return combine([this, other], combinator);\n  };\n\n  Observable.prototype.zip = function (other, combinator) {\n    return zip([this, other], combinator);\n  };\n\n  Observable.prototype.merge = function (other) {\n    return merge([this, other]);\n  };\n\n  Observable.prototype.concat = function (other) {\n    return concat$1([this, other]);\n  };\n\n  var pool = function () {\n    return new Pool();\n  };\n\n  Observable.prototype.flatMap = function (fn) {\n    return new FlatMap(this, fn).setName(this, 'flatMap');\n  };\n  Observable.prototype.flatMapLatest = function (fn) {\n    return new FlatMap(this, fn, { concurLim: 1, drop: 'old' }).setName(this, 'flatMapLatest');\n  };\n  Observable.prototype.flatMapFirst = function (fn) {\n    return new FlatMap(this, fn, { concurLim: 1 }).setName(this, 'flatMapFirst');\n  };\n  Observable.prototype.flatMapConcat = function (fn) {\n    return new FlatMap(this, fn, { queueLim: -1, concurLim: 1 }).setName(this, 'flatMapConcat');\n  };\n  Observable.prototype.flatMapConcurLimit = function (fn, limit) {\n    return new FlatMap(this, fn, { queueLim: -1, concurLim: limit }).setName(this, 'flatMapConcurLimit');\n  };\n\n  Observable.prototype.flatMapErrors = function (fn) {\n    return new FlatMapErrors(this, fn).setName(this, 'flatMapErrors');\n  };\n\n  Observable.prototype.filterBy = function (other) {\n    return filterBy(this, other);\n  };\n\n  Observable.prototype.sampledBy = function (other, combinator) {\n    return sampledBy(this, other, combinator);\n  };\n\n  Observable.prototype.skipUntilBy = function (other) {\n    return skipUntilBy(this, other);\n  };\n\n  Observable.prototype.takeUntilBy = function (other) {\n    return takeUntilBy(this, other);\n  };\n\n  Observable.prototype.bufferBy = function (other, options) {\n    return bufferBy(this, other, options);\n  };\n\n  Observable.prototype.bufferWhileBy = function (other, options) {\n    return bufferWhileBy(this, other, options);\n  };\n\n  // Deprecated\n  // -----------------------------------------------------------------------------\n\n  function warn(msg) {\n    if (Kefir.DEPRECATION_WARNINGS !== false && console && typeof console.warn === 'function') {\n      var msg2 = '\\nHere is an Error object for you containing the call stack:';\n      console.warn(msg, msg2, new Error());\n    }\n  }\n\n  Observable.prototype.awaiting = function (other) {\n    warn('You are using deprecated .awaiting() method, see https://github.com/rpominov/kefir/issues/145');\n    return awaiting(this, other);\n  };\n\n  Observable.prototype.valuesToErrors = function (fn) {\n    warn('You are using deprecated .valuesToErrors() method, see https://github.com/rpominov/kefir/issues/149');\n    return valuesToErrors(this, fn);\n  };\n\n  Observable.prototype.errorsToValues = function (fn) {\n    warn('You are using deprecated .errorsToValues() method, see https://github.com/rpominov/kefir/issues/149');\n    return errorsToValues(this, fn);\n  };\n\n  Observable.prototype.endOnError = function () {\n    warn('You are using deprecated .endOnError() method, see https://github.com/rpominov/kefir/issues/150');\n    return endOnError(this);\n  };\n\n  // Exports\n  // --------------------------------------------------------------------------\n\n  var Kefir = { Observable: Observable, Stream: Stream, Property: Property, never: never, later: later, interval: interval, sequentially: sequentially,\n    fromPoll: fromPoll, withInterval: withInterval, fromCallback: fromCallback, fromNodeCallback: fromNodeCallback, fromEvents: fromEvents, stream: stream,\n    constant: constant, constantError: constantError, fromPromise: fromPromise, fromESObservable: fromESObservable, combine: combine, zip: zip, merge: merge,\n    concat: concat$1, Pool: Pool, pool: pool, repeat: repeat };\n\n  Kefir.Kefir = Kefir;\n\n  exports.Kefir = Kefir;\n  exports.Observable = Observable;\n  exports.Stream = Stream;\n  exports.Property = Property;\n  exports.never = never;\n  exports.later = later;\n  exports.interval = interval;\n  exports.sequentially = sequentially;\n  exports.fromPoll = fromPoll;\n  exports.withInterval = withInterval;\n  exports.fromCallback = fromCallback;\n  exports.fromNodeCallback = fromNodeCallback;\n  exports.fromEvents = fromEvents;\n  exports.stream = stream;\n  exports.constant = constant;\n  exports.constantError = constantError;\n  exports.fromPromise = fromPromise;\n  exports.fromESObservable = fromESObservable;\n  exports.combine = combine;\n  exports.zip = zip;\n  exports.merge = merge;\n  exports.concat = concat$1;\n  exports.Pool = Pool;\n  exports.pool = pool;\n  exports.repeat = repeat;\n  exports['default'] = Kefir;\n\n}));\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/kefir/dist/kefir.js\n ** module id = 10\n ** module chunks = 0\n **/","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Atom = exports.LensedAtom = exports.AbstractMutable = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _kefir = require(\"kefir\");\n\nvar _kefir2 = _interopRequireDefault(_kefir);\n\nvar _partial = require(\"partial.lenses\");\n\nvar _partial2 = _interopRequireDefault(_partial);\n\nvar _ramda = require(\"ramda\");\n\nvar _ramda2 = _interopRequireDefault(_ramda);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n//\n\nvar AbstractMutable = exports.AbstractMutable = function (_Kefir$Property) {\n  _inherits(AbstractMutable, _Kefir$Property);\n\n  function AbstractMutable() {\n    _classCallCheck(this, AbstractMutable);\n\n    return _possibleConstructorReturn(this, Object.getPrototypeOf(AbstractMutable).apply(this, arguments));\n  }\n\n  _createClass(AbstractMutable, [{\n    key: \"set\",\n    value: function set(value) {\n      this.modify(function () {\n        return value;\n      });\n    }\n  }, {\n    key: \"lens\",\n    value: function lens(l) {\n      for (var _len = arguments.length, ls = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n        ls[_key - 1] = arguments[_key];\n      }\n\n      return new LensedAtom(this, ls.length === 0 ? l : _partial2.default.apply(undefined, [l].concat(ls)));\n    }\n  }, {\n    key: \"view\",\n    value: function view(l) {\n      for (var _len2 = arguments.length, ls = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n        ls[_key2 - 1] = arguments[_key2];\n      }\n\n      return this.lens.apply(this, [l].concat(ls));\n    }\n  }, {\n    key: \"_maybeEmitValue\",\n    value: function _maybeEmitValue(next) {\n      var prev = this._currentEvent;\n      if (!prev || !_ramda2.default.equals(prev.value, next)) this._emitValue(next);\n    }\n  }]);\n\n  return AbstractMutable;\n}(_kefir2.default.Property);\n\n//\n\nvar LensedAtom = exports.LensedAtom = function (_AbstractMutable) {\n  _inherits(LensedAtom, _AbstractMutable);\n\n  function LensedAtom(source, lens) {\n    _classCallCheck(this, LensedAtom);\n\n    var _this2 = _possibleConstructorReturn(this, Object.getPrototypeOf(LensedAtom).call(this));\n\n    _this2._source = source;\n    _this2._lens = lens;\n    _this2._$handleValue = null;\n    return _this2;\n  }\n\n  _createClass(LensedAtom, [{\n    key: \"get\",\n    value: function get() {\n      return _partial2.default.view(this._lens, this._source.get());\n    }\n  }, {\n    key: \"modify\",\n    value: function modify(fn) {\n      this._source.modify(_partial2.default.over(this._lens, fn));\n    }\n  }, {\n    key: \"_handleValue\",\n    value: function _handleValue(context) {\n      this._maybeEmitValue(_partial2.default.view(this._lens, context));\n    }\n  }, {\n    key: \"_onActivation\",\n    value: function _onActivation() {\n      var _this3 = this;\n\n      var handleValue = function handleValue(value) {\n        return _this3._handleValue(value);\n      };\n      this._$handleValue = handleValue;\n      this._source.onValue(handleValue);\n    }\n  }, {\n    key: \"_onDeactivation\",\n    value: function _onDeactivation() {\n      this._source.offValue(this._$handleValue);\n      this._$handleValue = null;\n      this._currentEvent = null;\n    }\n  }]);\n\n  return LensedAtom;\n}(AbstractMutable);\n\n//\n\nvar Atom = exports.Atom = function (_AbstractMutable2) {\n  _inherits(Atom, _AbstractMutable2);\n\n  function Atom(value) {\n    _classCallCheck(this, Atom);\n\n    var _this4 = _possibleConstructorReturn(this, Object.getPrototypeOf(Atom).call(this));\n\n    _this4._emitValue(value);\n    return _this4;\n  }\n\n  _createClass(Atom, [{\n    key: \"get\",\n    value: function get() {\n      return this._currentEvent.value;\n    }\n  }, {\n    key: \"modify\",\n    value: function modify(fn) {\n      this._maybeEmitValue(fn(this.get()));\n    }\n  }]);\n\n  return Atom;\n}(AbstractMutable);\n\n//\n\nexports.default = function (value) {\n  return new Atom(value);\n};\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9rZWZpci5hdG9tLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7SUFNYTs7Ozs7Ozs7Ozs7d0JBQ1AsT0FBTztBQUNULFdBQUssTUFBTCxDQUFZO2VBQU07T0FBTixDQUFaLENBRFM7Ozs7eUJBR04sR0FBVTt3Q0FBSjs7T0FBSTs7QUFDYixhQUFPLElBQUksVUFBSixDQUFlLElBQWYsRUFBcUIsR0FBRyxNQUFILEtBQWMsQ0FBZCxHQUFrQixDQUFsQixHQUFzQixvQ0FBRSxVQUFNLEdBQVIsQ0FBdEIsQ0FBNUIsQ0FEYTs7Ozt5QkFHVixHQUFVO3lDQUFKOztPQUFJOztBQUNiLGFBQU8sS0FBSyxJQUFMLGNBQVUsVUFBTSxHQUFoQixDQUFQLENBRGE7Ozs7b0NBR0MsTUFBTTtBQUNwQixVQUFNLE9BQU8sS0FBSyxhQUFMLENBRE87QUFFcEIsVUFBSSxDQUFDLElBQUQsSUFBUyxDQUFDLGdCQUFFLE1BQUYsQ0FBUyxLQUFLLEtBQUwsRUFBWSxJQUFyQixDQUFELEVBQ1gsS0FBSyxVQUFMLENBQWdCLElBQWhCLEVBREY7Ozs7U0FaUztFQUF3QixnQkFBTSxRQUFOOzs7O0lBbUJ4Qjs7O0FBQ1gsV0FEVyxVQUNYLENBQVksTUFBWixFQUFvQixJQUFwQixFQUEwQjswQkFEZixZQUNlOzt3RUFEZix3QkFDZTs7QUFFeEIsV0FBSyxPQUFMLEdBQWUsTUFBZixDQUZ3QjtBQUd4QixXQUFLLEtBQUwsR0FBYSxJQUFiLENBSHdCO0FBSXhCLFdBQUssYUFBTCxHQUFxQixJQUFyQixDQUp3Qjs7R0FBMUI7O2VBRFc7OzBCQU9MO0FBQ0osYUFBTyxrQkFBRSxJQUFGLENBQU8sS0FBSyxLQUFMLEVBQVksS0FBSyxPQUFMLENBQWEsR0FBYixFQUFuQixDQUFQLENBREk7Ozs7MkJBR0MsSUFBSTtBQUNULFdBQUssT0FBTCxDQUFhLE1BQWIsQ0FBb0Isa0JBQUUsSUFBRixDQUFPLEtBQUssS0FBTCxFQUFZLEVBQW5CLENBQXBCLEVBRFM7Ozs7aUNBR0UsU0FBUztBQUNwQixXQUFLLGVBQUwsQ0FBcUIsa0JBQUUsSUFBRixDQUFPLEtBQUssS0FBTCxFQUFZLE9BQW5CLENBQXJCLEVBRG9COzs7O29DQUdOOzs7QUFDZCxVQUFNLGNBQWMsU0FBZCxXQUFjO2VBQVMsT0FBSyxZQUFMLENBQWtCLEtBQWxCO09BQVQsQ0FETjtBQUVkLFdBQUssYUFBTCxHQUFxQixXQUFyQixDQUZjO0FBR2QsV0FBSyxPQUFMLENBQWEsT0FBYixDQUFxQixXQUFyQixFQUhjOzs7O3NDQUtFO0FBQ2hCLFdBQUssT0FBTCxDQUFhLFFBQWIsQ0FBc0IsS0FBSyxhQUFMLENBQXRCLENBRGdCO0FBRWhCLFdBQUssYUFBTCxHQUFxQixJQUFyQixDQUZnQjtBQUdoQixXQUFLLGFBQUwsR0FBcUIsSUFBckIsQ0FIZ0I7Ozs7U0FyQlA7RUFBbUI7Ozs7SUE4Qm5COzs7QUFDWCxXQURXLElBQ1gsQ0FBWSxLQUFaLEVBQW1COzBCQURSLE1BQ1E7O3dFQURSLGtCQUNROztBQUVqQixXQUFLLFVBQUwsQ0FBZ0IsS0FBaEIsRUFGaUI7O0dBQW5COztlQURXOzswQkFLTDtBQUNKLGFBQU8sS0FBSyxhQUFMLENBQW1CLEtBQW5CLENBREg7Ozs7MkJBR0MsSUFBSTtBQUNULFdBQUssZUFBTCxDQUFxQixHQUFHLEtBQUssR0FBTCxFQUFILENBQXJCLEVBRFM7Ozs7U0FSQTtFQUFhOzs7O2tCQWVYO1NBQVMsSUFBSSxJQUFKLENBQVMsS0FBVDtDQUFUIiwiZmlsZSI6ImtlZmlyLmF0b20uanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgS2VmaXIgZnJvbSBcImtlZmlyXCJcbmltcG9ydCBMICAgICBmcm9tIFwicGFydGlhbC5sZW5zZXNcIlxuaW1wb3J0IFIgICAgIGZyb20gXCJyYW1kYVwiXG5cbi8vXG5cbmV4cG9ydCBjbGFzcyBBYnN0cmFjdE11dGFibGUgZXh0ZW5kcyBLZWZpci5Qcm9wZXJ0eSB7XG4gIHNldCh2YWx1ZSkge1xuICAgIHRoaXMubW9kaWZ5KCgpID0+IHZhbHVlKVxuICB9XG4gIGxlbnMobCwgLi4ubHMpIHtcbiAgICByZXR1cm4gbmV3IExlbnNlZEF0b20odGhpcywgbHMubGVuZ3RoID09PSAwID8gbCA6IEwobCwgLi4ubHMpKVxuICB9XG4gIHZpZXcobCwgLi4ubHMpIHtcbiAgICByZXR1cm4gdGhpcy5sZW5zKGwsIC4uLmxzKVxuICB9XG4gIF9tYXliZUVtaXRWYWx1ZShuZXh0KSB7XG4gICAgY29uc3QgcHJldiA9IHRoaXMuX2N1cnJlbnRFdmVudFxuICAgIGlmICghcHJldiB8fCAhUi5lcXVhbHMocHJldi52YWx1ZSwgbmV4dCkpXG4gICAgICB0aGlzLl9lbWl0VmFsdWUobmV4dClcbiAgfVxufVxuXG4vL1xuXG5leHBvcnQgY2xhc3MgTGVuc2VkQXRvbSBleHRlbmRzIEFic3RyYWN0TXV0YWJsZSB7XG4gIGNvbnN0cnVjdG9yKHNvdXJjZSwgbGVucykge1xuICAgIHN1cGVyKClcbiAgICB0aGlzLl9zb3VyY2UgPSBzb3VyY2VcbiAgICB0aGlzLl9sZW5zID0gbGVuc1xuICAgIHRoaXMuXyRoYW5kbGVWYWx1ZSA9IG51bGxcbiAgfVxuICBnZXQoKSB7XG4gICAgcmV0dXJuIEwudmlldyh0aGlzLl9sZW5zLCB0aGlzLl9zb3VyY2UuZ2V0KCkpXG4gIH1cbiAgbW9kaWZ5KGZuKSB7XG4gICAgdGhpcy5fc291cmNlLm1vZGlmeShMLm92ZXIodGhpcy5fbGVucywgZm4pKVxuICB9XG4gIF9oYW5kbGVWYWx1ZShjb250ZXh0KSB7XG4gICAgdGhpcy5fbWF5YmVFbWl0VmFsdWUoTC52aWV3KHRoaXMuX2xlbnMsIGNvbnRleHQpKVxuICB9XG4gIF9vbkFjdGl2YXRpb24oKSB7XG4gICAgY29uc3QgaGFuZGxlVmFsdWUgPSB2YWx1ZSA9PiB0aGlzLl9oYW5kbGVWYWx1ZSh2YWx1ZSlcbiAgICB0aGlzLl8kaGFuZGxlVmFsdWUgPSBoYW5kbGVWYWx1ZVxuICAgIHRoaXMuX3NvdXJjZS5vblZhbHVlKGhhbmRsZVZhbHVlKVxuICB9XG4gIF9vbkRlYWN0aXZhdGlvbigpIHtcbiAgICB0aGlzLl9zb3VyY2Uub2ZmVmFsdWUodGhpcy5fJGhhbmRsZVZhbHVlKVxuICAgIHRoaXMuXyRoYW5kbGVWYWx1ZSA9IG51bGxcbiAgICB0aGlzLl9jdXJyZW50RXZlbnQgPSBudWxsXG4gIH1cbn1cblxuLy9cblxuZXhwb3J0IGNsYXNzIEF0b20gZXh0ZW5kcyBBYnN0cmFjdE11dGFibGUge1xuICBjb25zdHJ1Y3Rvcih2YWx1ZSkge1xuICAgIHN1cGVyKClcbiAgICB0aGlzLl9lbWl0VmFsdWUodmFsdWUpXG4gIH1cbiAgZ2V0KCkge1xuICAgIHJldHVybiB0aGlzLl9jdXJyZW50RXZlbnQudmFsdWVcbiAgfVxuICBtb2RpZnkoZm4pIHtcbiAgICB0aGlzLl9tYXliZUVtaXRWYWx1ZShmbih0aGlzLmdldCgpKSlcbiAgfVxufVxuXG4vL1xuXG5leHBvcnQgZGVmYXVsdCB2YWx1ZSA9PiBuZXcgQXRvbSh2YWx1ZSlcbiJdfQ==\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/kefir.atom/lib/kefir.atom.js\n ** module id = 11\n ** module chunks = 0\n **/","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.lift = undefined;\n\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol ? \"symbol\" : typeof obj; };\n\nvar _ramda = require(\"ramda\");\n\nvar _ramda2 = _interopRequireDefault(_ramda);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n//\n\nvar deleteKey = function deleteKey(k, o) {\n  if (o === undefined || !(k in o)) return o;\n  var r = undefined;\n  for (var p in o) {\n    if (p !== k) {\n      if (undefined === r) r = {};\n      r[p] = o[p];\n    }\n  }\n  return r;\n};\n\nvar setKey = function setKey(k, v, o) {\n  if (o === undefined) return _defineProperty({}, k, v);\n  if (k in o && _ramda2.default.equals(v, o[k])) return o;\n  var r = _defineProperty({}, k, v);\n  for (var p in o) {\n    if (p !== k) r[p] = o[p];\n  }return r;\n};\n\n//\n\nvar dropped = function dropped(xs) {\n  return Object.keys(xs).length === 0 ? undefined : xs;\n};\n\n//\n\nvar toPartial = function toPartial(transform) {\n  return function (x) {\n    return undefined === x ? x : transform(x);\n  };\n};\n\n//\n\nvar conserve = function conserve(c0, c1) {\n  return _ramda2.default.equals(c0, c1) ? c0 : c1;\n};\n\nvar toConserve = function toConserve(f) {\n  return function (y, c0) {\n    return conserve(c0, f(y, c0));\n  };\n};\n\n//\n\nvar lift = exports.lift = function lift(l) {\n  switch (typeof l === \"undefined\" ? \"undefined\" : _typeof(l)) {\n    case \"string\":\n      return L.prop(l);\n    case \"number\":\n      return L.index(l);\n    default:\n      return l;\n  }\n};\n\nvar L = function L(l) {\n  for (var _len = arguments.length, ls = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    ls[_key - 1] = arguments[_key];\n  }\n\n  return ls.length === 0 ? lift(l) : _ramda2.default.compose.apply(_ramda2.default, [lift(l)].concat(_toConsumableArray(ls.map(lift))));\n};\n\nL.compose = L;\nL.delete = _ramda2.default.curry(function (l, s) {\n  return _ramda2.default.set(lift(l), undefined, s);\n});\nL.deleteAll = _ramda2.default.curry(function (lens, data) {\n  while (L.view(lens, data) !== undefined) {\n    data = L.delete(lens, data);\n  }return data;\n});\nL.lens = _ramda2.default.lens;\nL.over = _ramda2.default.curry(function (l, x2x, s) {\n  return _ramda2.default.over(lift(l), x2x, s);\n});\nL.set = _ramda2.default.curry(function (l, x, s) {\n  return _ramda2.default.set(lift(l), x, s);\n});\nL.view = _ramda2.default.curry(function (l, s) {\n  return _ramda2.default.view(lift(l), s);\n});\n\nL.choose = function (x2yL) {\n  return function (toFunctor) {\n    return function (target) {\n      var l = lift(x2yL(target));\n      return _ramda2.default.map(function (focus) {\n        return _ramda2.default.set(l, focus, target);\n      }, toFunctor(_ramda2.default.view(l, target)));\n    };\n  };\n};\n\nL.firstOf = function (l) {\n  for (var _len2 = arguments.length, ls = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n    ls[_key2 - 1] = arguments[_key2];\n  }\n\n  return L.choose(function (x) {\n    var lls = [l].concat(ls);\n    return lls[Math.max(0, lls.findIndex(function (l) {\n      return L.view(l, x) !== undefined;\n    }))];\n  });\n};\n\nL.replace = _ramda2.default.curry(function (inn, out) {\n  return _ramda2.default.lens(function (x) {\n    return _ramda2.default.equals(x, inn) ? out : x;\n  }, toConserve(function (y) {\n    return _ramda2.default.equals(y, out) ? inn : y;\n  }));\n});\n\nL.default = L.replace(undefined);\nL.required = function (inn) {\n  return L.replace(inn, undefined);\n};\nL.define = function (v) {\n  return _ramda2.default.compose(L.required(v), L.default(v));\n};\n\nL.normalize = function (transform) {\n  return _ramda2.default.lens(toPartial(transform), toConserve(toPartial(transform)));\n};\n\nL.prop = function (k) {\n  return _ramda2.default.lens(function (o) {\n    return o && o[k];\n  }, function (v, o) {\n    return v === undefined ? deleteKey(k, o) : setKey(k, v, o);\n  });\n};\n\nL.find = function (predicate) {\n  return L.choose(function (xs) {\n    if (xs === undefined) return L.append;\n    var i = xs.findIndex(predicate);\n    return i < 0 ? L.append : i;\n  });\n};\n\nL.findWith = function (l) {\n  for (var _len3 = arguments.length, ls = Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {\n    ls[_key3 - 1] = arguments[_key3];\n  }\n\n  var lls = L.apply(undefined, [l].concat(ls));\n  return L(L.find(function (x) {\n    return L.view(lls, x) !== undefined;\n  }), lls);\n};\n\nL.index = function (i) {\n  return _ramda2.default.lens(function (xs) {\n    return xs && xs[i];\n  }, function (x, xs) {\n    if (x === undefined) {\n      if (xs === undefined) return undefined;\n      if (i < xs.length) return dropped(xs.slice(0, i).concat(xs.slice(i + 1)));\n      return xs;\n    } else {\n      if (xs === undefined) return Array(i).concat([x]);\n      if (xs.length <= i) return xs.concat(Array(i - xs.length), [x]);\n      if (_ramda2.default.equals(x, xs[i])) return xs;\n      return xs.slice(0, i).concat([x], xs.slice(i + 1));\n    }\n  });\n};\n\nL.append = _ramda2.default.lens(function () {}, function (x, xs) {\n  return x === undefined ? xs : xs === undefined ? [x] : xs.concat([x]);\n});\n\nL.filter = function (p) {\n  return _ramda2.default.lens(function (xs) {\n    return xs && xs.filter(p);\n  }, function (ys, xs) {\n    return conserve(xs, dropped(_ramda2.default.concat(ys || [], (xs || []).filter(_ramda2.default.complement(p)))));\n  });\n};\n\nL.augment = function (template) {\n  return _ramda2.default.lens(toPartial(function (x) {\n    var z = _extends({}, x);\n    for (var k in template) {\n      z[k] = template[k](x);\n    }return z;\n  }), toConserve(function (y, c) {\n    if (y === undefined) return undefined;\n    var z = undefined;\n    var set = function set(k, v) {\n      if (undefined === z) z = {};\n      z[k] = v;\n    };\n    for (var k in y) {\n      if (!(k in template)) set(k, y[k]);else if (k in c) set(k, c[k]);\n    }\n    return z;\n  }));\n};\n\nexports.default = L;\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9wYXJ0aWFsLmxlbnNlcy5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUlBLElBQU0sWUFBWSxTQUFaLFNBQVksQ0FBQyxDQUFELEVBQUksQ0FBSixFQUFVO0FBQzFCLE1BQUksTUFBTSxTQUFOLElBQW1CLEVBQUUsS0FBSyxDQUFMLENBQUYsRUFDckIsT0FBTyxDQUFQLENBREY7QUFFQSxNQUFJLGFBQUosQ0FIMEI7QUFJMUIsT0FBSyxJQUFNLENBQU4sSUFBVyxDQUFoQixFQUFtQjtBQUNqQixRQUFJLE1BQU0sQ0FBTixFQUFTO0FBQ1gsVUFBSSxjQUFjLENBQWQsRUFDRixJQUFJLEVBQUosQ0FERjtBQUVBLFFBQUUsQ0FBRixJQUFPLEVBQUUsQ0FBRixDQUFQLENBSFc7S0FBYjtHQURGO0FBT0EsU0FBTyxDQUFQLENBWDBCO0NBQVY7O0FBY2xCLElBQU0sU0FBUyxTQUFULE1BQVMsQ0FBQyxDQUFELEVBQUksQ0FBSixFQUFPLENBQVAsRUFBYTtBQUMxQixNQUFJLE1BQU0sU0FBTixFQUNGLDJCQUFTLEdBQUksRUFBYixDQURGO0FBRUEsTUFBSSxLQUFLLENBQUwsSUFBVSxnQkFBRSxNQUFGLENBQVMsQ0FBVCxFQUFZLEVBQUUsQ0FBRixDQUFaLENBQVYsRUFDRixPQUFPLENBQVAsQ0FERjtBQUVBLE1BQU0sd0JBQU0sR0FBSSxFQUFWLENBTG9CO0FBTTFCLE9BQUssSUFBTSxDQUFOLElBQVcsQ0FBaEI7QUFDRSxRQUFJLE1BQU0sQ0FBTixFQUNGLEVBQUUsQ0FBRixJQUFPLEVBQUUsQ0FBRixDQUFQLENBREY7R0FERixPQUdPLENBQVAsQ0FUMEI7Q0FBYjs7OztBQWNmLElBQU0sVUFBVSxTQUFWLE9BQVU7U0FBTSxPQUFPLElBQVAsQ0FBWSxFQUFaLEVBQWdCLE1BQWhCLEtBQTJCLENBQTNCLEdBQStCLFNBQS9CLEdBQTJDLEVBQTNDO0NBQU47Ozs7QUFJaEIsSUFBTSxZQUFZLFNBQVosU0FB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QUFFQSxRQUFJLGFBQUosQ0FIbUI7QUFJbkIsUUFBTSxNQUFNLFNBQU4sR0FBTSxDQUFDLENBQUQsRUFBSSxDQUFKLEVBQVU7QUFDcEIsVUFBSSxjQUFjLENBQWQsRUFDRixJQUFJLEVBQUosQ0FERjtBQUVBLFFBQUUsQ0FBRixJQUFPLENBQVAsQ0FIb0I7S0FBVixDQUpPO0FBU25CLFNBQUssSUFBTSxDQUFOLElBQVcsQ0FBaEIsRUFBbUI7QUFDakIsVUFBSSxFQUFFLEtBQUssUUFBTCxDQUFGLEVBQ0YsSUFBSSxDQUFKLEVBQU8sRUFBRSxDQUFGLENBQVAsRUFERixLQUdFLElBQUksS0FBSyxDQUFMLEVBQ0YsSUFBSSxDQUFKLEVBQU8sRUFBRSxDQUFGLENBQVAsRUFERjtLQUpKO0FBT0EsV0FBTyxDQUFQLENBaEJtQjtHQUFWLENBUFc7Q0FBWjs7a0JBMEJHIiwiZmlsZSI6InBhcnRpYWwubGVuc2VzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFIgZnJvbSBcInJhbWRhXCJcblxuLy9cblxuY29uc3QgZGVsZXRlS2V5ID0gKGssIG8pID0+IHtcbiAgaWYgKG8gPT09IHVuZGVmaW5lZCB8fCAhKGsgaW4gbykpXG4gICAgcmV0dXJuIG9cbiAgbGV0IHJcbiAgZm9yIChjb25zdCBwIGluIG8pIHtcbiAgICBpZiAocCAhPT0gaykge1xuICAgICAgaWYgKHVuZGVmaW5lZCA9PT0gcilcbiAgICAgICAgciA9IHt9XG4gICAgICByW3BdID0gb1twXVxuICAgIH1cbiAgfVxuICByZXR1cm4gclxufVxuXG5jb25zdCBzZXRLZXkgPSAoaywgdiwgbykgPT4ge1xuICBpZiAobyA9PT0gdW5kZWZpbmVkKVxuICAgIHJldHVybiB7W2tdOiB2fVxuICBpZiAoayBpbiBvICYmIFIuZXF1YWxzKHYsIG9ba10pKVxuICAgIHJldHVybiBvXG4gIGNvbnN0IHIgPSB7W2tdOiB2fVxuICBmb3IgKGNvbnN0IHAgaW4gbylcbiAgICBpZiAocCAhPT0gaylcbiAgICAgIHJbcF0gPSBvW3BdXG4gIHJldHVybiByXG59XG5cbi8vXG5cbmNvbnN0IGRyb3BwZWQgPSB4cyA9PiBPYmplY3Qua2V5cyh4cykubGVuZ3RoID09PSAwID8gdW5kZWZpbmVkIDogeHNcblxuLy9cblxuY29uc3QgdG9QYXJ0aWFsID0gdHJhbnNmb3JtID0+IHggPT4gdW5kZWZpbmVkID09PSB4ID8geCA6IHRyYW5zZm9ybSh4KVxuXG4vL1xuXG5jb25zdCBjb25zZXJ2ZSA9IChjMCwgYzEpID0+IFIuZXF1YWxzKGMwLCBjMSkgPyBjMCA6IGMxXG5cbmNvbnN0IHRvQ29uc2VydmUgPSBmID0+ICh5LCBjMCkgPT4gY29uc2VydmUoYzAsIGYoeSwgYzApKVxuXG4vL1xuXG5leHBvcnQgY29uc3QgbGlmdCA9IGwgPT4ge1xuICBzd2l0Y2ggKHR5cGVvZiBsKSB7XG4gIGNhc2UgXCJzdHJpbmdcIjogcmV0dXJuIEwucHJvcChsKVxuICBjYXNlIFwibnVtYmVyXCI6IHJldHVybiBMLmluZGV4KGwpXG4gIGRlZmF1bHQ6ICAgICAgIHJldHVybiBsXG4gIH1cbn1cblxuY29uc3QgTCA9IChsLCAuLi5scykgPT5cbiAgbHMubGVuZ3RoID09PSAwID8gbGlmdChsKSA6IFIuY29tcG9zZShsaWZ0KGwpLCAuLi5scy5tYXAobGlmdCkpXG5cbkwuY29tcG9zZSA9IExcbkwuZGVsZXRlID0gUi5jdXJyeSgobCwgcykgPT4gUi5zZXQobGlmdChsKSwgdW5kZWZpbmVkLCBzKSlcbkwuZGVsZXRlQWxsID0gUi5jdXJyeSgobGVucywgZGF0YSkgPT4ge1xuICB3aGlsZSAoTC52aWV3KGxlbnMsIGRhdGEpICE9PSB1bmRlZmluZWQpXG4gICAgZGF0YSA9IEwuZGVsZXRlKGxlbnMsIGRhdGEpXG4gIHJldHVybiBkYXRhXG59KVxuTC5sZW5zID0gUi5sZW5zXG5MLm92ZXIgPSBSLmN1cnJ5KChsLCB4MngsIHMpID0+IFIub3ZlcihsaWZ0KGwpLCB4MngsIHMpKVxuTC5zZXQgPSBSLmN1cnJ5KChsLCB4LCBzKSA9PiBSLnNldChsaWZ0KGwpLCB4LCBzKSlcbkwudmlldyA9IFIuY3VycnkoKGwsIHMpID0+IFIudmlldyhsaWZ0KGwpLCBzKSlcblxuTC5jaG9vc2UgPSB4MnlMID0+IHRvRnVuY3RvciA9PiB0YXJnZXQgPT4ge1xuICBjb25zdCBsID0gbGlmdCh4MnlMKHRhcmdldCkpXG4gIHJldHVybiBSLm1hcChmb2N1cyA9PiBSLnNldChsLCBmb2N1cywgdGFyZ2V0KSwgdG9GdW5jdG9yKFIudmlldyhsLCB0YXJnZXQpKSlcbn1cblxuTC5maXJzdE9mID0gKGwsIC4uLmxzKSA9PiBMLmNob29zZSh4ID0+IHtcbiAgY29uc3QgbGxzID0gW2wsIC4uLmxzXVxuICByZXR1cm4gbGxzW01hdGgubWF4KDAsIGxscy5maW5kSW5kZXgobCA9PiBMLnZpZXcobCwgeCkgIT09IHVuZGVmaW5lZCkpXVxufSlcblxuTC5yZXBsYWNlID0gUi5jdXJyeSgoaW5uLCBvdXQpID0+XG4gIFIubGVucyh4ID0+IFIuZXF1YWxzKHgsIGlubikgPyBvdXQgOiB4LFxuICAgICAgICAgdG9Db25zZXJ2ZSh5ID0+IFIuZXF1YWxzKHksIG91dCkgPyBpbm4gOiB5KSkpXG5cbkwuZGVmYXVsdCA9IEwucmVwbGFjZSh1bmRlZmluZWQpXG5MLnJlcXVpcmVkID0gaW5uID0+IEwucmVwbGFjZShpbm4sIHVuZGVmaW5lZClcbkwuZGVmaW5lID0gdiA9PiBSLmNvbXBvc2UoTC5yZXF1aXJlZCh2KSwgTC5kZWZhdWx0KHYpKVxuXG5MLm5vcm1hbGl6ZSA9IHRyYW5zZm9ybSA9PlxuICBSLmxlbnModG9QYXJ0aWFsKHRyYW5zZm9ybSksIHRvQ29uc2VydmUodG9QYXJ0aWFsKHRyYW5zZm9ybSkpKVxuXG5MLnByb3AgPSBrID0+XG4gIFIubGVucyhvID0+IG8gJiYgb1trXSxcbiAgICAgICAgICh2LCBvKSA9PiB2ID09PSB1bmRlZmluZWQgPyBkZWxldGVLZXkoaywgbykgOiBzZXRLZXkoaywgdiwgbykpXG5cbkwuZmluZCA9IHByZWRpY2F0ZSA9PiBMLmNob29zZSh4cyA9PiB7XG4gIGlmICh4cyA9PT0gdW5kZWZpbmVkKVxuICAgIHJldHVybiBMLmFwcGVuZFxuICBjb25zdCBpID0geHMuZmluZEluZGV4KHByZWRpY2F0ZSlcbiAgcmV0dXJuIGkgPCAwID8gTC5hcHBlbmQgOiBpXG59KVxuXG5MLmZpbmRXaXRoID0gKGwsIC4uLmxzKSA9PiB7XG4gIGNvbnN0IGxscyA9IEwobCwgLi4ubHMpXG4gIHJldHVybiBMKEwuZmluZCh4ID0+IEwudmlldyhsbHMsIHgpICE9PSB1bmRlZmluZWQpLCBsbHMpXG59XG5cbkwuaW5kZXggPSBpID0+IFIubGVucyh4cyA9PiB4cyAmJiB4c1tpXSwgKHgsIHhzKSA9PiB7XG4gIGlmICh4ID09PSB1bmRlZmluZWQpIHtcbiAgICBpZiAoeHMgPT09IHVuZGVmaW5lZClcbiAgICAgIHJldHVybiB1bmRlZmluZWRcbiAgICBpZiAoaSA8IHhzLmxlbmd0aClcbiAgICAgIHJldHVybiBkcm9wcGVkKHhzLnNsaWNlKDAsIGkpLmNvbmNhdCh4cy5zbGljZShpKzEpKSlcbiAgICByZXR1cm4geHNcbiAgfSBlbHNlIHtcbiAgICBpZiAoeHMgPT09IHVuZGVmaW5lZClcbiAgICAgIHJldHVybiBBcnJheShpKS5jb25jYXQoW3hdKVxuICAgIGlmICh4cy5sZW5ndGggPD0gaSlcbiAgICAgIHJldHVybiB4cy5jb25jYXQoQXJyYXkoaSAtIHhzLmxlbmd0aCksIFt4XSlcbiAgICBpZiAoUi5lcXVhbHMoeCwgeHNbaV0pKVxuICAgICAgcmV0dXJuIHhzXG4gICAgcmV0dXJuIHhzLnNsaWNlKDAsIGkpLmNvbmNhdChbeF0sIHhzLnNsaWNlKGkrMSkpXG4gIH1cbn0pXG5cbkwuYXBwZW5kID0gUi5sZW5zKCgpID0+IHt9LCAoeCwgeHMpID0+XG4gIHggPT09IHVuZGVmaW5lZCA/IHhzIDogeHMgPT09IHVuZGVmaW5lZCA/IFt4XSA6IHhzLmNvbmNhdChbeF0pKVxuXG5MLmZpbHRlciA9IHAgPT4gUi5sZW5zKHhzID0+IHhzICYmIHhzLmZpbHRlcihwKSwgKHlzLCB4cykgPT5cbiAgY29uc2VydmUoeHMsIGRyb3BwZWQoUi5jb25jYXQoeXMgfHwgW10sICh4cyB8fCBbXSkuZmlsdGVyKFIuY29tcGxlbWVudChwKSkpKSkpXG5cbkwuYXVnbWVudCA9IHRlbXBsYXRlID0+IFIubGVucyhcbiAgdG9QYXJ0aWFsKHggPT4ge1xuICAgIGNvbnN0IHogPSB7Li4ueH1cbiAgICBmb3IgKGNvbnN0IGsgaW4gdGVtcGxhdGUpXG4gICAgICB6W2tdID0gdGVtcGxhdGVba10oeClcbiAgICByZXR1cm4gelxuICB9KSxcbiAgdG9Db25zZXJ2ZSgoeSwgYykgPT4ge1xuICAgIGlmICh5ID09PSB1bmRlZmluZWQpXG4gICAgICByZXR1cm4gdW5kZWZpbmVkXG4gICAgbGV0IHpcbiAgICBjb25zdCBzZXQgPSAoaywgdikgPT4ge1xuICAgICAgaWYgKHVuZGVmaW5lZCA9PT0geilcbiAgICAgICAgeiA9IHt9XG4gICAgICB6W2tdID0gdlxuICAgIH1cbiAgICBmb3IgKGNvbnN0IGsgaW4geSkge1xuICAgICAgaWYgKCEoayBpbiB0ZW1wbGF0ZSkpXG4gICAgICAgIHNldChrLCB5W2tdKVxuICAgICAgZWxzZVxuICAgICAgICBpZiAoayBpbiBjKVxuICAgICAgICAgIHNldChrLCBjW2tdKVxuICAgIH1cbiAgICByZXR1cm4gelxuICB9KSlcblxuZXhwb3J0IGRlZmF1bHQgTFxuIl19\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/partial.lenses/lib/partial.lenses.js\n ** module id = 12\n ** module chunks = 0\n **/","(function () {\n  'use strict';\n\n  var ElementPrototype = Element.prototype;\n\n  /**\n   * Detect full support\n   */\n\n  var isSupported = ElementPrototype.after &&\n      ElementPrototype.append &&\n      ElementPrototype.before &&\n      ElementPrototype.prepend &&\n      ElementPrototype.remove &&\n      ElementPrototype.replace;\n\n  if (isSupported) { return; }\n\n  /**\n   * Apply mutation shims\n   */\n\n  function toNode(node) {\n    return typeof node === 'string' ? document.createTextNode(node) : node;\n  }\n\n  function mutationMacro(nodes) {\n    var fragment, i, len;\n    if (nodes) { len = nodes.length; }\n\n    if (!len) {\n      throw new Error('No node was specified (DOM Exception 8)');\n    }\n\n    if (len === 1) {\n      return toNode(nodes[0]);\n    } else {\n      fragment = document.createDocumentFragment();\n      for (i = 0; i < len; i++) {\n        fragment.appendChild(toNode(nodes[i]));\n      }\n      return fragment;\n    }\n  }\n\n  ElementPrototype.prepend = function prepend() {\n    this.insertBefore(mutationMacro(arguments), this.firstChild);\n  };\n\n  ElementPrototype.append = function append() {\n    this.appendChild(mutationMacro(arguments));\n  };\n\n  ElementPrototype.before = function before() {\n    var parentNode = this.parentNode;\n    if (parentNode) {\n      parentNode.insertBefore(mutationMacro(arguments), this);\n    }\n  };\n\n  ElementPrototype.after = function after() {\n    var parentNode = this.parentNode;\n    if (parentNode) {\n      parentNode.insertBefore(mutationMacro(arguments), this.nextSibling);\n    }\n  };\n\n  ElementPrototype.replace = function replace() {\n    var parentNode = this.parentNode;\n    if (parentNode) {\n      parentNode.replaceChild(mutationMacro(arguments), this);\n    }\n  };\n\n  /**\n   * This method is defined with bracket notation to avoid conflicting with the\n   * definition of HTMLSelectElement.\n   */\n  ElementPrototype['remove'] = function remove() {\n    var parentNode = this.parentNode;\n    if (parentNode) {\n      parentNode.removeChild(this);\n    }\n  };\n}());\n\n\n\n/** WEBPACK FOOTER **\n ** ./js/Element.mutation.js\n **/","// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = require(\"!!./../node_modules/css-loader/index.js!./../node_modules/postcss-loader/index.js!./global.css\");\nif(typeof content === 'string') content = [[module.id, content, '']];\n// add the styles to the DOM\nvar update = require(\"!./../node_modules/style-loader/addStyles.js\")(content, {});\nif(content.locals) module.exports = content.locals;\n// Hot Module Replacement\nif(module.hot) {\n\t// When the styles change, update the <style> tags\n\tif(!content.locals) {\n\t\tmodule.hot.accept(\"!!./../node_modules/css-loader/index.js!./../node_modules/postcss-loader/index.js!./global.css\", function() {\n\t\t\tvar newContent = require(\"!!./../node_modules/css-loader/index.js!./../node_modules/postcss-loader/index.js!./global.css\");\n\t\t\tif(typeof newContent === 'string') newContent = [[module.id, newContent, '']];\n\t\t\tupdate(newContent);\n\t\t});\n\t}\n\t// When the module is disposed, remove the <style> tags\n\tmodule.hot.dispose(function() { update(); });\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./css/global.css\n ** module id = 14\n ** module chunks = 0\n **/","exports = module.exports = require(\"./../node_modules/css-loader/lib/css-base.js\")();\n// imports\n\n\n// module\nexports.push([module.id, \"body,html{margin:0;background-color:#000;overflow:hidden;height:100%}canvas[resize]{width:100%;height:100%}video{width:100%}.draw{position:absolute;top:0;left:0}\", \"\"]);\n\n// exports\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/css-loader!./~/postcss-loader!./css/global.css\n ** module id = 15\n ** module chunks = 0\n **/"],"sourceRoot":""}